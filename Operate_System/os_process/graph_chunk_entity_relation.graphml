<?xml version='1.0' encoding='utf-8'?>
<graphml xmlns="http://graphml.graphdrawing.org/xmlns" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://graphml.graphdrawing.org/xmlns http://graphml.graphdrawing.org/xmlns/1.0/graphml.xsd">
  <key id="d11" for="edge" attr.name="created_at" attr.type="long" />
  <key id="d10" for="edge" attr.name="file_path" attr.type="string" />
  <key id="d9" for="edge" attr.name="source_id" attr.type="string" />
  <key id="d8" for="edge" attr.name="keywords" attr.type="string" />
  <key id="d7" for="edge" attr.name="description" attr.type="string" />
  <key id="d6" for="edge" attr.name="weight" attr.type="double" />
  <key id="d5" for="node" attr.name="created_at" attr.type="long" />
  <key id="d4" for="node" attr.name="file_path" attr.type="string" />
  <key id="d3" for="node" attr.name="source_id" attr.type="string" />
  <key id="d2" for="node" attr.name="description" attr.type="string" />
  <key id="d1" for="node" attr.name="entity_type" attr.type="string" />
  <key id="d0" for="node" attr.name="entity_id" attr.type="string" />
  <graph edgedefault="undirected">
    <node id="Signal Semaphore">
      <data key="d0">Signal Semaphore</data>
      <data key="d1">concept</data>
      <data key="d2">Signal semaphore is a synchronization mechanism used to solve mutual exclusion and synchronization problems in concurrent processes.</data>
      <data key="d3">chunk-5f130d8e8cad5fdb4c75e49961444322</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793441</data>
    </node>
    <node id="Wait Operation">
      <data key="d0">Wait Operation</data>
      <data key="d1">method</data>
      <data key="d2">The wait operation, also known as P operation, is a primitive that requests a resource and may block the process if the resource is unavailable.</data>
      <data key="d3">chunk-5f130d8e8cad5fdb4c75e49961444322</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793441</data>
    </node>
    <node id="Signal Operation">
      <data key="d0">Signal Operation</data>
      <data key="d1">method</data>
      <data key="d2">The signal operation, also known as V operation, is a primitive that releases a resource and may wake up a waiting process.</data>
      <data key="d3">chunk-5f130d8e8cad5fdb4c75e49961444322</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793441</data>
    </node>
    <node id="P Operation">
      <data key="d0">P Operation</data>
      <data key="d1">method</data>
      <data key="d2">P operation is a shorthand for the wait operation, used to request a resource in semaphore mechanisms.&lt;SEP&gt;P operation is a synchronization primitive used to acquire a semaphore before accessing a shared resource.</data>
      <data key="d3">chunk-5f130d8e8cad5fdb4c75e49961444322&lt;SEP&gt;chunk-d75ea791c964266b65c0ee55b3a8e15f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793862</data>
    </node>
    <node id="V Operation">
      <data key="d0">V Operation</data>
      <data key="d1">method</data>
      <data key="d2">V operation is a shorthand for the signal operation, used to release a resource in semaphore mechanisms.&lt;SEP&gt;V operation is a synchronization primitive used to release a semaphore after completing access to a shared resource.</data>
      <data key="d3">chunk-5f130d8e8cad5fdb4c75e49961444322&lt;SEP&gt;chunk-d75ea791c964266b65c0ee55b3a8e15f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793862</data>
    </node>
    <node id="Primitive">
      <data key="d0">Primitive</data>
      <data key="d1">method</data>
      <data key="d2">A primitive is a fundamental operation that is indivisible and uninterruptible, typically implemented by hardware.</data>
      <data key="d3">chunk-5f130d8e8cad5fdb4c75e49961444322</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793441</data>
    </node>
    <node id="Integer Semaphore">
      <data key="d0">Integer Semaphore</data>
      <data key="d1">concept</data>
      <data key="d2">Integer semaphore is a type of semaphore that uses a single integer variable to represent the number of available resources.</data>
      <data key="d3">chunk-5f130d8e8cad5fdb4c75e49961444322</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793441</data>
    </node>
    <node id="Busy Waiting">
      <data key="d0">Busy Waiting</data>
      <data key="d1">concept</data>
      <data key="d2">Busy waiting is a condition where a process continuously checks for a resource, consuming CPU cycles without yielding.&lt;SEP&gt;Busy waiting is a condition where a process repeatedly checks for the availability of a resource, such as a lock, without yielding the CPU.</data>
      <data key="d3">chunk-e16dceff2fc93c138aa86eb65cacc6c7&lt;SEP&gt;chunk-5f130d8e8cad5fdb4c75e49961444322</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793680</data>
    </node>
    <node id="Let-Go-Waiting Principle">
      <data key="d0">Let-Go-Waiting Principle</data>
      <data key="d1">concept</data>
      <data key="d2">The let-go-waiting principle states that when a process cannot obtain a resource, it should voluntarily give up the CPU instead of busy-waiting.</data>
      <data key="d3">chunk-5f130d8e8cad5fdb4c75e49961444322</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793442</data>
    </node>
    <node id="Record Semaphore">
      <data key="d0">Record Semaphore</data>
      <data key="d1">concept</data>
      <data key="d2">Record semaphore is a synchronization mechanism that avoids busy waiting by using an integer value and a list of waiting processes.</data>
      <data key="d3">chunk-5f130d8e8cad5fdb4c75e49961444322</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793442</data>
    </node>
    <node id="Value Variable">
      <data key="d0">Value Variable</data>
      <data key="d1">data</data>
      <data key="d2">The value variable in a record semaphore tracks the number of available resources.</data>
      <data key="d3">chunk-5f130d8e8cad5fdb4c75e49961444322</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793442</data>
    </node>
    <node id="Process List">
      <data key="d0">Process List</data>
      <data key="d1">data</data>
      <data key="d2">The process list in a record semaphore maintains a queue of processes waiting for a resource.</data>
      <data key="d3">chunk-5f130d8e8cad5fdb4c75e49961444322</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793442</data>
    </node>
    <node id="Block Primitive">
      <data key="d0">Block Primitive</data>
      <data key="d1">method</data>
      <data key="d2">The block primitive suspends a process and places it in a waiting queue when it cannot acquire a resource.</data>
      <data key="d3">chunk-5f130d8e8cad5fdb4c75e49961444322</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793442</data>
    </node>
    <node id="Wakeup Primitive">
      <data key="d0">Wakeup Primitive</data>
      <data key="d1">method</data>
      <data key="d2">The wakeup primitive resumes the execution of a process from the waiting queue when a resource becomes available.</data>
      <data key="d3">chunk-5f130d8e8cad5fdb4c75e49961444322</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793442</data>
    </node>
    <node id="Mutual Exclusion">
      <data key="d0">Mutual Exclusion</data>
      <data key="d1">concept</data>
      <data key="d2">Mutual exclusion ensures that only one process can access a critical resource at a time.</data>
      <data key="d3">chunk-5f130d8e8cad5fdb4c75e49961444322</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793442</data>
    </node>
    <node id="Synchronization">
      <data key="d0">Synchronization</data>
      <data key="d1">concept</data>
      <data key="d2">Synchronization coordinates the execution order of concurrent processes to ensure proper sequencing.&lt;SEP&gt;Synchronization is a mechanism used in concurrent programming to manage access to shared resources and coordinate the behavior of processes.</data>
      <data key="d3">chunk-5f130d8e8cad5fdb4c75e49961444322&lt;SEP&gt;chunk-62e7a5a2dcc4d8e5b08d9447994638c2</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794045</data>
    </node>
    <node id="Precedence Relationship">
      <data key="d0">Precedence Relationship</data>
      <data key="d1">concept</data>
      <data key="d2">A precedence relationship defines the order in which operations or statements must execute relative to each other.</data>
      <data key="d3">chunk-5f130d8e8cad5fdb4c75e49961444322</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793444</data>
    </node>
    <node id="Critical Section">
      <data key="d0">Critical Section</data>
      <data key="d1">concept</data>
      <data key="d2">A critical section is a segment of code where a shared resource is accessed, requiring exclusivity.</data>
      <data key="d3">chunk-5f130d8e8cad5fdb4c75e49961444322</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793444</data>
    </node>
    <node id="Resource Allocation">
      <data key="d0">Resource Allocation</data>
      <data key="d1">concept</data>
      <data key="d2">Resource allocation is the management of access to shared resources among concurrent processes.&lt;SEP&gt;Resource allocation refers to the system's distribution of CPU time, memory, and other devices to processes as independent units.</data>
      <data key="d3">chunk-5f130d8e8cad5fdb4c75e49961444322&lt;SEP&gt;chunk-fd195ae7c40727c5b83fa7b77d72095e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794199</data>
    </node>
    <node id="P() Operation">
      <data key="d0">P() Operation</data>
      <data key="d1">method</data>
      <data key="d2">P() operation is an alternative notation for the wait operation in semaphore mechanisms, used to request a resource.</data>
      <data key="d3">chunk-5f130d8e8cad5fdb4c75e49961444322</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793444</data>
    </node>
    <node id="V() Operation">
      <data key="d0">V() Operation</data>
      <data key="d1">method</data>
      <data key="d2">V() operation is an alternative notation for the signal operation in semaphore mechanisms, used to release a resource.</data>
      <data key="d3">chunk-5f130d8e8cad5fdb4c75e49961444322</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793444</data>
    </node>
    <node id="FCFS Scheduling Algorithm">
      <data key="d0">FCFS Scheduling Algorithm</data>
      <data key="d1">method</data>
      <data key="d2">FCFS (First-Come, First-Served) is a scheduling method where processes are served in the order they arrive in the ready queue.&lt;SEP&gt;FCFS (First-Come, First-Served) Scheduling Algorithm is a simple, non-preemptive scheduling method used for both job and process scheduling, where the first job or process in the queue is selected for execution.</data>
      <data key="d3">chunk-361e96af48cd5d95ba6650e6d3810455&lt;SEP&gt;chunk-1b524b2458aae3cb2440c44f7981f746</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793467</data>
    </node>
    <node id="Round Robin Scheduling Algorithm">
      <data key="d0">Round Robin Scheduling Algorithm</data>
      <data key="d1">method</data>
      <data key="d2">Round Robin is a time-sharing scheduling algorithm that allocates CPU time in fixed-time slices (time quanta) to each process in the ready queue.&lt;SEP&gt;RR (Round Robin) Scheduling Algorithm is a time-sharing method suitable for time-sharing systems, where processes are executed in a cyclic order with a fixed time slice (time quantum).</data>
      <data key="d3">chunk-361e96af48cd5d95ba6650e6d3810455&lt;SEP&gt;chunk-1b524b2458aae3cb2440c44f7981f746</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793467</data>
    </node>
    <node id="Time Quantum">
      <data key="d0">Time Quantum</data>
      <data key="d1">concept</data>
      <data key="d2">Time quantum is the fixed amount of time a process is allowed to run before being preempted and moved to the end of the ready queue.&lt;SEP&gt;The Time Quantum is a fixed time interval allocated to each process in the Round Robin scheduling algorithm.</data>
      <data key="d3">chunk-361e96af48cd5d95ba6650e6d3810455&lt;SEP&gt;chunk-1b524b2458aae3cb2440c44f7981f746</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793467</data>
    </node>
    <node id="Multilevel Queue Scheduling Algorithm">
      <data key="d0">Multilevel Queue Scheduling Algorithm</data>
      <data key="d1">method</data>
      <data key="d2">Multilevel Queue Scheduling divides the ready queue into multiple separate queues, each with its own scheduling algorithm.</data>
      <data key="d3">chunk-361e96af48cd5d95ba6650e6d3810455</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793467</data>
    </node>
    <node id="Multilevel Feedback Queue Scheduling Algorithm">
      <data key="d0">Multilevel Feedback Queue Scheduling Algorithm</data>
      <data key="d1">method</data>
      <data key="d2">Multilevel Feedback Queue Scheduling dynamically adjusts the priority and time quantum of processes based on their behavior, combining features of multiple scheduling algorithms.</data>
      <data key="d3">chunk-361e96af48cd5d95ba6650e6d3810455</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793467</data>
    </node>
    <node id="Fairness">
      <data key="d0">Fairness</data>
      <data key="d1">concept</data>
      <data key="d2">Fairness in scheduling refers to the equitable distribution of CPU resources among processes or users.</data>
      <data key="d3">chunk-361e96af48cd5d95ba6650e6d3810455</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793467</data>
    </node>
    <node id="Guaranteed Scheduling Algorithm">
      <data key="d0">Guaranteed Scheduling Algorithm</data>
      <data key="d1">method</data>
      <data key="d2">Guaranteed Scheduling Algorithm ensures that each user receives a guaranteed share of CPU time, typically 1/n for n logged-in users.</data>
      <data key="d3">chunk-361e96af48cd5d95ba6650e6d3810455</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793467</data>
    </node>
    <node id="Fair Share Scheduling Algorithm">
      <data key="d0">Fair Share Scheduling Algorithm</data>
      <data key="d1">method</data>
      <data key="d2">Fair Share Scheduling Algorithm ensures that all users receive equal CPU time or the proportion of time they require.</data>
      <data key="d3">chunk-361e96af48cd5d95ba6650e6d3810455</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793467</data>
    </node>
    <node id="Ready Queue">
      <data key="d0">Ready Queue</data>
      <data key="d1">concept</data>
      <data key="d2">The Ready Queue is a data structure that holds all processes ready to run and awaiting allocation of the CPU.&lt;SEP&gt;The Ready Queue is a list of processes that are waiting for the CPU and are ready to be executed.&lt;SEP&gt;The Ready Queue is a system-organized list containing all processes in the Ready State, waiting for CPU allocation.&lt;SEP&gt;The ready queue is a data structure in operating systems that holds processes waiting to be assigned to the CPU for execution.&lt;SEP&gt;The Ready Queue is a data structure containing all processes that are ready to run but are waiting for CPU allocation.&lt;SEP&gt;The ready queue is a list of processes waiting to be assigned to the CPU, where waiting time is accumulated.</data>
      <data key="d3">chunk-361e96af48cd5d95ba6650e6d3810455&lt;SEP&gt;chunk-491042f5eab097ef962a4657a4b61650&lt;SEP&gt;chunk-1b524b2458aae3cb2440c44f7981f746&lt;SEP&gt;chunk-76ab4199a2aae3d8b4b3b6c270c34a12&lt;SEP&gt;chunk-c39617d7522bbe85482a3d992382cd4b&lt;SEP&gt;chunk-156e9bc4a555d2a7cb0d3724273d5ea6</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794298</data>
    </node>
    <node id="CPU">
      <data key="d0">CPU</data>
      <data key="d1">artifact</data>
      <data key="d2">CPU is the central processing unit of a computer, responsible for executing instructions.&lt;SEP&gt;The CPU (Central Processing Unit) is the primary component responsible for executing instructions in a computer system.&lt;SEP&gt;The CPU is the central processing unit responsible for executing instructions and managing process execution.&lt;SEP&gt;The CPU is the central processing unit of a computer, responsible for executing instructions and managing the operation of threads and processes.&lt;SEP&gt;The CPU is the central processing unit responsible for executing instructions and managing process execution.</data>
      <data key="d3">chunk-e2c5907dce4f167e0b11853c616e448f&lt;SEP&gt;chunk-361e96af48cd5d95ba6650e6d3810455&lt;SEP&gt;chunk-1b524b2458aae3cb2440c44f7981f746&lt;SEP&gt;chunk-491042f5eab097ef962a4657a4b61650&lt;SEP&gt;chunk-156e9bc4a555d2a7cb0d3724273d5ea6</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794031</data>
    </node>
    <node id="Interrupt">
      <data key="d0">Interrupt</data>
      <data key="d1">event</data>
      <data key="d2">An interrupt is a signal generated by hardware or software to prompt the processor to suspend its current activity and execute a special routine.&lt;SEP&gt;An Interrupt is a signal generated by hardware or software indicating an event that requires immediate attention from the processor, often triggering a state transition.&lt;SEP&gt;An Interrupt is a signal that temporarily halts the execution of a process to handle an external event.</data>
      <data key="d3">chunk-361e96af48cd5d95ba6650e6d3810455&lt;SEP&gt;chunk-491042f5eab097ef962a4657a4b61650&lt;SEP&gt;chunk-156e9bc4a555d2a7cb0d3724273d5ea6</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794031</data>
    </node>
    <node id="Process">
      <data key="d0">Process</data>
      <data key="d1">concept</data>
      <data key="d2">Process is an instance of a program in execution, serving as the fundamental unit for resource allocation and scheduling within an operating system. It represents a dynamic, independent running entity that consists of program code, its current state, and associated system resources such as memory, file descriptors, and I/O devices. Each process operates within its own execution environment, managed by the operating system, which oversees its lifecycle, resource usage, and behavior. The process serves as a container for one or more threads, enabling concurrent execution and enabling coordinated interactions through synchronization and communication mechanisms. It is characterized by key attributes including independence, dynamic behavior, concurrency, and asynchrony, allowing multiple processes to run simultaneously while maintaining distinct states and execution paths. Processes can also receive and respond to signals, facilitating inter-process communication and external control. Collectively, these features make a process a core abstraction in modern computing systems, central to the efficient and secure operation of software environments.</data>
      <data key="d3">chunk-e2c5907dce4f167e0b11853c616e448f&lt;SEP&gt;chunk-361e96af48cd5d95ba6650e6d3810455&lt;SEP&gt;chunk-491042f5eab097ef962a4657a4b61650&lt;SEP&gt;chunk-c39617d7522bbe85482a3d992382cd4b&lt;SEP&gt;chunk-c214e070db9e1fbcd76d28e9e144db30&lt;SEP&gt;chunk-fd195ae7c40727c5b83fa7b77d72095e&lt;SEP&gt;chunk-62e7a5a2dcc4d8e5b08d9447994638c2&lt;SEP&gt;chunk-2da376f0975743dcb0cc169c929cbe5c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794212</data>
    </node>
    <node id="Priority">
      <data key="d0">Priority</data>
      <data key="d1">concept</data>
      <data key="d2">Priority is a value assigned to a process or queue to determine its order of execution in a scheduling system.</data>
      <data key="d3">chunk-361e96af48cd5d95ba6650e6d3810455</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793469</data>
    </node>
    <node id="Time Slice">
      <data key="d0">Time Slice</data>
      <data key="d1">concept</data>
      <data key="d2">A time slice is a fixed duration of time during which a process is allowed to execute before being preempted.&lt;SEP&gt;A Time Slice is a fixed period of CPU time allocated to a process during which it can execute before being preempted, triggering a state transition when expired.&lt;SEP&gt;A time slice is a unit of CPU time allocated to a process, representing how CPU resources are assigned to processes in a time-sharing system.</data>
      <data key="d3">chunk-361e96af48cd5d95ba6650e6d3810455&lt;SEP&gt;chunk-156e9bc4a555d2a7cb0d3724273d5ea6&lt;SEP&gt;chunk-fd195ae7c40727c5b83fa7b77d72095e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794199</data>
    </node>
    <node id="Process Execution">
      <data key="d0">Process Execution</data>
      <data key="d1">concept</data>
      <data key="d2">Process execution refers to the state in which a process is actively running on the CPU, utilizing allocated time slices or priority queues for its operation.&lt;SEP&gt;Process execution refers to the lifecycle and operational state changes of a process from creation to completion.</data>
      <data key="d3">chunk-c39617d7522bbe85482a3d992382cd4b&lt;SEP&gt;chunk-361e96af48cd5d95ba6650e6d3810455</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793782</data>
    </node>
    <node id="Preemption">
      <data key="d0">Preemption</data>
      <data key="d1">concept</data>
      <data key="d2">Preemption is the act of forcibly removing a running process from the CPU before it completes its time slice to allocate the CPU to another process based on scheduling rules.</data>
      <data key="d3">chunk-361e96af48cd5d95ba6650e6d3810455</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793469</data>
    </node>
    <node id="System Performance">
      <data key="d0">System Performance</data>
      <data key="d1">concept</data>
      <data key="d2">System performance is the overall efficiency and responsiveness of a computing system, influenced by scheduling algorithm behavior and resource allocation.</data>
      <data key="d3">chunk-361e96af48cd5d95ba6650e6d3810455</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793470</data>
    </node>
    <node id="Shortest Job First Scheduling Algorithm">
      <data key="d0">Shortest Job First Scheduling Algorithm</data>
      <data key="d1">method</data>
      <data key="d2">SJF (Shortest Job First) Scheduling Algorithm prioritizes jobs or processes with the shortest estimated execution time, aiming to improve average waiting time but potentially causing starvation for long jobs.</data>
      <data key="d3">chunk-1b524b2458aae3cb2440c44f7981f746</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793470</data>
    </node>
    <node id="Shortest Process First Scheduling Algorithm">
      <data key="d0">Shortest Process First Scheduling Algorithm</data>
      <data key="d1">method</data>
      <data key="d2">SPF (Shortest Process First) Scheduling Algorithm selects the process with the shortest estimated execution time from the ready queue, and can be either preemptive or non-preemptive.</data>
      <data key="d3">chunk-1b524b2458aae3cb2440c44f7981f746</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793470</data>
    </node>
    <node id="Highest Response Ratio First Scheduling Algorithm">
      <data key="d0">Highest Response Ratio First Scheduling Algorithm</data>
      <data key="d1">method</data>
      <data key="d2">HRRF (Highest Response Ratio First) Scheduling Algorithm balances FCFS and SJF by prioritizing jobs based on the response ratio, which considers both waiting time and required service time.</data>
      <data key="d3">chunk-1b524b2458aae3cb2440c44f7981f746</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793470</data>
    </node>
    <node id="Priority Scheduling Algorithm">
      <data key="d0">Priority Scheduling Algorithm</data>
      <data key="d1">method</data>
      <data key="d2">Priority Scheduling Algorithm assigns priorities to processes or jobs and schedules them accordingly, with variants based on preemptive or non-preemptive behavior and static or dynamic priorities.</data>
      <data key="d3">chunk-1b524b2458aae3cb2440c44f7981f746</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793470</data>
    </node>
    <node id="Backlog Job Queue">
      <data key="d0">Backlog Job Queue</data>
      <data key="d1">queue</data>
      <data key="d2">The Backlog Job Queue is a waiting list of jobs that have been submitted but not yet allocated resources or scheduled for execution.</data>
      <data key="d3">chunk-1b524b2458aae3cb2440c44f7981f746</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793470</data>
    </node>
    <node id="Waiting Time">
      <data key="d0">Waiting Time</data>
      <data key="d1">concept</data>
      <data key="d2">Waiting Time refers to the duration a job or process spends in the ready or backlog queue before being executed.&lt;SEP&gt;Waiting time refers to the total time a process spends waiting in the ready queue for CPU access, directly affecting user satisfaction.</data>
      <data key="d3">chunk-76ab4199a2aae3d8b4b3b6c270c34a12&lt;SEP&gt;chunk-1b524b2458aae3cb2440c44f7981f746</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794297</data>
    </node>
    <node id="Execution Time">
      <data key="d0">Execution Time</data>
      <data key="d1">concept</data>
      <data key="d2">Execution Time is the estimated or actual time required for a job or process to complete its execution.</data>
      <data key="d3">chunk-1b524b2458aae3cb2440c44f7981f746</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793470</data>
    </node>
    <node id="Response Ratio">
      <data key="d0">Response Ratio</data>
      <data key="d1">concept</data>
      <data key="d2">Response Ratio is a metric used in the HRRF scheduling algorithm, defined as (Waiting Time + Required Service Time) / Required Service Time.</data>
      <data key="d3">chunk-1b524b2458aae3cb2440c44f7981f746</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793470</data>
    </node>
    <node id="Preemptive Scheduling">
      <data key="d0">Preemptive Scheduling</data>
      <data key="d1">method</data>
      <data key="d2">Preemptive Scheduling is a method where a currently running process can be interrupted and replaced by a higher-priority or shorter pending process.&lt;SEP&gt;Preemptive Scheduling allows a higher-priority or more urgent process to interrupt a currently running process and take control of the CPU.</data>
      <data key="d3">chunk-1b524b2458aae3cb2440c44f7981f746&lt;SEP&gt;chunk-491042f5eab097ef962a4657a4b61650</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794029</data>
    </node>
    <node id="Non-Preemptive Scheduling">
      <data key="d0">Non-Preemptive Scheduling</data>
      <data key="d1">method</data>
      <data key="d2">Non-Preemptive Scheduling is a method where a process runs to completion or blocks before a new process can be scheduled.&lt;SEP&gt;Non-Preemptive Scheduling allows a process to run until it completes or blocks, without interruption, even if a higher-priority process arrives.</data>
      <data key="d3">chunk-1b524b2458aae3cb2440c44f7981f746&lt;SEP&gt;chunk-491042f5eab097ef962a4657a4b61650</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794029</data>
    </node>
    <node id="Static Priority">
      <data key="d0">Static Priority</data>
      <data key="d1">concept</data>
      <data key="d2">Static Priority is a priority assigned at process creation and remains unchanged throughout its lifetime.</data>
      <data key="d3">chunk-1b524b2458aae3cb2440c44f7981f746</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793472</data>
    </node>
    <node id="Dynamic Priority">
      <data key="d0">Dynamic Priority</data>
      <data key="d1">concept</data>
      <data key="d2">Dynamic Priority is a priority that changes during process execution, often based on waiting time or other system criteria.</data>
      <data key="d3">chunk-1b524b2458aae3cb2440c44f7981f746</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793472</data>
    </node>
    <node id="System Process">
      <data key="d0">System Process</data>
      <data key="d1">concept</data>
      <data key="d2">A System Process is a high-priority process managed by the operating system for core functions.</data>
      <data key="d3">chunk-1b524b2458aae3cb2440c44f7981f746</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793472</data>
    </node>
    <node id="User Process">
      <data key="d0">User Process</data>
      <data key="d1">concept</data>
      <data key="d2">A User Process is a process initiated by a user application and typically has lower priority than system processes.</data>
      <data key="d3">chunk-1b524b2458aae3cb2440c44f7981f746</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793472</data>
    </node>
    <node id="Interactive Process">
      <data key="d0">Interactive Process</data>
      <data key="d1">concept</data>
      <data key="d2">An Interactive Process is a process that interacts frequently with users, often requiring quick response times.</data>
      <data key="d3">chunk-1b524b2458aae3cb2440c44f7981f746</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793472</data>
    </node>
    <node id="Non-Interactive Process">
      <data key="d0">Non-Interactive Process</data>
      <data key="d1">concept</data>
      <data key="d2">A Non-Interactive Process is a background task that runs without user interaction and typically has lower priority.</data>
      <data key="d3">chunk-1b524b2458aae3cb2440c44f7981f746</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793472</data>
    </node>
    <node id="I/O-Bound Process">
      <data key="d0">I/O-Bound Process</data>
      <data key="d1">concept</data>
      <data key="d2">An I/O-Bound Process is a process that spends significant time waiting for input/output operations to complete.</data>
      <data key="d3">chunk-1b524b2458aae3cb2440c44f7981f746</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793472</data>
    </node>
    <node id="CPU-Bound Process">
      <data key="d0">CPU-Bound Process</data>
      <data key="d1">concept</data>
      <data key="d2">A CPU-Bound Process is a process that spends most of its time performing computations and requires significant CPU resources.</data>
      <data key="d3">chunk-1b524b2458aae3cb2440c44f7981f746</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793473</data>
    </node>
    <node id="Preemptive Shortest Process First">
      <data key="d0">Preemptive Shortest Process First</data>
      <data key="d1">method</data>
      <data key="d2">Preemptive Shortest Process First is a scheduling algorithm where a new process with a shorter remaining execution time can preempt the currently running process.</data>
      <data key="d3">chunk-1b524b2458aae3cb2440c44f7981f746</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793473</data>
    </node>
    <node id="管程">
      <data key="d0">管程</data>
      <data key="d1">concept</data>
      <data key="d2">管程是用于进程同步的一种机制，通过封装共享资源及其操作，实现进程互斥访问。</data>
      <data key="d3">chunk-77d7b8e6f06999efb089a2a4176d1434</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793536</data>
    </node>
    <node id="信号量机制">
      <data key="d0">信号量机制</data>
      <data key="d1">concept</data>
      <data key="d2">信号量机制是一种用于管理临界资源访问的同步方法，要求每个进程自行实现PV操作。</data>
      <data key="d3">chunk-77d7b8e6f06999efb089a2a4176d1434</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793536</data>
    </node>
    <node id="PV操作">
      <data key="d0">PV操作</data>
      <data key="d1">method</data>
      <data key="d2">PV操作是信号量机制中用于实现进程同步的两个基本原语，分别表示wait和signal。</data>
      <data key="d3">chunk-77d7b8e6f06999efb089a2a4176d1434</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793536</data>
    </node>
    <node id="临界资源">
      <data key="d0">临界资源</data>
      <data key="d1">artifact</data>
      <data key="d2">临界资源是多个进程共享的、必须互斥访问的资源。&lt;SEP&gt;The critical resource is a shared object (like the buffer or file) that must be accessed in a mutually exclusive manner to prevent race conditions.&lt;SEP&gt;临界资源is a system resource that can be used by only one process at a time, requiring exclusive access to prevent conflicts.</data>
      <data key="d3">chunk-77d7b8e6f06999efb089a2a4176d1434&lt;SEP&gt;chunk-d3e84198ebbd072f7382ef600186508e&lt;SEP&gt;chunk-96612cb99be5ccc8684e38f3d50f77f5</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793745</data>
    </node>
    <node id="共享数据结构">
      <data key="d0">共享数据结构</data>
      <data key="d1">data</data>
      <data key="d2">共享数据结构是管程中用于抽象表示共享资源的数据集合。</data>
      <data key="d3">chunk-77d7b8e6f06999efb089a2a4176d1434</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793536</data>
    </node>
    <node id="条件变量">
      <data key="d0">条件变量</data>
      <data key="d1">concept</data>
      <data key="d2">条件变量是用于管理因等待特定条件而阻塞进程的机制，支持wait和signal操作。</data>
      <data key="d3">chunk-77d7b8e6f06999efb089a2a4176d1434</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793536</data>
    </node>
    <node id="等待队列">
      <data key="d0">等待队列</data>
      <data key="d1">concept</data>
      <data key="d2">等待队列是条件变量中用于记录因该条件而阻塞的进程的队列结构。&lt;SEP&gt;等待队列是存储因等待特定事件而被阻塞的进程的队列。</data>
      <data key="d3">chunk-77d7b8e6f06999efb089a2a4176d1434&lt;SEP&gt;chunk-7ca51faf7f3faf56c56ab18dd6458c7e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794042</data>
    </node>
    <node id="x.wait">
      <data key="d0">x.wait</data>
      <data key="d1">method</data>
      <data key="d2">x.wait是条件变量的操作，当条件不满足时，进程调用该过程加入等待队列并释放管程。</data>
      <data key="d3">chunk-77d7b8e6f06999efb089a2a4176d1434</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793536</data>
    </node>
    <node id="x.signal">
      <data key="d0">x.signal</data>
      <data key="d1">method</data>
      <data key="d2">x.signal是条件变量的操作，当条件满足时，唤醒一个因该条件而阻塞的进程。</data>
      <data key="d3">chunk-77d7b8e6f06999efb089a2a4176d1434</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793538</data>
    </node>
    <node id="进程互斥">
      <data key="d0">进程互斥</data>
      <data key="d1">concept</data>
      <data key="d2">进程互斥是确保同一时间只有一个进程可进入管程的机制。</data>
      <data key="d3">chunk-77d7b8e6f06999efb089a2a4176d1434</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793538</data>
    </node>
    <node id="共享资源">
      <data key="d0">共享资源</data>
      <data key="d1">concept</data>
      <data key="d2">共享资源是多个进程可访问的资源，需通过管程进行受控访问。</data>
      <data key="d3">chunk-77d7b8e6f06999efb089a2a4176d1434</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793538</data>
    </node>
    <node id="管程名称">
      <data key="d0">管程名称</data>
      <data key="d1">data</data>
      <data key="d2">管程名称是管程的唯一标识符，用于区分不同管程。</data>
      <data key="d3">chunk-77d7b8e6f06999efb089a2a4176d1434</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793538</data>
    </node>
    <node id="初始值语句">
      <data key="d0">初始值语句</data>
      <data key="d1">method</data>
      <data key="d2">初始值语句用于对管程内部的共享数据结构设置初始值。</data>
      <data key="d3">chunk-77d7b8e6f06999efb089a2a4176d1434</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793538</data>
    </node>
    <node id="临界区互斥">
      <data key="d0">临界区互斥</data>
      <data key="d1">concept</data>
      <data key="d2">临界区互斥is a fundamental concept in concurrent programming that ensures only one process can access a critical section at a time.</data>
      <data key="d3">chunk-d9ae7922752a96dfde647be32905f641</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793549</data>
    </node>
    <node id="软件实现方法">
      <data key="d0">软件实现方法</data>
      <data key="d1">method</data>
      <data key="d2">软件实现方法refers to programming techniques using shared variables and loops to enforce mutual exclusion in critical sections.</data>
      <data key="d3">chunk-d9ae7922752a96dfde647be32905f641</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793549</data>
    </node>
    <node id="中断屏蔽方法">
      <data key="d0">中断屏蔽方法</data>
      <data key="d1">method</data>
      <data key="d2">中断屏蔽方法is a hardware-level technique that disables interrupts to prevent context switching during critical section execution.</data>
      <data key="d3">chunk-d9ae7922752a96dfde647be32905f641</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793549</data>
    </node>
    <node id="硬件指令方法">
      <data key="d0">硬件指令方法</data>
      <data key="d1">method</data>
      <data key="d2">硬件指令方法involves using atomic hardware instructions to implement mutual exclusion.</data>
      <data key="d3">chunk-d9ae7922752a96dfde647be32905f641</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793549</data>
    </node>
    <node id="算法一">
      <data key="d0">算法一</data>
      <data key="d1">method</data>
      <data key="d2">算法一, or the Single Flag Method, uses a shared variable 'turn' to determine which process can enter the critical section.</data>
      <data key="d3">chunk-d9ae7922752a96dfde647be32905f641</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793549</data>
    </node>
    <node id="单标志法">
      <data key="d0">单标志法</data>
      <data key="d1">method</data>
      <data key="d2">单标志法is a mutual exclusion algorithm using a single shared integer variable 'turn' to manage access to the critical section.</data>
      <data key="d3">chunk-d9ae7922752a96dfde647be32905f641</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793549</data>
    </node>
    <node id="算法二">
      <data key="d0">算法二</data>
      <data key="d1">method</data>
      <data key="d2">算法二, or the Two Flags Before Check Method, uses a boolean array 'flag[]' to indicate intent to enter the critical section.</data>
      <data key="d3">chunk-d9ae7922752a96dfde647be32905f641</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793549</data>
    </node>
    <node id="双标志先检查法">
      <data key="d0">双标志先检查法</data>
      <data key="d1">method</data>
      <data key="d2">双标志先检查法allows processes to check each other's flags before entering but may result in both processes entering simultaneously.</data>
      <data key="d3">chunk-d9ae7922752a96dfde647be32905f641</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793549</data>
    </node>
    <node id="算法三">
      <data key="d0">算法三</data>
      <data key="d1">method</data>
      <data key="d2">算法三, or the Two Flags After Check Method, sets a process's flag first, then checks the other’s flag.</data>
      <data key="d3">chunk-d9ae7922752a96dfde647be32905f641</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793550</data>
    </node>
    <node id="双标志后检查法">
      <data key="d0">双标志后检查法</data>
      <data key="d1">method</data>
      <data key="d2">双标志后检查法sets the own flag before checking the other's, but can lead to deadlock or starvation.</data>
      <data key="d3">chunk-d9ae7922752a96dfde647be32905f641</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793550</data>
    </node>
    <node id="算法四">
      <data key="d0">算法四</data>
      <data key="d1">method</data>
      <data key="d2">算法四, or Peterson's Algorithm, combines flag and turn variables to ensure mutual exclusion and fairness.</data>
      <data key="d3">chunk-d9ae7922752a96dfde647be32905f641</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793550</data>
    </node>
    <node id="Peterson算法">
      <data key="d0">Peterson算法</data>
      <data key="d1">method</data>
      <data key="d2">Peterson算法is a software-based mutual exclusion algorithm that prevents race conditions and avoids starvation.</data>
      <data key="d3">chunk-d9ae7922752a96dfde647be32905f641</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793550</data>
    </node>
    <node id="TestAndSet指令">
      <data key="d0">TestAndSet指令</data>
      <data key="d1">artifact</data>
      <data key="d2">TestAndSet指令is a hardware atomic instruction that reads and sets a lock flag in one operation.</data>
      <data key="d3">chunk-d9ae7922752a96dfde647be32905f641</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793550</data>
    </node>
    <node id="Swap指令">
      <data key="d0">Swap指令</data>
      <data key="d1">artifact</data>
      <data key="d2">Swap指令is a hardware atomic instruction that exchanges the contents of two memory locations.</data>
      <data key="d3">chunk-d9ae7922752a96dfde647be32905f641</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793550</data>
    </node>
    <node id="turn">
      <data key="d0">turn</data>
      <data key="d1">data</data>
      <data key="d2">turn is a shared integer variable used in mutual exclusion algorithms to indicate which process has the right to enter the critical section.</data>
      <data key="d3">chunk-d9ae7922752a96dfde647be32905f641</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793550</data>
    </node>
    <node id="flag">
      <data key="d0">flag</data>
      <data key="d1">data</data>
      <data key="d2">flag is a boolean array used to indicate whether a process intends to enter the critical section.</data>
      <data key="d3">chunk-d9ae7922752a96dfde647be32905f641</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793550</data>
    </node>
    <node id="P₀">
      <data key="d0">P₀</data>
      <data key="d1">person</data>
      <data key="d2">P₀ is the first process in the mutual exclusion algorithms discussed.</data>
      <data key="d3">chunk-d9ae7922752a96dfde647be32905f641</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793551</data>
    </node>
    <node id="P₁">
      <data key="d0">P₁</data>
      <data key="d1">person</data>
      <data key="d2">P₁ is the second process in the mutual exclusion algorithms discussed.</data>
      <data key="d3">chunk-d9ae7922752a96dfde647be32905f641</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793552</data>
    </node>
    <node id="临界区">
      <data key="d0">临界区</data>
      <data key="d1">concept</data>
      <data key="d2">临界区refers to a section of code that must not be concurrently accessed by multiple processes.&lt;SEP&gt;临界区is the section of code within a process that accesses a critical resource and must be executed exclusively.</data>
      <data key="d3">chunk-d9ae7922752a96dfde647be32905f641&lt;SEP&gt;chunk-96612cb99be5ccc8684e38f3d50f77f5</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793745</data>
    </node>
    <node id="空闲让进">
      <data key="d0">空闲让进</data>
      <data key="d1">concept</data>
      <data key="d2">空闲让进is a requirement of mutual exclusion algorithms that allows a process to enter the critical section when it is free.&lt;SEP&gt;空闲让进is a rule in synchronization mechanisms requiring that when the critical section is free, a requesting process should be allowed to enter immediately.</data>
      <data key="d3">chunk-d9ae7922752a96dfde647be32905f641&lt;SEP&gt;chunk-96612cb99be5ccc8684e38f3d50f77f5</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793746</data>
    </node>
    <node id="有限等待">
      <data key="d0">有限等待</data>
      <data key="d1">concept</data>
      <data key="d2">有限等待is a requirement ensuring that a process waiting to enter a critical section will eventually do so.&lt;SEP&gt;有限等待ensures that a process requesting access to the critical section will be allowed to enter within a finite amount of time, avoiding indefinite delay.</data>
      <data key="d3">chunk-d9ae7922752a96dfde647be32905f641&lt;SEP&gt;chunk-96612cb99be5ccc8684e38f3d50f77f5</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793747</data>
    </node>
    <node id="让权等待">
      <data key="d0">让权等待</data>
      <data key="d1">concept</data>
      <data key="d2">让权等待is a principle where a waiting process does not consume CPU cycles while waiting.&lt;SEP&gt;让权等待is a principle that when a process cannot enter the critical section, it should release the processor to prevent busy waiting.</data>
      <data key="d3">chunk-d9ae7922752a96dfde647be32905f641&lt;SEP&gt;chunk-96612cb99be5ccc8684e38f3d50f77f5</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793747</data>
    </node>
    <node id="饥饿">
      <data key="d0">饥饿</data>
      <data key="d1">concept</data>
      <data key="d2">饥饿refers to a situation where a process is indefinitely denied access to the critical section.&lt;SEP&gt;饥饿是指进程因长期无法获得所需资源而无法继续执行的状态。</data>
      <data key="d3">chunk-9aabe855c161e30442ff85ca7a64312e&lt;SEP&gt;chunk-d9ae7922752a96dfde647be32905f641</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793964</data>
    </node>
    <node id="原子操作">
      <data key="d0">原子操作</data>
      <data key="d1">concept</data>
      <data key="d2">原子操作is a fundamental property of hardware instructions that ensures an operation is completed without interruption, critical for mutual exclusion.</data>
      <data key="d3">chunk-d9ae7922752a96dfde647be32905f641</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793552</data>
    </node>
    <node id="Running State">
      <data key="d0">Running State</data>
      <data key="d1">concept</data>
      <data key="d2">The Running State is a process state where the process is actively executing on the CPU.&lt;SEP&gt;The running state is when a thread is actively executing on the CPU.</data>
      <data key="d3">chunk-e2c5907dce4f167e0b11853c616e448f&lt;SEP&gt;chunk-156e9bc4a555d2a7cb0d3724273d5ea6</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793921</data>
    </node>
    <node id="Ready State">
      <data key="d0">Ready State</data>
      <data key="d1">concept</data>
      <data key="d2">The Ready State is a process state where the process has all necessary resources except the CPU and is waiting to be scheduled for execution.&lt;SEP&gt;The ready state is the condition of a process that has been loaded into memory, possesses all required resources, and is waiting to be scheduled for execution.&lt;SEP&gt;The ready state is when a thread is prepared to execute but is waiting for the CPU to become available.&lt;SEP&gt;The ready state describes a thread that has all necessary resources and is awaiting CPU allocation to begin execution.</data>
      <data key="d3">chunk-e2c5907dce4f167e0b11853c616e448f&lt;SEP&gt;chunk-34425c38108ef3730cc0889df3f8434a&lt;SEP&gt;chunk-c39617d7522bbe85482a3d992382cd4b&lt;SEP&gt;chunk-156e9bc4a555d2a7cb0d3724273d5ea6</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793915</data>
    </node>
    <node id="Blocked State">
      <data key="d0">Blocked State</data>
      <data key="d1">concept</data>
      <data key="d2">The Blocked State, also known as Waiting State, is a process state where the process is waiting for a specific event or resource (excluding CPU) and cannot run even if the CPU is available.&lt;SEP&gt;The blocked state is when a thread is waiting for an external event, such as I/O, before it can proceed.&lt;SEP&gt;The blocked state occurs when a thread is paused due to an event it is waiting for, such as I/O completion or a lock.</data>
      <data key="d3">chunk-e2c5907dce4f167e0b11853c616e448f&lt;SEP&gt;chunk-34425c38108ef3730cc0889df3f8434a&lt;SEP&gt;chunk-156e9bc4a555d2a7cb0d3724273d5ea6</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793915</data>
    </node>
    <node id="Created State">
      <data key="d0">Created State</data>
      <data key="d1">concept</data>
      <data key="d2">The Created State is a process state where the process is being created and has not yet been assigned to the ready queue; it may be delayed if required resources like memory are unavailable.</data>
      <data key="d3">chunk-156e9bc4a555d2a7cb0d3724273d5ea6</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793610</data>
    </node>
    <node id="Terminated State">
      <data key="d0">Terminated State</data>
      <data key="d1">concept</data>
      <data key="d2">The Terminated State is a process state where the process is being removed from the system, either by normal completion or other termination reasons, and system resources are being reclaimed.</data>
      <data key="d3">chunk-156e9bc4a555d2a7cb0d3724273d5ea6</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793610</data>
    </node>
    <node id="Blocked Queue">
      <data key="d0">Blocked Queue</data>
      <data key="d1">data</data>
      <data key="d2">The Blocked Queue is a system-organized list containing processes in the Blocked State, often categorized by the type of event or resource they are waiting for.</data>
      <data key="d3">chunk-156e9bc4a555d2a7cb0d3724273d5ea6</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793610</data>
    </node>
    <node id="Process Control Block">
      <data key="d0">Process Control Block</data>
      <data key="d1">artifact</data>
      <data key="d2">The Process Control Block is a data structure used by the operating system to store information about a process, including its state, scheduling information, and resource usage.&lt;SEP&gt;The Process Control Block (PCB) is a data structure that stores information about a process, including pending and blocked signals.&lt;SEP&gt;The Process Control Block is a data structure used by the operating system to manage and track information about a process.&lt;SEP&gt;The Process Control Block (PCB) is a data structure that stores all state information for a process, including CPU registers and execution status.&lt;SEP&gt;The Process Control Block (PCB) is a data structure used by the operating system to manage and track the state and resources of a process; it is essential for process existence and is stored in memory throughout the process life cycle.&lt;SEP&gt;The Process Control Block (PCB) is a data structure used by the operating system to store information about a process, including its state, program counter, and resource usage.</data>
      <data key="d3">chunk-e2c5907dce4f167e0b11853c616e448f&lt;SEP&gt;chunk-d75ea791c964266b65c0ee55b3a8e15f&lt;SEP&gt;chunk-491042f5eab097ef962a4657a4b61650&lt;SEP&gt;chunk-fd195ae7c40727c5b83fa7b77d72095e&lt;SEP&gt;chunk-156e9bc4a555d2a7cb0d3724273d5ea6&lt;SEP&gt;chunk-2da376f0975743dcb0cc169c929cbe5c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794199</data>
    </node>
    <node id="Resource">
      <data key="d0">Resource</data>
      <data key="d1">concept</data>
      <data key="d2">A Resource refers to any system element required by a process, such as memory, I/O devices, or files, which may cause a process to enter a blocked state when unavailable.</data>
      <data key="d3">chunk-156e9bc4a555d2a7cb0d3724273d5ea6</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793612</data>
    </node>
    <node id="I/O Operation">
      <data key="d0">I/O Operation</data>
      <data key="d1">concept</data>
      <data key="d2">An I/O Operation is an input/output action performed by a process, such as reading from a file or writing to a device, which may result in a process entering a blocked state.&lt;SEP&gt;I/O operation refers to input/output activities performed by a process, which are part of the turnaround time but not affected by CPU scheduling.</data>
      <data key="d3">chunk-76ab4199a2aae3d8b4b3b6c270c34a12&lt;SEP&gt;chunk-156e9bc4a555d2a7cb0d3724273d5ea6</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794298</data>
    </node>
    <node id="System Call">
      <data key="d0">System Call</data>
      <data key="d1">method</data>
      <data key="d2">A System Call is a mechanism used by a user-level process to request services from the operating system kernel, often leading to a change in process state.</data>
      <data key="d3">chunk-156e9bc4a555d2a7cb0d3724273d5ea6</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793612</data>
    </node>
    <node id="Operating System">
      <data key="d0">Operating System</data>
      <data key="d1">organization</data>
      <data key="d2">The Operating System is a system software that manages computer hardware and software resources and provides common services for computer programs.&lt;SEP&gt;An operating system is a system software that manages computer hardware, software resources, and provides common services for computer programs.&lt;SEP&gt;The operating system manages system resources and controls process execution, using the PCB as a core mechanism for process management.</data>
      <data key="d3">chunk-c39617d7522bbe85482a3d992382cd4b&lt;SEP&gt;chunk-156e9bc4a555d2a7cb0d3724273d5ea6&lt;SEP&gt;chunk-2da376f0975743dcb0cc169c929cbe5c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794158</data>
    </node>
    <node id="生产者-消费者问题">
      <data key="d0">生产者-消费者问题</data>
      <data key="d1">concept</data>
      <data key="d2">The producer-consumer problem is a classic synchronization problem involving producers that generate items and consumers that process them, sharing a bounded buffer that must be accessed mutually exclusively.</data>
      <data key="d3">chunk-d3e84198ebbd072f7382ef600186508e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793633</data>
    </node>
    <node id="读者-写者问题">
      <data key="d0">读者-写者问题</data>
      <data key="d1">concept</data>
      <data key="d2">The reader-writer problem is a synchronization issue where multiple readers can access a shared resource simultaneously, but writers must have exclusive access to prevent data inconsistency.</data>
      <data key="d3">chunk-d3e84198ebbd072f7382ef600186508e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793633</data>
    </node>
    <node id="哲学家进餐问题">
      <data key="d0">哲学家进餐问题</data>
      <data key="d1">concept</data>
      <data key="d2">The dining philosophers problem is a classic synchronization problem where five philosophers sit around a table, needing two forks to eat, and must coordinate access to avoid deadlock and starvation.</data>
      <data key="d3">chunk-d3e84198ebbd072f7382ef600186508e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793633</data>
    </node>
    <node id="缓冲区">
      <data key="d0">缓冲区</data>
      <data key="d1">artifact</data>
      <data key="d2">The buffer is a shared, bounded-memory area used in the producer-consumer problem to store items produced by producers for consumption by consumers.</data>
      <data key="d3">chunk-d3e84198ebbd072f7382ef600186508e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793633</data>
    </node>
    <node id="生产者进程">
      <data key="d0">生产者进程</data>
      <data key="d1">person</data>
      <data key="d2">The producer processes are a set of concurrent processes that generate items and deposit them into a shared buffer.</data>
      <data key="d3">chunk-d3e84198ebbd072f7382ef600186508e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793633</data>
    </node>
    <node id="消费者进程">
      <data key="d0">消费者进程</data>
      <data key="d1">person</data>
      <data key="d2">The consumer processes are a set of concurrent processes that retrieve and consume items from a shared buffer.</data>
      <data key="d3">chunk-d3e84198ebbd072f7382ef600186508e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793633</data>
    </node>
    <node id="读者进程">
      <data key="d0">读者进程</data>
      <data key="d1">person</data>
      <data key="d2">The reader processes are concurrent processes that perform read operations on a shared file without causing side effects when multiple readers access it simultaneously.</data>
      <data key="d3">chunk-d3e84198ebbd072f7382ef600186508e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793633</data>
    </node>
    <node id="写者进程">
      <data key="d0">写者进程</data>
      <data key="d1">person</data>
      <data key="d2">The writer processes are concurrent processes that write data to a shared file, requiring exclusive access to maintain data consistency.</data>
      <data key="d3">chunk-d3e84198ebbd072f7382ef600186508e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793633</data>
    </node>
    <node id="哲学家">
      <data key="d0">哲学家</data>
      <data key="d1">person</data>
      <data key="d2">The philosophers are five agents seated around a table who must coordinate access to shared resources (forks) to eat without causing deadlock.</data>
      <data key="d3">chunk-d3e84198ebbd072f7382ef600186508e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793634</data>
    </node>
    <node id="筷子">
      <data key="d0">筷子</data>
      <data key="d1">artifact</data>
      <data key="d2">The chopsticks are shared resources placed between each pair of philosophers, and each philosopher must acquire two to eat.</data>
      <data key="d3">chunk-d3e84198ebbd072f7382ef600186508e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793635</data>
    </node>
    <node id="互斥访问">
      <data key="d0">互斥访问</data>
      <data key="d1">method</data>
      <data key="d2">Mutual exclusion is a principle ensuring that only one process at a time can access a critical resource, preventing data corruption.</data>
      <data key="d3">chunk-d3e84198ebbd072f7382ef600186508e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793635</data>
    </node>
    <node id="同步关系">
      <data key="d0">同步关系</data>
      <data key="d1">concept</data>
      <data key="d2">The synchronization relationship describes the coordination between processes where one must complete an action before another can proceed.</data>
      <data key="d3">chunk-d3e84198ebbd072f7382ef600186508e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793635</data>
    </node>
    <node id="死锁">
      <data key="d0">死锁</data>
      <data key="d1">concept</data>
      <data key="d2">Deadlock is a state in which two or more processes are unable to proceed because each is waiting for the other to release a resource.&lt;SEP&gt;死锁是指多个进程因竞争资源而陷入互相等待的僵局，若无外力干涉，这些进程将无法继续推进。</data>
      <data key="d3">chunk-9aabe855c161e30442ff85ca7a64312e&lt;SEP&gt;chunk-d3e84198ebbd072f7382ef600186508e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793964</data>
    </node>
    <node id="饥饿现象">
      <data key="d0">饥饿现象</data>
      <data key="d1">concept</data>
      <data key="d2">Starvation occurs when a process is perpetually denied necessary resources, preventing it from making progress.</data>
      <data key="d3">chunk-d3e84198ebbd072f7382ef600186508e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793635</data>
    </node>
    <node id="限制条件">
      <data key="d0">限制条件</data>
      <data key="d1">concept</data>
      <data key="d2">Restriction conditions are rules applied to processes to avoid undesirable states like deadlock or starvation.</data>
      <data key="d3">chunk-d3e84198ebbd072f7382ef600186508e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793635</data>
    </node>
    <node id="大小为n的缓冲区">
      <data key="d0">大小为n的缓冲区</data>
      <data key="d1">artifact</data>
      <data key="d2">The buffer is a shared memory area of fixed size n used to store items produced by producers and consumed by consumers, with access controlled by mutual exclusion.</data>
      <data key="d3">chunk-d3e84198ebbd072f7382ef600186508e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793636</data>
    </node>
    <node id="共享文件">
      <data key="d0">共享文件</data>
      <data key="d1">artifact</data>
      <data key="d2">The shared file is a common data resource accessed by readers and writers, where concurrent reads are allowed but writes require exclusive access.</data>
      <data key="d3">chunk-d3e84198ebbd072f7382ef600186508e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793636</data>
    </node>
    <node id="Multi-Processing System">
      <data key="d0">Multi-Processing System</data>
      <data key="d1">concept</data>
      <data key="d2">A multi-processing system involves multiple processors working together to execute tasks, with scheduling complexities influenced by system architecture.</data>
      <data key="d3">chunk-f326031f0d80f48ea7bc3e6da1a5f8a4</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793671</data>
    </node>
    <node id="Single Processing System">
      <data key="d0">Single Processing System</data>
      <data key="d1">concept</data>
      <data key="d2">A single processing system uses one central processor to execute tasks, with simpler scheduling compared to multi-processing systems.</data>
      <data key="d3">chunk-f326031f0d80f48ea7bc3e6da1a5f8a4</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793671</data>
    </node>
    <node id="Asymmetric MultiProcessing">
      <data key="d0">Asymmetric MultiProcessing</data>
      <data key="d1">method</data>
      <data key="d2">Asymmetric MultiProcessing (AMP) is a system architecture where one master processor handles the operating system kernel while other processors run user programs only.</data>
      <data key="d3">chunk-f326031f0d80f48ea7bc3e6da1a5f8a4</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793671</data>
    </node>
    <node id="Symmetric MultiProcessing">
      <data key="d0">Symmetric MultiProcessing</data>
      <data key="d1">method</data>
      <data key="d2">Symmetric MultiProcessing (SMP) is a system architecture where all processors are identical and capable of executing any process, allowing load distribution across any CPU.</data>
      <data key="d3">chunk-f326031f0d80f48ea7bc3e6da1a5f8a4</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793671</data>
    </node>
    <node id="Master Processor">
      <data key="d0">Master Processor</data>
      <data key="d1">artifact</data>
      <data key="d2">The master processor in an AMP system hosts the operating system kernel and manages all system-level tasks and process scheduling.</data>
      <data key="d3">chunk-f326031f0d80f48ea7bc3e6da1a5f8a4</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793671</data>
    </node>
    <node id="Slave Processor">
      <data key="d0">Slave Processor</data>
      <data key="d1">artifact</data>
      <data key="d2">The slave processor in an AMP system runs only user-level programs and does not run the kernel.</data>
      <data key="d3">chunk-f326031f0d80f48ea7bc3e6da1a5f8a4</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793671</data>
    </node>
    <node id="Processor Affinity">
      <data key="d0">Processor Affinity</data>
      <data key="d1">concept</data>
      <data key="d2">Processor affinity refers to the practice of keeping a process running on the same CPU to minimize cache invalidation and improve performance.</data>
      <data key="d3">chunk-f326031f0d80f48ea7bc3e6da1a5f8a4</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793671</data>
    </node>
    <node id="Load Balancing">
      <data key="d0">Load Balancing</data>
      <data key="d1">concept</data>
      <data key="d2">Load balancing is the method of distributing workloads evenly across all CPUs to ensure no single processor is overwhelmed.</data>
      <data key="d3">chunk-f326031f0d80f48ea7bc3e6da1a5f8a4</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793671</data>
    </node>
    <node id="Public Ready Queue">
      <data key="d0">Public Ready Queue</data>
      <data key="d1">artifact</data>
      <data key="d2">A public ready queue is a shared queue used in multi-processing systems where all CPUs draw processes from a single common queue.</data>
      <data key="d3">chunk-f326031f0d80f48ea7bc3e6da1a5f8a4</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793672</data>
    </node>
    <node id="Private Ready Queue">
      <data key="d0">Private Ready Queue</data>
      <data key="d1">artifact</data>
      <data key="d2">A private ready queue is a dedicated queue for each CPU, where processes are assigned and managed locally to support processor affinity.</data>
      <data key="d3">chunk-f326031f0d80f48ea7bc3e6da1a5f8a4</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793672</data>
    </node>
    <node id="Cache Invalidation">
      <data key="d0">Cache Invalidation</data>
      <data key="d1">concept</data>
      <data key="d2">Cache invalidation occurs when data in a CPU’s cache is marked as outdated after a process is moved, requiring time to re-fill the new CPU’s cache.</data>
      <data key="d3">chunk-f326031f0d80f48ea7bc3e6da1a5f8a4</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793672</data>
    </node>
    <node id="Process Scheduling">
      <data key="d0">Process Scheduling</data>
      <data key="d1">concept</data>
      <data key="d2">Process scheduling is the operation by which the operating system determines which process runs on which CPU at any given time.&lt;SEP&gt;Process Scheduling is the mechanism by which the operating system decides which process runs next on the CPU.</data>
      <data key="d3">chunk-491042f5eab097ef962a4657a4b61650&lt;SEP&gt;chunk-f326031f0d80f48ea7bc3e6da1a5f8a4</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794028</data>
    </node>
    <node id="Mutual Exclusion Lock">
      <data key="d0">Mutual Exclusion Lock</data>
      <data key="d1">concept</data>
      <data key="d2">A mutual exclusion lock (mutex lock) is a synchronization mechanism used to ensure only one process can access a critical section at a time.</data>
      <data key="d3">chunk-e16dceff2fc93c138aa86eb65cacc6c7</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793680</data>
    </node>
    <node id="Acquire Function">
      <data key="d0">Acquire Function</data>
      <data key="d1">method</data>
      <data key="d2">The acquire() function is used by a process to obtain a mutual exclusion lock before entering a critical section.</data>
      <data key="d3">chunk-e16dceff2fc93c138aa86eb65cacc6c7</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793680</data>
    </node>
    <node id="Release Function">
      <data key="d0">Release Function</data>
      <data key="d1">method</data>
      <data key="d2">The release() function is used by a process to free a mutual exclusion lock after exiting a critical section.</data>
      <data key="d3">chunk-e16dceff2fc93c138aa86eb65cacc6c7</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793680</data>
    </node>
    <node id="Available Boolean Variable">
      <data key="d0">Available Boolean Variable</data>
      <data key="d1">data</data>
      <data key="d2">The available boolean variable indicates whether a mutual exclusion lock is currently free or held by another process.</data>
      <data key="d3">chunk-e16dceff2fc93c138aa86eb65cacc6c7</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793680</data>
    </node>
    <node id="Atomic Operation">
      <data key="d0">Atomic Operation</data>
      <data key="d1">concept</data>
      <data key="d2">An atomic operation is a sequence of operations that must be executed as a single uninterruptible unit, crucial for the correct implementation of mutual exclusion locks.</data>
      <data key="d3">chunk-e16dceff2fc93c138aa86eb65cacc6c7</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793680</data>
    </node>
    <node id="Spin Lock">
      <data key="d0">Spin Lock</data>
      <data key="d1">concept</data>
      <data key="d2">A spin lock is another name for the mutual exclusion lock described, characterized by busy-waiting while waiting for the lock.</data>
      <data key="d3">chunk-e16dceff2fc93c138aa86eb65cacc6c7</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793680</data>
    </node>
    <node id="Multiprocessor System">
      <data key="d0">Multiprocessor System</data>
      <data key="d1">concept</data>
      <data key="d2">A multiprocessor system is a computing environment with multiple processors, where mutual exclusion locks are commonly used.</data>
      <data key="d3">chunk-e16dceff2fc93c138aa86eb65cacc6c7</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793680</data>
    </node>
    <node id="进程同步">
      <data key="d0">进程同步</data>
      <data key="d1">concept</data>
      <data key="d2">进程同步refers to the coordination of multiple processes that need to work together to achieve a common task, involving waiting and information exchange to manage execution order.</data>
      <data key="d3">chunk-96612cb99be5ccc8684e38f3d50f77f5</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793745</data>
    </node>
    <node id="进入区">
      <data key="d0">进入区</data>
      <data key="d1">concept</data>
      <data key="d2">进入区is the part of a process where it checks whether it can enter the critical section and sets a flag to indicate that the critical section is being accessed.</data>
      <data key="d3">chunk-96612cb99be5ccc8684e38f3d50f77f5</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793745</data>
    </node>
    <node id="退出区">
      <data key="d0">退出区</data>
      <data key="d1">concept</data>
      <data key="d2">退出区is the part of a process where it clears the access flag after leaving the critical section, allowing other processes to enter.</data>
      <data key="d3">chunk-96612cb99be5ccc8684e38f3d50f77f5</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793745</data>
    </node>
    <node id="剩余区">
      <data key="d0">剩余区</data>
      <data key="d1">concept</data>
      <data key="d2">剩余区is the part of the process code that lies outside the critical section and does not involve access to the critical resource.</data>
      <data key="d3">chunk-96612cb99be5ccc8684e38f3d50f77f5</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793745</data>
    </node>
    <node id="同步">
      <data key="d0">同步</data>
      <data key="d1">concept</data>
      <data key="d2">同步, also known as direct constraint, is the relationship between processes that must coordinate their execution order to achieve a common goal.</data>
      <data key="d3">chunk-96612cb99be5ccc8684e38f3d50f77f5</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793745</data>
    </node>
    <node id="互斥">
      <data key="d0">互斥</data>
      <data key="d1">concept</data>
      <data key="d2">互斥, also known as indirect constraint, is the mechanism that ensures only one process can access a critical resource at any given time.</data>
      <data key="d3">chunk-96612cb99be5ccc8684e38f3d50f77f5</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793745</data>
    </node>
    <node id="忙则等待">
      <data key="d0">忙则等待</data>
      <data key="d1">concept</data>
      <data key="d2">忙则等待is a rule requiring that if a process is already in the critical section, other requesting processes must wait.</data>
      <data key="d3">chunk-96612cb99be5ccc8684e38f3d50f77f5</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793747</data>
    </node>
    <node id="多道程序环境">
      <data key="d0">多道程序环境</data>
      <data key="d1">concept</data>
      <data key="d2">多道程序环境is a computing environment where multiple programs run concurrently, leading to process interaction and the need for synchronization.</data>
      <data key="d3">chunk-96612cb99be5ccc8684e38f3d50f77f5</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793747</data>
    </node>
    <node id="死锁检测">
      <data key="d0">死锁检测</data>
      <data key="d1">concept</data>
      <data key="d2">Deadlock detection is the process by which a system identifies whether a deadlock has occurred by analyzing resource request and allocation information.</data>
      <data key="d3">chunk-b5aa6485f08fa52f1ae6912e99884079</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793779</data>
    </node>
    <node id="死锁解除">
      <data key="d0">死锁解除</data>
      <data key="d1">concept</data>
      <data key="d2">Deadlock resolution refers to methods used to recover from a deadlock state by reallocating resources or terminating processes.</data>
      <data key="d3">chunk-b5aa6485f08fa52f1ae6912e99884079</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793779</data>
    </node>
    <node id="剥夺资源">
      <data key="d0">剥夺资源</data>
      <data key="d1">method</data>
      <data key="d2">Resource preemption involves taking resources from other processes and allocating them to a deadlocked process to resolve the deadlock.</data>
      <data key="d3">chunk-b5aa6485f08fa52f1ae6912e99884079</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793779</data>
    </node>
    <node id="撤销进程">
      <data key="d0">撤销进程</data>
      <data key="d1">method</data>
      <data key="d2">Process termination is a method of deadlock resolution that involves terminating one or more deadlocked processes until the deadlock is eliminated.&lt;SEP&gt;撤销进程is the termination of a process by the operating system, involving resource cleanup and kernel-level execution.</data>
      <data key="d3">chunk-b5aa6485f08fa52f1ae6912e99884079&lt;SEP&gt;chunk-b7f639a9301d2ec0568bcbcad2dc3725</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794244</data>
    </node>
    <node id="进程回退">
      <data key="d0">进程回退</data>
      <data key="d1">method</data>
      <data key="d2">Process rollback allows one or more processes to revert to a previous state to avoid deadlock, voluntarily releasing resources.</data>
      <data key="d3">chunk-b5aa6485f08fa52f1ae6912e99884079</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793779</data>
    </node>
    <node id="资源请求和分配信息">
      <data key="d0">资源请求和分配信息</data>
      <data key="d1">data</data>
      <data key="d2">Resource request and allocation information is crucial for detecting deadlocks and must be maintained by the system.</data>
      <data key="d3">chunk-b5aa6485f08fa52f1ae6912e99884079</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793779</data>
    </node>
    <node id="还原点">
      <data key="d0">还原点</data>
      <data key="d1">artifact</data>
      <data key="d2">A checkpoint is a saved state of a process used to enable rollback in case of deadlock.</data>
      <data key="d3">chunk-b5aa6485f08fa52f1ae6912e99884079</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793779</data>
    </node>
    <node id="系统">
      <data key="d0">系统</data>
      <data key="d1">organization</data>
      <data key="d2">The system refers to the computing environment or operating system that manages resources and implements deadlock handling procedures.</data>
      <data key="d3">chunk-b5aa6485f08fa52f1ae6912e99884079</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793779</data>
    </node>
    <node id="CPU Scheduling">
      <data key="d0">CPU Scheduling</data>
      <data key="d1">concept</data>
      <data key="d2">CPU scheduling is the process of allocating the CPU to processes from the ready queue using specific algorithms to enable concurrent execution in a multi-programming system.</data>
      <data key="d3">chunk-c39617d7522bbe85482a3d992382cd4b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793780</data>
    </node>
    <node id="Multi-Program System">
      <data key="d0">Multi-Program System</data>
      <data key="d1">concept</data>
      <data key="d2">A multi-program system is an operating system environment where multiple processes exist simultaneously, leading to competition for CPU resources.</data>
      <data key="d3">chunk-c39617d7522bbe85482a3d992382cd4b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793780</data>
    </node>
    <node id="High-Level Scheduling">
      <data key="d0">High-Level Scheduling</data>
      <data key="d1">concept</data>
      <data key="d2">High-level scheduling, also known as job scheduling, selects jobs from the backup queue on auxiliary storage and loads them into memory, assigning resources and creating processes.</data>
      <data key="d3">chunk-c39617d7522bbe85482a3d992382cd4b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793780</data>
    </node>
    <node id="Medium-Level Scheduling">
      <data key="d0">Medium-Level Scheduling</data>
      <data key="d1">concept</data>
      <data key="d2">Medium-level scheduling, or memory scheduling, temporarily removes processes from memory to external storage (swapping) to improve memory utilization and system throughput.</data>
      <data key="d3">chunk-c39617d7522bbe85482a3d992382cd4b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793780</data>
    </node>
    <node id="Low-Level Scheduling">
      <data key="d0">Low-Level Scheduling</data>
      <data key="d1">concept</data>
      <data key="d2">Low-level scheduling, also known as process scheduling, selects a process from the ready queue and allocates the CPU to it, occurring frequently.</data>
      <data key="d3">chunk-c39617d7522bbe85482a3d992382cd4b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793780</data>
    </node>
    <node id="Job Queue">
      <data key="d0">Job Queue</data>
      <data key="d1">concept</data>
      <data key="d2">The job queue is a collection of jobs stored on external storage awaiting assignment to the system and eventual loading into memory.</data>
      <data key="d3">chunk-c39617d7522bbe85482a3d992382cd4b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793780</data>
    </node>
    <node id="Backlog Queue">
      <data key="d0">Backlog Queue</data>
      <data key="d1">concept</data>
      <data key="d2">The backlog queue refers to the set of jobs stored on auxiliary storage awaiting execution and is used as input for high-level scheduling.</data>
      <data key="d3">chunk-c39617d7522bbe85482a3d992382cd4b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793780</data>
    </node>
    <node id="Suspended State">
      <data key="d0">Suspended State</data>
      <data key="d1">concept</data>
      <data key="d2">The suspended state is a process state in which a process is temporarily removed from memory and stored on external storage due to lack of resources or system load management.</data>
      <data key="d3">chunk-c39617d7522bbe85482a3d992382cd4b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793782</data>
    </node>
    <node id="Multi-Tasking System">
      <data key="d0">Multi-Tasking System</data>
      <data key="d1">concept</data>
      <data key="d2">A multi-tasking system is an operating system capability that allows multiple tasks or processes to be executed concurrently.</data>
      <data key="d3">chunk-c39617d7522bbe85482a3d992382cd4b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793782</data>
    </node>
    <node id="Memory Utilization">
      <data key="d0">Memory Utilization</data>
      <data key="d1">concept</data>
      <data key="d2">Memory utilization is the measure of how effectively main memory is being used in a computing system.</data>
      <data key="d3">chunk-c39617d7522bbe85482a3d992382cd4b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793782</data>
    </node>
    <node id="System Throughput">
      <data key="d0">System Throughput</data>
      <data key="d1">concept</data>
      <data key="d2">System throughput is the number of processes completed per unit of time, indicating efficiency in system execution.&lt;SEP&gt;System throughput refers to the number of jobs completed by the CPU per unit of time, influenced by the duration of individual jobs.</data>
      <data key="d3">chunk-76ab4199a2aae3d8b4b3b6c270c34a12&lt;SEP&gt;chunk-c39617d7522bbe85482a3d992382cd4b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794297</data>
    </node>
    <node id="CPU Allocation">
      <data key="d0">CPU Allocation</data>
      <data key="d1">concept</data>
      <data key="d2">CPU allocation is the mechanism by which the CPU is assigned to a selected process from the ready queue.</data>
      <data key="d3">chunk-c39617d7522bbe85482a3d992382cd4b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793784</data>
    </node>
    <node id="Auxiliary Storage">
      <data key="d0">Auxiliary Storage</data>
      <data key="d1">naturalobject</data>
      <data key="d2">Auxiliary storage refers to external storage such as hard drives, used for long-term data and program storage outside main memory.</data>
      <data key="d3">chunk-c39617d7522bbe85482a3d992382cd4b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793784</data>
    </node>
    <node id="Little-Level Scheduling">
      <data key="d0">Little-Level Scheduling</data>
      <data key="d3">chunk-c39617d7522bbe85482a3d992382cd4b</data>
      <data key="d2">Low-level scheduling performs CPU allocation frequently, often every few milliseconds.</data>
      <data key="d1">UNKNOWN</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793785</data>
    </node>
    <node id="死锁避免">
      <data key="d0">死锁避免</data>
      <data key="d1">concept</data>
      <data key="d2">死锁避免is a proactive strategy that prevents deadlocks by analyzing resource allocation to ensure the system remains in a safe state.</data>
      <data key="d3">chunk-fd78a6e2f6ac315b1d1c2a02efb03591</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793823</data>
    </node>
    <node id="死锁预防">
      <data key="d0">死锁预防</data>
      <data key="d1">concept</data>
      <data key="d2">死锁预防is a stricter strategy that rigidly restricts process access to resources to prevent deadlocks.</data>
      <data key="d3">chunk-fd78a6e2f6ac315b1d1c2a02efb03591</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793823</data>
    </node>
    <node id="系统安全状态">
      <data key="d0">系统安全状态</data>
      <data key="d1">concept</data>
      <data key="d2">系统安全状态refers to a state where the system can allocate resources to processes in a sequence that allows each to complete successfully.</data>
      <data key="d3">chunk-fd78a6e2f6ac315b1d1c2a02efb03591</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793823</data>
    </node>
    <node id="不安全状态">
      <data key="d0">不安全状态</data>
      <data key="d1">concept</data>
      <data key="d2">不安全状态occurs when the system cannot find a safe sequence to allocate resources, increasing the risk of deadlock.</data>
      <data key="d3">chunk-fd78a6e2f6ac315b1d1c2a02efb03591</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793823</data>
    </node>
    <node id="安全序列">
      <data key="d0">安全序列</data>
      <data key="d1">concept</data>
      <data key="d2">安全序列is an order of process execution in which each process can be allocated required resources and complete without causing deadlock.</data>
      <data key="d3">chunk-fd78a6e2f6ac315b1d1c2a02efb03591</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793823</data>
    </node>
    <node id="银行家算法">
      <data key="d0">银行家算法</data>
      <data key="d1">method</data>
      <data key="d2">银行家算法is a well-known deadlock avoidance algorithm inspired by a banker's loan system.</data>
      <data key="d3">chunk-fd78a6e2f6ac315b1d1c2a02efb03591</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793823</data>
    </node>
    <node id="操作系统">
      <data key="d0">操作系统</data>
      <data key="d1">organization</data>
      <data key="d2">操作系统manages system resources and implements algorithms like the Banker's Algorithm to ensure system safety.&lt;SEP&gt;操作系统是管理计算机硬件与软件资源的系统软件，负责进程控制、资源分配等。</data>
      <data key="d3">chunk-7ca51faf7f3faf56c56ab18dd6458c7e&lt;SEP&gt;chunk-fd78a6e2f6ac315b1d1c2a02efb03591</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794044</data>
    </node>
    <node id="资源分配">
      <data key="d0">资源分配</data>
      <data key="d1">concept</data>
      <data key="d2">资源分配refers to the process by which the system grants resources to processes based on safety checks.</data>
      <data key="d3">chunk-fd78a6e2f6ac315b1d1c2a02efb03591</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793823</data>
    </node>
    <node id="进程">
      <data key="d0">进程</data>
      <data key="d1">concept</data>
      <data key="d2">进程is a program in execution that requests and uses system resources.&lt;SEP&gt;进程是程序在计算机系统中的一次执行活动，可并发运行。</data>
      <data key="d3">chunk-9aabe855c161e30442ff85ca7a64312e&lt;SEP&gt;chunk-fd78a6e2f6ac315b1d1c2a02efb03591</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793966</data>
    </node>
    <node id="最大需求">
      <data key="d0">最大需求</data>
      <data key="d1">concept</data>
      <data key="d2">最大需求is the maximum amount of resources a process may require during its execution.</data>
      <data key="d3">chunk-fd78a6e2f6ac315b1d1c2a02efb03591</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793824</data>
    </node>
    <node id="Process Communication">
      <data key="d0">Process Communication</data>
      <data key="d1">concept</data>
      <data key="d2">Process communication refers to the exchange of information between processes, enabling coordination and data sharing in operating systems.</data>
      <data key="d3">chunk-d75ea791c964266b65c0ee55b3a8e15f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793859</data>
    </node>
    <node id="PV Operation">
      <data key="d0">PV Operation</data>
      <data key="d1">method</data>
      <data key="d2">PV operation is a low-level synchronization mechanism used to control access to shared resources, described in section 2.3.</data>
      <data key="d3">chunk-d75ea791c964266b65c0ee55b3a8e15f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793859</data>
    </node>
    <node id="Advanced Communication Method">
      <data key="d0">Advanced Communication Method</data>
      <data key="d1">method</data>
      <data key="d2">Advanced communication methods are high-efficiency techniques for transferring large amounts of data between processes.</data>
      <data key="d3">chunk-d75ea791c964266b65c0ee55b3a8e15f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793859</data>
    </node>
    <node id="Shared Memory">
      <data key="d0">Shared Memory</data>
      <data key="d1">method</data>
      <data key="d2">Shared memory allows processes to communicate by accessing a common memory area, requiring synchronization tools to prevent race conditions.</data>
      <data key="d3">chunk-d75ea791c964266b65c0ee55b3a8e15f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793859</data>
    </node>
    <node id="Low-Level Shared Memory">
      <data key="d0">Low-Level Shared Memory</data>
      <data key="d1">method</data>
      <data key="d2">Low-level shared memory is based on data structures and is used for direct read/write access in process communication.</data>
      <data key="d3">chunk-d75ea791c964266b65c0ee55b3a8e15f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793859</data>
    </node>
    <node id="High-Level Shared Memory">
      <data key="d0">High-Level Shared Memory</data>
      <data key="d1">method</data>
      <data key="d2">High-level shared memory is based on shared memory regions and enables efficient data exchange between processes.</data>
      <data key="d3">chunk-d75ea791c964266b65c0ee55b3a8e15f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793859</data>
    </node>
    <node id="Synchronization and Mutual Exclusion Tools">
      <data key="d0">Synchronization and Mutual Exclusion Tools</data>
      <data key="d1">method</data>
      <data key="d2">Synchronization and mutual exclusion tools, such as P and V operations, are used to manage access to shared memory.</data>
      <data key="d3">chunk-d75ea791c964266b65c0ee55b3a8e15f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793859</data>
    </node>
    <node id="Message Passing">
      <data key="d0">Message Passing</data>
      <data key="d1">method</data>
      <data key="d2">Message passing is a communication mechanism where processes exchange data in the form of formatted messages through system calls.</data>
      <data key="d3">chunk-d75ea791c964266b65c0ee55b3a8e15f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793859</data>
    </node>
    <node id="Direct Communication">
      <data key="d0">Direct Communication</data>
      <data key="d1">method</data>
      <data key="d2">Direct communication is a message-passing method where the sender sends a message directly to the receiver.</data>
      <data key="d3">chunk-d75ea791c964266b65c0ee55b3a8e15f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793860</data>
    </node>
    <node id="Indirect Communication">
      <data key="d0">Indirect Communication</data>
      <data key="d1">method</data>
      <data key="d2">Indirect communication involves sending messages to an intermediate entity (e.g., a mailbox) for retrieval by the receiver.</data>
      <data key="d3">chunk-d75ea791c964266b65c0ee55b3a8e15f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793860</data>
    </node>
    <node id="Mailbox">
      <data key="d0">Mailbox</data>
      <data key="d1">artifact</data>
      <data key="d2">A mailbox is an intermediate entity in indirect communication used to store messages for delivery to receiving processes.</data>
      <data key="d3">chunk-d75ea791c964266b65c0ee55b3a8e15f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793860</data>
    </node>
    <node id="Pipe Communication">
      <data key="d0">Pipe Communication</data>
      <data key="d1">method</data>
      <data key="d2">Pipe communication is a mechanism using a special file (pipe) for unidirectional or bidirectional data transfer between processes.</data>
      <data key="d3">chunk-d75ea791c964266b65c0ee55b3a8e15f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793860</data>
    </node>
    <node id="FIFO">
      <data key="d0">FIFO</data>
      <data key="d1">naturalobject</data>
      <data key="d2">FIFO refers to the first-in-first-out principle used in pipe communication, ensuring data order.</data>
      <data key="d3">chunk-d75ea791c964266b65c0ee55b3a8e15f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793860</data>
    </node>
    <node id="Linux">
      <data key="d0">Linux</data>
      <data key="d1">organization</data>
      <data key="d2">Linux is an operating system that extensively uses pipes for inter-process communication.</data>
      <data key="d3">chunk-d75ea791c964266b65c0ee55b3a8e15f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793860</data>
    </node>
    <node id="Pipe File">
      <data key="d0">Pipe File</data>
      <data key="d1">artifact</data>
      <data key="d2">A pipe file is a special type of file used in pipe communication that acts as a buffer with fixed size.</data>
      <data key="d3">chunk-d75ea791c964266b65c0ee55b3a8e15f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793860</data>
    </node>
    <node id="Signal">
      <data key="d0">Signal</data>
      <data key="d1">concept</data>
      <data key="d2">A signal is a software interrupt sent to a process to notify it of a system event or request, which may be handled or ignored based on its blocking status.&lt;SEP&gt;A signal is a mechanism used to notify a process that a specific event has occurred.</data>
      <data key="d3">chunk-d75ea791c964266b65c0ee55b3a8e15f&lt;SEP&gt;chunk-c214e070db9e1fbcd76d28e9e144db30</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793860</data>
    </node>
    <node id="Signal Vector">
      <data key="d0">Signal Vector</data>
      <data key="d1">data</data>
      <data key="d2">A signal vector is a bit vector in the PCB used to track pending signals for a process.</data>
      <data key="d3">chunk-d75ea791c964266b65c0ee55b3a8e15f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793862</data>
    </node>
    <node id="Blocked Signal Vector">
      <data key="d0">Blocked Signal Vector</data>
      <data key="d1">data</data>
      <data key="d2">A blocked signal vector is a bit vector in the PCB that indicates which signals are being ignored by the process.</data>
      <data key="d3">chunk-d75ea791c964266b65c0ee55b3a8e15f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793862</data>
    </node>
    <node id="Producer-Consumer Pattern">
      <data key="d0">Producer-Consumer Pattern</data>
      <data key="d1">concept</data>
      <data key="d2">The producer-consumer pattern is a synchronization model used in pipe communication where one process produces data and another consumes it, ensuring orderly data flow.</data>
      <data key="d3">chunk-d75ea791c964266b65c0ee55b3a8e15f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793862</data>
    </node>
    <node id="Bit Vector">
      <data key="d0">Bit Vector</data>
      <data key="d1">artifact</data>
      <data key="d2">A bit vector is used to record blocked or masked signals, where a value of 1 indicates that the corresponding signal type will be ignored by the process.</data>
      <data key="d3">chunk-c214e070db9e1fbcd76d28e9e144db30</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793862</data>
    </node>
    <node id="Kernel">
      <data key="d0">Kernel</data>
      <data key="d1">concept</data>
      <data key="d2">The kernel is the core component of an operating system responsible for managing system resources and detecting events that trigger signals.</data>
      <data key="d3">chunk-c214e070db9e1fbcd76d28e9e144db30</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793862</data>
    </node>
    <node id="System Event">
      <data key="d0">System Event</data>
      <data key="d1">concept</data>
      <data key="d2">A system event is a specific condition detected by the kernel that causes it to send a signal to a process.</data>
      <data key="d3">chunk-c214e070db9e1fbcd76d28e9e144db30</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793863</data>
    </node>
    <node id="kill Function">
      <data key="d0">kill Function</data>
      <data key="d1">method</data>
      <data key="d2">The kill function is a system call that allows a process to request the kernel to send a signal to another process.</data>
      <data key="d3">chunk-c214e070db9e1fbcd76d28e9e144db30</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793863</data>
    </node>
    <node id="User Mode">
      <data key="d0">User Mode</data>
      <data key="d1">concept</data>
      <data key="d2">User mode is the execution state of a process where it runs with limited access to system resources and cannot directly interact with hardware.</data>
      <data key="d3">chunk-c214e070db9e1fbcd76d28e9e144db30</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793864</data>
    </node>
    <node id="Kernel Mode">
      <data key="d0">Kernel Mode</data>
      <data key="d1">concept</data>
      <data key="d2">Kernel mode is the privileged execution state of a process where the kernel operates with full access to system resources and can perform critical operations.</data>
      <data key="d3">chunk-c214e070db9e1fbcd76d28e9e144db30</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793864</data>
    </node>
    <node id="Pending Signal">
      <data key="d0">Pending Signal</data>
      <data key="d1">concept</data>
      <data key="d2">A pending signal is a signal that has been sent to a process but not yet handled or processed.</data>
      <data key="d3">chunk-c214e070db9e1fbcd76d28e9e144db30</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793864</data>
    </node>
    <node id="Default Signal Handler">
      <data key="d0">Default Signal Handler</data>
      <data key="d1">method</data>
      <data key="d2">The default signal handler is the predefined action taken by the operating system when a signal is received and no custom handler is defined.</data>
      <data key="d3">chunk-c214e070db9e1fbcd76d28e9e144db30</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793864</data>
    </node>
    <node id="Custom Signal Handler">
      <data key="d0">Custom Signal Handler</data>
      <data key="d1">method</data>
      <data key="d2">A custom signal handler is a user-defined function that processes a specific type of signal, overriding the default behavior.</data>
      <data key="d3">chunk-c214e070db9e1fbcd76d28e9e144db30</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793864</data>
    </node>
    <node id="Signal Processing">
      <data key="d0">Signal Processing</data>
      <data key="d1">method</data>
      <data key="d2">Signal processing refers to the execution of a signal handler upon receiving a signal, after which the process resumes from the next instruction.</data>
      <data key="d3">chunk-c214e070db9e1fbcd76d28e9e144db30</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793864</data>
    </node>
    <node id="Thread">
      <data key="d0">Thread</data>
      <data key="d1">concept</data>
      <data key="d2">A thread is a lightweight execution unit within a process, representing the smallest unit of CPU execution and serving as a basic scheduling unit in operating systems.&lt;SEP&gt;A thread is a basic unit of execution within a process, capable of independent operation and sharing resources with other threads in the same process.</data>
      <data key="d3">chunk-e2c5907dce4f167e0b11853c616e448f&lt;SEP&gt;chunk-34425c38108ef3730cc0889df3f8434a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793915</data>
    </node>
    <node id="Execution State">
      <data key="d0">Execution State</data>
      <data key="d1">state</data>
      <data key="d2">The execution state refers to a thread that has acquired the CPU and is currently running instructions.</data>
      <data key="d3">chunk-34425c38108ef3730cc0889df3f8434a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793915</data>
    </node>
    <node id="Thread Control Block">
      <data key="d0">Thread Control Block</data>
      <data key="d1">artifact</data>
      <data key="d2">The Thread Control Block is a data structure that stores information about a thread's state, registers, stack, and other execution context.&lt;SEP&gt;The Thread Control Block (TCB) is a data structure used by the operating system to store and manage information related to a thread, such as identification, register values, and execution status.</data>
      <data key="d3">chunk-e2c5907dce4f167e0b11853c616e448f&lt;SEP&gt;chunk-34425c38108ef3730cc0889df3f8434a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793915</data>
    </node>
    <node id="Thread Identifier">
      <data key="d0">Thread Identifier</data>
      <data key="d1">data</data>
      <data key="d2">The thread identifier is a unique value assigned to each thread to distinguish it from other threads in the system.</data>
      <data key="d3">chunk-34425c38108ef3730cc0889df3f8434a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793915</data>
    </node>
    <node id="Registers">
      <data key="d0">Registers</data>
      <data key="d1">artifact</data>
      <data key="d2">Registers, including program counter, status register, and general-purpose registers, are used to store temporary data during thread execution.</data>
      <data key="d3">chunk-34425c38108ef3730cc0889df3f8434a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793915</data>
    </node>
    <node id="Thread Priority">
      <data key="d0">Thread Priority</data>
      <data key="d1">data</data>
      <data key="d2">Thread priority determines the order in which threads are scheduled for execution, influencing their access to CPU time.</data>
      <data key="d3">chunk-34425c38108ef3730cc0889df3f8434a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793915</data>
    </node>
    <node id="Thread Private Storage">
      <data key="d0">Thread Private Storage</data>
      <data key="d1">artifact</data>
      <data key="d2">Thread private storage is a memory area allocated to a thread for saving its context during switching operations.</data>
      <data key="d3">chunk-34425c38108ef3730cc0889df3f8434a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793917</data>
    </node>
    <node id="Stack Pointer">
      <data key="d0">Stack Pointer</data>
      <data key="d1">artifact</data>
      <data key="d2">The stack pointer is a register that points to the top of the thread's stack, used for managing function calls and local variables.</data>
      <data key="d3">chunk-34425c38108ef3730cc0889df3f8434a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793917</data>
    </node>
    <node id="Shared Address Space">
      <data key="d0">Shared Address Space</data>
      <data key="d1">concept</data>
      <data key="d2">The shared address space allows all threads within a process to access the same memory space, including global variables and code.</data>
      <data key="d3">chunk-34425c38108ef3730cc0889df3f8434a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793917</data>
    </node>
    <node id="Thread Stack">
      <data key="d0">Thread Stack</data>
      <data key="d1">artifact</data>
      <data key="d2">Each thread has its own stack for storing local variables and return addresses during function calls.</data>
      <data key="d3">chunk-34425c38108ef3730cc0889df3f8434a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793917</data>
    </node>
    <node id="Thread Creation Function">
      <data key="d0">Thread Creation Function</data>
      <data key="d1">method</data>
      <data key="d2">The thread creation function is a system function used to initiate a new thread, accepting parameters such as the entry point, stack size, and priority.</data>
      <data key="d3">chunk-34425c38108ef3730cc0889df3f8434a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793917</data>
    </node>
    <node id="Thread Termination Function">
      <data key="d0">Thread Termination Function</data>
      <data key="d1">method</data>
      <data key="d2">The thread termination function is used to end a thread's execution, either voluntarily or forcibly.</data>
      <data key="d3">chunk-34425c38108ef3730cc0889df3f8434a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793917</data>
    </node>
    <node id="Thread Separation Function">
      <data key="d0">Thread Separation Function</data>
      <data key="d1">method</data>
      <data key="d2">The thread separation function allows a terminated thread to release its resources so they can be reused by other threads.</data>
      <data key="d3">chunk-34425c38108ef3730cc0889df3f8434a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793917</data>
    </node>
    <node id="User-Level Thread">
      <data key="d0">User-Level Thread</data>
      <data key="d1">concept</data>
      <data key="d2">A user-level thread is managed entirely by the application in user space without kernel involvement, offering fast context switching but limited system integration.</data>
      <data key="d3">chunk-34425c38108ef3730cc0889df3f8434a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793917</data>
    </node>
    <node id="Kernel-Level Thread">
      <data key="d0">Kernel-Level Thread</data>
      <data key="d1">concept</data>
      <data key="d2">A kernel-level thread is managed by the operating system kernel, enabling better concurrency and fault isolation but requiring mode switches.</data>
      <data key="d3">chunk-34425c38108ef3730cc0889df3f8434a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793918</data>
    </node>
    <node id="Combination Thread Implementation">
      <data key="d0">Combination Thread Implementation</data>
      <data key="d1">concept</data>
      <data key="d2">A combination thread implementation integrates both user-level and kernel-level threads, allowing flexibility and performance optimization.</data>
      <data key="d3">chunk-34425c38108ef3730cc0889df3f8434a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793918</data>
    </node>
    <node id="System Call Blocking">
      <data key="d0">System Call Blocking</data>
      <data key="d1">concept</data>
      <data key="d2">System call blocking occurs when a thread performing a system call blocks the entire process, including other threads, in user-level thread systems.</data>
      <data key="d3">chunk-34425c38108ef3730cc0889df3f8434a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793919</data>
    </node>
    <node id="Multicore CPU Utilization">
      <data key="d0">Multicore CPU Utilization</data>
      <data key="d1">concept</data>
      <data key="d2">Multicore CPU utilization refers to the ability to run multiple threads in parallel across multiple processor cores, supported by kernel-level thread implementations.</data>
      <data key="d3">chunk-34425c38108ef3730cc0889df3f8434a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793919</data>
    </node>
    <node id="Thread State Transition">
      <data key="d0">Thread State Transition</data>
      <data key="d1">concept</data>
      <data key="d2">Thread state transition refers to the movement of a thread between execution, ready, and blocked states based on system events and scheduling decisions.</data>
      <data key="d3">chunk-34425c38108ef3730cc0889df3f8434a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793919</data>
    </node>
    <node id="Thread Scheduling">
      <data key="d0">Thread Scheduling</data>
      <data key="d1">method</data>
      <data key="d2">Thread scheduling is the process by which the operating system determines the order and timing of thread execution, based on priority, fairness, or other criteria.</data>
      <data key="d3">chunk-34425c38108ef3730cc0889df3f8434a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793919</data>
    </node>
    <node id="Context Switching">
      <data key="d0">Context Switching</data>
      <data key="d1">concept</data>
      <data key="d2">Context switching is the mechanism by which the CPU saves the state of a running thread and loads the state of another thread to enable multitasking.&lt;SEP&gt;Context Switching is the process of saving and restoring the state of a CPU so that a process can be paused and another resumed.</data>
      <data key="d3">chunk-34425c38108ef3730cc0889df3f8434a&lt;SEP&gt;chunk-491042f5eab097ef962a4657a4b61650</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794028</data>
    </node>
    <node id="System Resource">
      <data key="d0">System Resource</data>
      <data key="d1">concept</data>
      <data key="d2">System resources include memory, I/O devices, and other hardware or software assets managed by the operating system.</data>
      <data key="d3">chunk-e2c5907dce4f167e0b11853c616e448f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793920</data>
    </node>
    <node id="Context Switch">
      <data key="d0">Context Switch</data>
      <data key="d1">concept</data>
      <data key="d2">Context switching is the mechanism by which the CPU saves the state of a currently running thread or process and restores the state of another.</data>
      <data key="d3">chunk-e2c5907dce4f167e0b11853c616e448f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793920</data>
    </node>
    <node id="Multithreading Model">
      <data key="d0">Multithreading Model</data>
      <data key="d1">concept</data>
      <data key="d2">The multithreading model is an architectural approach that allows multiple threads within a process to execute concurrently, enhancing system performance.</data>
      <data key="d3">chunk-e2c5907dce4f167e0b11853c616e448f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793920</data>
    </node>
    <node id="Scheduling">
      <data key="d0">Scheduling</data>
      <data key="d1">method</data>
      <data key="d2">Scheduling is the process by which the operating system determines the order in which threads or processes are executed on the CPU.</data>
      <data key="d3">chunk-e2c5907dce4f167e0b11853c616e448f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793920</data>
    </node>
    <node id="Concurrency">
      <data key="d0">Concurrency</data>
      <data key="d1">concept</data>
      <data key="d2">Concurrency refers to the ability of a system to execute multiple threads or processes in overlapping time periods, improving system throughput.&lt;SEP&gt;Concurrency is the ability of multiple processes to coexist in memory and run simultaneously over a period of time, a key feature of modern operating systems.</data>
      <data key="d3">chunk-e2c5907dce4f167e0b11853c616e448f&lt;SEP&gt;chunk-fd195ae7c40727c5b83fa7b77d72095e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794199</data>
    </node>
    <node id="Single CPU">
      <data key="d0">Single CPU</data>
      <data key="d1">naturalobject</data>
      <data key="d2">A single CPU is a computing unit with one processing core, which can only execute one thread at a time through time-slicing.</data>
      <data key="d3">chunk-e2c5907dce4f167e0b11853c616e448f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793920</data>
    </node>
    <node id="Multiple CPU">
      <data key="d0">Multiple CPU</data>
      <data key="d1">naturalobject</data>
      <data key="d2">A multiple CPU system contains more than one processing core, enabling true parallel execution of threads across different cores.</data>
      <data key="d3">chunk-e2c5907dce4f167e0b11853c616e448f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793920</data>
    </node>
    <node id="Thread State">
      <data key="d0">Thread State</data>
      <data key="d1">concept</data>
      <data key="d2">Thread state refers to the current condition of a thread, such as running, ready, or blocked, which governs its execution.</data>
      <data key="d3">chunk-e2c5907dce4f167e0b11853c616e448f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793920</data>
    </node>
    <node id="Thread ID">
      <data key="d0">Thread ID</data>
      <data key="d1">artifact</data>
      <data key="d2">Thread ID is a unique identifier assigned to each thread to distinguish it from other threads within the same process.</data>
      <data key="d3">chunk-e2c5907dce4f167e0b11853c616e448f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793922</data>
    </node>
    <node id="Program Counter">
      <data key="d0">Program Counter</data>
      <data key="d1">artifact</data>
      <data key="d2">The Program Counter is a register that holds the address of the next instruction to be executed by a thread.</data>
      <data key="d3">chunk-e2c5907dce4f167e0b11853c616e448f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793922</data>
    </node>
    <node id="Register Set">
      <data key="d0">Register Set</data>
      <data key="d1">artifact</data>
      <data key="d2">The Register Set is a collection of CPU registers that store data and state information specific to a thread’s execution.</data>
      <data key="d3">chunk-e2c5907dce4f167e0b11853c616e448f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793922</data>
    </node>
    <node id="Stack">
      <data key="d0">Stack</data>
      <data key="d1">artifact</data>
      <data key="d2">The Stack is a memory region used by a thread to store temporary data, function parameters, return addresses, and local variables.</data>
      <data key="d3">chunk-e2c5907dce4f167e0b11853c616e448f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793922</data>
    </node>
    <node id="线程切换">
      <data key="d0">线程切换</data>
      <data key="d1">concept</data>
      <data key="d2">线程切换refers to the process of switching between executing threads, requiring a transition from user mode to kernel mode, which incurs significant system overhead.</data>
      <data key="d3">chunk-f910452b3163456182b06ef94a84992f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793922</data>
    </node>
    <node id="用户态">
      <data key="d0">用户态</data>
      <data key="d1">concept</data>
      <data key="d2">用户态is the execution state of a program where it runs with limited privileges, requiring a transition to kernel mode for certain operations.&lt;SEP&gt;用户态is a processor mode in which user applications run and have limited access to system resources.</data>
      <data key="d3">chunk-f910452b3163456182b06ef94a84992f&lt;SEP&gt;chunk-b7f639a9301d2ec0568bcbcad2dc3725</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794241</data>
    </node>
    <node id="内核态">
      <data key="d0">内核态</data>
      <data key="d1">concept</data>
      <data key="d2">内核态is the execution state of the operating system with full privileges, required for system-level operations and handling hardware requests.&lt;SEP&gt;内核态is a processor mode in which the operating system kernel runs with full access to hardware and system resources.</data>
      <data key="d3">chunk-f910452b3163456182b06ef94a84992f&lt;SEP&gt;chunk-b7f639a9301d2ec0568bcbcad2dc3725</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794242</data>
    </node>
    <node id="组合方式">
      <data key="d0">组合方式</data>
      <data key="d1">method</data>
      <data key="d2">组合方式is a threading implementation that combines both kernel-level and user-level threads, enabling efficient thread management and better concurrency.</data>
      <data key="d3">chunk-f910452b3163456182b06ef94a84992f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793922</data>
    </node>
    <node id="内核级线程">
      <data key="d0">内核级线程</data>
      <data key="d1">artifact</data>
      <data key="d2">内核级线程are threads managed and scheduled by the operating system kernel, allowing for true parallelism across multiple CPUs.</data>
      <data key="d3">chunk-f910452b3163456182b06ef94a84992f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793923</data>
    </node>
    <node id="用户级线程">
      <data key="d0">用户级线程</data>
      <data key="d1">artifact</data>
      <data key="d2">用户级线程are threads managed entirely within user space, without direct kernel involvement, enabling fast context switches.</data>
      <data key="d3">chunk-f910452b3163456182b06ef94a84992f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793923</data>
    </node>
    <node id="多线程模型">
      <data key="d0">多线程模型</data>
      <data key="d1">concept</data>
      <data key="d2">多线程模型refers to the architectural design that defines how user-level and kernel-level threads are mapped and interact within a system.</data>
      <data key="d3">chunk-f910452b3163456182b06ef94a84992f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793923</data>
    </node>
    <node id="多对一模型">
      <data key="d0">多对一模型</data>
      <data key="d1">method</data>
      <data key="d2">多对一模型maps multiple user-level threads to a single kernel-level thread, resulting in high efficiency but limited concurrency.</data>
      <data key="d3">chunk-f910452b3163456182b06ef94a84992f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793923</data>
    </node>
    <node id="一对一模型">
      <data key="d0">一对一模型</data>
      <data key="d1">method</data>
      <data key="d2">一对一模型maps each user-level thread to a dedicated kernel-level thread, enabling strong concurrency but incurring high overhead.</data>
      <data key="d3">chunk-f910452b3163456182b06ef94a84992f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793923</data>
    </node>
    <node id="多对多模型">
      <data key="d0">多对多模型</data>
      <data key="d1">method</data>
      <data key="d2">多对多模型maps n user-level threads to m kernel-level threads (n ≥ m), balancing efficiency and concurrency while minimizing resource usage.</data>
      <data key="d3">chunk-f910452b3163456182b06ef94a84992f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793923</data>
    </node>
    <node id="线程阻塞">
      <data key="d0">线程阻塞</data>
      <data key="d1">concept</data>
      <data key="d2">线程阻塞occurs when a thread waits for a resource or event, potentially halting execution until the condition is met.</data>
      <data key="d3">chunk-f910452b3163456182b06ef94a84992f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793923</data>
    </node>
    <node id="时分多路复用">
      <data key="d0">时分多路复用</data>
      <data key="d1">method</data>
      <data key="d2">时分多路复用is a technique used to allow multiple user-level threads to share a limited number of kernel-level threads over time.</data>
      <data key="d3">chunk-f910452b3163456182b06ef94a84992f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793923</data>
    </node>
    <node id="并行执行">
      <data key="d0">并行执行</data>
      <data key="d1">concept</data>
      <data key="d2">并行执行refers to the simultaneous execution of multiple threads across multiple CPUs, improving overall performance.</data>
      <data key="d3">chunk-f910452b3163456182b06ef94a84992f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793923</data>
    </node>
    <node id="系统开销">
      <data key="d0">系统开销</data>
      <data key="d1">concept</data>
      <data key="d2">系统开销represents the cost in system resources (e.g., CPU time, memory) incurred when performing operations like mode switching or thread creation.</data>
      <data key="d3">chunk-f910452b3163456182b06ef94a84992f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793925</data>
    </node>
    <node id="多道程序系统">
      <data key="d0">多道程序系统</data>
      <data key="d1">concept</data>
      <data key="d2">多道程序系统允许多个进程并发执行，从而提升系统效率。</data>
      <data key="d3">chunk-9aabe855c161e30442ff85ca7a64312e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793964</data>
    </node>
    <node id="系统资源竞争">
      <data key="d0">系统资源竞争</data>
      <data key="d1">concept</data>
      <data key="d2">系统资源竞争指不可剥夺资源数量不足以满足多个进程运行需求，导致进程争夺资源。</data>
      <data key="d3">chunk-9aabe855c161e30442ff85ca7a64312e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793964</data>
    </node>
    <node id="进程推进顺序非法">
      <data key="d0">进程推进顺序非法</data>
      <data key="d1">concept</data>
      <data key="d2">进程推进顺序非法指进程请求和释放资源的顺序不当，可能导致死锁。</data>
      <data key="d3">chunk-9aabe855c161e30442ff85ca7a64312e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793964</data>
    </node>
    <node id="互斥条件">
      <data key="d0">互斥条件</data>
      <data key="d1">concept</data>
      <data key="d2">互斥条件指资源在一段时间内只能由一个进程占有，实现排他性控制。</data>
      <data key="d3">chunk-9aabe855c161e30442ff85ca7a64312e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793964</data>
    </node>
    <node id="请求和保持条件">
      <data key="d0">请求和保持条件</data>
      <data key="d1">concept</data>
      <data key="d2">请求和保持条件指进程在未使用完资源前，不能被其他进程强行夺走。</data>
      <data key="d3">chunk-9aabe855c161e30442ff85ca7a64312e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793964</data>
    </node>
    <node id="不剥夺条件">
      <data key="d0">不剥夺条件</data>
      <data key="d1">concept</data>
      <data key="d2">不剥夺条件指进程已获得的资源在使用完前不能被剥夺，只能由自身释放。</data>
      <data key="d3">chunk-9aabe855c161e30442ff85ca7a64312e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793964</data>
    </node>
    <node id="循环等待条件">
      <data key="d0">循环等待条件</data>
      <data key="d1">concept</data>
      <data key="d2">循环等待条件指存在一个进程资源的循环等待链，每个进程所请求的资源被下一个进程所占有。</data>
      <data key="d3">chunk-9aabe855c161e30442ff85ca7a64312e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793965</data>
    </node>
    <node id="不可剥夺资源">
      <data key="d0">不可剥夺资源</data>
      <data key="d1">artifact</data>
      <data key="d2">不可剥夺资源是系统中不能被强制收回的资源，如打印机等。</data>
      <data key="d3">chunk-9aabe855c161e30442ff85ca7a64312e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793966</data>
    </node>
    <node id="资源">
      <data key="d0">资源</data>
      <data key="d1">artifact</data>
      <data key="d2">资源是系统中可供进程使用的各种硬件或软件对象，如内存、打印机、文件等。</data>
      <data key="d3">chunk-9aabe855c161e30442ff85ca7a64312e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793966</data>
    </node>
    <node id="打印机">
      <data key="d0">打印机</data>
      <data key="d1">artifact</data>
      <data key="d2">打印机是一种典型的不可剥夺资源，只能由一个进程独占使用。</data>
      <data key="d3">chunk-9aabe855c161e30442ff85ca7a64312e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793966</data>
    </node>
    <node id="等待态">
      <data key="d0">等待态</data>
      <data key="d1">concept</data>
      <data key="d2">等待态是进程因等待资源而无法执行的状态。</data>
      <data key="d3">chunk-9aabe855c161e30442ff85ca7a64312e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793966</data>
    </node>
    <node id="就绪态">
      <data key="d0">就绪态</data>
      <data key="d1">concept</data>
      <data key="d2">就绪态是进程已具备运行条件，但尚未获得CPU资源的状态。</data>
      <data key="d3">chunk-9aabe855c161e30442ff85ca7a64312e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793966</data>
    </node>
    <node id="死锁产生的必要条件">
      <data key="d0">死锁产生的必要条件</data>
      <data key="d1">concept</data>
      <data key="d2">死锁产生的必要条件是指产生死锁必须同时满足的四个条件：互斥条件、请求和保持条件、不剥夺条件、循环等待条件。</data>
      <data key="d3">chunk-9aabe855c161e30442ff85ca7a64312e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793966</data>
    </node>
    <node id="进程资源的循环等待链">
      <data key="d0">进程资源的循环等待链</data>
      <data key="d1">concept</data>
      <data key="d2">进程资源的循环等待链是循环等待条件的具体表现，指每个进程所请求的资源被下一个进程所占有，形成闭环。</data>
      <data key="d3">chunk-9aabe855c161e30442ff85ca7a64312e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793967</data>
    </node>
    <node id="过程资源的循环等待链">
      <data key="d0">过程资源的循环等待链</data>
      <data key="d3">chunk-9aabe855c161e30442ff85ca7a64312e</data>
      <data key="d2">循环等待条件表现为进程资源的循环等待链。</data>
      <data key="d1">UNKNOWN</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761793970</data>
    </node>
    <node id="Scheduler">
      <data key="d0">Scheduler</data>
      <data key="d1">artifact</data>
      <data key="d2">The Scheduler is a component responsible for managing and allocating CPU time to processes in a computer system.</data>
      <data key="d3">chunk-491042f5eab097ef962a4657a4b61650</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794028</data>
    </node>
    <node id="Queue Manager">
      <data key="d0">Queue Manager</data>
      <data key="d1">method</data>
      <data key="d2">The Queue Manager organizes all ready processes into one or more queues according to a scheduling policy for efficient selection.</data>
      <data key="d3">chunk-491042f5eab097ef962a4657a4b61650</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794028</data>
    </node>
    <node id="Dispatcher">
      <data key="d0">Dispatcher</data>
      <data key="d1">artifact</data>
      <data key="d2">The Dispatcher retrieves a selected process from the ready queue and assigns CPU to it for execution.</data>
      <data key="d3">chunk-491042f5eab097ef962a4657a4b61650</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794028</data>
    </node>
    <node id="Context Switcher">
      <data key="d0">Context Switcher</data>
      <data key="d1">method</data>
      <data key="d2">The Context Switcher performs two pairs of context switching operations during CPU switching: saving the current process's context to its PCB and loading the dispatcher’s context, then loading the new process's CPU state into the registers.</data>
      <data key="d3">chunk-491042f5eab097ef962a4657a4b61650</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794028</data>
    </node>
    <node id="Interrupt Processing">
      <data key="d0">Interrupt Processing</data>
      <data key="d1">concept</data>
      <data key="d2">Interrupt Processing is the handling of hardware or software signals that temporarily halt normal execution to respond to external events.</data>
      <data key="d3">chunk-491042f5eab097ef962a4657a4b61650</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794028</data>
    </node>
    <node id="Idle Process">
      <data key="d0">Idle Process</data>
      <data key="d1">process</data>
      <data key="d2">The Idle Process is a special low-priority process with PID 0 that runs when no other processes are ready; it consumes CPU cycles until a new process becomes ready.</data>
      <data key="d3">chunk-491042f5eab097ef962a4657a4b61650</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794029</data>
    </node>
    <node id="Priority Principle">
      <data key="d0">Priority Principle</data>
      <data key="d1">method</data>
      <data key="d2">The Priority Principle is a scheduling rule that assigns CPU time based on the priority level of processes.</data>
      <data key="d3">chunk-491042f5eab097ef962a4657a4b61650</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794029</data>
    </node>
    <node id="Shortest Process First">
      <data key="d0">Shortest Process First</data>
      <data key="d1">method</data>
      <data key="d2">The Shortest Process First principle schedules processes with the shortest estimated execution time first.</data>
      <data key="d3">chunk-491042f5eab097ef962a4657a4b61650</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794029</data>
    </node>
    <node id="Time Slice Principle">
      <data key="d0">Time Slice Principle</data>
      <data key="d1">method</data>
      <data key="d2">The Time Slice Principle allocates a fixed time quantum to each process before switching to the next.</data>
      <data key="d3">chunk-491042f5eab097ef962a4657a4b61650</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794029</data>
    </node>
    <node id="User-Level Threads">
      <data key="d0">User-Level Threads</data>
      <data key="d1">process</data>
      <data key="d2">User-Level Threads are threads managed entirely by user-space libraries, without kernel knowledge.</data>
      <data key="d3">chunk-491042f5eab097ef962a4657a4b61650</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794029</data>
    </node>
    <node id="Kernel-Level Threads">
      <data key="d0">Kernel-Level Threads</data>
      <data key="d1">process</data>
      <data key="d2">Kernel-Level Threads are threads recognized and managed by the operating system kernel.</data>
      <data key="d3">chunk-491042f5eab097ef962a4657a4b61650</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794029</data>
    </node>
    <node id="CPU Registers">
      <data key="d0">CPU Registers</data>
      <data key="d1">artifact</data>
      <data key="d2">CPU Registers are high-speed storage locations within the CPU used to hold data and addresses during execution.</data>
      <data key="d3">chunk-491042f5eab097ef962a4657a4b61650</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794031</data>
    </node>
    <node id="I/O Device">
      <data key="d0">I/O Device</data>
      <data key="d1">naturalobject</data>
      <data key="d2">An I/O Device is a hardware component that facilitates input or output between the system and external devices.</data>
      <data key="d3">chunk-491042f5eab097ef962a4657a4b61650</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794031</data>
    </node>
    <node id="Load Store Instructions">
      <data key="d0">Load Store Instructions</data>
      <data key="d3">chunk-491042f5eab097ef962a4657a4b61650</data>
      <data key="d2">Context switching involves significant execution of load and store instructions to save and restore register states, increasing system overhead.</data>
      <data key="d1">UNKNOWN</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794035</data>
    </node>
    <node id="进程控制">
      <data key="d0">进程控制</data>
      <data key="d1">concept</data>
      <data key="d2">进程控制是操作系统中用于管理所有进程的功能，包括创建、撤销和状态转换等。</data>
      <data key="d3">chunk-7ca51faf7f3faf56c56ab18dd6458c7e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794040</data>
    </node>
    <node id="原语">
      <data key="d0">原语</data>
      <data key="d1">method</data>
      <data key="d2">原语是操作系统中用于进程控制的程序段，执行期间不允许中断，是不可分割的基本单位。</data>
      <data key="d3">chunk-7ca51faf7f3faf56c56ab18dd6458c7e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794040</data>
    </node>
    <node id="父进程">
      <data key="d0">父进程</data>
      <data key="d1">person</data>
      <data key="d2">父进程是创建新进程的进程，可以分配资源给子进程并接收其释放的资源。</data>
      <data key="d3">chunk-7ca51faf7f3faf56c56ab18dd6458c7e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794040</data>
    </node>
    <node id="子进程">
      <data key="d0">子进程</data>
      <data key="d1">person</data>
      <data key="d2">子进程是由父进程创建的进程，继承父进程的资源，并在终止时归还资源。</data>
      <data key="d3">chunk-7ca51faf7f3faf56c56ab18dd6458c7e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794040</data>
    </node>
    <node id="PCB">
      <data key="d0">PCB</data>
      <data key="d1">artifact</data>
      <data key="d2">PCB(进程控制块)是操作系统中用于记录进程信息的数据结构，包含状态、CPU信息、优先级等。</data>
      <data key="d3">chunk-7ca51faf7f3faf56c56ab18dd6458c7e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794040</data>
    </node>
    <node id="创建原语">
      <data key="d0">创建原语</data>
      <data key="d1">method</data>
      <data key="d2">创建原语是操作系统用于创建新进程的原语，包含分配PID、申请PCB、分配资源、初始化PCB等步骤。</data>
      <data key="d3">chunk-7ca51faf7f3faf56c56ab18dd6458c7e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794040</data>
    </node>
    <node id="终止原语">
      <data key="d0">终止原语</data>
      <data key="d1">method</data>
      <data key="d2">终止原语是操作系统用于终止进程的原语，包括检索PCB、终止运行、回收资源和删除PCB等步骤。</data>
      <data key="d3">chunk-7ca51faf7f3faf56c56ab18dd6458c7e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794040</data>
    </node>
    <node id="阻塞原语">
      <data key="d0">阻塞原语</data>
      <data key="d1">method</data>
      <data key="d2">阻塞原语是使进程由运行态变为阻塞态的原语，由进程主动调用，以等待特定事件发生。</data>
      <data key="d3">chunk-7ca51faf7f3faf56c56ab18dd6458c7e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794040</data>
    </node>
    <node id="唤醒原语">
      <data key="d0">唤醒原语</data>
      <data key="d1">method</data>
      <data key="d2">唤醒原语是将处于阻塞态的进程恢复为就绪态的原语，由相关事件触发。</data>
      <data key="d3">chunk-7ca51faf7f3faf56c56ab18dd6458c7e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794042</data>
    </node>
    <node id="运行态">
      <data key="d0">运行态</data>
      <data key="d1">concept</data>
      <data key="d2">运行态是进程正在使用CPU执行指令的状态。</data>
      <data key="d3">chunk-7ca51faf7f3faf56c56ab18dd6458c7e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794042</data>
    </node>
    <node id="阻塞态">
      <data key="d0">阻塞态</data>
      <data key="d1">concept</data>
      <data key="d2">阻塞态是进程因等待事件而暂停运行的状态。</data>
      <data key="d3">chunk-7ca51faf7f3faf56c56ab18dd6458c7e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794042</data>
    </node>
    <node id="就绪队列">
      <data key="d0">就绪队列</data>
      <data key="d1">concept</data>
      <data key="d2">就绪队列是存储等待调度运行的进程的队列。&lt;SEP&gt;就绪队列is a list of processes that are ready to be executed and are waiting for CPU time.</data>
      <data key="d3">chunk-7ca51faf7f3faf56c56ab18dd6458c7e&lt;SEP&gt;chunk-b7f639a9301d2ec0568bcbcad2dc3725</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794241</data>
    </node>
    <node id="级联终止">
      <data key="d0">级联终止</data>
      <data key="d1">concept</data>
      <data key="d2">级联终止是当父进程终止时，其所有子进程也被自动终止的现象。</data>
      <data key="d3">chunk-7ca51faf7f3faf56c56ab18dd6458c7e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794042</data>
    </node>
    <node id="资源回收">
      <data key="d0">资源回收</data>
      <data key="d1">concept</data>
      <data key="d2">资源回收是进程终止时，将其占用的资源释放并归还给父进程或操作系统的过程。</data>
      <data key="d3">chunk-7ca51faf7f3faf56c56ab18dd6458c7e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794042</data>
    </node>
    <node id="存储区越界">
      <data key="d0">存储区越界</data>
      <data key="d1">concept</data>
      <data key="d2">存储区越界是异常事件的一种，表示进程试图访问超出其分配内存范围的地址。</data>
      <data key="d3">chunk-7ca51faf7f3faf56c56ab18dd6458c7e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794042</data>
    </node>
    <node id="保护错">
      <data key="d0">保护错</data>
      <data key="d1">concept</data>
      <data key="d2">保护错是异常事件的一种，发生在进程试图访问受保护的内存区域时。</data>
      <data key="d3">chunk-7ca51faf7f3faf56c56ab18dd6458c7e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794043</data>
    </node>
    <node id="非法指令">
      <data key="d0">非法指令</data>
      <data key="d1">concept</data>
      <data key="d2">非法指令是异常事件的一种，表示进程执行了不可识别或不允许的指令。</data>
      <data key="d3">chunk-7ca51faf7f3faf56c56ab18dd6458c7e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794043</data>
    </node>
    <node id="特权指令错">
      <data key="d0">特权指令错</data>
      <data key="d1">concept</data>
      <data key="d2">特权指令错是异常事件的一种，表示进程在非特权模式下执行了需要特权的指令。</data>
      <data key="d3">chunk-7ca51faf7f3faf56c56ab18dd6458c7e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794044</data>
    </node>
    <node id="运行超时">
      <data key="d0">运行超时</data>
      <data key="d1">concept</data>
      <data key="d2">运行超时是异常事件的一种，表示进程执行时间超过了规定限制。</data>
      <data key="d3">chunk-7ca51faf7f3faf56c56ab18dd6458c7e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794044</data>
    </node>
    <node id="算术运算错">
      <data key="d0">算术运算错</data>
      <data key="d1">concept</data>
      <data key="d2">算术运算错是异常事件的一种，发生在执行无效数学运算时。</data>
      <data key="d3">chunk-7ca51faf7f3faf56c56ab18dd6458c7e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794044</data>
    </node>
    <node id="I/O故障">
      <data key="d0">I/O故障</data>
      <data key="d1">concept</data>
      <data key="d2">I/O故障是异常事件的一种，表示输入/输出设备出现错误或无法响应。</data>
      <data key="d3">chunk-7ca51faf7f3faf56c56ab18dd6458c7e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794044</data>
    </node>
    <node id="进程标识号">
      <data key="d0">进程标识号</data>
      <data key="d1">data</data>
      <data key="d2">进程标识号是操作系统为每个进程分配的唯一编号，用于识别和管理进程。</data>
      <data key="d3">chunk-7ca51faf7f3faf56c56ab18dd6458c7e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794044</data>
    </node>
    <node id="CPU时间">
      <data key="d0">CPU时间</data>
      <data key="d1">data</data>
      <data key="d2">CPU时间是进程运行所需的处理器时间资源。</data>
      <data key="d3">chunk-7ca51faf7f3faf56c56ab18dd6458c7e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794044</data>
    </node>
    <node id="内存">
      <data key="d0">内存</data>
      <data key="d1">naturalobject</data>
      <data key="d2">内存是计算机系统中用于存储程序和数据的硬件资源。</data>
      <data key="d3">chunk-7ca51faf7f3faf56c56ab18dd6458c7e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794045</data>
    </node>
    <node id="I/O设备">
      <data key="d0">I/O设备</data>
      <data key="d1">naturalobject</data>
      <data key="d2">I/O设备是计算机系统中用于输入输出操作的硬件设备。</data>
      <data key="d3">chunk-7ca51faf7f3faf56c56ab18dd6458c7e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794045</data>
    </node>
    <node id="文件">
      <data key="d0">文件</data>
      <data key="d1">artifact</data>
      <data key="d2">文件是存储在系统中用于保存数据的结构化数据单元。</data>
      <data key="d3">chunk-7ca51faf7f3faf56c56ab18dd6458c7e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794045</data>
    </node>
    <node id="Block">
      <data key="d0">Block</data>
      <data key="d1">method</data>
      <data key="d2">The Block method is a synchronization primitive used in processes to cause a process to enter a blocked state.</data>
      <data key="d3">chunk-62e7a5a2dcc4d8e5b08d9447994638c2</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794045</data>
    </node>
    <node id="Wakeup">
      <data key="d0">Wakeup</data>
      <data key="d1">method</data>
      <data key="d2">The Wakeup method is a synchronization primitive used to wake up a process that is in a blocked state.</data>
      <data key="d3">chunk-62e7a5a2dcc4d8e5b08d9447994638c2</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794045</data>
    </node>
    <node id="Blocking State">
      <data key="d0">Blocking State</data>
      <data key="d1">concept</data>
      <data key="d2">The blocking state is a condition in which a process is unable to proceed until a specific condition is met, such as being woken up.</data>
      <data key="d3">chunk-62e7a5a2dcc4d8e5b08d9447994638c2</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794045</data>
    </node>
    <node id="Deadlock Prevention">
      <data key="d0">Deadlock Prevention</data>
      <data key="d1">method</data>
      <data key="d2">Deadlock prevention is a method that ensures at least one of the four necessary conditions for deadlock cannot be met, thereby preventing deadlock.</data>
      <data key="d3">chunk-6de1df73d142ee13cb1e9512464e4e80</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794100</data>
    </node>
    <node id="Mutual Exclusion Condition">
      <data key="d0">Mutual Exclusion Condition</data>
      <data key="d1">concept</data>
      <data key="d2">The mutual exclusion condition is a necessary condition for deadlock, where a resource can only be used by one process at a time.</data>
      <data key="d3">chunk-6de1df73d142ee13cb1e9512464e4e80</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794100</data>
    </node>
    <node id="Request and Hold Condition">
      <data key="d0">Request and Hold Condition</data>
      <data key="d1">concept</data>
      <data key="d2">The request and hold condition occurs when a process holds at least one resource and is waiting for additional resources that are currently held by other processes.</data>
      <data key="d3">chunk-6de1df73d142ee13cb1e9512464e4e80</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794100</data>
    </node>
    <node id="No Preemption Condition">
      <data key="d0">No Preemption Condition</data>
      <data key="d1">concept</data>
      <data key="d2">The no preemption condition exists when resources cannot be forcibly taken away from a process; they must be released voluntarily.</data>
      <data key="d3">chunk-6de1df73d142ee13cb1e9512464e4e80</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794100</data>
    </node>
    <node id="Circular Wait Condition">
      <data key="d0">Circular Wait Condition</data>
      <data key="d1">concept</data>
      <data key="d2">The circular wait condition arises when a set of processes are waiting in a circular chain, each holding a resource and waiting for another resource held by the next process in the chain.</data>
      <data key="d3">chunk-6de1df73d142ee13cb1e9512464e4e80</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794100</data>
    </node>
    <node id="Resource Sharing">
      <data key="d0">Resource Sharing</data>
      <data key="d1">concept</data>
      <data key="d2">Resource sharing refers to the ability to use system resources simultaneously, which can help prevent deadlock if applicable.</data>
      <data key="d3">chunk-6de1df73d142ee13cb1e9512464e4e80</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794100</data>
    </node>
    <node id="First Protocol">
      <data key="d0">First Protocol</data>
      <data key="d1">method</data>
      <data key="d2">The first protocol requires all processes to request all necessary resources before beginning execution.</data>
      <data key="d3">chunk-6de1df73d142ee13cb1e9512464e4e80</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794100</data>
    </node>
    <node id="Second Protocol">
      <data key="d0">Second Protocol</data>
      <data key="d1">method</data>
      <data key="d2">The second protocol allows a process to request only initial resources, then release unused ones and request new ones during execution.</data>
      <data key="d3">chunk-6de1df73d142ee13cb1e9512464e4e80</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794100</data>
    </node>
    <node id="Orderly Resource Allocation">
      <data key="d0">Orderly Resource Allocation</data>
      <data key="d1">method</data>
      <data key="d2">Orderly resource allocation is a technique that prevents circular waiting by assigning a fixed order to resources and requiring processes to request them in increasing order.</data>
      <data key="d3">chunk-6de1df73d142ee13cb1e9512464e4e80</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794102</data>
    </node>
    <node id="Resource Numbering">
      <data key="d0">Resource Numbering</data>
      <data key="d1">concept</data>
      <data key="d2">Resource numbering is a method of identifying system resources through unique numbers to enforce sequence in resource requests.</data>
      <data key="d3">chunk-6de1df73d142ee13cb1e9512464e4e80</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794102</data>
    </node>
    <node id="Program Segment">
      <data key="d0">Program Segment</data>
      <data key="d1">artifact</data>
      <data key="d2">The program segment contains the executable code that can be scheduled by the operating system to run on the CPU.&lt;SEP&gt;The program segment is the part of a process entity that contains the executable instructions of a program loaded into memory.</data>
      <data key="d3">chunk-2da376f0975743dcb0cc169c929cbe5c&lt;SEP&gt;chunk-fd195ae7c40727c5b83fa7b77d72095e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794201</data>
    </node>
    <node id="Data Segment">
      <data key="d0">Data Segment</data>
      <data key="d1">content</data>
      <data key="d2">The data segment contains the data processed by a program, including original input, intermediate results, and final outputs.</data>
      <data key="d3">chunk-2da376f0975743dcb0cc169c929cbe5c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794158</data>
    </node>
    <node id="CPU Context">
      <data key="d0">CPU Context</data>
      <data key="d1">artifact</data>
      <data key="d2">CPU context refers to the state of CPU registers and other processor information, saved in the PCB during process switching to allow recovery.</data>
      <data key="d3">chunk-2da376f0975743dcb0cc169c929cbe5c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794158</data>
    </node>
    <node id="进程控制块">
      <data key="d0">进程控制块</data>
      <data key="d1">artifact</data>
      <data key="d2">The Process Control Block (PCB) is used to manage process states and resources in the operating system.</data>
      <data key="d3">chunk-2da376f0975743dcb0cc169c929cbe5c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794158</data>
    </node>
    <node id="链接方式">
      <data key="d0">链接方式</data>
      <data key="d1">method</data>
      <data key="d2">The linked method organizes PCBs by state, linking those with the same state into queues, and can further separate blocked processes by the cause of blocking.</data>
      <data key="d3">chunk-2da376f0975743dcb0cc169c929cbe5c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794158</data>
    </node>
    <node id="索引方式">
      <data key="d0">索引方式</data>
      <data key="d1">method</data>
      <data key="d2">The indexed method organizes PCBs by state using index tables, where each table entry points to a specific PCB, enabling efficient process scheduling.</data>
      <data key="d3">chunk-2da376f0975743dcb0cc169c929cbe5c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794160</data>
    </node>
    <node id="Process Identifier">
      <data key="d0">Process Identifier</data>
      <data key="d1">data</data>
      <data key="d2">The process identifier is a unique number assigned to each process to distinguish it from others within the system.</data>
      <data key="d3">chunk-2da376f0975743dcb0cc169c929cbe5c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794160</data>
    </node>
    <node id="User Identifier">
      <data key="d0">User Identifier</data>
      <data key="d1">data</data>
      <data key="d2">The user identifier links a process to the user who owns it, supporting access control and resource sharing.</data>
      <data key="d3">chunk-2da376f0975743dcb0cc169c929cbe5c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794160</data>
    </node>
    <node id="Process State">
      <data key="d0">Process State</data>
      <data key="d1">concept</data>
      <data key="d2">The process state describes the current condition of a process, such as running, ready, or blocked, used by the scheduler for decision-making.</data>
      <data key="d3">chunk-2da376f0975743dcb0cc169c929cbe5c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794160</data>
    </node>
    <node id="Process Priority">
      <data key="d0">Process Priority</data>
      <data key="d1">data</data>
      <data key="d2">Process priority determines the order in which processes access the CPU, with higher-priority processes favored.</data>
      <data key="d3">chunk-2da376f0975743dcb0cc169c929cbe5c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794160</data>
    </node>
    <node id="Resource Allocation List">
      <data key="d0">Resource Allocation List</data>
      <data key="d1">data</data>
      <data key="d2">The resource allocation list includes memory, open files, and input/output devices allocated to a process, tracked in the PCB.</data>
      <data key="d3">chunk-2da376f0975743dcb0cc169c929cbe5c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794160</data>
    </node>
    <node id="Linked Method">
      <data key="d0">Linked Method</data>
      <data key="d3">chunk-2da376f0975743dcb0cc169c929cbe5c</data>
      <data key="d2">The linked method uses queues to organize PCBs by their current state, enabling efficient management.</data>
      <data key="d1">UNKNOWN</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794164</data>
    </node>
    <node id="Indexed Method">
      <data key="d0">Indexed Method</data>
      <data key="d3">chunk-2da376f0975743dcb0cc169c929cbe5c</data>
      <data key="d2">The indexed method organizes PCBs using index tables, where each entry points to a specific PCB.</data>
      <data key="d1">UNKNOWN</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794164</data>
    </node>
    <node id="Multi-Program Environment">
      <data key="d0">Multi-Program Environment</data>
      <data key="d1">concept</data>
      <data key="d2">A multi-program environment allows multiple programs to execute concurrently, leading to loss of closure, discontinuity, and non-reproducibility of results.</data>
      <data key="d3">chunk-fd195ae7c40727c5b83fa7b77d72095e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794199</data>
    </node>
    <node id="Process Entity">
      <data key="d0">Process Entity</data>
      <data key="d1">artifact</data>
      <data key="d2">The process entity, also known as a process image, consists of the program segment, related data segment, and the Process Control Block (PCB).</data>
      <data key="d3">chunk-fd195ae7c40727c5b83fa7b77d72095e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794199</data>
    </node>
    <node id="Program">
      <data key="d0">Program</data>
      <data key="d1">concept</data>
      <data key="d2">A program is a static set of instructions, in contrast to a process, which is the dynamic execution of those instructions.</data>
      <data key="d3">chunk-fd195ae7c40727c5b83fa7b77d72095e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794199</data>
    </node>
    <node id="Dynamic Nature">
      <data key="d0">Dynamic Nature</data>
      <data key="d1">concept</data>
      <data key="d2">The dynamic nature of a process refers to its lifecycle, including creation, execution, suspension, and termination.</data>
      <data key="d3">chunk-fd195ae7c40727c5b83fa7b77d72095e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794201</data>
    </node>
    <node id="Independent Execution">
      <data key="d0">Independent Execution</data>
      <data key="d1">concept</data>
      <data key="d2">Independent execution means a process can run autonomously, obtain resources, and be scheduled without interference from other processes.</data>
      <data key="d3">chunk-fd195ae7c40727c5b83fa7b77d72095e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794201</data>
    </node>
    <node id="Asynchrony">
      <data key="d0">Asynchrony</data>
      <data key="d1">concept</data>
      <data key="d2">Asynchrony describes the unpredictable progression of processes due to mutual dependencies, leading to non-reproducible outcomes.</data>
      <data key="d3">chunk-fd195ae7c40727c5b83fa7b77d72095e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794201</data>
    </node>
    <node id="Process Synchronization Mechanism">
      <data key="d0">Process Synchronization Mechanism</data>
      <data key="d1">method</data>
      <data key="d2">A process synchronization mechanism is implemented in the operating system to address the issues caused by asynchrony and ensure coordinated access to shared resources.</data>
      <data key="d3">chunk-fd195ae7c40727c5b83fa7b77d72095e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794201</data>
    </node>
    <node id="Related Data Segment">
      <data key="d0">Related Data Segment</data>
      <data key="d1">artifact</data>
      <data key="d2">The related data segment is the portion of a process entity that holds the data associated with the program during execution.</data>
      <data key="d3">chunk-fd195ae7c40727c5b83fa7b77d72095e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794201</data>
    </node>
    <node id="Process Lifecycle">
      <data key="d0">Process Lifecycle</data>
      <data key="d1">concept</data>
      <data key="d2">The process lifecycle refers to the stages a process goes through, including creation, execution, suspension, and termination, embodying its dynamic nature.</data>
      <data key="d3">chunk-fd195ae7c40727c5b83fa7b77d72095e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794201</data>
    </node>
    <node id="Mutual Dependence">
      <data key="d0">Mutual Dependence</data>
      <data key="d1">concept</data>
      <data key="d2">Mutual dependence occurs when processes interact or rely on each other, leading to asynchronous execution and unpredictable progression.</data>
      <data key="d3">chunk-fd195ae7c40727c5b83fa7b77d72095e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794202</data>
    </node>
    <node id="进程切换">
      <data key="d0">进程切换</data>
      <data key="d1">concept</data>
      <data key="d2">进程切换is the process by which the operating system saves the context of a currently running process and loads the context of another process to allow execution to continue in the new process.</data>
      <data key="d3">chunk-b7f639a9301d2ec0568bcbcad2dc3725</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794241</data>
    </node>
    <node id="上下文切换">
      <data key="d0">上下文切换</data>
      <data key="d1">concept</data>
      <data key="d2">上下文切换refers to the operation of saving the current state of a process and restoring the state of a new process, enabling the CPU to switch between processes.</data>
      <data key="d3">chunk-b7f639a9301d2ec0568bcbcad2dc3725</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794241</data>
    </node>
    <node id="CPU寄存器">
      <data key="d0">CPU寄存器</data>
      <data key="d1">artifact</data>
      <data key="d2">CPU寄存器are hardware components that store temporary data during the execution of a process and are part of the process context.</data>
      <data key="d3">chunk-b7f639a9301d2ec0568bcbcad2dc3725</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794241</data>
    </node>
    <node id="程序计数器">
      <data key="d0">程序计数器</data>
      <data key="d1">artifact</data>
      <data key="d2">程序计数器holds the address of the next instruction to be executed and is saved and restored during context switching.</data>
      <data key="d3">chunk-b7f639a9301d2ec0568bcbcad2dc3725</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794241</data>
    </node>
    <node id="进程PCB">
      <data key="d0">进程PCB</data>
      <data key="d1">artifact</data>
      <data key="d2">进程PCB (Process Control Block) is a data structure that stores information about a process, including state, registers, and memory management details.</data>
      <data key="d3">chunk-b7f639a9301d2ec0568bcbcad2dc3725</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794241</data>
    </node>
    <node id="阻塞队列">
      <data key="d0">阻塞队列</data>
      <data key="d1">concept</data>
      <data key="d2">阻塞队列is a list of processes that are waiting for a specific event, such as I/O completion, before they can proceed.</data>
      <data key="d3">chunk-b7f639a9301d2ec0568bcbcad2dc3725</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794241</data>
    </node>
    <node id="系统调用">
      <data key="d0">系统调用</data>
      <data key="d1">method</data>
      <data key="d2">系统调用is a mechanism that allows user programs to request services from the operating system, which leads to a transition into kernel mode.</data>
      <data key="d3">chunk-b7f639a9301d2ec0568bcbcad2dc3725</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794242</data>
    </node>
    <node id="调度">
      <data key="d0">调度</data>
      <data key="d1">concept</data>
      <data key="d2">调度is the process of selecting which process should be executed next by the CPU based on scheduling algorithms.</data>
      <data key="d3">chunk-b7f639a9301d2ec0568bcbcad2dc3725</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794242</data>
    </node>
    <node id="切换">
      <data key="d0">切换</data>
      <data key="d1">concept</data>
      <data key="d2">切换is the actual act of transferring control from one process to another, which follows scheduling decisions.</data>
      <data key="d3">chunk-b7f639a9301d2ec0568bcbcad2dc3725</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794242</data>
    </node>
    <node id="系统调用处理程序">
      <data key="d0">系统调用处理程序</data>
      <data key="d1">method</data>
      <data key="d2">系统调用处理程序is a kernel function responsible for handling system calls made by user processes.</data>
      <data key="d3">chunk-b7f639a9301d2ec0568bcbcad2dc3725</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794242</data>
    </node>
    <node id="多任务操作系统">
      <data key="d0">多任务操作系统</data>
      <data key="d1">concept</data>
      <data key="d2">多任务操作系统is an operating system that allows multiple processes to run concurrently by interleaving their execution.</data>
      <data key="d3">chunk-b7f639a9301d2ec0568bcbcad2dc3725</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794242</data>
    </node>
    <node id="I/O操作">
      <data key="d0">I/O操作</data>
      <data key="d1">method</data>
      <data key="d2">I/O操作refers to input/output operations that require system resources and are typically managed by the operating system through system calls.</data>
      <data key="d3">chunk-b7f639a9301d2ec0568bcbcad2dc3725</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794242</data>
    </node>
    <node id="系统设备">
      <data key="d0">系统设备</data>
      <data key="d1">artifact</data>
      <data key="d2">系统设备denotes hardware components that provide input/output services and are accessed by processes through system calls.</data>
      <data key="d3">chunk-b7f639a9301d2ec0568bcbcad2dc3725</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794242</data>
    </node>
    <node id="创建进程">
      <data key="d0">创建进程</data>
      <data key="d1">method</data>
      <data key="d2">创建进程is the act of initializing a new process by the operating system, requiring system calls and kernel intervention.</data>
      <data key="d3">chunk-b7f639a9301d2ec0568bcbcad2dc3725</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794243</data>
    </node>
    <node id="CPU Utilization">
      <data key="d0">CPU Utilization</data>
      <data key="d1">concept</data>
      <data key="d2">CPU utilization is a performance metric that measures how much time the CPU spends executing tasks, aiming to keep it as high as possible to maximize resource efficiency.</data>
      <data key="d3">chunk-76ab4199a2aae3d8b4b3b6c270c34a12</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794297</data>
    </node>
    <node id="Turnaround Time">
      <data key="d0">Turnaround Time</data>
      <data key="d1">concept</data>
      <data key="d2">Turnaround time is the total time elapsed from job submission to job completion, including waiting, ready queue time, CPU execution, and I/O operations.</data>
      <data key="d3">chunk-76ab4199a2aae3d8b4b3b6c270c34a12</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794297</data>
    </node>
    <node id="Weighted Turnaround Time">
      <data key="d0">Weighted Turnaround Time</data>
      <data key="d1">concept</data>
      <data key="d2">Weighted turnaround time is the ratio of turnaround time to actual execution time, providing a normalized measure of job completion speed.</data>
      <data key="d3">chunk-76ab4199a2aae3d8b4b3b6c270c34a12</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794297</data>
    </node>
    <node id="Response Time">
      <data key="d0">Response Time</data>
      <data key="d1">concept</data>
      <data key="d2">Response time is the duration from when a user submits a request to when the system first responds, critical in interactive systems.</data>
      <data key="d3">chunk-76ab4199a2aae3d8b4b3b6c270c34a12</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794297</data>
    </node>
    <node id="CPU Scheduling Algorithm">
      <data key="d0">CPU Scheduling Algorithm</data>
      <data key="d1">method</data>
      <data key="d2">CPU scheduling algorithms determine the order in which processes are executed by the CPU, influencing waiting and response times.</data>
      <data key="d3">chunk-76ab4199a2aae3d8b4b3b6c270c34a12</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794297</data>
    </node>
    <node id="Long Job">
      <data key="d0">Long Job</data>
      <data key="d1">concept</data>
      <data key="d2">A long job is a task that requires a substantial amount of CPU time, which reduces system throughput.</data>
      <data key="d3">chunk-76ab4199a2aae3d8b4b3b6c270c34a12</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794297</data>
    </node>
    <node id="Short Job">
      <data key="d0">Short Job</data>
      <data key="d1">concept</data>
      <data key="d2">A short job is a task that requires a minimal amount of CPU time, which increases system throughput.</data>
      <data key="d3">chunk-76ab4199a2aae3d8b4b3b6c270c34a12</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794298</data>
    </node>
    <node id="Interactive System">
      <data key="d0">Interactive System</data>
      <data key="d1">concept</data>
      <data key="d2">An interactive system is a computing environment where users provide input and expect prompt responses, making response time a key evaluation criterion.</data>
      <data key="d3">chunk-76ab4199a2aae3d8b4b3b6c270c34a12</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794298</data>
    </node>
    <node id="Job Submission">
      <data key="d0">Job Submission</data>
      <data key="d1">concept</data>
      <data key="d2">Job submission is the act of introducing a job into the system for processing, marking the start of the turnaround time calculation.</data>
      <data key="d3">chunk-76ab4199a2aae3d8b4b3b6c270c34a12</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794298</data>
    </node>
    <node id="Job Completion">
      <data key="d0">Job Completion</data>
      <data key="d1">concept</data>
      <data key="d2">Job completion refers to the point at which a job has finished execution, marking the end of the turnaround time.</data>
      <data key="d3">chunk-76ab4199a2aae3d8b4b3b6c270c34a12</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794298</data>
    </node>
    <node id="CPU Execution">
      <data key="d0">CPU Execution</data>
      <data key="d1">concept</data>
      <data key="d2">CPU execution is the period during which a process is actively running on the CPU, contributing to turnaround and execution time.</data>
      <data key="d3">chunk-76ab4199a2aae3d8b4b3b6c270c34a12</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794298</data>
    </node>
    <edge source="Signal Semaphore" target="Wait Operation">
      <data key="d6">1.0</data>
      <data key="d7">The signal semaphore mechanism uses the wait operation (P) to request access to resources.</data>
      <data key="d8">mechanism operation,resource request</data>
      <data key="d9">chunk-5f130d8e8cad5fdb4c75e49961444322</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793445</data>
    </edge>
    <edge source="Signal Semaphore" target="Signal Operation">
      <data key="d6">1.0</data>
      <data key="d7">The signal semaphore mechanism uses the signal operation (V) to release resources.</data>
      <data key="d8">mechanism operation,resource release</data>
      <data key="d9">chunk-5f130d8e8cad5fdb4c75e49961444322</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793445</data>
    </edge>
    <edge source="Signal Semaphore" target="Synchronization">
      <data key="d6">1.0</data>
      <data key="d7">Signal semaphore is used to coordinate the execution order of concurrent processes.</data>
      <data key="d8">execution coordination,implementation mechanism</data>
      <data key="d9">chunk-5f130d8e8cad5fdb4c75e49961444322</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793446</data>
    </edge>
    <edge source="Signal Semaphore" target="Mutual Exclusion">
      <data key="d6">1.0</data>
      <data key="d7">Signal semaphore is used to implement mutual exclusion among processes.</data>
      <data key="d8">implementation mechanism,synchronization design</data>
      <data key="d9">chunk-5f130d8e8cad5fdb4c75e49961444322</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793447</data>
    </edge>
    <edge source="Signal Semaphore" target="Precedence Relationship">
      <data key="d6">1.0</data>
      <data key="d7">Precedence relationships are enforced using semaphore operations: V after predecessor, P before successor.</data>
      <data key="d8">V-P ordering,implementation method</data>
      <data key="d9">chunk-5f130d8e8cad5fdb4c75e49961444322</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793448</data>
    </edge>
    <edge source="Wait Operation" target="Busy Waiting">
      <data key="d6">1.0</data>
      <data key="d7">The wait operation in integer semaphore leads to busy waiting when the resource is unavailable.</data>
      <data key="d8">execution behavior,inefficient waiting</data>
      <data key="d9">chunk-5f130d8e8cad5fdb4c75e49961444322</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793445</data>
    </edge>
    <edge source="Wait Operation" target="P() Operation">
      <data key="d6">1.0</data>
      <data key="d7">The wait operation is also known as the P() operation, serving as an alternative notation for requesting resources.</data>
      <data key="d8">alternative notation,synonym</data>
      <data key="d9">chunk-5f130d8e8cad5fdb4c75e49961444322</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793447</data>
    </edge>
    <edge source="Signal Operation" target="V() Operation">
      <data key="d6">1.0</data>
      <data key="d7">The signal operation is also known as the V() operation, serving as an alternative notation for releasing resources.</data>
      <data key="d8">alternative notation,synonym</data>
      <data key="d9">chunk-5f130d8e8cad5fdb4c75e49961444322</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793447</data>
    </edge>
    <edge source="P Operation" target="Synchronization and Mutual Exclusion Tools">
      <data key="d6">1.0</data>
      <data key="d7">The P operation is a core part of synchronization and mutual exclusion tools for managing shared access.</data>
      <data key="d8">resource access control,semaphore operation</data>
      <data key="d9">chunk-d75ea791c964266b65c0ee55b3a8e15f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793867</data>
    </edge>
    <edge source="V Operation" target="Synchronization and Mutual Exclusion Tools">
      <data key="d6">1.0</data>
      <data key="d7">The V operation is a core part of synchronization and mutual exclusion tools for releasing access to shared resources.</data>
      <data key="d8">resource release,semaphore operation</data>
      <data key="d9">chunk-d75ea791c964266b65c0ee55b3a8e15f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793868</data>
    </edge>
    <edge source="Integer Semaphore" target="Busy Waiting">
      <data key="d6">1.0</data>
      <data key="d7">Integer semaphore violates the let-go-waiting principle by causing busy waiting.</data>
      <data key="d8">detection condition,non-compliance with principle</data>
      <data key="d9">chunk-5f130d8e8cad5fdb4c75e49961444322</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793446</data>
    </edge>
    <edge source="Busy Waiting" target="Spin Lock">
      <data key="d6">1.0</data>
      <data key="d7">The spin lock is characterized by busy waiting, where a process waits in a loop until the lock becomes available.</data>
      <data key="d8">behavior characteristic,implementation method</data>
      <data key="d9">chunk-e16dceff2fc93c138aa86eb65cacc6c7</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793682</data>
    </edge>
    <edge source="Let-Go-Waiting Principle" target="Record Semaphore">
      <data key="d6">1.0</data>
      <data key="d7">Record semaphore adheres to the let-go-waiting principle by blocking processes instead of busy-waiting.</data>
      <data key="d8">avoidance of busy waiting,design compliance</data>
      <data key="d9">chunk-5f130d8e8cad5fdb4c75e49961444322</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793445</data>
    </edge>
    <edge source="Record Semaphore" target="Value Variable">
      <data key="d6">1.0</data>
      <data key="d7">The record semaphore maintains a value variable to track available resource quantity.</data>
      <data key="d8">data structure,resource count</data>
      <data key="d9">chunk-5f130d8e8cad5fdb4c75e49961444322</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793445</data>
    </edge>
    <edge source="Record Semaphore" target="Process List">
      <data key="d6">1.0</data>
      <data key="d7">The record semaphore maintains a process list to manage waiting processes.</data>
      <data key="d8">data structure,waiting queue</data>
      <data key="d9">chunk-5f130d8e8cad5fdb4c75e49961444322</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793446</data>
    </edge>
    <edge source="Record Semaphore" target="Block Primitive">
      <data key="d6">1.0</data>
      <data key="d7">When a process cannot acquire a resource in record semaphore, it uses the block primitive to suspend itself.</data>
      <data key="d8">process management,suspension</data>
      <data key="d9">chunk-5f130d8e8cad5fdb4c75e49961444322</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793446</data>
    </edge>
    <edge source="Record Semaphore" target="Wakeup Primitive">
      <data key="d6">1.0</data>
      <data key="d7">When a resource is released in record semaphore, the wakeup primitive resumes the first waiting process.</data>
      <data key="d8">process management,resumption</data>
      <data key="d9">chunk-5f130d8e8cad5fdb4c75e49961444322</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793447</data>
    </edge>
    <edge source="Mutual Exclusion" target="Critical Section">
      <data key="d6">1.0</data>
      <data key="d7">Mutual exclusion is implemented by ensuring only one process can enter the critical section at a time.</data>
      <data key="d8">access control,synchronization goal</data>
      <data key="d9">chunk-5f130d8e8cad5fdb4c75e49961444322</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793445</data>
    </edge>
    <edge source="Mutual Exclusion" target="Resource Allocation">
      <data key="d6">1.0</data>
      <data key="d7">Resource allocation ensures mutual exclusion by managing access to shared resources.</data>
      <data key="d8">concurrent access control,resource management</data>
      <data key="d9">chunk-5f130d8e8cad5fdb4c75e49961444322</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793448</data>
    </edge>
    <edge source="Synchronization" target="Precedence Relationship">
      <data key="d6">1.0</data>
      <data key="d7">Precedence relationships are implemented using synchronization mechanisms to ensure proper sequence.</data>
      <data key="d8">execution ordering,logical dependency</data>
      <data key="d9">chunk-5f130d8e8cad5fdb4c75e49961444322</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793447</data>
    </edge>
    <edge source="Resource Allocation" target="Process">
      <data key="d6">1.0</data>
      <data key="d7">A process is the smallest unit for resource allocation and scheduling in an operating system.</data>
      <data key="d8">scheduling,unit of allocation</data>
      <data key="d9">chunk-fd195ae7c40727c5b83fa7b77d72095e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794214</data>
    </edge>
    <edge source="FCFS Scheduling Algorithm" target="Ready Queue">
      <data key="d6">2.0</data>
      <data key="d7">The FCFS Scheduling Algorithm organizes the ready queue in a first-come-first-served order for process execution.&lt;SEP&gt;FCFS scheduling algorithm selects the process that has been in the ready queue the longest.</data>
      <data key="d8">first-in-first-out,order-based scheduling,process scheduling,queue selection</data>
      <data key="d9">chunk-361e96af48cd5d95ba6650e6d3810455&lt;SEP&gt;chunk-1b524b2458aae3cb2440c44f7981f746</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793476</data>
    </edge>
    <edge source="FCFS Scheduling Algorithm" target="Backlog Job Queue">
      <data key="d6">1.0</data>
      <data key="d7">FCFS scheduling algorithm selects the job that has been in the backlog job queue the longest.</data>
      <data key="d8">job scheduling,queue selection</data>
      <data key="d9">chunk-1b524b2458aae3cb2440c44f7981f746</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793476</data>
    </edge>
    <edge source="FCFS Scheduling Algorithm" target="CPU">
      <data key="d6">1.0</data>
      <data key="d7">FCFS assigns the CPU to a process until it completes or blocks, without interruption.</data>
      <data key="d8">non-preemptive,resource allocation</data>
      <data key="d9">chunk-1b524b2458aae3cb2440c44f7981f746</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793477</data>
    </edge>
    <edge source="Round Robin Scheduling Algorithm" target="Time Quantum">
      <data key="d6">1.0</data>
      <data key="d7">The Round Robin Scheduling Algorithm uses a fixed time quantum to control how long each process runs before being preempted.</data>
      <data key="d8">scheduling cycle,time management</data>
      <data key="d9">chunk-361e96af48cd5d95ba6650e6d3810455</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793474</data>
    </edge>
    <edge source="Round Robin Scheduling Algorithm" target="Ready Queue">
      <data key="d6">2.0</data>
      <data key="d7">The Round Robin algorithm manages processes in the ready queue using a cyclic order, with each process executing for one time slice.&lt;SEP&gt;RR schedules processes from the ready queue in a cyclic manner using a fixed time quantum.</data>
      <data key="d8">process scheduling,queue processing,time quantum</data>
      <data key="d9">chunk-361e96af48cd5d95ba6650e6d3810455&lt;SEP&gt;chunk-1b524b2458aae3cb2440c44f7981f746</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793475</data>
    </edge>
    <edge source="Round Robin Scheduling Algorithm" target="Preemption">
      <data key="d6">1.0</data>
      <data key="d7">The Round Robin Scheduling Algorithm uses preemption to ensure each process gets a fair share of CPU time by interrupting execution after a time quantum expires.</data>
      <data key="d8">scheduling mechanism,time-based switching</data>
      <data key="d9">chunk-361e96af48cd5d95ba6650e6d3810455</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793475</data>
    </edge>
    <edge source="Round Robin Scheduling Algorithm" target="CPU">
      <data key="d6">1.0</data>
      <data key="d7">RR assigns the CPU to a process for one time quantum before moving to the next in the ready queue.</data>
      <data key="d8">resource allocation,time-sharing</data>
      <data key="d9">chunk-1b524b2458aae3cb2440c44f7981f746</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793479</data>
    </edge>
    <edge source="Time Quantum" target="Multilevel Feedback Queue Scheduling Algorithm">
      <data key="d6">1.0</data>
      <data key="d7">The algorithm assigns smaller time quanta to higher-priority queues to improve responsiveness.</data>
      <data key="d8">dynamic time allocation,performance optimization</data>
      <data key="d9">chunk-361e96af48cd5d95ba6650e6d3810455</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793475</data>
    </edge>
    <edge source="Time Quantum" target="System Performance">
      <data key="d6">1.0</data>
      <data key="d7">The size of the time quantum directly affects system performance; too small increases overhead, too large undermines responsiveness.</data>
      <data key="d8">algorithm impact,efficiency factor</data>
      <data key="d9">chunk-361e96af48cd5d95ba6650e6d3810455</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793476</data>
    </edge>
    <edge source="Multilevel Queue Scheduling Algorithm" target="Ready Queue">
      <data key="d6">1.0</data>
      <data key="d7">The Multilevel Queue Scheduling Algorithm uses multiple independent ready queues to categorize processes by type or priority.</data>
      <data key="d8">classification,queue segmentation</data>
      <data key="d9">chunk-361e96af48cd5d95ba6650e6d3810455</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793475</data>
    </edge>
    <edge source="Multilevel Feedback Queue Scheduling Algorithm" target="Priority">
      <data key="d6">1.0</data>
      <data key="d7">The Multilevel Feedback Queue Scheduling Algorithm dynamically adjusts process priorities based on execution behavior.</data>
      <data key="d8">dynamic adjustment,scheduling parameter</data>
      <data key="d9">chunk-361e96af48cd5d95ba6650e6d3810455</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793474</data>
    </edge>
    <edge source="Multilevel Feedback Queue Scheduling Algorithm" target="Preemption">
      <data key="d6">1.0</data>
      <data key="d7">The Multilevel Feedback Queue Scheduling Algorithm employs preemption when a higher-priority process arrives, moving the current process back to the queue of its original level.</data>
      <data key="d8">dynamic scheduling,priority-based switching</data>
      <data key="d9">chunk-361e96af48cd5d95ba6650e6d3810455</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793476</data>
    </edge>
    <edge source="Fairness" target="Guaranteed Scheduling Algorithm">
      <data key="d6">1.0</data>
      <data key="d7">The Guaranteed Scheduling Algorithm ensures fairness by providing each user with a fixed share of CPU time, typically 1/n for n users.</data>
      <data key="d8">resource allocation,user equity</data>
      <data key="d9">chunk-361e96af48cd5d95ba6650e6d3810455</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793474</data>
    </edge>
    <edge source="Fairness" target="Fair Share Scheduling Algorithm">
      <data key="d6">1.0</data>
      <data key="d7">The Fair Share Scheduling Algorithm ensures that each user receives a fair share of CPU time, promoting equitable resource usage.</data>
      <data key="d8">equitable distribution,user access</data>
      <data key="d9">chunk-361e96af48cd5d95ba6650e6d3810455</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793474</data>
    </edge>
    <edge source="Ready Queue" target="Shortest Process First Scheduling Algorithm">
      <data key="d6">1.0</data>
      <data key="d7">SPF selects the process with the shortest estimated execution time from the ready queue.</data>
      <data key="d8">process scheduling,shortest execution time</data>
      <data key="d9">chunk-1b524b2458aae3cb2440c44f7981f746</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793476</data>
    </edge>
    <edge source="Ready Queue" target="Priority Scheduling Algorithm">
      <data key="d6">1.0</data>
      <data key="d7">Priority scheduling selects the highest-priority process from the ready queue for execution.</data>
      <data key="d8">priority-based ordering,process scheduling</data>
      <data key="d9">chunk-1b524b2458aae3cb2440c44f7981f746</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793477</data>
    </edge>
    <edge source="Ready Queue" target="CPU Scheduling">
      <data key="d6">1.0</data>
      <data key="d7">CPU scheduling selects a process from the ready queue based on specific algorithms to assign the CPU.</data>
      <data key="d8">resource management,scheduling algorithm</data>
      <data key="d9">chunk-c39617d7522bbe85482a3d992382cd4b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793785</data>
    </edge>
    <edge source="Ready Queue" target="Low-Level Scheduling">
      <data key="d6">1.0</data>
      <data key="d7">Low-level scheduling selects a process from the ready queue and allocates the CPU.</data>
      <data key="d8">process selection,resource assignment</data>
      <data key="d9">chunk-c39617d7522bbe85482a3d992382cd4b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793786</data>
    </edge>
    <edge source="Ready Queue" target="Idle Process">
      <data key="d6">1.0</data>
      <data key="d7">The Idle Process runs when the Ready Queue is empty and immediately yields to any process that becomes ready.</data>
      <data key="d8">contingency process</data>
      <data key="d9">chunk-491042f5eab097ef962a4657a4b61650</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794032</data>
    </edge>
    <edge source="Ready Queue" target="Dispatcher">
      <data key="d6">1.0</data>
      <data key="d7">The Dispatcher retrieves the next process to run from the Ready Queue based on the scheduling decision.</data>
      <data key="d8">process retrieval</data>
      <data key="d9">chunk-491042f5eab097ef962a4657a4b61650</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794033</data>
    </edge>
    <edge source="Ready Queue" target="Interrupt">
      <data key="d6">1.0</data>
      <data key="d7">An I/O interrupt changes a blocked process to a ready state, potentially triggering a new scheduling decision.</data>
      <data key="d8">process state change</data>
      <data key="d9">chunk-491042f5eab097ef962a4657a4b61650</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794034</data>
    </edge>
    <edge source="Ready Queue" target="Waiting Time">
      <data key="d6">1.0</data>
      <data key="d7">Waiting time is accumulated while a process resides in the ready queue.</data>
      <data key="d8">process state,queue duration</data>
      <data key="d9">chunk-76ab4199a2aae3d8b4b3b6c270c34a12</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794301</data>
    </edge>
    <edge source="CPU" target="Interrupt">
      <data key="d6">1.0</data>
      <data key="d7">An interrupt is generated to trigger the CPU to invoke the scheduler, enabling context switching and process management.</data>
      <data key="d8">signal handling,system control</data>
      <data key="d9">chunk-361e96af48cd5d95ba6650e6d3810455</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793474</data>
    </edge>
    <edge source="CPU" target="Process Execution">
      <data key="d6">1.0</data>
      <data key="d7">Process execution is the active use of the CPU by a running process to carry out instructions.</data>
      <data key="d8">central execution unit,resource utilization</data>
      <data key="d9">chunk-361e96af48cd5d95ba6650e6d3810455</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793475</data>
    </edge>
    <edge source="CPU" target="Shortest Process First Scheduling Algorithm">
      <data key="d6">1.0</data>
      <data key="d7">SPF can be preemptive; if a new process has a shorter remaining time, it can take over CPU from the current process.</data>
      <data key="d8">preemptive possibility,resource allocation</data>
      <data key="d9">chunk-1b524b2458aae3cb2440c44f7981f746</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793477</data>
    </edge>
    <edge source="CPU" target="Priority Scheduling Algorithm">
      <data key="d6">1.0</data>
      <data key="d7">The CPU is allocated to the highest-priority process based on the scheduling policy.</data>
      <data key="d8">priority-based,resource allocation</data>
      <data key="d9">chunk-1b524b2458aae3cb2440c44f7981f746</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793478</data>
    </edge>
    <edge source="CPU" target="Running State">
      <data key="d6">1.0</data>
      <data key="d7">The CPU is required for a process to enter the Running State; its availability determines process execution.</data>
      <data key="d8">execution resource,state eligibility</data>
      <data key="d9">chunk-156e9bc4a555d2a7cb0d3724273d5ea6</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793615</data>
    </edge>
    <edge source="CPU" target="Thread">
      <data key="d6">1.0</data>
      <data key="d7">A thread is the smallest unit scheduled by the CPU for execution, enabling fine-grained concurrency.</data>
      <data key="d8">execution,scheduling unit</data>
      <data key="d9">chunk-e2c5907dce4f167e0b11853c616e448f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793931</data>
    </edge>
    <edge source="CPU" target="Process">
      <data key="d6">1.0</data>
      <data key="d7">The CPU executes processes according to the scheduling decisions made by the Scheduler.</data>
      <data key="d8">execution,resource allocation</data>
      <data key="d9">chunk-491042f5eab097ef962a4657a4b61650</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794035</data>
    </edge>
    <edge source="Interrupt" target="Blocked State">
      <data key="d6">1.0</data>
      <data key="d7">An interrupt, such as from I/O completion, signals the system to transition a process from Blocked State to Ready State.</data>
      <data key="d8">event-driven signal,state transition</data>
      <data key="d9">chunk-156e9bc4a555d2a7cb0d3724273d5ea6</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793616</data>
    </edge>
    <edge source="Interrupt" target="I/O Device">
      <data key="d6">1.0</data>
      <data key="d7">An I/O device generates an interrupt when it becomes ready, signaling the system to re-evaluate process scheduling.</data>
      <data key="d8">event trigger</data>
      <data key="d9">chunk-491042f5eab097ef962a4657a4b61650</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794034</data>
    </edge>
    <edge source="Process" target="Ready State">
      <data key="d6">1.0</data>
      <data key="d7">A process transitions into the ready state after being loaded into memory and is ready to execute.</data>
      <data key="d8">execution readiness,state transition</data>
      <data key="d9">chunk-c39617d7522bbe85482a3d992382cd4b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793785</data>
    </edge>
    <edge source="Process" target="Suspended State">
      <data key="d6">1.0</data>
      <data key="d7">A process may be moved to the suspended state to conserve memory and system resources.</data>
      <data key="d8">state transition,temporary offload</data>
      <data key="d9">chunk-c39617d7522bbe85482a3d992382cd4b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793786</data>
    </edge>
    <edge source="Process" target="High-Level Scheduling">
      <data key="d6">1.0</data>
      <data key="d7">High-level scheduling initiates the creation of a process by assigning resources and loading a job into memory.</data>
      <data key="d8">creation,process development</data>
      <data key="d9">chunk-c39617d7522bbe85482a3d992382cd4b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793787</data>
    </edge>
    <edge source="Process" target="Process Execution">
      <data key="d6">1.0</data>
      <data key="d7">Process execution encompasses all phases a process undergoes from creation to termination.</data>
      <data key="d8">execution lifecycle,operational state</data>
      <data key="d9">chunk-c39617d7522bbe85482a3d992382cd4b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793788</data>
    </edge>
    <edge source="Process" target="System Throughput">
      <data key="d6">1.0</data>
      <data key="d7">System throughput depends on how efficiently processes are scheduled and executed.</data>
      <data key="d8">execution efficiency,performance metric</data>
      <data key="d9">chunk-c39617d7522bbe85482a3d992382cd4b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793788</data>
    </edge>
    <edge source="Process" target="Medium-Level Scheduling">
      <data key="d6">1.0</data>
      <data key="d7">Medium-level scheduling manages the state of processes by suspending them when inactive and resuming them when memory becomes available.</data>
      <data key="d8">memory control,state management</data>
      <data key="d9">chunk-c39617d7522bbe85482a3d992382cd4b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793789</data>
    </edge>
    <edge source="Process" target="Low-Level Scheduling">
      <data key="d6">1.0</data>
      <data key="d7">Low-level scheduling selects a process to run and assigns the CPU to it, transitioning the process to the running state.</data>
      <data key="d8">CPU assignment,execution initiation</data>
      <data key="d9">chunk-c39617d7522bbe85482a3d992382cd4b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793789</data>
    </edge>
    <edge source="Process" target="kill Function">
      <data key="d6">1.0</data>
      <data key="d7">A process can initiate a signal to another process by invoking the kill function.</data>
      <data key="d8">inter-process communication,signal initiation</data>
      <data key="d9">chunk-c214e070db9e1fbcd76d28e9e144db30</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793868</data>
    </edge>
    <edge source="Process" target="Pending Signal">
      <data key="d6">1.0</data>
      <data key="d7">When a process is switched to user mode, it checks for pending, unblocked signals and processes them immediately.</data>
      <data key="d8">immediate processing,signal reception</data>
      <data key="d9">chunk-c214e070db9e1fbcd76d28e9e144db30</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793869</data>
    </edge>
    <edge source="Process" target="Kernel">
      <data key="d6">1.0</data>
      <data key="d7">The kernel is responsible for delivering signals to processes and operates in kernel mode during this task.</data>
      <data key="d8">privilege execution,signal delivery</data>
      <data key="d9">chunk-c214e070db9e1fbcd76d28e9e144db30</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793869</data>
    </edge>
    <edge source="Process" target="Default Signal Handler">
      <data key="d6">1.0</data>
      <data key="d7">A process executes the default signal handler when no custom handler is defined for a signal.</data>
      <data key="d8">signal response,system default</data>
      <data key="d9">chunk-c214e070db9e1fbcd76d28e9e144db30</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793869</data>
    </edge>
    <edge source="Process" target="Custom Signal Handler">
      <data key="d6">1.0</data>
      <data key="d7">A process can define a custom signal handler to specify its own response to a signal.</data>
      <data key="d8">signal response,user-defined behavior</data>
      <data key="d9">chunk-c214e070db9e1fbcd76d28e9e144db30</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793869</data>
    </edge>
    <edge source="Process" target="Signal Processing">
      <data key="d6">1.0</data>
      <data key="d7">After signal processing is completed, the process resumes execution from the next instruction.</data>
      <data key="d8">execution flow,post-handling continuation</data>
      <data key="d9">chunk-c214e070db9e1fbcd76d28e9e144db30</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793870</data>
    </edge>
    <edge source="Process" target="Thread">
      <data key="d6">1.0</data>
      <data key="d7">A thread is an execution unit within a process and shares the process's address space and resources.</data>
      <data key="d8">containment,execution unit</data>
      <data key="d9">chunk-e2c5907dce4f167e0b11853c616e448f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793931</data>
    </edge>
    <edge source="Process" target="Process Control Block">
      <data key="d6">3.0</data>
      <data key="d7">The Process Control Block maintains control and status information for a process, including resource allocation.&lt;SEP&gt;The Process Control Block is the central component of a process, serving as the sole identifier of its existence in the operating system.&lt;SEP&gt;The operating system uses the Process Control Block (PCB) to describe and manage the state and attributes of a process.</data>
      <data key="d8">core management structure,data structure,process identity,process management,state tracking</data>
      <data key="d9">chunk-e2c5907dce4f167e0b11853c616e448f&lt;SEP&gt;chunk-2da376f0975743dcb0cc169c929cbe5c&lt;SEP&gt;chunk-fd195ae7c40727c5b83fa7b77d72095e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794213</data>
    </edge>
    <edge source="Process" target="System Resource">
      <data key="d6">1.0</data>
      <data key="d7">A process owns system resources and manages their allocation and deallocation.</data>
      <data key="d8">allocation,resource ownership</data>
      <data key="d9">chunk-e2c5907dce4f167e0b11853c616e448f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793932</data>
    </edge>
    <edge source="Process" target="Scheduler">
      <data key="d6">2.0</data>
      <data key="d7">The Scheduler is responsible for managing processes by selecting them for CPU execution based on scheduling algorithms.&lt;SEP&gt;The Scheduler manages and controls the execution of processes by determining which process runs on the CPU next.</data>
      <data key="d8">execution control,process management,resource allocation,task dispatch</data>
      <data key="d9">chunk-491042f5eab097ef962a4657a4b61650</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794035</data>
    </edge>
    <edge source="Process" target="Wakeup">
      <data key="d6">1.0</data>
      <data key="d7">The Wakeup method is used to transition a process from a blocking state back to an active state.</data>
      <data key="d8">process control,state transition</data>
      <data key="d9">chunk-62e7a5a2dcc4d8e5b08d9447994638c2</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794049</data>
    </edge>
    <edge source="Process" target="Blocking State">
      <data key="d6">1.0</data>
      <data key="d7">A process may enter a blocking state when it is unable to continue execution until it is woken up.</data>
      <data key="d8">execution suspension,process state</data>
      <data key="d9">chunk-62e7a5a2dcc4d8e5b08d9447994638c2</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794050</data>
    </edge>
    <edge source="Process" target="Block">
      <data key="d6">1.0</data>
      <data key="d7">The Block method is used by a process to transition into a blocking state.</data>
      <data key="d8">process control,state transition</data>
      <data key="d9">chunk-62e7a5a2dcc4d8e5b08d9447994638c2</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794050</data>
    </edge>
    <edge source="Process" target="Program Segment">
      <data key="d6">1.0</data>
      <data key="d7">The program segment is the executable code portion of a process that runs on the CPU.</data>
      <data key="d8">code processing,execution component</data>
      <data key="d9">chunk-2da376f0975743dcb0cc169c929cbe5c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794162</data>
    </edge>
    <edge source="Process" target="Data Segment">
      <data key="d6">1.0</data>
      <data key="d7">The data segment contains the data that the process operates on, including inputs, outputs, and intermediate results.</data>
      <data key="d8">computation input/output,data handling</data>
      <data key="d9">chunk-2da376f0975743dcb0cc169c929cbe5c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794162</data>
    </edge>
    <edge source="Process" target="Multi-Program Environment">
      <data key="d6">1.0</data>
      <data key="d7">Processes are introduced as a concept to manage the execution of programs in a multi-program environment.</data>
      <data key="d8">execution model,operational context</data>
      <data key="d9">chunk-fd195ae7c40727c5b83fa7b77d72095e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794213</data>
    </edge>
    <edge source="Process" target="Concurrency">
      <data key="d6">1.0</data>
      <data key="d7">The concept of a process enables concurrency, allowing multiple processes to run simultaneously in memory.</data>
      <data key="d8">execution characteristic,system feature</data>
      <data key="d9">chunk-fd195ae7c40727c5b83fa7b77d72095e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794213</data>
    </edge>
    <edge source="Process" target="Time Slice">
      <data key="d6">1.0</data>
      <data key="d7">Time slices are allocated to processes, making them the fundamental unit of CPU time distribution.</data>
      <data key="d8">CPU management,execution unit</data>
      <data key="d9">chunk-fd195ae7c40727c5b83fa7b77d72095e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794214</data>
    </edge>
    <edge source="Process" target="Process Entity">
      <data key="d6">1.0</data>
      <data key="d7">A process entity is composed of a program segment, related data, and a PCB, representing the complete picture of a running process.</data>
      <data key="d8">composition,execution representation</data>
      <data key="d9">chunk-fd195ae7c40727c5b83fa7b77d72095e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794215</data>
    </edge>
    <edge source="Process" target="Program">
      <data key="d6">1.0</data>
      <data key="d7">A process is an instance of a program in execution, while a program is a static entity.</data>
      <data key="d8">execution vs. static code</data>
      <data key="d9">chunk-fd195ae7c40727c5b83fa7b77d72095e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794215</data>
    </edge>
    <edge source="Process" target="Dynamic Nature">
      <data key="d6">1.0</data>
      <data key="d7">The dynamic nature is the most fundamental characteristic of a process, defining its creation, execution, and termination.</data>
      <data key="d8">core characteristic,lifecycle</data>
      <data key="d9">chunk-fd195ae7c40727c5b83fa7b77d72095e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794216</data>
    </edge>
    <edge source="Process" target="Independent Execution">
      <data key="d6">1.0</data>
      <data key="d7">A process is a unit capable of independent execution, obtaining resources and being scheduled without dependence on other processes.</data>
      <data key="d8">execution autonomy,resource access</data>
      <data key="d9">chunk-fd195ae7c40727c5b83fa7b77d72095e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794216</data>
    </edge>
    <edge source="Process" target="Asynchrony">
      <data key="d6">1.0</data>
      <data key="d7">Processes proceed at unpredictable speeds due to mutual dependence, causing asynchrony and requiring synchronization mechanisms.</data>
      <data key="d8">behavioral trait,coordination challenge</data>
      <data key="d9">chunk-fd195ae7c40727c5b83fa7b77d72095e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794216</data>
    </edge>
    <edge source="Process" target="Process Lifecycle">
      <data key="d6">1.0</data>
      <data key="d7">The process lifecycle defines the dynamic states and transitions a process undergoes during its existence.</data>
      <data key="d8">execution phases,state transitions</data>
      <data key="d9">chunk-fd195ae7c40727c5b83fa7b77d72095e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794216</data>
    </edge>
    <edge source="Process" target="Mutual Dependence">
      <data key="d6">1.0</data>
      <data key="d7">Mutual dependence among processes is a key factor contributing to asynchrony in concurrent execution.</data>
      <data key="d8">asynchrony origin,interaction cause</data>
      <data key="d9">chunk-fd195ae7c40727c5b83fa7b77d72095e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794217</data>
    </edge>
    <edge source="Priority" target="System Performance">
      <data key="d6">1.0</data>
      <data key="d7">System performance is influenced by how effectively priority levels are managed across multiple queues.</data>
      <data key="d8">responsiveness,scheduling trade-off</data>
      <data key="d9">chunk-361e96af48cd5d95ba6650e6d3810455</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793476</data>
    </edge>
    <edge source="Time Slice" target="Ready State">
      <data key="d6">1.0</data>
      <data key="d7">The expiration of a time slice forces a Running State process to return to Ready State for rescheduling.</data>
      <data key="d8">scheduling interval,state management</data>
      <data key="d9">chunk-156e9bc4a555d2a7cb0d3724273d5ea6</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793615</data>
    </edge>
    <edge source="Process Execution" target="Ready State">
      <data key="d6">1.0</data>
      <data key="d7">The ready state is a key phase in process execution, indicating that a process is prepared to be scheduled for CPU time.</data>
      <data key="d8">execution readiness,lifecycle phase</data>
      <data key="d9">chunk-c39617d7522bbe85482a3d992382cd4b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793788</data>
    </edge>
    <edge source="Shortest Job First Scheduling Algorithm" target="Backlog Job Queue">
      <data key="d6">1.0</data>
      <data key="d7">SJF selects the job with the shortest estimated execution time from the backlog job queue.</data>
      <data key="d8">job scheduling,shortest execution time</data>
      <data key="d9">chunk-1b524b2458aae3cb2440c44f7981f746</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793477</data>
    </edge>
    <edge source="Shortest Process First Scheduling Algorithm" target="Preemptive Shortest Process First">
      <data key="d6">1.0</data>
      <data key="d7">Preemptive Shortest Process First is a variant of the Shortest Process First Scheduling Algorithm that allows preemption based on remaining execution time.</data>
      <data key="d8">algorithm variant,preemptive behavior</data>
      <data key="d9">chunk-1b524b2458aae3cb2440c44f7981f746</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793478</data>
    </edge>
    <edge source="Highest Response Ratio First Scheduling Algorithm" target="Backlog Job Queue">
      <data key="d6">1.0</data>
      <data key="d7">HRRF calculates the response ratio for each job in the backlog queue and selects the one with the highest ratio.</data>
      <data key="d8">job scheduling,response ratio calculation</data>
      <data key="d9">chunk-1b524b2458aae3cb2440c44f7981f746</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793477</data>
    </edge>
    <edge source="Waiting Time" target="Response Ratio">
      <data key="d6">1.0</data>
      <data key="d7">Response Ratio is calculated using Waiting Time and Required Service Time.</data>
      <data key="d8">metric composition</data>
      <data key="d9">chunk-1b524b2458aae3cb2440c44f7981f746</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793477</data>
    </edge>
    <edge source="Waiting Time" target="Turnaround Time">
      <data key="d6">1.0</data>
      <data key="d7">Turnaround time includes waiting time as one of its contributing components.</data>
      <data key="d8">component relationship,time accumulation</data>
      <data key="d9">chunk-76ab4199a2aae3d8b4b3b6c270c34a12</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794300</data>
    </edge>
    <edge source="Waiting Time" target="CPU Scheduling Algorithm">
      <data key="d6">1.0</data>
      <data key="d7">The scheduling algorithm affects how long processes remain in the ready queue, thereby influencing waiting time.</data>
      <data key="d8">process delay,queue management</data>
      <data key="d9">chunk-76ab4199a2aae3d8b4b3b6c270c34a12</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794302</data>
    </edge>
    <edge source="Execution Time" target="Response Ratio">
      <data key="d6">1.0</data>
      <data key="d7">Response Ratio includes the Required Service Time, which is synonymous with estimated execution time.</data>
      <data key="d8">metric composition</data>
      <data key="d9">chunk-1b524b2458aae3cb2440c44f7981f746</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793478</data>
    </edge>
    <edge source="Preemptive Scheduling" target="Non-Preemptive Scheduling">
      <data key="d6">1.0</data>
      <data key="d7">Non-Preemptive and Preemptive Scheduling are two contrasting models of process management, differing in how CPU allocation is handled during execution.</data>
      <data key="d8">scheduling model</data>
      <data key="d9">chunk-491042f5eab097ef962a4657a4b61650</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794032</data>
    </edge>
    <edge source="Preemptive Scheduling" target="Time Slice Principle">
      <data key="d6">1.0</data>
      <data key="d7">The Time Slice Principle is a fundamental mechanism enabling Preemptive Scheduling through periodic time quanta.</data>
      <data key="d8">scheduling mechanism</data>
      <data key="d9">chunk-491042f5eab097ef962a4657a4b61650</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794033</data>
    </edge>
    <edge source="Static Priority" target="Dynamic Priority">
      <data key="d6">1.0</data>
      <data key="d7">Static and dynamic priorities are two ways to assign process priorities in scheduling algorithms.</data>
      <data key="d8">priority type,scheduling method</data>
      <data key="d9">chunk-1b524b2458aae3cb2440c44f7981f746</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793477</data>
    </edge>
    <edge source="System Process" target="User Process">
      <data key="d6">1.0</data>
      <data key="d7">System processes are typically assigned higher priority than user processes.</data>
      <data key="d8">priority comparison,scheduling priority</data>
      <data key="d9">chunk-1b524b2458aae3cb2440c44f7981f746</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793478</data>
    </edge>
    <edge source="Interactive Process" target="Non-Interactive Process">
      <data key="d6">1.0</data>
      <data key="d7">Interactive processes are generally given higher priority than non-interactive ones.</data>
      <data key="d8">priority classification,system behavior</data>
      <data key="d9">chunk-1b524b2458aae3cb2440c44f7981f746</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793478</data>
    </edge>
    <edge source="I/O-Bound Process" target="CPU-Bound Process">
      <data key="d6">1.0</data>
      <data key="d7">I/O-bound processes rely more on input/output operations, while CPU-bound processes rely on computational power.</data>
      <data key="d8">process type,resource focus</data>
      <data key="d9">chunk-1b524b2458aae3cb2440c44f7981f746</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793478</data>
    </edge>
    <edge source="管程" target="信号量机制">
      <data key="d6">1.0</data>
      <data key="d7">管程是信号量机制中PV操作分散问题的替代方案，提供更集中化的同步管理。</data>
      <data key="d8">solution,synchronization alternative</data>
      <data key="d9">chunk-77d7b8e6f06999efb089a2a4176d1434</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793539</data>
    </edge>
    <edge source="管程" target="共享数据结构">
      <data key="d6">1.0</data>
      <data key="d7">管程包含共享数据结构，用于抽象表示系统中的共享资源。</data>
      <data key="d8">abstraction,containment</data>
      <data key="d9">chunk-77d7b8e6f06999efb089a2a4176d1434</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793539</data>
    </edge>
    <edge source="管程" target="进程互斥">
      <data key="d6">1.0</data>
      <data key="d7">管程通过一次仅允许一个进程进入，确保进程互斥。</data>
      <data key="d8">enforcement,guarantee</data>
      <data key="d9">chunk-77d7b8e6f06999efb089a2a4176d1434</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793539</data>
    </edge>
    <edge source="管程" target="共享资源">
      <data key="d6">1.0</data>
      <data key="d7">管程封装共享资源，仅允许内部过程访问，实现资源的受控访问。</data>
      <data key="d8">access control,encapsulation</data>
      <data key="d9">chunk-77d7b8e6f06999efb089a2a4176d1434</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793540</data>
    </edge>
    <edge source="管程" target="PV操作">
      <data key="d6">1.0</data>
      <data key="d7">管程作为PV操作的替代机制，解决其分散和易出错的问题。</data>
      <data key="d8">alternative,replacement</data>
      <data key="d9">chunk-77d7b8e6f06999efb089a2a4176d1434</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793540</data>
    </edge>
    <edge source="管程" target="初始值语句">
      <data key="d6">1.0</data>
      <data key="d7">初始值语句用于对管程内部的共享数据结构设置初始状态。</data>
      <data key="d8">initialization,setup</data>
      <data key="d9">chunk-77d7b8e6f06999efb089a2a4176d1434</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793540</data>
    </edge>
    <edge source="管程" target="条件变量">
      <data key="d6">1.0</data>
      <data key="d7">条件变量是管程的组成部分，用于支持进程的条件等待与唤醒。</data>
      <data key="d8">component,integration</data>
      <data key="d9">chunk-77d7b8e6f06999efb089a2a4176d1434</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793541</data>
    </edge>
    <edge source="临界资源" target="临界区">
      <data key="d6">1.0</data>
      <data key="d7">Processes access临界资源through the临界区section of their code.</data>
      <data key="d8">access relationship,resource usage</data>
      <data key="d9">chunk-96612cb99be5ccc8684e38f3d50f77f5</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793748</data>
    </edge>
    <edge source="临界资源" target="互斥">
      <data key="d6">1.0</data>
      <data key="d7">互斥is the mechanism used to protect临界资源by ensuring only one process can access it at a time.</data>
      <data key="d8">access control mechanism,exclusive use</data>
      <data key="d9">chunk-96612cb99be5ccc8684e38f3d50f77f5</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793748</data>
    </edge>
    <edge source="条件变量" target="等待队列">
      <data key="d6">1.0</data>
      <data key="d7">条件变量包含一个等待队列，用于保存因该条件而阻塞的进程。</data>
      <data key="d8">containment,management</data>
      <data key="d9">chunk-77d7b8e6f06999efb089a2a4176d1434</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793539</data>
    </edge>
    <edge source="条件变量" target="x.wait">
      <data key="d6">1.0</data>
      <data key="d7">x.wait是作用于条件变量的操作，用于在条件不满足时阻塞进程。</data>
      <data key="d8">control,operation</data>
      <data key="d9">chunk-77d7b8e6f06999efb089a2a4176d1434</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793539</data>
    </edge>
    <edge source="条件变量" target="x.signal">
      <data key="d6">1.0</data>
      <data key="d7">x.signal是作用于条件变量的操作，用于唤醒一个因该条件阻塞的进程。</data>
      <data key="d8">control,operation</data>
      <data key="d9">chunk-77d7b8e6f06999efb089a2a4176d1434</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793540</data>
    </edge>
    <edge source="等待队列" target="阻塞原语">
      <data key="d6">1.0</data>
      <data key="d7">阻塞原语将进程的PCB插入对应事件的等待队列。</data>
      <data key="d8">event waiting,process state change</data>
      <data key="d9">chunk-7ca51faf7f3faf56c56ab18dd6458c7e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794049</data>
    </edge>
    <edge source="等待队列" target="唤醒原语">
      <data key="d6">1.0</data>
      <data key="d7">唤醒原语从等待队列中移出进程并恢复其运行能力。</data>
      <data key="d8">event completion,process resumption</data>
      <data key="d9">chunk-7ca51faf7f3faf56c56ab18dd6458c7e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794049</data>
    </edge>
    <edge source="临界区互斥" target="软件实现方法">
      <data key="d6">1.0</data>
      <data key="d7">软件实现方法is used to achieve critical section mutual exclusion through software logic.</data>
      <data key="d8">concurrency control,implementation method</data>
      <data key="d9">chunk-d9ae7922752a96dfde647be32905f641</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793553</data>
    </edge>
    <edge source="临界区互斥" target="中断屏蔽方法">
      <data key="d6">1.0</data>
      <data key="d7">中断屏蔽方法is a direct way to enforce mutual exclusion by disabling interrupts.</data>
      <data key="d8">hardware implementation,process isolation</data>
      <data key="d9">chunk-d9ae7922752a96dfde647be32905f641</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793554</data>
    </edge>
    <edge source="临界区互斥" target="硬件指令方法">
      <data key="d6">1.0</data>
      <data key="d7">硬件指令方法uses atomic hardware instructions to ensure mutual exclusion.</data>
      <data key="d8">atomic operation,hardware support</data>
      <data key="d9">chunk-d9ae7922752a96dfde647be32905f641</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793555</data>
    </edge>
    <edge source="中断屏蔽方法" target="空闲让进">
      <data key="d6">1.0</data>
      <data key="d7">中断屏蔽方法violates the "空闲让进" principle by potentially blocking other processes indefinitely.</data>
      <data key="d8">system limitation,violation of principle</data>
      <data key="d9">chunk-d9ae7922752a96dfde647be32905f641</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793555</data>
    </edge>
    <edge source="硬件指令方法" target="让权等待">
      <data key="d6">1.0</data>
      <data key="d7">硬件指令methods using while loops fail to implement "让权等待" because waiting processes busy-wait.</data>
      <data key="d8">CPU waste,violation of principle</data>
      <data key="d9">chunk-d9ae7922752a96dfde647be32905f641</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793556</data>
    </edge>
    <edge source="算法一" target="turn">
      <data key="d6">1.0</data>
      <data key="d7">算法一uses the 'turn' variable to manage which process enters the critical section.</data>
      <data key="d8">access control,variable usage</data>
      <data key="d9">chunk-d9ae7922752a96dfde647be32905f641</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793553</data>
    </edge>
    <edge source="算法二" target="flag">
      <data key="d6">1.0</data>
      <data key="d7">算法二uses the 'flag' array to indicate processes' intent to access the critical section.</data>
      <data key="d8">intent flag,variable usage</data>
      <data key="d9">chunk-d9ae7922752a96dfde647be32905f641</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793553</data>
    </edge>
    <edge source="双标志先检查法" target="有限等待">
      <data key="d6">1.0</data>
      <data key="d7">双标志先检查法violates the "有限等待" and "空闲让进" principles due to possible simultaneous entry.</data>
      <data key="d8">race condition,violation of principle</data>
      <data key="d9">chunk-d9ae7922752a96dfde647be32905f641</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793554</data>
    </edge>
    <edge source="算法三" target="flag">
      <data key="d6">1.0</data>
      <data key="d7">算法三checks the other process's flag after setting its own, leading to potential deadlock.</data>
      <data key="d8">flag check timing,variable usage</data>
      <data key="d9">chunk-d9ae7922752a96dfde647be32905f641</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793554</data>
    </edge>
    <edge source="双标志后检查法" target="饥饿">
      <data key="d6">1.0</data>
      <data key="d7">双标志后检查法can cause starvation, violating the "饥饿" principle.</data>
      <data key="d8">indefinite blocking,violates fairness</data>
      <data key="d9">chunk-d9ae7922752a96dfde647be32905f641</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793555</data>
    </edge>
    <edge source="Peterson算法" target="flag">
      <data key="d6">1.0</data>
      <data key="d7">Peterson算法combines flag and turn to ensure fairness and mutual exclusion.</data>
      <data key="d8">coordinated use,fairness control</data>
      <data key="d9">chunk-d9ae7922752a96dfde647be32905f641</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793555</data>
    </edge>
    <edge source="Peterson算法" target="turn">
      <data key="d6">1.0</data>
      <data key="d7">Peterson算法uses the 'turn' variable to resolve contention between processes.</data>
      <data key="d8">coordinated use,fairness control</data>
      <data key="d9">chunk-d9ae7922752a96dfde647be32905f641</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793556</data>
    </edge>
    <edge source="Peterson算法" target="饥饿">
      <data key="d6">1.0</data>
      <data key="d7">Peterson算法prevents starvation by ensuring fair access.</data>
      <data key="d8">prevention of starvation</data>
      <data key="d9">chunk-d9ae7922752a96dfde647be32905f641</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793556</data>
    </edge>
    <edge source="TestAndSet指令" target="原子操作">
      <data key="d6">1.0</data>
      <data key="d7">TestAndSet指令is implemented as an atomic operation to ensure mutual exclusion.</data>
      <data key="d8">atomic operation,hardware guarantee</data>
      <data key="d9">chunk-d9ae7922752a96dfde647be32905f641</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793554</data>
    </edge>
    <edge source="Swap指令" target="原子操作">
      <data key="d6">1.0</data>
      <data key="d7">Swap指令is implemented as an atomic operation in hardware to support mutual exclusion.</data>
      <data key="d8">atomic operation,hardware guarantee</data>
      <data key="d9">chunk-d9ae7922752a96dfde647be32905f641</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793554</data>
    </edge>
    <edge source="临界区" target="进入区">
      <data key="d6">1.0</data>
      <data key="d7">The进入区precedes the临界区as part of the protocol to enter the critical section.</data>
      <data key="d8">entry requirement,sequential phase</data>
      <data key="d9">chunk-96612cb99be5ccc8684e38f3d50f77f5</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793750</data>
    </edge>
    <edge source="临界区" target="退出区">
      <data key="d6">1.0</data>
      <data key="d7">The退出区follows the临界区to signal the end of access to the critical resource.</data>
      <data key="d8">exit requirement,sequential phase</data>
      <data key="d9">chunk-96612cb99be5ccc8684e38f3d50f77f5</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793750</data>
    </edge>
    <edge source="空闲让进" target="进入区">
      <data key="d6">1.0</data>
      <data key="d7">The进入区enforces the空闲让进rule by allowing access when the critical section is free.</data>
      <data key="d8">access control,rule enforcement</data>
      <data key="d9">chunk-96612cb99be5ccc8684e38f3d50f77f5</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793748</data>
    </edge>
    <edge source="有限等待" target="进入区">
      <data key="d6">1.0</data>
      <data key="d7">The进入区must ensure the有限等待condition is met by avoiding indefinite waiting.</data>
      <data key="d8">fairness,rule enforcement</data>
      <data key="d9">chunk-96612cb99be5ccc8684e38f3d50f77f5</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793749</data>
    </edge>
    <edge source="有限等待" target="退出区">
      <data key="d6">1.0</data>
      <data key="d7">The退出区contributes to maintaining the有限等待condition by freeing access for waiting processes.</data>
      <data key="d8">fairness enforcement,process continuity</data>
      <data key="d9">chunk-96612cb99be5ccc8684e38f3d50f77f5</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793749</data>
    </edge>
    <edge source="让权等待" target="进入区">
      <data key="d6">1.0</data>
      <data key="d7">The进入区may trigger the让权等待principle by releasing the processor when access is denied.</data>
      <data key="d8">processor release,rule implementation</data>
      <data key="d9">chunk-96612cb99be5ccc8684e38f3d50f77f5</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793749</data>
    </edge>
    <edge source="让权等待" target="退出区">
      <data key="d6">1.0</data>
      <data key="d7">The退出区supports the让权等待principle by allowing other processes to run after a process exits the critical section.</data>
      <data key="d8">efficiency,processor release</data>
      <data key="d9">chunk-96612cb99be5ccc8684e38f3d50f77f5</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793750</data>
    </edge>
    <edge source="饥饿" target="死锁">
      <data key="d6">1.0</data>
      <data key="d7">死锁和饥饿的共同点是进程都因资源问题无法继续执行。</data>
      <data key="d8">common characteristic,process blocking</data>
      <data key="d9">chunk-9aabe855c161e30442ff85ca7a64312e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793967</data>
    </edge>
    <edge source="Running State" target="Ready State">
      <data key="d6">2.0</data>
      <data key="d7">A process in Running State transitions to Ready State when its time slice expires or is preempted by a higher-priority process.&lt;SEP&gt;A process in Ready State transitions to Running State when scheduled by the operating system and allocated a CPU time slice.</data>
      <data key="d8">process scheduling,state transition,time slice expiration</data>
      <data key="d9">chunk-156e9bc4a555d2a7cb0d3724273d5ea6</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793613</data>
    </edge>
    <edge source="Running State" target="Blocked State">
      <data key="d6">1.0</data>
      <data key="d7">A process in Running State transitions to Blocked State when it requests a resource or waits for an I/O operation to complete via a system call.</data>
      <data key="d8">resource request,state transition</data>
      <data key="d9">chunk-156e9bc4a555d2a7cb0d3724273d5ea6</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793613</data>
    </edge>
    <edge source="Running State" target="Terminated State">
      <data key="d6">1.0</data>
      <data key="d7">A process in Running State transitions to Terminated State when it completes execution or is terminated by an external signal.</data>
      <data key="d8">process termination,state transition</data>
      <data key="d9">chunk-156e9bc4a555d2a7cb0d3724273d5ea6</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793614</data>
    </edge>
    <edge source="Running State" target="System Call">
      <data key="d6">1.0</data>
      <data key="d7">A system call, made from user-mode execution, can trigger a transition from Running State to Blocked State.</data>
      <data key="d8">execution mechanism,state change initiation</data>
      <data key="d9">chunk-156e9bc4a555d2a7cb0d3724273d5ea6</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793614</data>
    </edge>
    <edge source="Running State" target="Process Control Block">
      <data key="d6">1.0</data>
      <data key="d7">The Process Control Block contains information that reflects the process's state during execution on the CPU.</data>
      <data key="d8">data structure,execution tracking</data>
      <data key="d9">chunk-156e9bc4a555d2a7cb0d3724273d5ea6</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793615</data>
    </edge>
    <edge source="Running State" target="Thread">
      <data key="d6">1.0</data>
      <data key="d7">A thread is in the running state when it is actively being executed on the CPU.</data>
      <data key="d8">current execution state</data>
      <data key="d9">chunk-e2c5907dce4f167e0b11853c616e448f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793933</data>
    </edge>
    <edge source="Ready State" target="Created State">
      <data key="d6">1.0</data>
      <data key="d7">A process in Created State transitions to Ready State once all required resources are allocated and the process is prepared for execution.</data>
      <data key="d8">initialization completion,state transition</data>
      <data key="d9">chunk-156e9bc4a555d2a7cb0d3724273d5ea6</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793613</data>
    </edge>
    <edge source="Ready State" target="Process Control Block">
      <data key="d6">1.0</data>
      <data key="d7">The Process Control Block stores the current state of a process, including its transition into Ready State.</data>
      <data key="d8">data structure,state tracking</data>
      <data key="d9">chunk-156e9bc4a555d2a7cb0d3724273d5ea6</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793614</data>
    </edge>
    <edge source="Ready State" target="Blocked State">
      <data key="d6">1.0</data>
      <data key="d7">A process in Blocked State transitions to Ready State when the awaited event (e.g., I/O completion) occurs and is signaled by an interrupt.</data>
      <data key="d8">event completion,state transition</data>
      <data key="d9">chunk-156e9bc4a555d2a7cb0d3724273d5ea6</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793614</data>
    </edge>
    <edge source="Ready State" target="Thread">
      <data key="d6">2.0</data>
      <data key="d7">A thread is in the ready state when it is prepared to run but is waiting for CPU allocation.</data>
      <data key="d8">execution readiness,readiness,scheduling,state</data>
      <data key="d9">chunk-e2c5907dce4f167e0b11853c616e448f&lt;SEP&gt;chunk-34425c38108ef3730cc0889df3f8434a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793925</data>
    </edge>
    <edge source="Blocked State" target="Process Control Block">
      <data key="d6">1.0</data>
      <data key="d7">The Process Control Block preserves the state of a process when it enters the Blocked State due to waiting for resources or events.</data>
      <data key="d8">data structure,suspension tracking</data>
      <data key="d9">chunk-156e9bc4a555d2a7cb0d3724273d5ea6</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793615</data>
    </edge>
    <edge source="Blocked State" target="Resource">
      <data key="d6">1.0</data>
      <data key="d7">A process enters Blocked State when it waits for a resource that is currently unavailable.</data>
      <data key="d8">blocking cause,dependency</data>
      <data key="d9">chunk-156e9bc4a555d2a7cb0d3724273d5ea6</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793616</data>
    </edge>
    <edge source="Blocked State" target="I/O Operation">
      <data key="d6">1.0</data>
      <data key="d7">The initiation of an I/O operation causes a process to move from Running State to Blocked State.</data>
      <data key="d8">event trigger,state transition</data>
      <data key="d9">chunk-156e9bc4a555d2a7cb0d3724273d5ea6</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793616</data>
    </edge>
    <edge source="Blocked State" target="Thread">
      <data key="d6">2.0</data>
      <data key="d7">A thread enters the blocked state when it is waiting for an I/O operation or external resource.&lt;SEP&gt;A thread enters the blocked state when it is waiting for an external event or resource, causing it to pause execution.</data>
      <data key="d8">state,suspension,synchronization,waiting state</data>
      <data key="d9">chunk-e2c5907dce4f167e0b11853c616e448f&lt;SEP&gt;chunk-34425c38108ef3730cc0889df3f8434a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793926</data>
    </edge>
    <edge source="Process Control Block" target="Signal">
      <data key="d6">1.0</data>
      <data key="d7">The Process Control Block stores signal-related information used by the signal mechanism.</data>
      <data key="d8">event notification,process state</data>
      <data key="d9">chunk-d75ea791c964266b65c0ee55b3a8e15f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793866</data>
    </edge>
    <edge source="Process Control Block" target="Signal Vector">
      <data key="d6">1.0</data>
      <data key="d7">The signal vector in the PCB records which signals are pending for a process.</data>
      <data key="d8">pending signal tracking,status monitoring</data>
      <data key="d9">chunk-d75ea791c964266b65c0ee55b3a8e15f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793867</data>
    </edge>
    <edge source="Process Control Block" target="Blocked Signal Vector">
      <data key="d6">1.0</data>
      <data key="d7">The blocked signal vector in the PCB indicates which signals are disabled or ignored by the process.</data>
      <data key="d8">ignore state,signal masking</data>
      <data key="d9">chunk-d75ea791c964266b65c0ee55b3a8e15f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793868</data>
    </edge>
    <edge source="Process Control Block" target="Context Switcher">
      <data key="d6">1.0</data>
      <data key="d7">The Context Switcher saves the current process's context into its Process Control Block (PCB) during a schedule transition.</data>
      <data key="d8">context saving</data>
      <data key="d9">chunk-491042f5eab097ef962a4657a4b61650</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794034</data>
    </edge>
    <edge source="Process Control Block" target="Operating System">
      <data key="d6">1.0</data>
      <data key="d7">The operating system uses the Process Control Block to allocate resources and manage process scheduling.</data>
      <data key="d8">resource control,scheduling mechanism</data>
      <data key="d9">chunk-2da376f0975743dcb0cc169c929cbe5c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794162</data>
    </edge>
    <edge source="Process Control Block" target="Process State">
      <data key="d6">1.0</data>
      <data key="d7">The Process Control Block stores the current state of the process, which is essential for scheduling decisions.</data>
      <data key="d8">scheduling control,state tracking</data>
      <data key="d9">chunk-2da376f0975743dcb0cc169c929cbe5c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794162</data>
    </edge>
    <edge source="Process Control Block" target="Process Priority">
      <data key="d6">1.0</data>
      <data key="d7">The Process Control Block holds the priority level used to determine the order of CPU access.</data>
      <data key="d8">CPU scheduling,priority management</data>
      <data key="d9">chunk-2da376f0975743dcb0cc169c929cbe5c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794162</data>
    </edge>
    <edge source="Process Control Block" target="Resource Allocation List">
      <data key="d6">1.0</data>
      <data key="d7">The Resource Allocation List in the PCB keeps track of memory, files, and I/O devices assigned to the process.</data>
      <data key="d8">resource management,system resource tracking</data>
      <data key="d9">chunk-2da376f0975743dcb0cc169c929cbe5c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794163</data>
    </edge>
    <edge source="Process Control Block" target="CPU Context">
      <data key="d6">1.0</data>
      <data key="d7">The CPU context is saved in the PCB to allow a process to resume execution from its previous breakpoint.</data>
      <data key="d8">context switching,execution resume</data>
      <data key="d9">chunk-2da376f0975743dcb0cc169c929cbe5c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794163</data>
    </edge>
    <edge source="Process Control Block" target="Process Identifier">
      <data key="d6">1.0</data>
      <data key="d7">The Process Identifier in the PCB uniquely distinguishes a process within the system.</data>
      <data key="d8">system tracking,unique identification</data>
      <data key="d9">chunk-2da376f0975743dcb0cc169c929cbe5c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794163</data>
    </edge>
    <edge source="Process Control Block" target="User Identifier">
      <data key="d6">1.0</data>
      <data key="d7">The User Identifier in the PCB links the process to its owning user for access and protection.</data>
      <data key="d8">access control,ownership tracking</data>
      <data key="d9">chunk-2da376f0975743dcb0cc169c929cbe5c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794164</data>
    </edge>
    <edge source="Process Control Block" target="Linked Method">
      <data key="d6">1.0</data>
      <data key="d7">The linked method uses queues to organize PCBs by their current state, enabling efficient management.</data>
      <data key="d8">organization method,state grouping</data>
      <data key="d9">chunk-2da376f0975743dcb0cc169c929cbe5c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794164</data>
    </edge>
    <edge source="Process Control Block" target="Indexed Method">
      <data key="d6">1.0</data>
      <data key="d7">The indexed method organizes PCBs using index tables, where each entry points to a specific PCB.</data>
      <data key="d8">index table usage,organization method</data>
      <data key="d9">chunk-2da376f0975743dcb0cc169c929cbe5c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794164</data>
    </edge>
    <edge source="I/O Operation" target="Turnaround Time">
      <data key="d6">1.0</data>
      <data key="d7">Turnaround time encompasses the duration of I/O operations performed by the job.</data>
      <data key="d8">component relationship,time accumulation</data>
      <data key="d9">chunk-76ab4199a2aae3d8b4b3b6c270c34a12</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794301</data>
    </edge>
    <edge source="Operating System" target="CPU Scheduling">
      <data key="d6">2.0</data>
      <data key="d7">CPU scheduling is a fundamental function of the operating system responsible for managing process execution.&lt;SEP&gt;CPU scheduling is a foundational component of the operating system's process management mechanisms.</data>
      <data key="d8">core system function,process management,system core function</data>
      <data key="d9">chunk-c39617d7522bbe85482a3d992382cd4b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793786</data>
    </edge>
    <edge source="Operating System" target="Medium-Level Scheduling">
      <data key="d6">1.0</data>
      <data key="d7">The operating system implements medium-level scheduling to manage memory and improve system efficiency.</data>
      <data key="d8">memory management,system functionality</data>
      <data key="d9">chunk-c39617d7522bbe85482a3d992382cd4b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793787</data>
    </edge>
    <edge source="Operating System" target="High-Level Scheduling">
      <data key="d6">1.0</data>
      <data key="d7">The operating system uses high-level scheduling to control job loading and resource allocation.</data>
      <data key="d8">job management,system functionality</data>
      <data key="d9">chunk-c39617d7522bbe85482a3d992382cd4b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793788</data>
    </edge>
    <edge source="Operating System" target="System Throughput">
      <data key="d6">1.0</data>
      <data key="d7">The operating system influences system throughput by managing how efficiently processes are scheduled and executed.</data>
      <data key="d8">performance optimization,resource utilization</data>
      <data key="d9">chunk-c39617d7522bbe85482a3d992382cd4b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793789</data>
    </edge>
    <edge source="生产者-消费者问题" target="缓冲区">
      <data key="d6">1.0</data>
      <data key="d7">The producer-consumer problem relies on the buffer as the shared resource that enables synchronization between producers and consumers.</data>
      <data key="d8">resource dependency,synchronization</data>
      <data key="d9">chunk-d3e84198ebbd072f7382ef600186508e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793639</data>
    </edge>
    <edge source="读者-写者问题" target="共享文件">
      <data key="d6">1.0</data>
      <data key="d7">The reader-writer problem is defined by access to a shared file, requiring specific policies for reader and writer concurrency.</data>
      <data key="d8">concurrency control,resource access model</data>
      <data key="d9">chunk-d3e84198ebbd072f7382ef600186508e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793638</data>
    </edge>
    <edge source="哲学家进餐问题" target="死锁">
      <data key="d6">1.0</data>
      <data key="d7">The dining philosophers problem is a classic example where deadlock can occur if all philosophers pick up one fork and wait indefinitely for the other.</data>
      <data key="d8">problem,risk state</data>
      <data key="d9">chunk-d3e84198ebbd072f7382ef600186508e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793637</data>
    </edge>
    <edge source="哲学家进餐问题" target="饥饿现象">
      <data key="d6">1.0</data>
      <data key="d7">Starvation can occur if some philosophers are repeatedly denied access to both forks, preventing them from eating.</data>
      <data key="d8">fairness issue,problem</data>
      <data key="d9">chunk-d3e84198ebbd072f7382ef600186508e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793638</data>
    </edge>
    <edge source="哲学家进餐问题" target="限制条件">
      <data key="d6">1.0</data>
      <data key="d7">Restriction conditions are applied to the dining philosophers problem to prevent deadlock and starvation.</data>
      <data key="d8">deadlock avoidance,solution</data>
      <data key="d9">chunk-d3e84198ebbd072f7382ef600186508e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793638</data>
    </edge>
    <edge source="哲学家进餐问题" target="筷子">
      <data key="d6">1.0</data>
      <data key="d7">The dining philosophers problem involves coordination among philosophers competing for shared chopsticks, requiring strategies to prevent deadlock.</data>
      <data key="d8">deadlock prevention,resource coordination</data>
      <data key="d9">chunk-d3e84198ebbd072f7382ef600186508e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793639</data>
    </edge>
    <edge source="缓冲区" target="生产者进程">
      <data key="d6">1.0</data>
      <data key="d7">The producer processes place products into the buffer when it is not full, subject to mutual exclusion.</data>
      <data key="d8">production,resource access</data>
      <data key="d9">chunk-d3e84198ebbd072f7382ef600186508e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793636</data>
    </edge>
    <edge source="缓冲区" target="消费者进程">
      <data key="d6">1.0</data>
      <data key="d7">The consumer processes remove products from the buffer when it is not empty, subject to mutual exclusion.</data>
      <data key="d8">consumption,resource access</data>
      <data key="d9">chunk-d3e84198ebbd072f7382ef600186508e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793637</data>
    </edge>
    <edge source="缓冲区" target="互斥访问">
      <data key="d6">1.0</data>
      <data key="d7">Mutual exclusion is enforced on the buffer to ensure safe access by producers and consumers.</data>
      <data key="d8">access enforcement,critical section</data>
      <data key="d9">chunk-d3e84198ebbd072f7382ef600186508e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793638</data>
    </edge>
    <edge source="缓冲区" target="哲学家">
      <data key="d6">1.0</data>
      <data key="d7">The dining philosophers problem is conceptually analogous to resource allocation and synchronization issues modeled using a shared resource.</data>
      <data key="d8">analogy,conceptual model</data>
      <data key="d9">chunk-d3e84198ebbd072f7382ef600186508e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793639</data>
    </edge>
    <edge source="生产者进程" target="同步关系">
      <data key="d6">1.0</data>
      <data key="d7">Synchronization ensures that the consumer only accesses the buffer after the producer has placed an item.</data>
      <data key="d8">coordination mechanism,process dependency</data>
      <data key="d9">chunk-d3e84198ebbd072f7382ef600186508e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793637</data>
    </edge>
    <edge source="生产者进程" target="消费者进程">
      <data key="d6">1.0</data>
      <data key="d7">The producer processes must produce items before consumer processes can consume them, creating a synchronization dependency.</data>
      <data key="d8">dependency,synchronization</data>
      <data key="d9">chunk-d3e84198ebbd072f7382ef600186508e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793638</data>
    </edge>
    <edge source="读者进程" target="写者进程">
      <data key="d6">1.0</data>
      <data key="d7">Readers and writers cannot access the file simultaneously; writers require exclusive access to prevent data inconsistency.</data>
      <data key="d8">access conflict,mutual exclusion</data>
      <data key="d9">chunk-d3e84198ebbd072f7382ef600186508e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793636</data>
    </edge>
    <edge source="写者进程" target="互斥访问">
      <data key="d6">1.0</data>
      <data key="d7">Mutual exclusion ensures that only one writer can access the file at a time, maintaining data integrity.</data>
      <data key="d8">access enforcement,data consistency</data>
      <data key="d9">chunk-d3e84198ebbd072f7382ef600186508e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793639</data>
    </edge>
    <edge source="哲学家" target="筷子">
      <data key="d6">1.0</data>
      <data key="d7">Each philosopher must acquire two adjacent chopsticks to eat, and access to each chopstick is mutually exclusive.</data>
      <data key="d8">mutual exclusion,resource request</data>
      <data key="d9">chunk-d3e84198ebbd072f7382ef600186508e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793636</data>
    </edge>
    <edge source="死锁" target="互斥条件">
      <data key="d6">1.0</data>
      <data key="d7">互斥条件是产生死锁必须满足的四个必要条件之一。</data>
      <data key="d8">deadlock prerequisite,necessity condition</data>
      <data key="d9">chunk-9aabe855c161e30442ff85ca7a64312e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793968</data>
    </edge>
    <edge source="死锁" target="请求和保持条件">
      <data key="d6">1.0</data>
      <data key="d7">请求和保持条件是产生死锁必须满足的四个必要条件之一。</data>
      <data key="d8">deadlock prerequisite,necessity condition</data>
      <data key="d9">chunk-9aabe855c161e30442ff85ca7a64312e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793968</data>
    </edge>
    <edge source="死锁" target="不剥夺条件">
      <data key="d6">1.0</data>
      <data key="d7">不剥夺条件是产生死锁必须满足的四个必要条件之一。</data>
      <data key="d8">deadlock prerequisite,necessity condition</data>
      <data key="d9">chunk-9aabe855c161e30442ff85ca7a64312e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793969</data>
    </edge>
    <edge source="死锁" target="循环等待条件">
      <data key="d6">1.0</data>
      <data key="d7">循环等待条件是产生死锁必须满足的四个必要条件之一。</data>
      <data key="d8">deadlock prerequisite,necessity condition</data>
      <data key="d9">chunk-9aabe855c161e30442ff85ca7a64312e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793969</data>
    </edge>
    <edge source="死锁" target="系统资源竞争">
      <data key="d6">1.0</data>
      <data key="d7">系统资源竞争是导致死锁的两个主要原因之一。</data>
      <data key="d8">causal factor,deadlock trigger</data>
      <data key="d9">chunk-9aabe855c161e30442ff85ca7a64312e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793970</data>
    </edge>
    <edge source="死锁" target="进程推进顺序非法">
      <data key="d6">1.0</data>
      <data key="d7">进程推进顺序非法是导致死锁的两个主要原因之一。</data>
      <data key="d8">causal factor,deadlock trigger</data>
      <data key="d9">chunk-9aabe855c161e30442ff85ca7a64312e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793970</data>
    </edge>
    <edge source="死锁" target="等待态">
      <data key="d6">1.0</data>
      <data key="d7">发生死锁的进程必然处于等待态。</data>
      <data key="d8">deadlock state,state condition</data>
      <data key="d9">chunk-9aabe855c161e30442ff85ca7a64312e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793971</data>
    </edge>
    <edge source="死锁" target="就绪态">
      <data key="d6">1.0</data>
      <data key="d7">死锁进程可能处于就绪态但长期得不到CPU，体现为潜在的死锁风险。</data>
      <data key="d8">deadlock possibility,state condition</data>
      <data key="d9">chunk-9aabe855c161e30442ff85ca7a64312e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793971</data>
    </edge>
    <edge source="死锁" target="死锁产生的必要条件">
      <data key="d6">1.0</data>
      <data key="d7">死锁的发生必须同时满足死锁产生的必要条件，缺一不可。</data>
      <data key="d8">prerequisite set,requirement dependency</data>
      <data key="d9">chunk-9aabe855c161e30442ff85ca7a64312e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793971</data>
    </edge>
    <edge source="Asymmetric MultiProcessing" target="Master Processor">
      <data key="d6">1.0</data>
      <data key="d7">In an asymmetric multi-processing system, the master processor holds the operating system kernel and controls task scheduling.</data>
      <data key="d8">kernel management,system architecture</data>
      <data key="d9">chunk-f326031f0d80f48ea7bc3e6da1a5f8a4</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793673</data>
    </edge>
    <edge source="Asymmetric MultiProcessing" target="Slave Processor">
      <data key="d6">1.0</data>
      <data key="d7">In an asymmetric multi-processing system, slave processors only execute user-level programs without kernel access.</data>
      <data key="d8">system architecture,user program execution</data>
      <data key="d9">chunk-f326031f0d80f48ea7bc3e6da1a5f8a4</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793674</data>
    </edge>
    <edge source="Symmetric MultiProcessing" target="Process Scheduling">
      <data key="d6">1.0</data>
      <data key="d7">In symmetric multi-processing systems, the process scheduling mechanism assigns any process to any CPU without restriction.</data>
      <data key="d8">load distribution,symmetric execution</data>
      <data key="d9">chunk-f326031f0d80f48ea7bc3e6da1a5f8a4</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793673</data>
    </edge>
    <edge source="Symmetric MultiProcessing" target="Public Ready Queue">
      <data key="d6">1.0</data>
      <data key="d7">Symmetric multi-processing systems can implement a public ready queue for centralized scheduling and improved load balancing.</data>
      <data key="d8">shared scheduling,system design</data>
      <data key="d9">chunk-f326031f0d80f48ea7bc3e6da1a5f8a4</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793674</data>
    </edge>
    <edge source="Symmetric MultiProcessing" target="Private Ready Queue">
      <data key="d6">1.0</data>
      <data key="d7">Symmetric multi-processing systems may use private ready queues to support processor affinity, though it complicates load balancing.</data>
      <data key="d8">affinity support,system design</data>
      <data key="d9">chunk-f326031f0d80f48ea7bc3e6da1a5f8a4</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793675</data>
    </edge>
    <edge source="Processor Affinity" target="Cache Invalidation">
      <data key="d6">1.0</data>
      <data key="d7">Moving a process between CPUs forces cache invalidation, which deteriorates performance, making processor affinity beneficial.</data>
      <data key="d8">CPU migration cost,performance trade-off</data>
      <data key="d9">chunk-f326031f0d80f48ea7bc3e6da1a5f8a4</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793673</data>
    </edge>
    <edge source="Processor Affinity" target="Load Balancing">
      <data key="d6">1.0</data>
      <data key="d7">Load balancing often requires process migration across CPUs, which contradicts the benefits of processor affinity.</data>
      <data key="d8">conflicting objectives,resource optimization</data>
      <data key="d9">chunk-f326031f0d80f48ea7bc3e6da1a5f8a4</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793674</data>
    </edge>
    <edge source="Processor Affinity" target="Private Ready Queue">
      <data key="d6">1.0</data>
      <data key="d7">The private ready queue enhances processor affinity by keeping processes on their assigned CPU, reducing migration overhead.</data>
      <data key="d8">process localization,system design</data>
      <data key="d9">chunk-f326031f0d80f48ea7bc3e6da1a5f8a4</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793674</data>
    </edge>
    <edge source="Load Balancing" target="Public Ready Queue">
      <data key="d6">1.0</data>
      <data key="d7">The public ready queue supports system-wide load balancing by enabling all CPUs to access the same set of ready processes.</data>
      <data key="d8">system design,workload distribution</data>
      <data key="d9">chunk-f326031f0d80f48ea7bc3e6da1a5f8a4</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793674</data>
    </edge>
    <edge source="Process Scheduling" target="Context Switching">
      <data key="d6">1.0</data>
      <data key="d7">Process Scheduling determines when to switch, and Context Switching executes the actual transition between processes.</data>
      <data key="d8">execution cycle</data>
      <data key="d9">chunk-491042f5eab097ef962a4657a4b61650</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794034</data>
    </edge>
    <edge source="Mutual Exclusion Lock" target="Acquire Function">
      <data key="d6">1.0</data>
      <data key="d7">The mutual exclusion lock is obtained by calling the acquire() function when a process enters a critical section.</data>
      <data key="d8">lock acquisition,synchronization</data>
      <data key="d9">chunk-e16dceff2fc93c138aa86eb65cacc6c7</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793682</data>
    </edge>
    <edge source="Mutual Exclusion Lock" target="Release Function">
      <data key="d6">1.0</data>
      <data key="d7">The mutual exclusion lock is released by calling the release() function when a process exits a critical section.</data>
      <data key="d8">lock release,synchronization</data>
      <data key="d9">chunk-e16dceff2fc93c138aa86eb65cacc6c7</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793683</data>
    </edge>
    <edge source="Mutual Exclusion Lock" target="Available Boolean Variable">
      <data key="d6">1.0</data>
      <data key="d7">The available boolean variable tracks the availability of the mutual exclusion lock.</data>
      <data key="d8">lock status,state tracking</data>
      <data key="d9">chunk-e16dceff2fc93c138aa86eb65cacc6c7</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793684</data>
    </edge>
    <edge source="Mutual Exclusion Lock" target="Multiprocessor System">
      <data key="d6">1.0</data>
      <data key="d7">Mutual exclusion locks are typically used in multiprocessor systems to coordinate access to shared resources.</data>
      <data key="d8">application context,system use</data>
      <data key="d9">chunk-e16dceff2fc93c138aa86eb65cacc6c7</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793684</data>
    </edge>
    <edge source="Acquire Function" target="Atomic Operation">
      <data key="d6">1.0</data>
      <data key="d7">The acquire() function must be implemented using atomic operations to prevent race conditions.</data>
      <data key="d8">implementation requirement,thread safety</data>
      <data key="d9">chunk-e16dceff2fc93c138aa86eb65cacc6c7</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793683</data>
    </edge>
    <edge source="Release Function" target="Atomic Operation">
      <data key="d6">1.0</data>
      <data key="d7">The release() function must be implemented using atomic operations to ensure correctness.</data>
      <data key="d8">implementation requirement,thread safety</data>
      <data key="d9">chunk-e16dceff2fc93c138aa86eb65cacc6c7</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793682</data>
    </edge>
    <edge source="进程同步" target="同步">
      <data key="d6">1.0</data>
      <data key="d7">进程同步and同步are equivalent concepts, both describing the direct coordination between processes to achieve a common task.</data>
      <data key="d8">conceptual equivalence,coordination</data>
      <data key="d9">chunk-96612cb99be5ccc8684e38f3d50f77f5</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793748</data>
    </edge>
    <edge source="进程同步" target="多道程序环境">
      <data key="d6">1.0</data>
      <data key="d7">The多道程序环境necessitates进程同步due to the concurrent execution of multiple processes.</data>
      <data key="d8">coordination requirement,environmental necessity</data>
      <data key="d9">chunk-96612cb99be5ccc8684e38f3d50f77f5</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793749</data>
    </edge>
    <edge source="进入区" target="忙则等待">
      <data key="d6">1.0</data>
      <data key="d7">The进入区implements the忙则等待rule by rejecting entry if the critical section is occupied.</data>
      <data key="d8">access control,rule enforcement</data>
      <data key="d9">chunk-96612cb99be5ccc8684e38f3d50f77f5</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793748</data>
    </edge>
    <edge source="死锁检测" target="资源请求和分配信息">
      <data key="d6">1.0</data>
      <data key="d7">Deadlock detection relies on the availability and analysis of resource request and allocation information.</data>
      <data key="d8">data dependency,detection mechanism</data>
      <data key="d9">chunk-b5aa6485f08fa52f1ae6912e99884079</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793782</data>
    </edge>
    <edge source="死锁检测" target="系统">
      <data key="d6">1.0</data>
      <data key="d7">The system performs deadlock detection by continuously evaluating resource states.</data>
      <data key="d8">monitoring,system function</data>
      <data key="d9">chunk-b5aa6485f08fa52f1ae6912e99884079</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793783</data>
    </edge>
    <edge source="死锁解除" target="剥夺资源">
      <data key="d6">1.0</data>
      <data key="d7">Resource preemption is a key method used in deadlock resolution.</data>
      <data key="d8">resolution technique,resource recovery</data>
      <data key="d9">chunk-b5aa6485f08fa52f1ae6912e99884079</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793782</data>
    </edge>
    <edge source="死锁解除" target="撤销进程">
      <data key="d6">1.0</data>
      <data key="d7">Process termination is a method for eliminating deadlock by removing deadlocked processes.</data>
      <data key="d8">process termination,resolution technique</data>
      <data key="d9">chunk-b5aa6485f08fa52f1ae6912e99884079</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793783</data>
    </edge>
    <edge source="死锁解除" target="进程回退">
      <data key="d6">1.0</data>
      <data key="d7">Process rollback provides a non-destructive way to resolve deadlock by allowing processes to return to a safe state.</data>
      <data key="d8">resolution technique,rollback-based recovery</data>
      <data key="d9">chunk-b5aa6485f08fa52f1ae6912e99884079</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793784</data>
    </edge>
    <edge source="撤销进程" target="系统调用">
      <data key="d6">1.0</data>
      <data key="d7">撤销进程is executed through a system call, requiring kernel support for resource release.</data>
      <data key="d8">kernel execution,system-level termination</data>
      <data key="d9">chunk-b7f639a9301d2ec0568bcbcad2dc3725</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794246</data>
    </edge>
    <edge source="进程回退" target="还原点">
      <data key="d6">1.0</data>
      <data key="d7">Process rollback requires the presence of checkpoints to restore a process to a prior state.</data>
      <data key="d8">checkpoint dependency,recovery mechanism</data>
      <data key="d9">chunk-b5aa6485f08fa52f1ae6912e99884079</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793782</data>
    </edge>
    <edge source="CPU Scheduling" target="Multi-Program System">
      <data key="d6">1.0</data>
      <data key="d7">CPU scheduling arises as a necessary mechanism in a multi-program system due to the contention for CPU resources.</data>
      <data key="d8">operational environment,resource competition</data>
      <data key="d9">chunk-c39617d7522bbe85482a3d992382cd4b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793787</data>
    </edge>
    <edge source="High-Level Scheduling" target="Job Queue">
      <data key="d6">1.0</data>
      <data key="d7">High-level scheduling selects jobs from the job queue and assigns memory and I/O devices to them.</data>
      <data key="d8">job selection,resource assignment</data>
      <data key="d9">chunk-c39617d7522bbe85482a3d992382cd4b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793785</data>
    </edge>
    <edge source="High-Level Scheduling" target="Medium-Level Scheduling">
      <data key="d6">1.0</data>
      <data key="d7">High-level scheduling precedes medium-level scheduling in the sequence of process management activities.</data>
      <data key="d8">precedence,scheduler hierarchy</data>
      <data key="d9">chunk-c39617d7522bbe85482a3d992382cd4b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793789</data>
    </edge>
    <edge source="High-Level Scheduling" target="Backlog Queue">
      <data key="d6">1.0</data>
      <data key="d7">High-level scheduling selects jobs from the backlog queue, which is synonymous with the job queue, to prepare them for memory loading and execution.</data>
      <data key="d8">job selection,process initiation</data>
      <data key="d9">chunk-c39617d7522bbe85482a3d992382cd4b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793789</data>
    </edge>
    <edge source="Medium-Level Scheduling" target="Suspended State">
      <data key="d6">1.0</data>
      <data key="d7">Medium-level scheduling places processes into a suspended state when they are temporarily removed from memory.</data>
      <data key="d8">memory optimization,process suspension</data>
      <data key="d9">chunk-c39617d7522bbe85482a3d992382cd4b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793785</data>
    </edge>
    <edge source="Medium-Level Scheduling" target="Memory Utilization">
      <data key="d6">1.0</data>
      <data key="d7">Medium-level scheduling improves memory utilization by swapping out inactive processes.</data>
      <data key="d8">memory management,system optimization</data>
      <data key="d9">chunk-c39617d7522bbe85482a3d992382cd4b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793786</data>
    </edge>
    <edge source="Medium-Level Scheduling" target="Low-Level Scheduling">
      <data key="d6">1.0</data>
      <data key="d7">Medium-level scheduling and low-level scheduling are sequentially related, with medium scheduling managing temporary offloading and low scheduling handling CPU allocation.</data>
      <data key="d8">scheduler hierarchy,state management</data>
      <data key="d9">chunk-c39617d7522bbe85482a3d992382cd4b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793787</data>
    </edge>
    <edge source="System Throughput" target="Long Job">
      <data key="d6">1.0</data>
      <data key="d7">Long jobs consume more CPU time, reducing the number of jobs completed per unit time and lowering system throughput.</data>
      <data key="d8">efficiency reduction,negative impact</data>
      <data key="d9">chunk-76ab4199a2aae3d8b4b3b6c270c34a12</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794300</data>
    </edge>
    <edge source="System Throughput" target="Short Job">
      <data key="d6">1.0</data>
      <data key="d7">Short jobs require less CPU time, allowing more jobs to be completed quickly, increasing system throughput.</data>
      <data key="d8">efficiency boost,positive impact</data>
      <data key="d9">chunk-76ab4199a2aae3d8b4b3b6c270c34a12</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794300</data>
    </edge>
    <edge source="System Throughput" target="CPU Scheduling Algorithm">
      <data key="d6">1.0</data>
      <data key="d7">The choice of CPU scheduling algorithm affects the rate at which jobs are completed, impacting system throughput.</data>
      <data key="d8">job efficiency,performance metric</data>
      <data key="d9">chunk-76ab4199a2aae3d8b4b3b6c270c34a12</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794301</data>
    </edge>
    <edge source="CPU Allocation" target="Little-Level Scheduling">
      <data key="d6">1.0</data>
      <data key="d7">Low-level scheduling performs CPU allocation frequently, often every few milliseconds.</data>
      <data key="d8">execution control,scheduling frequency</data>
      <data key="d9">chunk-c39617d7522bbe85482a3d992382cd4b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793785</data>
    </edge>
    <edge source="死锁避免" target="系统安全状态">
      <data key="d6">1.0</data>
      <data key="d7">死锁避免relies on determining whether a resource allocation leads to a safe state to avoid deadlock.</data>
      <data key="d8">preventive strategy,safety analysis</data>
      <data key="d9">chunk-fd78a6e2f6ac315b1d1c2a02efb03591</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793825</data>
    </edge>
    <edge source="死锁避免" target="不安全状态">
      <data key="d6">1.0</data>
      <data key="d7">The existence of an unsafe state triggers the need for the deadlock avoidance strategy to intervene.</data>
      <data key="d8">algorithm trigger,risk condition</data>
      <data key="d9">chunk-fd78a6e2f6ac315b1d1c2a02efb03591</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793826</data>
    </edge>
    <edge source="系统安全状态" target="安全序列">
      <data key="d6">1.0</data>
      <data key="d7">A system is in a safe state if a safe sequence of process execution exists.</data>
      <data key="d8">deadlock prevention,resource allocation sequence</data>
      <data key="d9">chunk-fd78a6e2f6ac315b1d1c2a02efb03591</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793826</data>
    </edge>
    <edge source="银行家算法" target="操作系统">
      <data key="d6">1.0</data>
      <data key="d7">The Banker's Algorithm is implemented by the operating system to manage resource allocation safely.</data>
      <data key="d8">algorithm implementation,system management</data>
      <data key="d9">chunk-fd78a6e2f6ac315b1d1c2a02efb03591</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793825</data>
    </edge>
    <edge source="银行家算法" target="资源分配">
      <data key="d6">1.0</data>
      <data key="d7">The Banker's Algorithm evaluates resource allocation requests before granting them.</data>
      <data key="d8">allocation decision,safety check</data>
      <data key="d9">chunk-fd78a6e2f6ac315b1d1c2a02efb03591</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793825</data>
    </edge>
    <edge source="操作系统" target="进程控制">
      <data key="d6">1.0</data>
      <data key="d7">操作系统负责执行进程控制功能以管理所有进程。</data>
      <data key="d8">process oversight,system management</data>
      <data key="d9">chunk-7ca51faf7f3faf56c56ab18dd6458c7e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794048</data>
    </edge>
    <edge source="资源分配" target="进程">
      <data key="d6">1.0</data>
      <data key="d7">Processes request resources, and their successful execution depends on proper resource allocation.</data>
      <data key="d8">execution dependency,resource request</data>
      <data key="d9">chunk-fd78a6e2f6ac315b1d1c2a02efb03591</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793826</data>
    </edge>
    <edge source="进程" target="最大需求">
      <data key="d6">1.0</data>
      <data key="d7">Each process has a maximum resource demand that must be satisfied for completion.</data>
      <data key="d8">execution constraint,resource requirement</data>
      <data key="d9">chunk-fd78a6e2f6ac315b1d1c2a02efb03591</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793825</data>
    </edge>
    <edge source="进程" target="资源">
      <data key="d6">1.0</data>
      <data key="d7">进程在执行过程中依赖于资源的分配与使用。</data>
      <data key="d8">dependency,resource usage</data>
      <data key="d9">chunk-9aabe855c161e30442ff85ca7a64312e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793967</data>
    </edge>
    <edge source="Process Communication" target="PV Operation">
      <data key="d6">1.0</data>
      <data key="d7">PV operation is a fundamental low-level method used to control access in process communication.</data>
      <data key="d8">low-level communication,synchronization mechanism</data>
      <data key="d9">chunk-d75ea791c964266b65c0ee55b3a8e15f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793865</data>
    </edge>
    <edge source="Process Communication" target="Advanced Communication Method">
      <data key="d6">1.0</data>
      <data key="d7">Advanced communication methods are used for efficient, high-volume data exchange between processes.</data>
      <data key="d8">communication technique,high-level data transfer</data>
      <data key="d9">chunk-d75ea791c964266b65c0ee55b3a8e15f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793866</data>
    </edge>
    <edge source="Shared Memory" target="Low-Level Shared Memory">
      <data key="d6">1.0</data>
      <data key="d7">Low-level shared memory is a form of shared memory based on data structures.</data>
      <data key="d8">communication type,data structure-based sharing</data>
      <data key="d9">chunk-d75ea791c964266b65c0ee55b3a8e15f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793865</data>
    </edge>
    <edge source="Shared Memory" target="High-Level Shared Memory">
      <data key="d6">1.0</data>
      <data key="d7">High-level shared memory is a form of shared memory based on dedicated shared memory regions.</data>
      <data key="d8">communication type,memory region-based sharing</data>
      <data key="d9">chunk-d75ea791c964266b65c0ee55b3a8e15f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793866</data>
    </edge>
    <edge source="Shared Memory" target="Synchronization and Mutual Exclusion Tools">
      <data key="d6">1.0</data>
      <data key="d7">Synchronization and mutual exclusion tools are required to manage read/write operations on shared memory.</data>
      <data key="d8">access control,coordination</data>
      <data key="d9">chunk-d75ea791c964266b65c0ee55b3a8e15f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793867</data>
    </edge>
    <edge source="Message Passing" target="Direct Communication">
      <data key="d6">1.0</data>
      <data key="d7">Direct communication is a form of message passing where messages are sent directly to the receiver.</data>
      <data key="d8">direct data exchange,message transfer</data>
      <data key="d9">chunk-d75ea791c964266b65c0ee55b3a8e15f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793865</data>
    </edge>
    <edge source="Message Passing" target="Indirect Communication">
      <data key="d6">1.0</data>
      <data key="d7">Indirect communication uses a mailbox as an intermediary for message delivery.</data>
      <data key="d8">intermediary-based exchange,mailbox usage</data>
      <data key="d9">chunk-d75ea791c964266b65c0ee55b3a8e15f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793866</data>
    </edge>
    <edge source="Indirect Communication" target="Mailbox">
      <data key="d6">1.0</data>
      <data key="d7">The mailbox serves as a storage point where messages are placed and retrieved by the destination process.</data>
      <data key="d8">intermediate storage,message routing</data>
      <data key="d9">chunk-d75ea791c964266b65c0ee55b3a8e15f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793867</data>
    </edge>
    <edge source="Pipe Communication" target="FIFO">
      <data key="d6">1.0</data>
      <data key="d7">Pipe communication follows the FIFO principle for data transmission.</data>
      <data key="d8">data flow,data ordering</data>
      <data key="d9">chunk-d75ea791c964266b65c0ee55b3a8e15f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793866</data>
    </edge>
    <edge source="Pipe Communication" target="Pipe File">
      <data key="d6">1.0</data>
      <data key="d7">Pipe file is a special file used to create a buffer for inter-process communication.</data>
      <data key="d8">data buffer,special file type</data>
      <data key="d9">chunk-d75ea791c964266b65c0ee55b3a8e15f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793866</data>
    </edge>
    <edge source="Pipe Communication" target="Linux">
      <data key="d6">1.0</data>
      <data key="d7">Linux commonly uses pipe communication for inter-process exchange.</data>
      <data key="d8">communication mechanism,operating system support</data>
      <data key="d9">chunk-d75ea791c964266b65c0ee55b3a8e15f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793867</data>
    </edge>
    <edge source="Pipe Communication" target="Producer-Consumer Pattern">
      <data key="d6">1.0</data>
      <data key="d7">Pipe communication supports the producer-consumer pattern, enabling structured data transfer between processes.</data>
      <data key="d8">data exchange,synchronization model</data>
      <data key="d9">chunk-d75ea791c964266b65c0ee55b3a8e15f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793868</data>
    </edge>
    <edge source="Signal" target="Bit Vector">
      <data key="d6">1.0</data>
      <data key="d7">A bit vector is used to track which signals are blocked or masked, preventing the process from responding to them.</data>
      <data key="d8">blocking mechanism,signal management</data>
      <data key="d9">chunk-c214e070db9e1fbcd76d28e9e144db30</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793867</data>
    </edge>
    <edge source="Kernel" target="System Event">
      <data key="d6">1.0</data>
      <data key="d7">The kernel detects specific system events and generates corresponding signals to notify relevant processes.</data>
      <data key="d8">detection,signal generation</data>
      <data key="d9">chunk-c214e070db9e1fbcd76d28e9e144db30</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793867</data>
    </edge>
    <edge source="User Mode" target="Kernel Mode">
      <data key="d6">1.0</data>
      <data key="d7">The operating system transitions a process from kernel mode to user mode, at which point pending unblocked signals are checked and handled.</data>
      <data key="d8">operating state transition,signal handling trigger</data>
      <data key="d9">chunk-c214e070db9e1fbcd76d28e9e144db30</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793868</data>
    </edge>
    <edge source="Default Signal Handler" target="Custom Signal Handler">
      <data key="d6">1.0</data>
      <data key="d7">A custom signal handler overrides the default signal handling behavior for a specific signal.</data>
      <data key="d8">behavior override,signal handling customization</data>
      <data key="d9">chunk-c214e070db9e1fbcd76d28e9e144db30</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793870</data>
    </edge>
    <edge source="Thread" target="Execution State">
      <data key="d6">1.0</data>
      <data key="d7">A thread transitions into the execution state when it gains access to the CPU and begins executing instructions.</data>
      <data key="d8">execution,state</data>
      <data key="d9">chunk-34425c38108ef3730cc0889df3f8434a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793925</data>
    </edge>
    <edge source="Thread" target="Thread Control Block">
      <data key="d6">3.0</data>
      <data key="d7">The Thread Control Block stores critical runtime state information for a thread, including registers and stack.&lt;SEP&gt;The Thread Control Block holds the execution context and unique identifier for a thread.&lt;SEP&gt;The Thread Control Block holds critical information about a thread’s state, registers, and scheduling details.</data>
      <data key="d8">control structure,data structure,identification,metadata storage,state management,state storage</data>
      <data key="d9">chunk-e2c5907dce4f167e0b11853c616e448f&lt;SEP&gt;chunk-34425c38108ef3730cc0889df3f8434a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793926</data>
    </edge>
    <edge source="Thread" target="Registers">
      <data key="d6">1.0</data>
      <data key="d7">Registers store the current execution state of a thread, including program flow and temporary data.</data>
      <data key="d8">execution context,state preservation</data>
      <data key="d9">chunk-34425c38108ef3730cc0889df3f8434a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793926</data>
    </edge>
    <edge source="Thread" target="Thread Priority">
      <data key="d6">1.0</data>
      <data key="d7">Thread priority influences how soon a thread is scheduled to run relative to others.</data>
      <data key="d8">execution order,scheduling</data>
      <data key="d9">chunk-34425c38108ef3730cc0889df3f8434a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793927</data>
    </edge>
    <edge source="Thread" target="Thread Private Storage">
      <data key="d6">1.0</data>
      <data key="d7">Thread private storage is used during context switching to preserve the thread’s execution state.</data>
      <data key="d8">context saving,switching</data>
      <data key="d9">chunk-34425c38108ef3730cc0889df3f8434a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793927</data>
    </edge>
    <edge source="Thread" target="Stack Pointer">
      <data key="d6">1.0</data>
      <data key="d7">The stack pointer manages the thread's call stack, facilitating local variable storage and return address tracking.</data>
      <data key="d8">function execution,stack management</data>
      <data key="d9">chunk-34425c38108ef3730cc0889df3f8434a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793928</data>
    </edge>
    <edge source="Thread" target="Shared Address Space">
      <data key="d6">1.0</data>
      <data key="d7">Threads within the same process share the same address space, enabling direct access to global variables and code.</data>
      <data key="d8">memory sharing,process collaboration</data>
      <data key="d9">chunk-34425c38108ef3730cc0889df3f8434a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793928</data>
    </edge>
    <edge source="Thread" target="Thread Stack">
      <data key="d6">1.0</data>
      <data key="d7">Each thread has an independent stack, ensuring that local data does not interfere with other threads.</data>
      <data key="d8">memory isolation,stack management</data>
      <data key="d9">chunk-34425c38108ef3730cc0889df3f8434a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793929</data>
    </edge>
    <edge source="Thread" target="Thread Creation Function">
      <data key="d6">1.0</data>
      <data key="d7">The thread creation function is invoked to establish a new thread with specified parameters.</data>
      <data key="d8">creation,initialization</data>
      <data key="d9">chunk-34425c38108ef3730cc0889df3f8434a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793929</data>
    </edge>
    <edge source="Thread" target="Thread Termination Function">
      <data key="d6">1.0</data>
      <data key="d7">The thread termination function ends a thread's execution after task completion or error conditions.</data>
      <data key="d8">lifecycle management,termination</data>
      <data key="d9">chunk-34425c38108ef3730cc0889df3f8434a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793929</data>
    </edge>
    <edge source="Thread" target="Thread Separation Function">
      <data key="d6">1.0</data>
      <data key="d7">The thread separation function releases the resources of a terminated thread, allowing reuse.</data>
      <data key="d8">resource cleanup,state transition</data>
      <data key="d9">chunk-34425c38108ef3730cc0889df3f8434a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793930</data>
    </edge>
    <edge source="Thread" target="Thread State Transition">
      <data key="d6">1.0</data>
      <data key="d7">A thread undergoes state transitions as it moves from ready to execution or from execution to blocked based on system events and scheduling.</data>
      <data key="d8">execution flow,state management</data>
      <data key="d9">chunk-34425c38108ef3730cc0889df3f8434a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793930</data>
    </edge>
    <edge source="Thread" target="Thread Scheduling">
      <data key="d6">1.0</data>
      <data key="d7">Thread scheduling governs when a thread becomes eligible for execution and how long it runs before switching.</data>
      <data key="d8">execution timing,scheduling control</data>
      <data key="d9">chunk-34425c38108ef3730cc0889df3f8434a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793930</data>
    </edge>
    <edge source="Thread" target="Context Switching">
      <data key="d6">1.0</data>
      <data key="d7">Context switching enables the CPU to switch between threads, allowing concurrent execution within a process.</data>
      <data key="d8">execution management,multitasking</data>
      <data key="d9">chunk-34425c38108ef3730cc0889df3f8434a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793930</data>
    </edge>
    <edge source="Thread" target="System Resource">
      <data key="d6">1.0</data>
      <data key="d7">A thread does not own system resources but can access those shared by its parent process.</data>
      <data key="d8">access,resource sharing</data>
      <data key="d9">chunk-e2c5907dce4f167e0b11853c616e448f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793932</data>
    </edge>
    <edge source="Thread" target="Context Switch">
      <data key="d6">1.0</data>
      <data key="d7">Context switching between threads incurs minimal overhead compared to process switching.</data>
      <data key="d8">execution overhead,state transition</data>
      <data key="d9">chunk-e2c5907dce4f167e0b11853c616e448f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793932</data>
    </edge>
    <edge source="Thread" target="Single CPU">
      <data key="d6">1.0</data>
      <data key="d7">On a single CPU, multiple threads are executed through time-slicing, alternating between execution states.</data>
      <data key="d8">time-slicing execution</data>
      <data key="d9">chunk-e2c5907dce4f167e0b11853c616e448f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793933</data>
    </edge>
    <edge source="Thread" target="Multiple CPU">
      <data key="d6">1.0</data>
      <data key="d7">On a multiple CPU system, threads can execute in parallel across different cores, reducing overall processing time.</data>
      <data key="d8">parallel execution,performance</data>
      <data key="d9">chunk-e2c5907dce4f167e0b11853c616e448f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793933</data>
    </edge>
    <edge source="Thread" target="Thread ID">
      <data key="d6">1.0</data>
      <data key="d7">Each thread is assigned a unique Thread ID to enable identification and management by the operating system.</data>
      <data key="d8">entity reference,unique identification</data>
      <data key="d9">chunk-e2c5907dce4f167e0b11853c616e448f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793934</data>
    </edge>
    <edge source="Thread" target="Program Counter">
      <data key="d6">1.0</data>
      <data key="d7">The Program Counter is part of a thread's context and tracks the next instruction to execute.</data>
      <data key="d8">execution control,instruction tracking</data>
      <data key="d9">chunk-e2c5907dce4f167e0b11853c616e448f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793934</data>
    </edge>
    <edge source="Thread" target="Register Set">
      <data key="d6">1.0</data>
      <data key="d7">The Register Set holds the current state of CPU registers during thread execution and is saved during context switches.</data>
      <data key="d8">execution context,state preservation</data>
      <data key="d9">chunk-e2c5907dce4f167e0b11853c616e448f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793935</data>
    </edge>
    <edge source="Thread" target="Stack">
      <data key="d6">1.0</data>
      <data key="d7">Each thread has its own stack to manage function calls, local variables, and return addresses during execution.</data>
      <data key="d8">function execution,local data storage</data>
      <data key="d9">chunk-e2c5907dce4f167e0b11853c616e448f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793935</data>
    </edge>
    <edge source="Thread Control Block" target="Thread State Transition">
      <data key="d6">1.0</data>
      <data key="d7">The Thread Control Block maintains the current state of a thread, facilitating state transition operations.</data>
      <data key="d8">control,state tracking</data>
      <data key="d9">chunk-34425c38108ef3730cc0889df3f8434a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793929</data>
    </edge>
    <edge source="Thread Control Block" target="Program Counter">
      <data key="d6">1.0</data>
      <data key="d7">The Thread Control Block stores the Program Counter value to resume execution at the correct instruction after a context switch.</data>
      <data key="d8">context storage,execution flow</data>
      <data key="d9">chunk-e2c5907dce4f167e0b11853c616e448f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793935</data>
    </edge>
    <edge source="Thread Control Block" target="Register Set">
      <data key="d6">1.0</data>
      <data key="d7">The Thread Control Block maintains the current values of the thread's register set for state preservation.</data>
      <data key="d8">context storage,execution state</data>
      <data key="d9">chunk-e2c5907dce4f167e0b11853c616e448f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793935</data>
    </edge>
    <edge source="Thread Control Block" target="Stack">
      <data key="d6">1.0</data>
      <data key="d7">The Thread Control Block stores the thread's stack pointer and other stack-related state information.</data>
      <data key="d8">context storage,state management</data>
      <data key="d9">chunk-e2c5907dce4f167e0b11853c616e448f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793936</data>
    </edge>
    <edge source="User-Level Thread" target="Kernel-Level Thread">
      <data key="d6">1.0</data>
      <data key="d7">User-level and kernel-level threads represent different models of thread management, differing in system intervention and scalability.</data>
      <data key="d8">concurrency,implementation model</data>
      <data key="d9">chunk-34425c38108ef3730cc0889df3f8434a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793927</data>
    </edge>
    <edge source="User-Level Thread" target="System Call Blocking">
      <data key="d6">1.0</data>
      <data key="d7">User-level threads suffer from system call blocking, where one blocked thread can halt the entire process.</data>
      <data key="d8">limitation,system integration</data>
      <data key="d9">chunk-34425c38108ef3730cc0889df3f8434a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793927</data>
    </edge>
    <edge source="User-Level Thread" target="Combination Thread Implementation">
      <data key="d6">1.0</data>
      <data key="d7">The combination implementation allows multiple user-level threads to map to kernel-level threads, enhancing scalability and control.</data>
      <data key="d8">flexibility,hybrid design</data>
      <data key="d9">chunk-34425c38108ef3730cc0889df3f8434a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793928</data>
    </edge>
    <edge source="Kernel-Level Thread" target="Multicore CPU Utilization">
      <data key="d6">1.0</data>
      <data key="d7">Kernel-level threads can leverage multicore CPUs by allowing multiple threads to run in parallel.</data>
      <data key="d8">parallelism,performance advantage</data>
      <data key="d9">chunk-34425c38108ef3730cc0889df3f8434a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793928</data>
    </edge>
    <edge source="Kernel-Level Thread" target="Combination Thread Implementation">
      <data key="d6">1.0</data>
      <data key="d7">The combination model uses kernel-level threads to manage system-level execution while maintaining user-level thread flexibility.</data>
      <data key="d8">hybrid design,resource management</data>
      <data key="d9">chunk-34425c38108ef3730cc0889df3f8434a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793928</data>
    </edge>
    <edge source="Thread State Transition" target="Thread Scheduling">
      <data key="d6">1.0</data>
      <data key="d7">Thread scheduling decisions trigger state transitions, such as moving a thread from ready to execution.</data>
      <data key="d8">scheduling logic,state change trigger</data>
      <data key="d9">chunk-34425c38108ef3730cc0889df3f8434a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793929</data>
    </edge>
    <edge source="Thread State Transition" target="Context Switching">
      <data key="d6">1.0</data>
      <data key="d7">Context switching is the operational mechanism that enables state transitions by saving and restoring thread states.</data>
      <data key="d8">execution handoff,state preservation</data>
      <data key="d9">chunk-34425c38108ef3730cc0889df3f8434a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793931</data>
    </edge>
    <edge source="Multithreading Model" target="Concurrency">
      <data key="d6">1.0</data>
      <data key="d7">The multithreading model improves system concurrency and throughput by enabling parallel thread execution.</data>
      <data key="d8">parallelism,performance enhancement</data>
      <data key="d9">chunk-e2c5907dce4f167e0b11853c616e448f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793930</data>
    </edge>
    <edge source="线程切换" target="用户态">
      <data key="d6">1.0</data>
      <data key="d7">Thread switching requires transitioning from user mode to kernel mode to perform system-level tasks.</data>
      <data key="d8">context switch,system operation</data>
      <data key="d9">chunk-f910452b3163456182b06ef94a84992f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793934</data>
    </edge>
    <edge source="线程切换" target="内核态">
      <data key="d6">1.0</data>
      <data key="d7">Thread switching necessitates a switch to kernel mode to allow the operating system to manage thread execution.</data>
      <data key="d8">kernel transition,system operation</data>
      <data key="d9">chunk-f910452b3163456182b06ef94a84992f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793934</data>
    </edge>
    <edge source="用户态" target="内核态">
      <data key="d6">1.0</data>
      <data key="d7">用户态and内核态represent different privilege levels in the processor, with transitions occurring via system calls or interrupts.</data>
      <data key="d8">mode transition,privilege level</data>
      <data key="d9">chunk-b7f639a9301d2ec0568bcbcad2dc3725</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794244</data>
    </edge>
    <edge source="内核态" target="系统调用">
      <data key="d6">1.0</data>
      <data key="d7">系统调用causes a transition to内核态to access privileged operating system services.</data>
      <data key="d8">mode transition,service request</data>
      <data key="d9">chunk-b7f639a9301d2ec0568bcbcad2dc3725</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794245</data>
    </edge>
    <edge source="组合方式" target="内核级线程">
      <data key="d6">1.0</data>
      <data key="d7">The combined approach relies on kernel-level threads for scheduling and execution, providing efficient system-level control.</data>
      <data key="d8">kernel support,thread management</data>
      <data key="d9">chunk-f910452b3163456182b06ef94a84992f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793934</data>
    </edge>
    <edge source="组合方式" target="用户级线程">
      <data key="d6">1.0</data>
      <data key="d7">The combined approach allows user programs to manage user-level threads independently, improving scheduling flexibility.</data>
      <data key="d8">thread management,user-level scheduling</data>
      <data key="d9">chunk-f910452b3163456182b06ef94a84992f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793935</data>
    </edge>
    <edge source="组合方式" target="系统开销">
      <data key="d6">1.0</data>
      <data key="d7">The combined model maintains lower system overhead by reusing kernel-level threads through time-sharing.</data>
      <data key="d8">balanced overhead,efficiency</data>
      <data key="d9">chunk-f910452b3163456182b06ef94a84992f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793937</data>
    </edge>
    <edge source="内核级线程" target="多对一模型">
      <data key="d6">1.0</data>
      <data key="d7">Each process is assigned only one kernel-level thread in the one-to-many model.</data>
      <data key="d8">mapping,single thread per process</data>
      <data key="d9">chunk-f910452b3163456182b06ef94a84992f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793936</data>
    </edge>
    <edge source="内核级线程" target="多对多模型">
      <data key="d6">1.0</data>
      <data key="d7">m kernel-level threads are used to execute multiple user-level threads, allowing efficient resource sharing.</data>
      <data key="d8">mapping,resource utilization</data>
      <data key="d9">chunk-f910452b3163456182b06ef94a84992f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793937</data>
    </edge>
    <edge source="内核级线程" target="并行执行">
      <data key="d6">1.0</data>
      <data key="d7">Multiple threads can run in parallel on multiple CPUs when managed by kernel-level threads.</data>
      <data key="d8">CPU utilization,parallelism</data>
      <data key="d9">chunk-f910452b3163456182b06ef94a84992f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793938</data>
    </edge>
    <edge source="内核级线程" target="一对一模型">
      <data key="d6">1.0</data>
      <data key="d7">There is a one-to-one correspondence between user-level and kernel-level threads.</data>
      <data key="d8">direct correspondence,mapping</data>
      <data key="d9">chunk-f910452b3163456182b06ef94a84992f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793938</data>
    </edge>
    <edge source="用户级线程" target="多对一模型">
      <data key="d6">1.0</data>
      <data key="d7">Multiple user-level threads are mapped to a single kernel-level thread, reducing the number of kernel resources needed.</data>
      <data key="d8">mapping,thread grouping</data>
      <data key="d9">chunk-f910452b3163456182b06ef94a84992f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793936</data>
    </edge>
    <edge source="用户级线程" target="一对一模型">
      <data key="d6">1.0</data>
      <data key="d7">Each user-level thread is directly mapped to a separate kernel-level thread, ensuring full concurrency.</data>
      <data key="d8">mapping,one-to-one relationship</data>
      <data key="d9">chunk-f910452b3163456182b06ef94a84992f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793936</data>
    </edge>
    <edge source="用户级线程" target="多对多模型">
      <data key="d6">1.0</data>
      <data key="d7">n user-level threads are dynamically mapped to m kernel-level threads (n ≥ m) to balance performance and resource usage.</data>
      <data key="d8">mapping,scalable concurrency</data>
      <data key="d9">chunk-f910452b3163456182b06ef94a84992f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793937</data>
    </edge>
    <edge source="多对一模型" target="线程阻塞">
      <data key="d6">1.0</data>
      <data key="d7">In the one-to-many model, blocking a thread may cause the entire process to block since only one kernel thread is available.</data>
      <data key="d8">blocking behavior,process-level impact</data>
      <data key="d9">chunk-f910452b3163456182b06ef94a84992f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793937</data>
    </edge>
    <edge source="一对一模型" target="线程阻塞">
      <data key="d6">1.0</data>
      <data key="d7">In the one-to-one model, blocking a thread does not prevent other threads from running, enabling better concurrency.</data>
      <data key="d8">blocking behavior,concurrency limitation</data>
      <data key="d9">chunk-f910452b3163456182b06ef94a84992f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793939</data>
    </edge>
    <edge source="一对一模型" target="系统开销">
      <data key="d6">1.0</data>
      <data key="d7">The one-to-one model incurs high system overhead due to the creation of a kernel-level thread for every user-level thread.</data>
      <data key="d8">creation overhead,resource cost</data>
      <data key="d9">chunk-f910452b3163456182b06ef94a84992f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793939</data>
    </edge>
    <edge source="多对多模型" target="时分多路复用">
      <data key="d6">1.0</data>
      <data key="d7">The multithreaded model uses time-division multiplexing to allow multiple user-level threads to share kernel-level threads efficiently.</data>
      <data key="d8">execution scheduling,thread sharing</data>
      <data key="d9">chunk-f910452b3163456182b06ef94a84992f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793937</data>
    </edge>
    <edge source="互斥条件" target="不可剥夺资源">
      <data key="d6">1.0</data>
      <data key="d7">不可剥夺资源需满足互斥条件，即同一时间只允许一个进程使用。</data>
      <data key="d8">exclusive access,resource property</data>
      <data key="d9">chunk-9aabe855c161e30442ff85ca7a64312e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793968</data>
    </edge>
    <edge source="互斥条件" target="打印机">
      <data key="d6">1.0</data>
      <data key="d7">打印机作为不可剥夺资源，必须满足互斥条件。</data>
      <data key="d8">exclusive access,resource example</data>
      <data key="d9">chunk-9aabe855c161e30442ff85ca7a64312e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793969</data>
    </edge>
    <edge source="互斥条件" target="死锁产生的必要条件">
      <data key="d6">1.0</data>
      <data key="d7">死锁产生的必要条件包括互斥条件，该条件要求资源在一段时间内只能由一个进程独占。</data>
      <data key="d8">deadlock prerequisite,necessary condition</data>
      <data key="d9">chunk-9aabe855c161e30442ff85ca7a64312e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793969</data>
    </edge>
    <edge source="请求和保持条件" target="死锁产生的必要条件">
      <data key="d6">1.0</data>
      <data key="d7">死锁产生的必要条件包括请求和保持条件，指进程占有资源后仍可请求新资源。</data>
      <data key="d8">deadlock prerequisite,necessary condition</data>
      <data key="d9">chunk-9aabe855c161e30442ff85ca7a64312e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793969</data>
    </edge>
    <edge source="不剥夺条件" target="死锁产生的必要条件">
      <data key="d6">1.0</data>
      <data key="d7">死锁产生的必要条件包括不剥夺条件，指已分配资源不能被强行收回。</data>
      <data key="d8">deadlock prerequisite,necessary condition</data>
      <data key="d9">chunk-9aabe855c161e30442ff85ca7a64312e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793970</data>
    </edge>
    <edge source="循环等待条件" target="过程资源的循环等待链">
      <data key="d6">1.0</data>
      <data key="d7">循环等待条件表现为进程资源的循环等待链。</data>
      <data key="d8">deadlock manifestation,logical structure</data>
      <data key="d9">chunk-9aabe855c161e30442ff85ca7a64312e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793970</data>
    </edge>
    <edge source="循环等待条件" target="死锁产生的必要条件">
      <data key="d6">1.0</data>
      <data key="d7">死锁产生的必要条件包括循环等待条件，即存在进程资源的循环等待链。</data>
      <data key="d8">deadlock prerequisite,necessary condition</data>
      <data key="d9">chunk-9aabe855c161e30442ff85ca7a64312e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761793971</data>
    </edge>
    <edge source="Scheduler" target="Queue Manager">
      <data key="d6">1.0</data>
      <data key="d7">The Queue Manager is a core component of the Scheduler, responsible for organizing processes into queues for selection.</data>
      <data key="d8">component integration</data>
      <data key="d9">chunk-491042f5eab097ef962a4657a4b61650</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794032</data>
    </edge>
    <edge source="Scheduler" target="Dispatcher">
      <data key="d6">1.0</data>
      <data key="d7">The Dispatcher is a key part of the Scheduler, responsible for executing the chosen process allocation.</data>
      <data key="d8">component integration</data>
      <data key="d9">chunk-491042f5eab097ef962a4657a4b61650</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794033</data>
    </edge>
    <edge source="Scheduler" target="Context Switcher">
      <data key="d6">1.0</data>
      <data key="d7">The Context Switcher is an integral function of the Scheduler, handling context preservation and restoration during process transitions.</data>
      <data key="d8">component integration</data>
      <data key="d9">chunk-491042f5eab097ef962a4657a4b61650</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794033</data>
    </edge>
    <edge source="Scheduler" target="User-Level Threads">
      <data key="d6">1.0</data>
      <data key="d7">In user-level threads, the Scheduler selects a process, and the process itself chooses which thread to run.</data>
      <data key="d8">thread scheduling</data>
      <data key="d9">chunk-491042f5eab097ef962a4657a4b61650</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794034</data>
    </edge>
    <edge source="Scheduler" target="Kernel-Level Threads">
      <data key="d6">1.0</data>
      <data key="d7">In kernel-level threads, the Scheduler directly selects and schedules a specific thread for execution.</data>
      <data key="d8">thread scheduling</data>
      <data key="d9">chunk-491042f5eab097ef962a4657a4b61650</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794035</data>
    </edge>
    <edge source="Context Switcher" target="CPU Registers">
      <data key="d6">1.0</data>
      <data key="d7">The Context Switcher restores the new process's CPU state by loading information into the CPU registers.</data>
      <data key="d8">context restoration</data>
      <data key="d9">chunk-491042f5eab097ef962a4657a4b61650</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794035</data>
    </edge>
    <edge source="Context Switcher" target="Load Store Instructions">
      <data key="d6">1.0</data>
      <data key="d7">Context switching involves significant execution of load and store instructions to save and restore register states, increasing system overhead.</data>
      <data key="d8">system overhead</data>
      <data key="d9">chunk-491042f5eab097ef962a4657a4b61650</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794035</data>
    </edge>
    <edge source="Priority Principle" target="Shortest Process First">
      <data key="d6">1.0</data>
      <data key="d7">The Priority Principle and Shortest Process First are scheduling criteria used to determine the order of process execution.</data>
      <data key="d8">scheduling criterion</data>
      <data key="d9">chunk-491042f5eab097ef962a4657a4b61650</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794033</data>
    </edge>
    <edge source="User-Level Threads" target="Kernel-Level Threads">
      <data key="d6">1.0</data>
      <data key="d7">User-Level and Kernel-Level Threads represent two distinct models of thread management, differing in kernel involvement.</data>
      <data key="d8">thread model</data>
      <data key="d9">chunk-491042f5eab097ef962a4657a4b61650</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794033</data>
    </edge>
    <edge source="进程控制" target="原语">
      <data key="d6">1.0</data>
      <data key="d7">进程控制的功能通过原语实现，原语是其基本执行单位。</data>
      <data key="d8">mechanism,system function</data>
      <data key="d9">chunk-7ca51faf7f3faf56c56ab18dd6458c7e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794047</data>
    </edge>
    <edge source="父进程" target="子进程">
      <data key="d6">1.0</data>
      <data key="d7">父进程可以创建子进程，子进程继承父进程的资源。</data>
      <data key="d8">creation,resource inheritance</data>
      <data key="d9">chunk-7ca51faf7f3faf56c56ab18dd6458c7e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794047</data>
    </edge>
    <edge source="子进程" target="资源回收">
      <data key="d6">1.0</data>
      <data key="d7">子进程在终止时需要将其从父进程获得的资源归还。</data>
      <data key="d8">resource release,termination</data>
      <data key="d9">chunk-7ca51faf7f3faf56c56ab18dd6458c7e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794048</data>
    </edge>
    <edge source="PCB" target="创建原语">
      <data key="d6">1.0</data>
      <data key="d7">创建原语在进程创建过程中会申请并初始化PCB。</data>
      <data key="d8">initialization,resource allocation</data>
      <data key="d9">chunk-7ca51faf7f3faf56c56ab18dd6458c7e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794047</data>
    </edge>
    <edge source="创建原语" target="就绪队列">
      <data key="d6">1.0</data>
      <data key="d7">创建成功后，新进程会被插入就绪队列等待调度。</data>
      <data key="d8">process scheduling,state transition</data>
      <data key="d9">chunk-7ca51faf7f3faf56c56ab18dd6458c7e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794048</data>
    </edge>
    <edge source="创建原语" target="终止原语">
      <data key="d6">1.0</data>
      <data key="d7">创建原语和终止原语共同构成进程生命周期管理的核心机制。</data>
      <data key="d8">process lifecycle,system operations</data>
      <data key="d9">chunk-7ca51faf7f3faf56c56ab18dd6458c7e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794049</data>
    </edge>
    <edge source="终止原语" target="运行态">
      <data key="d6">1.0</data>
      <data key="d7">若进程处于运行态，终止原语会立即停止其执行并释放CPU。</data>
      <data key="d8">CPU release,process termination</data>
      <data key="d9">chunk-7ca51faf7f3faf56c56ab18dd6458c7e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794047</data>
    </edge>
    <edge source="终止原语" target="级联终止">
      <data key="d6">1.0</data>
      <data key="d7">在某些系统中，父进程终止会导致所有子进程级联终止。</data>
      <data key="d8">system policy,termination behavior</data>
      <data key="d9">chunk-7ca51faf7f3faf56c56ab18dd6458c7e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794048</data>
    </edge>
    <edge source="终止原语" target="资源回收">
      <data key="d6">1.0</data>
      <data key="d7">终止原语负责回收进程所占用的资源。</data>
      <data key="d8">system resource management</data>
      <data key="d9">chunk-7ca51faf7f3faf56c56ab18dd6458c7e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794048</data>
    </edge>
    <edge source="阻塞原语" target="运行态">
      <data key="d6">1.0</data>
      <data key="d7">阻塞原语仅对处于运行态的进程生效，将其转为阻塞态。</data>
      <data key="d8">process suspension,state transition</data>
      <data key="d9">chunk-7ca51faf7f3faf56c56ab18dd6458c7e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794048</data>
    </edge>
    <edge source="阻塞原语" target="唤醒原语">
      <data key="d6">1.0</data>
      <data key="d7">阻塞原语和唤醒原语成对使用，用于进程间同步。</data>
      <data key="d8">complementary actions,synchronization</data>
      <data key="d9">chunk-7ca51faf7f3faf56c56ab18dd6458c7e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794050</data>
    </edge>
    <edge source="唤醒原语" target="就绪队列">
      <data key="d6">1.0</data>
      <data key="d7">唤醒原语将进程设置为就绪态并插入就绪队列。</data>
      <data key="d8">process scheduling,state transition</data>
      <data key="d9">chunk-7ca51faf7f3faf56c56ab18dd6458c7e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794050</data>
    </edge>
    <edge source="就绪队列" target="进程切换">
      <data key="d6">1.0</data>
      <data key="d7">The就绪队列holds processes ready for switching, and the scheduler selects the next process for switching from this queue.</data>
      <data key="d8">context planning,ready state management</data>
      <data key="d9">chunk-b7f639a9301d2ec0568bcbcad2dc3725</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794245</data>
    </edge>
    <edge source="Block" target="Wakeup">
      <data key="d6">1.0</data>
      <data key="d7">The Block and Wakeup methods are used in pairs to coordinate process execution, where Block causes a process to wait, and Wakeup resumes it.</data>
      <data key="d8">complementary behavior,process coordination</data>
      <data key="d9">chunk-62e7a5a2dcc4d8e5b08d9447994638c2</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794049</data>
    </edge>
    <edge source="Deadlock Prevention" target="Mutual Exclusion Condition">
      <data key="d6">1.0</data>
      <data key="d7">Deadlock prevention aims to break the mutual exclusion condition by enabling resource sharing, though this is not always feasible.</data>
      <data key="d8">prevention strategy,system design</data>
      <data key="d9">chunk-6de1df73d142ee13cb1e9512464e4e80</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794103</data>
    </edge>
    <edge source="Deadlock Prevention" target="Request and Hold Condition">
      <data key="d6">1.0</data>
      <data key="d7">Deadlock prevention addresses the request and hold condition through two protocols that regulate when and how resources are requested.</data>
      <data key="d8">prevention strategy,protocol implementation</data>
      <data key="d9">chunk-6de1df73d142ee13cb1e9512464e4e80</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794103</data>
    </edge>
    <edge source="Deadlock Prevention" target="No Preemption Condition">
      <data key="d6">1.0</data>
      <data key="d7">Deadlock prevention breaks the no preemption condition by requiring a process to release its resources if it cannot get new ones.</data>
      <data key="d8">prevention strategy,resource management</data>
      <data key="d9">chunk-6de1df73d142ee13cb1e9512464e4e80</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794103</data>
    </edge>
    <edge source="Deadlock Prevention" target="Circular Wait Condition">
      <data key="d6">1.0</data>
      <data key="d7">Deadlock prevention avoids the circular wait condition by using orderly resource allocation and resource numbering.</data>
      <data key="d8">ordering system,prevention strategy</data>
      <data key="d9">chunk-6de1df73d142ee13cb1e9512464e4e80</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794104</data>
    </edge>
    <edge source="Deadlock Prevention" target="First Protocol">
      <data key="d6">1.0</data>
      <data key="d7">The first protocol is a method used in deadlock prevention to ensure resources are requested in full at startup.</data>
      <data key="d8">implementation,resource request control</data>
      <data key="d9">chunk-6de1df73d142ee13cb1e9512464e4e80</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794104</data>
    </edge>
    <edge source="Deadlock Prevention" target="Second Protocol">
      <data key="d6">1.0</data>
      <data key="d7">The second protocol is a method used in deadlock prevention that allows incremental resource acquisition and release during execution.</data>
      <data key="d8">dynamic resource management,implementation</data>
      <data key="d9">chunk-6de1df73d142ee13cb1e9512464e4e80</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794104</data>
    </edge>
    <edge source="Deadlock Prevention" target="Orderly Resource Allocation">
      <data key="d6">1.0</data>
      <data key="d7">Orderly resource allocation prevents deadlock by eliminating circular wait through a fixed request order.</data>
      <data key="d8">cycle prevention,implementation</data>
      <data key="d9">chunk-6de1df73d142ee13cb1e9512464e4e80</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794105</data>
    </edge>
    <edge source="Orderly Resource Allocation" target="Resource Numbering">
      <data key="d6">1.0</data>
      <data key="d7">Resource numbering is essential for orderly resource allocation to enforce a consistent sequence in requests.</data>
      <data key="d8">dependency,resource management</data>
      <data key="d9">chunk-6de1df73d142ee13cb1e9512464e4e80</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794103</data>
    </edge>
    <edge source="Program Segment" target="Process Entity">
      <data key="d6">1.0</data>
      <data key="d7">The program segment is a core component of the process entity, representing the executable code.</data>
      <data key="d8">component,execution unit</data>
      <data key="d9">chunk-fd195ae7c40727c5b83fa7b77d72095e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794214</data>
    </edge>
    <edge source="Process Entity" target="Related Data Segment">
      <data key="d6">1.0</data>
      <data key="d7">The related data segment is a necessary part of the process entity, storing runtime data.</data>
      <data key="d8">component,data storage</data>
      <data key="d9">chunk-fd195ae7c40727c5b83fa7b77d72095e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794215</data>
    </edge>
    <edge source="Asynchrony" target="Process Synchronization Mechanism">
      <data key="d6">1.0</data>
      <data key="d7">The process synchronization mechanism is designed to address the problems caused by asynchrony and ensure predictable execution.</data>
      <data key="d8">coordination,corrective measure</data>
      <data key="d9">chunk-fd195ae7c40727c5b83fa7b77d72095e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794216</data>
    </edge>
    <edge source="进程切换" target="上下文切换">
      <data key="d6">1.0</data>
      <data key="d7">进程切换is implemented through the process of上下文切换, which is a fundamental operation in multitasking systems.</data>
      <data key="d8">core concept,operational mechanism</data>
      <data key="d9">chunk-b7f639a9301d2ec0568bcbcad2dc3725</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794244</data>
    </edge>
    <edge source="进程切换" target="阻塞队列">
      <data key="d6">1.0</data>
      <data key="d7">The阻塞队列holds processes awaiting events; they are not eligible for switching until unblocked.</data>
      <data key="d8">blocked state management,event waiting</data>
      <data key="d9">chunk-b7f639a9301d2ec0568bcbcad2dc3725</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794246</data>
    </edge>
    <edge source="上下文切换" target="进程PCB">
      <data key="d6">1.0</data>
      <data key="d7">上下文切换involves saving and restoring the CPU context into and from the进程PCB.</data>
      <data key="d8">context representation,data storage</data>
      <data key="d9">chunk-b7f639a9301d2ec0568bcbcad2dc3725</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794245</data>
    </edge>
    <edge source="上下文切换" target="CPU寄存器">
      <data key="d6">1.0</data>
      <data key="d7">During context switching, the values of CPU寄存器are saved and restored to preserve process state.</data>
      <data key="d8">hardware context,state preservation</data>
      <data key="d9">chunk-b7f639a9301d2ec0568bcbcad2dc3725</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794245</data>
    </edge>
    <edge source="上下文切换" target="程序计数器">
      <data key="d6">2.0</data>
      <data key="d7">The program counter is restored to resume execution from the correct instruction after context switching.&lt;SEP&gt;The程序计数器is part of the context that is saved and restored during context switching.</data>
      <data key="d8">control flow transfer,execution resumption,instruction state management</data>
      <data key="d9">chunk-b7f639a9301d2ec0568bcbcad2dc3725</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794246</data>
    </edge>
    <edge source="系统调用" target="系统调用处理程序">
      <data key="d6">1.0</data>
      <data key="d7">系统调用处理程序is the kernel component responsible for executing system calls.</data>
      <data key="d8">handler,responsible execution</data>
      <data key="d9">chunk-b7f639a9301d2ec0568bcbcad2dc3725</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794245</data>
    </edge>
    <edge source="系统调用" target="创建进程">
      <data key="d6">1.0</data>
      <data key="d7">创建进程is initiated via a system call that transitions the CPU into kernel mode.</data>
      <data key="d8">kernel execution,system-level initiation</data>
      <data key="d9">chunk-b7f639a9301d2ec0568bcbcad2dc3725</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794246</data>
    </edge>
    <edge source="系统调用" target="I/O操作">
      <data key="d6">1.0</data>
      <data key="d7">I/O操作is performed through system calls that invoke kernel functions for hardware interaction.</data>
      <data key="d8">kernel interface,resource access</data>
      <data key="d9">chunk-b7f639a9301d2ec0568bcbcad2dc3725</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794247</data>
    </edge>
    <edge source="调度" target="切换">
      <data key="d6">1.0</data>
      <data key="d7">调度precedes切换; scheduling decisions determine which process will be switched to.</data>
      <data key="d8">decision-execution relationship,sequential dependency</data>
      <data key="d9">chunk-b7f639a9301d2ec0568bcbcad2dc3725</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794244</data>
    </edge>
    <edge source="切换" target="多任务操作系统">
      <data key="d6">1.0</data>
      <data key="d7">切换is a necessary mechanism in a多任务操作系统to enable concurrent execution of multiple processes.</data>
      <data key="d8">required feature,system necessity</data>
      <data key="d9">chunk-b7f639a9301d2ec0568bcbcad2dc3725</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794245</data>
    </edge>
    <edge source="I/O操作" target="系统设备">
      <data key="d6">1.0</data>
      <data key="d7">I/O操作depends on系统设备to complete data transfer and device interaction.</data>
      <data key="d8">hardware dependency,operation support</data>
      <data key="d9">chunk-b7f639a9301d2ec0568bcbcad2dc3725</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794247</data>
    </edge>
    <edge source="CPU Utilization" target="CPU Scheduling Algorithm">
      <data key="d6">1.0</data>
      <data key="d7">The CPU scheduling algorithm directly influences how efficiently the CPU is utilized, aiming to keep it busy.</data>
      <data key="d8">performance optimization,resource management</data>
      <data key="d9">chunk-76ab4199a2aae3d8b4b3b6c270c34a12</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794300</data>
    </edge>
    <edge source="Turnaround Time" target="CPU Execution">
      <data key="d6">1.0</data>
      <data key="d7">Turnaround time is composed of CPU execution time among other phases.</data>
      <data key="d8">component relationship,time accumulation</data>
      <data key="d9">chunk-76ab4199a2aae3d8b4b3b6c270c34a12</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794301</data>
    </edge>
    <edge source="Turnaround Time" target="Job Submission">
      <data key="d6">1.0</data>
      <data key="d7">Turnaround time begins at the moment a job is submitted to the system.</data>
      <data key="d8">start point,temporal boundary</data>
      <data key="d9">chunk-76ab4199a2aae3d8b4b3b6c270c34a12</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794301</data>
    </edge>
    <edge source="Turnaround Time" target="Job Completion">
      <data key="d6">1.0</data>
      <data key="d7">Turnaround time ends when the job finishes execution.</data>
      <data key="d8">end point,temporal boundary</data>
      <data key="d9">chunk-76ab4199a2aae3d8b4b3b6c270c34a12</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794302</data>
    </edge>
    <edge source="Turnaround Time" target="CPU Scheduling Algorithm">
      <data key="d6">1.0</data>
      <data key="d7">The scheduling algorithm determines how quickly jobs progress through the system by managing waiting and execution times.</data>
      <data key="d8">job completion,timing impact</data>
      <data key="d9">chunk-76ab4199a2aae3d8b4b3b6c270c34a12</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794302</data>
    </edge>
    <edge source="Turnaround Time" target="Weighted Turnaround Time">
      <data key="d6">1.0</data>
      <data key="d7">Weighted turnaround time is derived by dividing turnaround time by actual execution time to normalize performance.</data>
      <data key="d8">execution ratio,normalized metric</data>
      <data key="d9">chunk-76ab4199a2aae3d8b4b3b6c270c34a12</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794302</data>
    </edge>
    <edge source="Response Time" target="Interactive System">
      <data key="d6">1.0</data>
      <data key="d7">Response time is a key performance criterion in interactive systems where timely feedback is essential.</data>
      <data key="d8">performance criterion,system requirement</data>
      <data key="d9">chunk-76ab4199a2aae3d8b4b3b6c270c34a12</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794301</data>
    </edge>
    <edge source="Response Time" target="CPU Scheduling Algorithm">
      <data key="d6">1.0</data>
      <data key="d7">In interactive systems, the scheduling algorithm is crucial for minimizing response time and improving user satisfaction.</data>
      <data key="d8">interactive performance,user experience</data>
      <data key="d9">chunk-76ab4199a2aae3d8b4b3b6c270c34a12</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794303</data>
    </edge>
  </graph>
</graphml>
