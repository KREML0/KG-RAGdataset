{
  "chunk-5f130d8e8cad5fdb4c75e49961444322": {
    "tokens": 586,
    "content": "16. 信号量 信号量机制是一种功能较强的机制, 可用来解决互斥与同步问题, 它只能被两个标准的原语wait()和 signal()访问, 也可简写为P()和V()。 原语是指完成某种功能且不被分割、不被中断执行的操作序列, 通常可由硬件来实现。 整型信号量 整型信号量被定义为一个用于表示资源数量的整型量S。在整型信号量机制中的wait 操作, 只要信号量S≤0, 就会不断循环测试。因此, 该机制并未遵循“让权等待”的准则, 而是使进程处于“忙等”的状态。 记录型信号量 记录型信号量机制是一种不存在“忙等”现象的进程同步机制。除了需要一个用于代表资源数量的整型变量value外, 再增加一个进程链表L, 用于链接所有等待该资源的进程。 对信号量S的一次P操作, 表示进程请求一个该类资源。当S.value<0时, 表示该类资源已分配完毕, 因此应调用 block 原语进行自我阻塞, 主动放弃CPU, 可见该机制遵循了“让权等待”准则。 对信号量S的一次V操作, 表示进程释放一个该类资源。若加1后仍是S.value≤0, 则表示仍有进程在等待该类资源, 因此应调用 wakeup 原语将S.L中的第一个进程唤醒。 利用信号量实现进程互斥 为了使多个进程能互斥地访问某个临界资源, 需要为该资源设置一个互斥信号量S, 其初值为1, 然后将各个进程访问该资源的临界区置于P(S)和V(S)之间。 利用信号量实现同步 要让本来异步的并发进程相互配合, 有序推进。为了实现这种同步关系, 需要设置一个同步信号量S, 其初值为0。 利用信号量实现前驱关系 信号量也可用来描述程序或语句之间的前驱关系。要为每对前驱关系设置一个同步信号量, 其初值均为0。在“前驱操作”之后, 对相应的同步信号量执行V操作, 在“后继操作”之前, 对相应的同步信号量执行P操作。",
    "chunk_order_index": 0,
    "full_doc_id": "doc-5f130d8e8cad5fdb4c75e49961444322",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:2b05480ef48ac49c40cd7f29306fd261",
      "default:extract:4264ea1a615b0151c81b6d58b5ba8e25"
    ],
    "create_time": 1761793345,
    "update_time": 1761793441,
    "_id": "chunk-5f130d8e8cad5fdb4c75e49961444322"
  },
  "chunk-1b524b2458aae3cb2440c44f7981f746": {
    "tokens": 1200,
    "content": "11. CPU 调度算法 先来先服务(FCFS)调度算法 FCFS 调度算法是一种最简单的调度算法, 它既可用于作业调度, 又可用于进程调度。 在作业调度中, FCFS调度算法每次从后备作业队列中选择最先进入该队列的一个或几个作业, 将它们调入内存, 分配必要的资源, 创建进程并放入就绪队列。 在进程调度中, FCFS调度算法每次从就绪队列中选择最先进入该队列的进程, 将CPU分配给它, 使之投入运行, 直到运行完成或因某种原因此阻塞时才释放CPU。 FCFS 调度算法属于不可剥夺算法。若一个长作业先到达系统, 就会使后面的许多短作业等待很长时间。 FCFS 调度算法的特点是算法简单, 但效率低;对长作业比较有利, 但对短作业不利;有利于CPU繁忙型作业, 而不利于1/0繁忙型作业。 短作业优先(SJF)调度算法 短作业(进程)优先调度算法是指对短作业(进程)优先调度的算法。短作业优先(SJF)调度算法从后备队列中选择一个或几个估计运行时间最短的作业;短进程优先(SPF)调度算法从就绪队列中选择一个估计运行时间最短的进程。 SJF 算法也存在不容忽视的缺点: 该算法对长作业不利。若有一长作业进入系统的后备队列, 由于调度程序总是优先调度那些(即使是后进来的)短作业, 将导致长作业长期不被调度, 产生饥饿现象。 该算法完全未考虑作业的紧迫程度, 因此不能保证紧迫性作业会被及时处理。 由于作业的长短是根据用户所提供的估计执行时间而定的, 而用户又可能有意或无意地缩短其作业的估计运行时间, 致使该算法不一定能真正做到短作业优先调度。 SPF 算法也可以是抢占式的。当一个新进程到达就绪队列时, 若其估计执行时间比当前进程的剩余时间小, 则立即暂停当前进程, 将CPU分配给新进程。因此, 抢占式SPF调度算法也称最短剩余时间优先调度算法。 高响应比优先调度算法 高响应比优先调度算法主要用于作业调度, 是对FCFS 调度算法和SJF 调度算法的一种综合平衡, 同时考虑了每个作业的等待时间和估计的运行时间。在每次进行作业调度时, 先计算后备作业队列中每个作业的响应比, 从中选出响应比最高的作业投入运行。 响应比 = (等待时间+要求服务时间) / 要求服务时间。 优先级调度算法 优先级调度算法既可用于作业调度, 又可用于进程调度。 根据新的更高优先级进程能否抢占正在执行的进程, 可将该调度算法分为如下两种: 非抢占式优先级调度算法。当一个进程正在CPU上运行时, 即使有某个优先级更高的进程进入就绪队列, 仍让正在运行的进程继续运行。 抢占式优先级调度算法。当一个进程正在CPU上运行时, 若有某个优先级更高的进程进入就绪队列, 则立即暂停正在运行的进程, 将CPU分配给优先级更高的进程。 根据进程创建后其优先级是否可以改变, 可将进程优先级分为以下两种: 静态优先级。优先级是在创建进程时确定的, 且在进程的整个运行期间保持不变。 动态优先级。创建进程时先赋予进程一个优先级, 但优先级会随进程的推进或等待时间的增加而改变。 一般来说, 进程优先级的设置可以参照以下原则: 系统进程 > 用户进程。 交互型进程 > 非交互型进程(或前台进程 > 后台进程)。 I/O型进程 > 计算型进程。 时间片轮转(RR)调度算法 时间片轮转(RR)调度算法主要适用于分时系统。这种算法最大的特点是公平, 系统将所有的就绪进程按FCFS策略排成一个就绪队列, 每隔一定的时间便产生一次时钟中断, 激活调度程序进行调度, 将CPU分配给就绪队列的队首进程, 并令其执行一个时间片。在执行完一个时间片后, 即使进程并未运行完成, 它也必须释放出(被剥夺",
    "chunk_order_index": 0,
    "full_doc_id": "doc-c98a5fa2e2c907903ada408db717755c",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:e868579fb9e26eb43d28a3ddb13091fb",
      "default:extract:19ff087dea7aaa044f4d350f805ecd3b"
    ],
    "create_time": 1761793345,
    "update_time": 1761793467,
    "_id": "chunk-1b524b2458aae3cb2440c44f7981f746"
  },
  "chunk-361e96af48cd5d95ba6650e6d3810455": {
    "tokens": 836,
    "content": "算法最大的特点是公平, 系统将所有的就绪进程按FCFS策略排成一个就绪队列, 每隔一定的时间便产生一次时钟中断, 激活调度程序进行调度, 将CPU分配给就绪队列的队首进程, 并令其执行一个时间片。在执行完一个时间片后, 即使进程并未运行完成, 它也必须释放出(被剥夺)CPU给就绪队列的新队首进程, 而被剥夺的进程返回到就绪队列的末尾重新排队, 等候再次运行。 在RR 调度算法中, 时间片的大小对系统性能的影响很大。若时间片足够大, 则时间片轮转调度算法就退化为先来先服务调度算法。若时间片很小, 则CPU将在进程间过于频繁地切换, 使CPU的开销增大。 多级队列调度算法 该算法在系统中设置多个就绪队列, 将不同类型或性质的进程固定分配到不同的就绪队列。每个队列可实施不同的调度算法。同一队列中的进程可以设置不同的优先级, 不同的队列本身也可以设置不同的优先级。 多级反馈队列调度算法(融合了前几种算法的优点) 多级反馈队列调度算法是时间片轮转调度算法和优先级调度算法的综合与发展。通过动态调整进程优先级和时间片大小, 多级反馈队列调度算法可以兼顾多方面的系统目标。 多级反馈队列调度算法的实现思想如下: 设置多个就绪队列, 并为每个队列赋予不同的优先级。第1级队列的优先级最高, 第2级队列的优先级次之, 其余队列的优先级逐个降低。 赋予各个队列的进程运行时间片的大小各不相同。在优先级越高的队列中, 每个进程的时间片就越小。 每个队列都采用FCFS算法。新进程进入内存后, 首先将它放入第1级队列的末尾。若它在一个时间片结束时尚未完成, 调度程序将其转入第2级队列的末尾等待调度;若它在第2级队列中运行一个时间片后仍未完成, 再将它放入第3级队列, 以此类推。 按队列优先级调度。仅当第1级队列为空时, 才调度第2级队列中的进程运行;仅当第1~i-1级队列均为空时, 才会调度第i级队列中的进程运行。若CPU正在执行第i级队列中的某个进程时, 又有新进程进入任何一个优先级较高的队列, 此时须立即将正在运行的进程放回到第i级队列的末尾, 而将CPU分配给新到的高优先级进程。 基于公平原则的调度算法 (1) 保证调度算法 保证调度算法向用户做出明确的性能保证。一种很实际且很容易实现的保证是:若系统中有n个用户登录, 则每个用户都保证获得1/n的CPU时间。 (2) 公平分享调度算法 保证对进程公平, 但并不意味着对用户也公平。公平分享调度算法保证所有用户能获得相同的CPU时间, 或所要求的时间比例。",
    "chunk_order_index": 1,
    "full_doc_id": "doc-c98a5fa2e2c907903ada408db717755c",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:60cb515f95624d64ff298cb6214f1a2b",
      "default:extract:0413470044dd4e42959ad567d72d49eb"
    ],
    "create_time": 1761793345,
    "update_time": 1761793439,
    "_id": "chunk-361e96af48cd5d95ba6650e6d3810455"
  },
  "chunk-d9ae7922752a96dfde647be32905f641": {
    "tokens": 838,
    "content": "14. 实现临界区互斥的基本方法 软件实现方法 在进入区设置并检查一些标志来标明是否有进程在临界区中, 若已有进程在临界区, 则在进入区通过循环检查进行等待, 进程离开临界区后则在退出区修改标志。 (1) 算法一:单标志法 该算法设置一个公用整型变量 turn, 指示允许进入临界区的进程编号。该算法可以实现每次只允许一个进程进入临界区。但两个进程必须交替进入临界区, 若某个进程不再进入临界区, 则另一个进程也将无法进入临界区(违背“空闲让进”准则)。 (2) 算法二:双标志先检查法 该算法设置一个布尔型数组flag[2], 用来标记各个进程想进入临界区的意愿。优点:不用交替进入, 可连续使用。缺点:P₀和 P₁ 可能同时进入临界区。 (3) 算法三:双标志后检查法 算法三先设置自己的标志, 再检查对方的标志, 若对方的标志为true, 则等待;否则, 进入临界区。两个进程都想进入时, 双方都争着进入临界区, 结果谁也进不了(违背“空闲让进”准则), 于是因各个进程都长期无法访问临界区而导致“饥饿”现象(违背“有限等待”准则)。 (4) 算法四:Peterson 算法 Peterson 算法结合了算法一和算法三的思想, 利用flag[]解决互斥访问问题, 而利用 turn 解决“饥饿”问题。若双方都争着进入临界区, 则可让进程将进入临界区的机会谦让给对方。 硬件实现方法 (1) 中断屏蔽方法 当一个进程正在执行它的临界区代码时, 防止其他进程进入其临界区的最简单方法是关中断。 这种方法的缺点:①限制了CPU 交替执行程序的能力, 因此系统效率会明显降低。②将关中断的权限交给用户则很不明智。③不适用于多处理器系统。 (2) 硬件指令方法——TestAndSet 指令 借助一条硬件指令 TestAndSet 指令(简称TS指令)实现互斥, 这条指令是原子操作。其功能是读出指定标志后将该标志设置为真。 相比于软件实现方法, TS指令将“加锁”和“检查”操作用硬件的方式变成了一气呵成的原子操作。缺点是, 暂时无法进入临界区的进程会占用CPU循环执行TS指令, 因此不能实现“让权等待”。 (3) 硬件指令方法——Swap 指令 Swap 指令的功能是交换两个字(字节)的内容。 用硬件指令方法实现互斥的优点:①简单、容易验证其正确性;②适用于任意数量的进程, 支持多处理器系统;③支持系统中有多个临界区。缺点:①等待进入临界区的进程会占用CPU执行while循环, 不能实现“让权等待”;②从等待进程中随机选择一个进程进入临界区, 有的进程可能一直选不上, 从而导致“饥饿”现象。",
    "chunk_order_index": 0,
    "full_doc_id": "doc-d9ae7922752a96dfde647be32905f641",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:d0b7398ae72dabddcd72840cefa3f8f9",
      "default:extract:84f63b5f370abd04db7d34e2a583ec01"
    ],
    "create_time": 1761793448,
    "update_time": 1761793549,
    "_id": "chunk-d9ae7922752a96dfde647be32905f641"
  },
  "chunk-77d7b8e6f06999efb089a2a4176d1434": {
    "tokens": 410,
    "content": "18. 管程 在信号量机制中, 每个要访问临界资源的进程都必须自备同步的PV操作, 大量分散的同步操作给系统管理带来了麻烦, 且容易因同步操作不当而导致系统死锁。于是, 便产生了一种新的进程同步工具——————管程。 管程的定义 利用共享数据结构抽象地表示系统中的共享资源, 而将对该数据结构实施的操作定义为一组过程。这个代表共享资源的数据结构, 以及由对该共享数据结构实施操作的一组过程所组成的资源管理程序, 称为管程(monitor)。 管程由4部分组成:①管程的名称;②局部于管程内部的共享数据结构说明;③对该数据结构进行操作的一组过程(或函数);④对局部于管程内部的共享数据设置初始值的语句。 管程将对共享资源的操作封装起来, 管程内的共享数据结构只能被管程内的过程所访问。每次仅允许一个进程进入管程, 从而实现进程互斥。 条件变量 当一个进程进入管程后被阻塞, 若该进程不释放管程, 则其他进程无法进入管程。为此, 将阻塞原因定义为条件变量 condition。每个条件变量保存了一个等待队列, 用于记录因该条件变量而阻塞的所有进程, 对条件变量只能进行两种操作, 即wait 和 signal。 x.wait:当x对应的条件不满足时, 正在调用管程的进程调用x.wait将自己插入x条件的等待队列, 并释放管程。 x.signal:x对应的条件发生了变化, 则调用x.signal, 唤醒一个因x条件而阻塞的进程。",
    "chunk_order_index": 0,
    "full_doc_id": "doc-77d7b8e6f06999efb089a2a4176d1434",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:bc87625f24a57e724a48d90a19aee026",
      "default:extract:c4d77275160b24e96ec2c3b39e3c1a21"
    ],
    "create_time": 1761793480,
    "update_time": 1761793536,
    "_id": "chunk-77d7b8e6f06999efb089a2a4176d1434"
  },
  "chunk-156e9bc4a555d2a7cb0d3724273d5ea6": {
    "tokens": 817,
    "content": "3. 进程的状态与转换 进程在其生命周期内, 由于系统中各个进程之间的相互制约及系统的运行环境的变化, 使得进程的状态也在不断地发生变化。通常进程有以下5种状态, 前3种是进程的基本状态。 运行态。进程正在CPU上运行。在单CPU中, 每个时刻只有一个进程处于运行态。 就绪态。进程获得了除CPU外的一切所需资源, 一旦得到CPU, 便可立即运行。系统中处于就绪态的进程可能有多个, 通常将它们排成一个队列, 称为就绪队列。 阻塞态, 也称等待态。进程正在等待某一事件而暂停运行, 如等待某个资源可用(不包括CPU)或等待1/0完成。即使CPU空闲, 该进程也不能运行。系统通常将处于阻塞态的进程也排成一个队列, 甚至根据阻塞原因的不同, 设置多个阻塞队列。 创建态。进程正在被创建, 尚未转到就绪态。创建进程需要多个步骤:首先申请一个空白PCB, 并向PCB中填写用于控制和管理进程的信息;然后为该进程分配运行时所必须的资源;最后将该进程转入就绪态并插入就绪队列。但是, 若进程所需的资源尚不能得到满足, 如内存不足, 则创建工作尚未完成, 进程此时所处的状态称为创建态。 终止态。进程正从系统中消失, 可能是进程正常结束或其他原因退出运行。进程需要结束运行时, 系统首先将该进程置为终止态, 然后进一步处理资源释放和回收等工作。 区分就绪态和阻塞态:就绪态是指进程仅缺少CPU, 只要获得CPU就立即运行;而阻塞态是指进程需要其他资源(除了CPU)或等待某一事件。 3种基本状态之间的转换如下: 就绪态→运行态:处于就绪态的进程被调度后, 获得CPU资源(分派CPU的时间片), 于是进程由就绪态转换为运行态。 运行态→就绪态:处于运行态的进程在时间片用完后, 不得不让出CPU, 从而进程由运行态转换为就绪态。此外, 在可剥夺的操作系统中, 当有更高优先级的进程就绪时, 调度程序将正在执行的进程转换为就绪态, 让更高优先级的进程执行。 运行态→阻塞态:进程请求某一资源(如外设)的使用和分配或等待某一事件的发生(如I/O 操作的完成)时, 它就从运行态转换为阻塞态。进程以系统调用的形式请求操作系统提供服务, 这是一种特殊的、由运行用户态程序调用操作系统内核过程的形式。 阻塞态→就绪态:进程等待的事件到来时, 如I/O操作完成或中断结束时, 中断处理程序必须将相应进程的状态由阻塞态转换为就绪态。 需要注意的是, 一个进程从运行态变为阻塞态是主动的行为, 而从阻塞态变为就绪态是被动的行为, 需要其他相关进程的协助。",
    "chunk_order_index": 0,
    "full_doc_id": "doc-156e9bc4a555d2a7cb0d3724273d5ea6",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:25aceac3850a22b97f7e59b08989affb",
      "default:extract:9e88a8675bcf742ff33e7a849b95a484"
    ],
    "create_time": 1761793541,
    "update_time": 1761793610,
    "_id": "chunk-156e9bc4a555d2a7cb0d3724273d5ea6"
  },
  "chunk-d3e84198ebbd072f7382ef600186508e": {
    "tokens": 634,
    "content": "17. 经典同步问题 生产者-消费者问题 问题描述:系统中有一组生产者进程和一组消费者进程, 生产者每次生产一个产品并放入缓冲区, 消费者每次从缓冲区中取出一个产品并消费。生产者和消费者共享一个初始为空、大小为n的缓冲区。只有当缓冲区不满时, 生产者才能将产品放入缓冲区;只有当缓冲区不空时, 消费者才能从中取出产品。缓冲区是临界资源, 各进程必须互斥访问。 问题分析:生产者和消费者对缓冲区的访问是互斥关系, 同时生产者和消费者又是一个相互协作的关系, 只有生产者生产之后, 消费者才能消费, 它们也是同步关系。 读者-写者问题 问题描述:有读者和写者两组并发进程, 共享一个文件, 当两个或以上的读进程同时访问共享数据时不会产生副作用, 但若某个写进程和其他进程(读进程或写进程)同时访问共享数据时则可能导致数据不一致的错误。因此要求:①允许多个读者可以同时对文件执行读操作;②只允许一个写者往文件中写信息;③任意一个写者在完成写操作之前不允许其他读者或写者工作;④写者执行写操作前, 应让已有的读者和写者全部退出。 问题分析:由题目分析读者和写者是互斥的, 写者和写者也是互斥的, 而读者和读者不存在互斥问题。 哲学家进餐问题 问题描述:一张圆桌边上坐着5名哲学家, 每两名哲学家之间的桌上摆一根筷子。饥饿的哲学家只有同时拿到了两根筷子才可以开始进餐。 问题分析:5名哲学家与左右邻居对其中间筷子的访问是互斥关系。本题的关键是如何让一名哲学家拿到左右两根筷子而不造成死锁或饥饿现象。 为防止死锁发生, 可对哲学家进程施加一些限制条件, 比如:①至多允许4名哲学家同时进餐;②仅当一名哲学家左右两边的筷子都可用时, 才允许他拿起筷子;③对哲学家顺序编号, 要求奇数号哲学家先拿左边的筷子, 然后拿右边的筷子, 而偶数号哲学家刚好相反。",
    "chunk_order_index": 0,
    "full_doc_id": "doc-d3e84198ebbd072f7382ef600186508e",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:678d100c3e6292d50860c29cc5288419",
      "default:extract:6742ba7d625bf880a1ee31909065a66d"
    ],
    "create_time": 1761793556,
    "update_time": 1761793633,
    "_id": "chunk-d3e84198ebbd072f7382ef600186508e"
  },
  "chunk-f326031f0d80f48ea7bc3e6da1a5f8a4": {
    "tokens": 377,
    "content": "12. 多处理机调度 多处理机系统的调度较单处理机系统复杂, 它与系统结构有关。 非对称多处理机(Asymmetric MultiProcessing, AMP)大多采用主从式操作系统, 内核驻留在主机上, 而从机上只运行用户程序, 进程调度由主机负责。 对称多处理机(Symmetric MultiProcessing,SMP)的所有处理机都是相同的, 因此由调度程序将任何一个进程分配给任何一个CPU。 亲和性和负载平衡 当一个进程从一个CPU移到其他CPU上时, 应将第一个CPU的缓存设置为无效, 然后重新填充第二个CPU的缓存, 这种操作的代价较高, 因此系统应尽量避免将进程从一个CPU 移到另一个CPU, 而应试图让一个进程运行在同一个CPU上, 这称为处理器亲和性。 对于SMP系统, 应尽量保证所有CPU的负载平衡(也称负载均衡)。 然而, 负载平衡通常会抵消处理器亲和性带来的好处。 多处理机调度方案 方案一:公共就绪队列 系统中仅设置一个公共就绪队列, 所有CPU共享同一个就绪队列。这种方案很好地实现了负载平衡, 但处理器亲和性不好。 方案二:私有就绪队列 系统为每个CPU设置一个私有就绪队列。这种方案很好地实现了处理器亲和性, 缺点是必须进行负载平衡。",
    "chunk_order_index": 0,
    "full_doc_id": "doc-f326031f0d80f48ea7bc3e6da1a5f8a4",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:60ae9a85f53311e43e851485d72e9d6e",
      "default:extract:9afa3950da721bb7343d623af5d37bbc"
    ],
    "create_time": 1761793617,
    "update_time": 1761793671,
    "_id": "chunk-f326031f0d80f48ea7bc3e6da1a5f8a4"
  },
  "chunk-e16dceff2fc93c138aa86eb65cacc6c7": {
    "tokens": 142,
    "content": "15. 互斥锁 解决临界区最简单的工具就是互斥锁(mutexlock)。一个进程在进入临界区时调用 acquire()函数, 以获得锁;在退出临界区时调用 release()函数, 以释放锁。每个互斥锁有一个布尔变量 available, 表示锁是否可用。 acquire()或 release()的执行必须是原子操作, 因此互斥锁通常采用硬件机制来实现。 上面描述的互斥锁也称自旋锁, 其主要缺点是忙等待。互斥锁通常用于多处理器系统。",
    "chunk_order_index": 0,
    "full_doc_id": "doc-e16dceff2fc93c138aa86eb65cacc6c7",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:f0b7159399c8478f1c7bae3ea6c1ec04",
      "default:extract:f60ce5a50e7f2d46a24f29d59ef84a56"
    ],
    "create_time": 1761793639,
    "update_time": 1761793680,
    "_id": "chunk-e16dceff2fc93c138aa86eb65cacc6c7"
  },
  "chunk-c39617d7522bbe85482a3d992382cd4b": {
    "tokens": 715,
    "content": "7. 调度的概念 调度的基本概念 在多道程序系统中, 进程的数量往往多于CPU的个数, 因此进程争用CPU的情况在所难免。 CPU 调度是对CPU进行分配, 即从就绪队列中按照一定的算法(公平、高效的原则)选择一个进程并将CPU分配给它运行, 以实现进程并发地执行。 CPU 调度是多道程序操作系统的基础, 是操作系统设计的核心问题。 调度的层次 一个作业从提交开始直到完成, 往往要经历以下三级调度。 (1) 高级调度(作业调度) 按照某种规则从外存上处于后备队列的作业中挑选一个(或多个), 给它(们)分配内存、I/O 设备等必要的资源, 并建立相应的进程, 以使它(们)获得竞争CPU的权利。简言之, 作业调度就是内存与辅存之间的调度。每个作业只调入一次、调出一次。 多道批处理系统中大多配有作业调度, 而其他系统中通常不需要配置作业调度。 (2) 中级调度(内存调度) 引入中级调度的目的是提高内存利用率和系统吞吐量。为此, 将那些暂时不能运行的进程调至外存等待, 此时进程的状态称为挂起态。当它们已具备运行条件且内存又稍有空闲时, 由中级调度来决定将外存上的那些已具备运行条件的挂起进程再重新调入内存, 并修改其状态为就绪态, 挂在就绪队列上等待。中级调度实际上是存储器管理中的对换功能。 (3) 低级调度(进程调度) 按照某种算法从就绪队列中选取一个进程, 将CPU 分配给它。进程调度是最基本的一种调度, 在各种操作系统中都必须配置这级调度。进程调度的频率很高, 一般几十毫秒一次。 三级调度的联系 作业调度从外存的后备队列中选择一批作业进入内存, 为它们建立进程, 这些进程被送入就绪队列, 进程调度从就绪队列中选出一个进程, 并将其状态改为运行态, 将CPU分配给它。中级调度是为了提高内存的利用率, 系统将那些暂时不能运行的进程挂起来。 作业调度为进程活动做准备, 进程调度使进程正常活动起来。 中级调度将暂时不能运行的进程挂起, 中级调度处于作业调度和进程调度之间。 作业调度次数少, 中级调度次数略多, 进程调度频率最高。 进程调度是最基本的, 不可或缺。",
    "chunk_order_index": 0,
    "full_doc_id": "doc-c39617d7522bbe85482a3d992382cd4b",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:ee532f6e67c263e68b73cffb9f234fbd",
      "default:extract:2d7b553c979274ea320b756753556e18"
    ],
    "create_time": 1761793675,
    "update_time": 1761793780,
    "_id": "chunk-c39617d7522bbe85482a3d992382cd4b"
  },
  "chunk-96612cb99be5ccc8684e38f3d50f77f5": {
    "tokens": 561,
    "content": "13. 同步与互斥的基本概念 在多道程序环境下, 进程是并发执行的, 不同进程之间存在着不同的相互制约关系。为了协调进程之间的相互制约关系, 引入了进程同步的概念。 临界资源 虽然多个进程可以共享系统中的各种资源, 但其中许多资源一次只能为一个进程所用, 我们将一次仅允许一个进程使用的资源称为临界资源。 对临界资源的访问, 必须互斥地进行, 在每个进程中, 访问临界资源的那段代码称为临界区。 为了保证临界资源的正确使用, 可将临界资源的访问过程分成4个部分: 进入区。为了进入临界区使用临界资源, 在进入区要检查可否进入临界区, 若能进入临界区, 则应设置正在访问临界区的标志, 以阻止其他进程同时进入临界区。 临界区。进程中访问临界资源的那段代码, 也称临界段。 退出区。将正在访问临界区的标志清除。 剩余区。代码中的其余部分。 同步 同步亦称直接制约关系, 是指为完成某种任务而建立的两个或多个进程, 这些进程因为需要协调它们的运行次序而等待、传递信息所产生的制约关系。同步关系源于进程之间的相互合作。 互斥 互斥也称间接制约关系。当一个进程进入临界区使用临界资源时, 另一个进程必须等待, 当占用临界资源的进程退出临界区后, 另一进程才允许去访问此临界资源。 为禁止两个进程同时进入临界区, 同步机制应遵循以下准则: 空闲让进。临界区空闲时, 可以允许一个请求进入临界区的进程立即进入临界区。 忙则等待。当已有进程进入临界区时, 其他试图进入临界区的进程必须等待。 有限等待。对请求访问的进程, 应保证能在有限时间内进入临界区, 防止进程无限等待。 让权等待(原则上应该遵循, 但非必须)。当进程不能进入临界区时, 应立即释放处理器, 防止进程忙等待。",
    "chunk_order_index": 0,
    "full_doc_id": "doc-96612cb99be5ccc8684e38f3d50f77f5",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:d76962dddbf56d738523fede676ea559",
      "default:extract:ee67895a9f78d7d93229900b4fcb8e0b"
    ],
    "create_time": 1761793684,
    "update_time": 1761793745,
    "_id": "chunk-96612cb99be5ccc8684e38f3d50f77f5"
  },
  "chunk-b5aa6485f08fa52f1ae6912e99884079": {
    "tokens": 229,
    "content": "22. 死锁检测和解除 死锁检测 死锁检测和解除是指系统在运行过程中, 能发现死锁的存在, 并能解除死锁。 为了能对系统是否已发生了死锁进行检测, 必须: 保存有关资源的请求和分配信息。 提供一种能利用这些信息去检测系统是否已进入死锁状态的算法。 死锁解除 死锁解除的主要方法有: 剥夺资源。从其他进程剥夺足够数量的资源给死锁进程, 以解除死锁状态。 撤销进程。最简单的方法是撤销全部死锁进程, 但代价太大。另一种方法是逐个撤销死锁进程, 直至死锁状态消除。 进程回退。让一个或多个进程回退到足以避免死锁的地步, 进程回退时自愿释放资源而不是被剥夺。要求系统保持进程的历史信息, 设置还原点。",
    "chunk_order_index": 0,
    "full_doc_id": "doc-b5aa6485f08fa52f1ae6912e99884079",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:b51463ce0a84dfb2a1a63c2778c83e6c",
      "default:extract:dbd499047070a478c35ac7b9429fef29"
    ],
    "create_time": 1761793750,
    "update_time": 1761793779,
    "_id": "chunk-b5aa6485f08fa52f1ae6912e99884079"
  },
  "chunk-fd78a6e2f6ac315b1d1c2a02efb03591": {
    "tokens": 218,
    "content": "21. 死锁避免 避免死锁同样是事先预防策略, 但它并不像死锁预防策略那样严格地限制进程对资源的访问, 而是在每次资源分配前, 先分析此次分配是否会使系统进入不安全状态, 若不会, 才将资源分配给它。 系统安全状态 所谓系统安全状态, 是指系统能按某种进程推进顺序, 为每个进程分配其所需资源, 直至满足每个进程对资源的最大需求, 使每个进程都可顺利地完成。 若系统无法找到这样一个安全序列, 则称系统处于不安全状态。 银行家算法 银行家算法是著名的死锁避免算法, 其思想是:操作系统视为银行家, 操作系统管理的资源视为银行家的资金, 进程向操作系统请求资源视为用户向银行家贷款。",
    "chunk_order_index": 0,
    "full_doc_id": "doc-fd78a6e2f6ac315b1d1c2a02efb03591",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:a2fe80f9c2494ec98d5cf301be641b17",
      "default:extract:dbfe8e0d0bde500df916a2a833d49d0b"
    ],
    "create_time": 1761793785,
    "update_time": 1761793823,
    "_id": "chunk-fd78a6e2f6ac315b1d1c2a02efb03591"
  },
  "chunk-d75ea791c964266b65c0ee55b3a8e15f": {
    "tokens": 1200,
    "content": "5. 进程的通信 进程通信是指进程之间的信息交换。PV操作(见2.3节)是低级通信方式, 高级通信方式是指以较高的效率传输大量数据的通信方式。高级通信方法主要有以下三类。 共享存储 在通信的进程之间存在一块可直接访问的共享空间, 通过对这片共享空间进行读/写操作实现进程之间的信息交换。在对共享空间进行读/写操作时, 需要使用同步互斥工具(如P操作、V操作)对共享空间的读/写进行控制。共享存储又分为两种:低级方式的共享是基于数据结构的共享:高级方式的共享则是基于存储区的共享。操作系统只负责为通信进程提供可共享使用的存储空间和同步互斥工具, 而数据交换则由用户自己安排读/写指令完成。 注意, 进程空间一般都是独立的, 进程运行期间一般不能访问其他进程的空间, 想让两个进程共享空间, 必须通过特殊的系统调用实现, 而进程内的线程是自然共享进程空间的。 消息传递 若通信的进程之间不存在可直接访问的共享空间, 则必须利用操作系统提供的消息传递方法实现进程通信。在消息传递系统中, 进程间的数据交换以格式化的消息(Message)为单位。进程通过操作系统提供的发送消息和接收消息两个原语进行数据交换。这种方式隐藏了通信实现细节, 使通信过程对用户透明, 简化了通信程序的设计, 是当前应用最广泛的进程间通信机制。在微内核操作系统中, 微内核与服务器之间的通信就采用了消息传递机制。该机制能很好地支持多CPU系统、分布式系统和计算机网络, 因此也成为这些领域最主要的通信工具。 直接通信方式。发送进程直接将消息发送给接收进程, 并将它挂在接收进程的消息缓冲队列上, 接收进程从消息缓冲队列中取得消息。 间接通信方式。发送进程将消息发送到某个中间实体, 接收进程从中间实体取得消息。这种中间实体一般称为信箱。该通信方式广泛应用于计算机网络中。 管道通信 管道是一个特殊的共享文件, 也称pipe文件, 数据在管道中是先进先出的。管道通信允许两个进程按生产者-消费者方式进行通信。为了协调双方的通信, 管道机制必须提供三方面的协调能力:①互斥, 指当一个进程对管道进行读/写操作时, 其他进程必须等待。②同步, 指写进程向管道写入一定数量的数据后, 写进程阻塞, 直到读进程取走数据后再将它唤醒; 读进程将管道中的数据取空后, 读进程阻塞, 直到写进程将数据写入管道后才将其唤醒。③确定对方的存在。 在Linux中, 管道是一种使用非常频繁的通信机制。从本质上说, 管道也是一种文件, 但它又和一般的文件有所不同, 管道可以克服使用文件进行通信的两个问题, 具体表现如下: 限制管道的大小。管道文件是一个固定大小的缓冲区, 在Linux中该缓冲区的大小为4KB, 这使得它的大小不像普通文件那样不加检验地增长。 读进程也可能工作得比写进程快。当管道内的数据已被读取时, 管道变空。当这种情况发生时, 一个随后的read()调用将被阻塞, 等待某些数据的写入。 管道只能由创建进程所访问, 当父进程创建一个管道后, 管道是一种特殊文件, 子进程会继承父进程的打开文件, 因此子进程也继承父进程的管道, 并可用它来与父进程进行通信。 从管道读数据是一次性操作, 数据一旦被读取, 就释放空间以便写更多数据。普通管道只允许单向通信, 若要实现两个进程双向通信, 则需要定义两个管道。 信号 信号(Signal)是一种用于通知进程发生了某个事件的机制。不同的系统事件对应不同的信号类型, 每类信号对应一个序号。 在进程的PCB中, 用至少位向量记录该进程的待处理信号。若给某个进程发送一个信号, 则把该类信号对应的位修改为1。一旦该信号被处理, 就把对应的位修改为0。此外, 还用另一个位向量记录被阻塞(被屏蔽)的信号。当某个位为1时, 表示该位对应的信号类型将被进程忽略, 无须响应。 信号的发送方式主要有两种: 内核给某个进程发送信号。当内核检测到某个特定的系统事件时, 就给进程发送信号。 一个进程给另一个进",
    "chunk_order_index": 0,
    "full_doc_id": "doc-3cb253a00dc29a6f3e799f512507d052",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:3b9849595a8b6c13913a0e544d24a6bf",
      "default:extract:6494226775f459b591165de3ff43f51d"
    ],
    "create_time": 1761793790,
    "update_time": 1761793859,
    "_id": "chunk-d75ea791c964266b65c0ee55b3a8e15f"
  },
  "chunk-c214e070db9e1fbcd76d28e9e144db30": {
    "tokens": 261,
    "content": "0。此外, 还用另一个位向量记录被阻塞(被屏蔽)的信号。当某个位为1时, 表示该位对应的信号类型将被进程忽略, 无须响应。 信号的发送方式主要有两种: 内核给某个进程发送信号。当内核检测到某个特定的系统事件时, 就给进程发送信号。 一个进程给另一个进程发送信号。进程可以调用kill函数, 要求内核发送一个信号给目的进程。 当操作系统把一个进程从内核态切换到用户态时会检查该进程是否有未被阻塞的待处理信号, 若有, 则强制进程接收信号并立即处理。信号的处理方式有两种: 执行默认的信号处理程序。操作系统为每类信号预设了默认的信号处理程序。 执行进程定义的信号处理程序。进程可为某类信号自定义信号处理程序。 信号处理程序运行结束后, 通常会返回进程的下一条指令继续执行。",
    "chunk_order_index": 1,
    "full_doc_id": "doc-3cb253a00dc29a6f3e799f512507d052",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:f3ff189cfe9944b97ab7a454b4673688",
      "default:extract:e3d7a46fad2732fff0469d9a2ab44362"
    ],
    "create_time": 1761793790,
    "update_time": 1761793856,
    "_id": "chunk-c214e070db9e1fbcd76d28e9e144db30"
  },
  "chunk-e2c5907dce4f167e0b11853c616e448f": {
    "tokens": 1200,
    "content": "6. 线程和多线程模型 线程的基本概念 引入进程的目的是更好地使多道程序并发执行, 提高资源利用率和系统吞吐量; 而引入线程(Threads)的目的则是减小程序在并发执行时所付出的时空开销, 提高操作系统的并发性能。 线程最直接的理解就是轻量级进程, 它是一个基本的CPU执行单元, 也是程序执行流的最小单元, 由线程ID、程序计数器、寄存器集合和堆栈组成。线程是进程中的一个实体, 是被系统独立调度和分派的基本单位, 线程自己不拥有系统资源, 只拥有一点儿在运行中必不可少的资源, 但它可与同属一个进程的其他线程共享进程所拥有的全部资源。一个线程可以创建和撤销另一个线程, 同一进程中的多个线程之间可以并发执行。由于线程之间相互制约, 致使线程在运行中呈现出间断性。线程也有就绪、阻塞和运行三种基本状态。 引入线程后, 进程的内涵发生了改变, 进程只作为除 CPU外的系统资源的分配单元, 而线程则作为CPU的分配单元。由于一个进程内部有多个线程, 若线程的切换发生在同一个进程内部, 则只需要很少的时空开销。 线程与进程的比较 调度。在传统的操作系统中, 拥有资源和独立调度的基本单位都是进程, 每次调度都要进行上下文切换, 开销较大。在引入线程的操作系统中, 线程是独立调度的基本单位, 而线程切换的代价远低于进程。在同一进程中, 线程的切换不会引起进程切换。但从一个进程中的线程切换到另一个进程中的线程时, 会引起进程切换。 并发性。在引入线程的操作系统中, 不仅进程之间可以并发执行, 一个进程中的多个线程之间也可并发执行, 甚至不同进程中的线程也能并发执行, 从而使操作系统具有更好的并发性, 提高了系统资源的利用率和系统的吞吐量。 拥有资源。进程是系统中拥有资源的基本单位, 而线程不拥有系统资源(仅有一点必不可少、能保证独立运行的资源), 但线程可以访问其隶属进程的系统资源, 这主要表现在属于同一进程的所有线程都具有相同的地址空间。 独立性。每个进程都拥有独立的地址空间和资源, 除了共享全局变量, 不允许其他进程访问。某个进程中的线程对其他进程不可见。同一进程中的不同线程是为了提高并发性及进行相互之间的合作而创建的, 它们共享进程的地址空间和资源。 系统开销。在创建或撤销进程时, 系统都要为之分配或回收进程控制块(PCB)及其他资源, 如内存空间、I/O设备等。操作系统为此所付出的开销, 明显大于创建或撤销线程时的开销。类似地, 在进程切换时涉及进程上下文的切换, 而线程切换时只需保存和设置少量寄存器内容, 开销很小。 支持多处理器系统。对于传统单线程进程, 不管有多少个CPU, 进程只能运行在一个CPU上。对于多线程进程, 可将进程中的多个线程分配到多个CPU上执行。 线程的属性 线程是一个轻型实体, 它不拥有系统资源, 但每个线程都应有一个唯一的标识符和一个线程控制块, 线程控制块记录线程执行的寄存器和栈等现场状态。 不同的线程可以执行相同的程序, 即同一个服务程序被不同的用户调用时, 操作系统将它们创建成不同的线程。 同一进程中的各个线程共享该进程所拥有的资源。 线程是CPU的独立调度单位, 多个线程是可以并发执行的。在单CPU的计算机系统中, 各线程可交替地占用CPU; 在多CPU的计算机系统中, 各线程可同时占用不同的CPU, 若各个CPU同时为一个进程内的各线程服务, 则可缩短进程的处理时间。 一个线程被创建后, 便开始了它的生命周期, 直至终止。线程在生命周期内会经历阻塞态、就绪态和运行态等各种状态变化。 线程的状态与转换 与进程一样, 各线程之间也存在共享资源和相互合作的制约关系, 致使线程在运行时也具有间断性。相应地, 线程在运行时也具有下面三种基本状态。 执行态:线程已获得CPU而正在运行。 就绪态:线程已具备各种执行条件, 只需再获得CPU便可立即执行。 阻塞态:线程在执行",
    "chunk_order_index": 0,
    "full_doc_id": "doc-487071d7bc0418a368cd03f9a4b87b27",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:3acfdbca4799f9dca22bab83484d1b97",
      "default:extract:33549280d96e8c2d10b7e7e35aa21dc6"
    ],
    "create_time": 1761793826,
    "update_time": 1761793896,
    "_id": "chunk-e2c5907dce4f167e0b11853c616e448f"
  },
  "chunk-34425c38108ef3730cc0889df3f8434a": {
    "tokens": 1200,
    "content": "的状态与转换 与进程一样, 各线程之间也存在共享资源和相互合作的制约关系, 致使线程在运行时也具有间断性。相应地, 线程在运行时也具有下面三种基本状态。 执行态:线程已获得CPU而正在运行。 就绪态:线程已具备各种执行条件, 只需再获得CPU便可立即执行。 阻塞态:线程在执行中因某事件受阻而处于暂停状态。 线程这三种基本状态之间的转换和进程基本状态之间的转换是一样的。 线程的组织与控制 (1) 线程控制块 与进程类似, 系统也为每个线程配置一个线程控制块TCB, 用于记录控制和管理线程的信息。线程控制块通常包括:①线程标识符;②一组寄存器, 包括程序计数器、状态寄存器和通用寄存器;③线程运行状态, 用于描述线程正处于何种状态;④优先级;⑤线程专有存储区, 线程切换时用于保存现场等;⑥堆栈指针, 用于过程调用时保存局部变量及返回地址等。 同一进程中的所有线程都能访问进程的地址空间和全局变量。但是, 每个线程都拥有自己的堆栈, 且互不共享。 (2) 线程的创建 线程也是具有生命期的, 它由创建而产生, 由调度而执行, 由终止而消亡。 用户程序启动时, 通常仅有一个称为初始化线程的线程正在执行, 其主要功能是用于创建新线程。在创建新线程时, 需要利用一个线程创建函数, 并提供相应的参数, 如指向线程主程序的入口指针、堆栈的大小、线程优先级等。线程创建函数执行完后, 将返回一个线程标识符。 (3) 线程的终止 当一个线程完成自己的任务后, 或线程在运行中出现异常而要被强制终止时, 由终止线程调用相应的函数执行终止操作。但是有些线程(主要是系统线程)一旦被建立, 便一直运行而不会被终止。通常, 线程被终止后并不立即释放它所占有的资源, 只有当进程中的其他线程执行了分离函数后, 被终止线程才与资源分离, 此时的资源才能被其他线程利用。 线程的实现方式 线程的实现可以分为两类: 用户级线程(User-Level Thread, ULT)和内核级线程(Kernel-Level Thread, KLT)。内核级线程也称内核支持的线程。 (1) 用户级线程(ULT) 在用户级线程中, 有关线程管理(创建、撤销和切换等)的所有工作都由应用程序在用户空间内(用户态)完成, 无须操作系统干预, 内核意识不到线程的存在。 这种实现方式的优点如下:①线程切换不需要转换到内核空间, 节省了模式切换的开销。②调度算法可以是进程专用的, 不同的进程可根据自身的需要, 对自己的线程选择不同的调度算法。③用户级线程的实现与操作系统平台无关, 对线程管理的代码是属于用户程序的一部分。 这种实现方式的缺点如下:①系统调用的阻塞问题, 当线程执行一个系统调用时, 不仅该线程被阻塞, 进程内的所有线程也都被阻塞。②不能发挥多CPU的优势, 内核每次分配给一个进程的仅有一个CPU, 因此进程中仅有一个线程能执行。 (2) 内核级线程(KLT) 在操作系统中, 无论是系统进程还是用户进程, 都是在操作系统内核的支持下运行的, 与内核紧密相关。内核级线程同样也是在内核的支持下运行的, 线程管理的所有工作也是在内核空间内(内核态)实现的。操作系统也为每个内核级线程设置一个线程控制块TCB, 内核根据该控制块感知某线程的存在, 并对其加以控制。 这种实现方式的优点如下:①能发挥多CPU的优势, 内核能同时调度同一进程中的多个线程并行执行。②若进程中的一个线程被阻塞, 则内核可以调度该进程中的其他线程占用CPU, 也可运行其他进程中的线程。③内核支持线程具有很小的数据结构和堆栈, 线程切换比较快、开销小。④内核本身也可采用多线程技术, 可以提高系统的执行速度和效率。 这种实现方式的缺点如下:同一进程中的线程切换, 需要从用户态转到内核态进行, 系统开销较大。 (3) 组合方式 有些系统使用组合方式的多线程实现。在组合实现方式中, 内核支持多个内核级线程的建立、调度和管理, 同时允许用户程序建立、调度和管理用户级线程。一些内核级线程对应多个用户级线程, 这是用户级线程通过时分多路复",
    "chunk_order_index": 1,
    "full_doc_id": "doc-487071d7bc0418a368cd03f9a4b87b27",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:82eb56dccc4207189a26e3f38d51ecb8",
      "default:extract:df6076456ab6a37e6a2aa6ba66059ebc"
    ],
    "create_time": 1761793826,
    "update_time": 1761793909,
    "_id": "chunk-34425c38108ef3730cc0889df3f8434a"
  },
  "chunk-f910452b3163456182b06ef94a84992f": {
    "tokens": 531,
    "content": "程中的线程切换, 需要从用户态转到内核态进行, 系统开销较大。 (3) 组合方式 有些系统使用组合方式的多线程实现。在组合实现方式中, 内核支持多个内核级线程的建立、调度和管理, 同时允许用户程序建立、调度和管理用户级线程。一些内核级线程对应多个用户级线程, 这是用户级线程通过时分多路复用内核级线程实现的。同一进程中的多个线程可以同时在多CPU上并行执行, 且在阻塞一个线程时不需要将整个进程阻塞, 所以组合方式能结合 KLT和ULT的优点, 并且克服各自的不足。 多线程模型 在同时支持用户级线程和内核级线程的系统中, 用户级线程和内核级线程连接方式的不同, 形成了下面三种不同的多线程模型。 多对一模型。将多个用户级线程映射到一个内核级线程。每个进程只被分配一个内核级线程, 线程的调度和管理在用户空间完成。 优点:线程管理是在用户空间进行的, 无须切换到内核态, 因此效率比较高。 缺点:若一个线程在访问内核时发生阻塞, 则整个进程都会被阻塞; 在任何时刻, 只有一个线程能够访问内核, 多个线程不能同时在多个CPU上运行。 一对一模型。将每个用户级线程映射到一个内核级线程。每个进程有与用户级线程数量相同的内核级线程, 线程切换由内核完成, 需要切换到内核态。 优点:当一个线程被阻塞后, 允许调度另一个线程运行, 所以并发能力较强。 缺点:每创建一个用户线程, 相应地就需要创建一个内核线程, 开销较大。 多对多模型。将n个用户级线程映射到m个内核级线程上, 要求n≥m。 特点:既克服了多对一模型并发度不高的缺点, 又克服了一对一模型的一个用户进程占用太多内核级线程而开销太大的缺点。此外, 还拥有上述两种模型各自的优点。",
    "chunk_order_index": 2,
    "full_doc_id": "doc-487071d7bc0418a368cd03f9a4b87b27",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:4f8c1d679a6c2f98f68bb659f649f9ab",
      "default:extract:fa669236b6a0aabf02d016b0e65f9f93"
    ],
    "create_time": 1761793826,
    "update_time": 1761793915,
    "_id": "chunk-f910452b3163456182b06ef94a84992f"
  },
  "chunk-9aabe855c161e30442ff85ca7a64312e": {
    "tokens": 508,
    "content": "19. 死锁的概念 死锁的定义 在多道程序系统中, 由于进程的并发执行, 极大地提升了系统效率。然而, 多个进程的并发执行也带来了新的问题——死锁。死锁, 是指多个进程因竞争资源而造成的一种僵局(互相等待), 若无外力干涉, 这些进程都将无法向前推进。 死锁和饥饿的共同点是进程无法顺利执行下去。 死锁和饥饿的主要差别:①死锁进程的集合中的每一个进程都在等待被该集合中的其他进程所占有的资源, 而饥饿的进程仅在等待被其他进程所占有的资源。②若有死锁现象, 则发生死锁的进程必然处于等待态, 也可能处于就绪态(长期得不到CPU)。 死锁产生的原因 (1) 系统资源的竞争 通常系统中拥有的不可剥夺资源, 其数量不足以满足多个进程运行的需要, 使得进程在运行过程中, 会因争夺资源而陷入僵局。 (2) 进程推进顺序非法 进程在运行过程中, 请求和释放资源的顺序不当, 也会导致产生进程死锁。 死锁产生的必要条件 产生死锁必须同时满足以下4个条件, 只要其中任一条件不成立, 死锁就不会发生。 互斥条件。进程要求对所分配的资源(如打印机)进行排他性控制, 即在一段时间内某资源仅为一个进程所占有。 请求和保持条件。进程所获得的资源在未使用完之前, 不能被其他进程强行夺走, 即使自己已占有的资源只能由自己来释放。 不剥夺条件。进程已获得的资源在未使用完之前, 不能被剥夺, 只能在使用完时由自己释放。 循环等待条件。存在一种进程资源的循环等待链, 链中每个进程已获得的资源同时被链中下一个进程所请求。",
    "chunk_order_index": 0,
    "full_doc_id": "doc-9aabe855c161e30442ff85ca7a64312e",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:385a201dd85921ff7f66d414bb03c214",
      "default:extract:384bbab0bdb5c256bbab6c110bcc0577"
    ],
    "create_time": 1761793870,
    "update_time": 1761793964,
    "_id": "chunk-9aabe855c161e30442ff85ca7a64312e"
  },
  "chunk-491042f5eab097ef962a4657a4b61650": {
    "tokens": 1105,
    "content": "8. 调度的实现 调度程序(调度器) 用于调度和分派CPU的组件称为调度程序, 它通常由三部分组成。 排队器。将系统中的所有就绪进程按照一定的策略排成一个或多个队列, 以便于调度程序选择。 分派器。依据调度程序所选的进程, 将其从就绪队列中取出, 将CPU分配给新进程。 上下文切换器。在对CPU进行切换时, 会发生两对上下文的切换操作:第一对, 将当前进程的上下文保存到其PCB中, 再装入分派程序的上下文, 以便分派程序运行;第二对, 移出分派程序的上下文, 将新选进程的CPU现场信息装入CPU的各个相应寄存器。 在上下文切换时, 需要执行大量load 和 store指令, 以保存寄存器的内容, 因此会花费较多时间。 调度的时机、切换与过程 现代操作系统中, 应该进行进程调度与切换的情况如下: 创建新进程后, 父进程和子进程都处于就绪态, 因此需要决定是运行父进程还是运行子进程。 进程正常结束或异常终止后, 必须从就绪队列中选择某个进程运行。 当进程因I/O请求、信号量操作或其他原因此被阻塞时, 必须调度其他进程运行。 当1/0设备准备就绪后, 发出I/O 中断, 原先等待I/O的进程从阻塞态变为就绪态, 此时需要决定是让新的就绪进程投入运行, 还是让中断发生时运行的进程继续执行。 不能进行进程的调度与切换的情况如下: 在处理中断的过程中。 需要完全屏蔽中断的原子操作过程中。 若在上述过程中发生了引起调度的条件, 则不能马上进行调度和切换, 应置系统的请求调度标志, 直到上述过程结束后才进行相应的调度与切换。 进程调度的方式 通常有以下两种进程调度方式: 非抢占调度方式, 也称非剥夺方式。是指当一个进程正在CPU上执行时, 即使有某个更为重要或紧迫的进程进入就绪队列, 仍然让正在执行的进程继续执行, 直到该进程运行完成或发生某种事件而进入阻塞态时, 才将CPU分配给其他进程。 非抢占调度方式的优点是实现简单、系统开销小, 适用于早期的批处理系统, 但它不能用于分时系统和大多数的实时系统。 抢占调度方式, 也称剥夺方式。是指当一个进程正在CPU上执行时, 若有某个更为重要或紧迫的进程需要使用CPU, 则允许调度程序根据某种原则去暂停正在执行的进程, 将CPU 分配给这个更为重要或紧迫的进程。 抢占调度方式对提高系统吞吐率和响应效率都有明显的好处。但“抢占”不是一种任意性行为, 必须遵循一定的原则, 主要有优先权、短进程优先和时间片原则等。 闲逛进程 当进程切换时, 若系统中没有就绪进程, 则会调度闲逛进程(Idle Process)运行, 它的PID为0。若没有其他进程就绪, 则该进程就一直运行, 并在指令周期后测试中断。闲逛进程的优先级最低, 没有就绪进程时才会运行闲逛进程, 只要有进程就绪, 就会立即让出CPU。 闲逛进程不需要CPU之外的资源, 它不会被阻塞。 两种线程的调度 用户级线程调度。因为内核并不知道线程的存在, 所以内核还是和以前一样, 选择一个进程, 并给予时间控制。由进程中的调度程序决定哪个线程运行。 内核级线程调度。内核选择一个特定线程运行, 通常不用考虑该线程属于哪个进程。对被选择的线程赋予一个时间片, 若超过了时间片, 则会强制挂起该线程。 用户级线程的线程切换在同一进程中进行, 仅需少量的机器指令; 内核级线程的线程切换需要完整的上下文切换、修改内存映像、使高速缓存失效, 这就导致了若干数量级的延迟。",
    "chunk_order_index": 0,
    "full_doc_id": "doc-491042f5eab097ef962a4657a4b61650",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:76b185ff3dabb518342a212d1431e63f",
      "default:extract:0355ff09a1daf75dc2914b58026a3659"
    ],
    "create_time": 1761793939,
    "update_time": 1761794028,
    "_id": "chunk-491042f5eab097ef962a4657a4b61650"
  },
  "chunk-78245f9f1818877740dc30da5ae2c6e1": {
    "tokens": 5,
    "content": "级的延迟。",
    "chunk_order_index": 1,
    "full_doc_id": "doc-491042f5eab097ef962a4657a4b61650",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:2171a77c864d02a761986215fc733260",
      "default:extract:555f19c0228c9b08f085ec7d77b984f4"
    ],
    "create_time": 1761793939,
    "update_time": 1761793941,
    "_id": "chunk-78245f9f1818877740dc30da5ae2c6e1"
  },
  "chunk-7ca51faf7f3faf56c56ab18dd6458c7e": {
    "tokens": 1188,
    "content": "4. 进程控制 进程控制的主要功能是对系统中的所有进程实施有效的管理, 它具有创建新进程、撤销已有进程、实现进程状态转换等功能。在操作系统中, 一般将进程控制用的程序段称为原语, 原语的特点是执行期间不允许中断, 它是一个不可分割的基本单位。 进程的创建 允许一个进程创建另一个进程, 此时创建者称为父进程, 被创建的进程称为子进程。子进程可以继承父进程所拥有的资源。当子进程终止时, 应将其从父进程那里获得的资源还给父进程。 在操作系统中, 终端用户登录系统、作业调度、系统提供服务、用户程序的应用请求等都会引起进程的创建。操作系统创建一个新进程的过程如下(创建原语): 为新进程分配一个唯一的进程标识号, 并申请一个空白PCB(PCB是有限的)。若PCB申请失败, 则创建失败。 为进程分配其运行所需的资源, 如内存、文件、I/O设备和CPU时间等(在PCB中体现)。这些资源或从操作系统获得, 或仅从其父进程获得。若资源不足(如内存), 则并不是创建失败, 而是处于创建态, 等待内存资源。 初始化PCB, 主要包括初始化标志信息、初始化CPU状态信息和初始化CPU控制信息,以及设置进程的优先级等。 若进程就绪队列能够接纳新进程, 则将新进程插入就绪队列, 等待被调度运行。 进程的终止 引起进程终止的事件主要有:①正常结束, 表示进程的任务已完成并准备退出运行。②异常结束, 表示进程在运行时, 发生了某种异常事件, 使程序无法继续运行, 如存储区越界、保护错、非法指令、特权指令错、运行超时、算术运算错、I/O故障等。③外界干预, 指进程应外界的请求而终止运行, 如操作员或操作系统干预、父进程请求和父进程终止。 操作系统终止进程的过程如下(终止原语): 根据被终止进程的标识符, 检索出该进程的PCB, 从中读出该进程的状态。 若被终止进程处于运行状态, 立即终止该进程的执行, 将CPU资源分配给其他进程。 若该进程还有子孙进程, 则通常需将其所有子孙进程终止(有些系统无此要求)。 将该进程所拥有的全部资源, 或归还给其父进程, 或归还给操作系统。 将该PCB从所在队列(链表)中删除。 有些系统不允许子进程在父进程终止的情况下存在, 对于这类系统, 若一个进程终止, 则它的所有子进程也终止, 这种现象称为级联终止。然而, 不是所有操作系统都是这么设计的。 进程的阻塞和唤醒 正在执行的进程, 由于期待的某些事件未发生, 如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新任务可做等, 进程便通过调用阻塞原语(Block), 使自己由运行态变为阻塞态。可见, 阻塞是进程自身的一种主动行为, 也因此只有处于运行态的进程(获得CPU), 才可能将其转为阻塞态。阻塞原语的执行过程如下: 找到将要被阻塞进程的标识号(PID)对应的PCB。 若该进程为运行态, 则保护其现场, 将其状态转为阻塞态, 停止运行。 将该PCB插入相应事件的等待队列, 将CPU资源调度给其他就绪进程。 当被阻塞进程所期待的事件出现时, 如它所期待的I/O操作已完成或其所期待的数据已到达, 由有关进程(比如, 释放该1/0设备的进程, 或提供数据的进程)调用唤醒原语(Wakeup), 将等待该事件的进程唤醒。唤醒原语的执行过程如下: 在该事件的等待队列中找到相应进程的PCB。 将其从等待队列中移出, 并置其状态为就绪态。 将该PCB插入就绪队列, 等待调度程序调度。 应当注意, Block 原语和 Wakeup 原语是一对作用刚好相反的原语, 必须成对使用。若在某个进程中调用了 Block原语, 则必须在与之合作的或其他相关的进程中安排一条相应的 Wakeup原语, 以便唤醒阻塞进程;否则, 阻塞进程将因不能被唤醒而永久地处于阻塞态。",
    "chunk_order_index": 0,
    "full_doc_id": "doc-7ca51faf7f3faf56c56ab18dd6458c7e",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:64e811fb0fcd63cc400033d9310203ae",
      "default:extract:94eed3327cd634a2a7ae08e73a75b00a"
    ],
    "create_time": 1761793972,
    "update_time": 1761794040,
    "_id": "chunk-7ca51faf7f3faf56c56ab18dd6458c7e"
  },
  "chunk-62e7a5a2dcc4d8e5b08d9447994638c2": {
    "tokens": 88,
    "content": "作用刚好相反的原语, 必须成对使用。若在某个进程中调用了 Block原语, 则必须在与之合作的或其他相关的进程中安排一条相应的 Wakeup原语, 以便唤醒阻塞进程;否则, 阻塞进程将因不能被唤醒而永久地处于阻塞态。",
    "chunk_order_index": 1,
    "full_doc_id": "doc-7ca51faf7f3faf56c56ab18dd6458c7e",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:7d8c19cfe86e5f1fd7de469643d00049",
      "default:extract:d7843e8d6b48bc92c315f669078c7fe7"
    ],
    "create_time": 1761793972,
    "update_time": 1761794004,
    "_id": "chunk-62e7a5a2dcc4d8e5b08d9447994638c2"
  },
  "chunk-2da376f0975743dcb0cc169c929cbe5c": {
    "tokens": 914,
    "content": "2. 进程的组成 进程是一个独立的运行单位, 也是操作系统进行资源分配和调度的基本单位。它由以下三部分组成, 其中最核心的是进程控制块(PCB)。 进程控制块 进程创建时, 操作系统为它新建一个PCB, 该结构之后常驻内存, 任意时刻都可以存取, 并在进程结束时删除。PCB是进程实体的一部分, 是进程存在的唯一标志。 进程执行时, 系统通过其PCB 了解进程的现行状态信息, 以便操作系统对其进行控制和管理; 进程结束时, 系统收回其PCB, 该进程随之消亡。 当操作系统希望调度某个进程运行时, 要从该进程的PCB中查出其现行状态及优先级; 在调度到某个进程后, 要根据其PCB中所保存的CPU状态信息, 设置该进程恢复运行的现场, 并根据其PCB中的程序和数据的内存始址, 找到其程序和数据; 进程在运行过程中, 当需要和与之合作的进程实现同步、通信或访问文件时, 也需要访问PCB; 当进程由于某种原因此暂停运行时, 又需将其断点的CPU环境保存在PCB中。可见, 在进程的整个生命期中, 系统总是通过PCB对进程进行控制的, 亦即系统唯有通过进程的PCB才能感知到该进程的存在。 PCB 主要包括进程描述信息、进程控制和管理信息、资源分配清单和CPU相关信息等。各部分的主要说明如下: 进程描述信息。进程标识符:标志各个进程, 每个进程都有一个唯一的标识号。用户标识符:进程所归属的用户, 用户标识符主要为共享和保护服务。 进程控制和管理信息。进程当前状态:描述进程的状态信息, 作为CPU分配调度的依据。进程优先级:描述进程抢占CPU的优先级, 优先级高的进程可优先获得CPU。 资源分配清单, 用于说明有关内存地址空间或虚拟地址空间的状况, 所打开文件的列表和所使用的输入/输出设备信息。 处理机相关信息, 也称CPU上下文, 主要指CPU中各寄存器的值。当进程处于执行态时, CPU的许多信息都在寄存器中。当进程被切换时, CPU状态信息都必须保存在相应的PCB中, 以便在该进程重新执行时, 能从断点继续执行。 在一个系统中, 通常存在着许多进程的PCB, 有的处于就绪态, 有的处于阻塞态, 而且阻塞的原因各不相同。为了方便进程的调度和管理, 需要将各个进程的PCB用适当的方法组织起来。目前, 常用的组织方式有链接方式和索引方式两种。链接方式将同一状态的PCB链接成一个队列, 不同状态对应不同的队列, 也可将处于阻塞态的进程的PCB, 根据其阻塞原因的不同, 排成多个阻塞队列。索引方式将同一状态的进程组织在一个索引表中, 索引表的表项指向相应的PCB, 不同状态对应不同的索引表, 如就绪索引表和阻塞索引表等。 程序段 程序段就是能被进程调度程序调度到CPU 执行的程序代码段。注意, 程序可被多个进程共享, 即多个进程可以运行同一个程序。 数据段 一个进程的数据段, 可以是进程对应的程序加工处理的原始数据, 也可以是程序执行时产生的中间或最终结果。",
    "chunk_order_index": 0,
    "full_doc_id": "doc-2da376f0975743dcb0cc169c929cbe5c",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:1f3cc7e6bccea354f8eadd2ac0123ea6",
      "default:extract:63189cbf3fd6c471432b4a18641bbeb1"
    ],
    "create_time": 1761794036,
    "update_time": 1761794158,
    "_id": "chunk-2da376f0975743dcb0cc169c929cbe5c"
  },
  "chunk-6de1df73d142ee13cb1e9512464e4e80": {
    "tokens": 331,
    "content": "20. 死锁预防 死锁预防的方法是使4个必要条件中的至少一个不能成立, 来预防死锁的发生。 破坏互斥条件 若允许系统资源都能共享使用, 则系统不会进入死锁状态。但有些资源根本不能同时共享, 故破坏互斥条件而预防死锁的方法不太可行。 破坏请求和保持条件 为了不致发生死锁, 必须保证当一个进程已保持了某些不可剥夺资源时, 便不能再请求其他任何资源。要做到这一点, 可采用两种协议: 第一种协议。所有进程在开始运行之前, 必须一次性地申请其在整个运行过程中所需的全部资源。 第二种协议。允许一个进程只获得运行初期所需的资源后, 便开始运行。进程运行过程中再逐步释放已分配到的、且已用毕的全部资源, 然后再请求新的所需资源。 破坏不剥夺条件 当一个已保持了某些资源的进程, 再提出新的资源请求而不能立即得到满足时, 必须释放它已保持的所有资源, 待以后需要时再重新申请。 破坏循环等待条件 为了破坏循环等待条件, 可采用顺序资源分配法。首先给系统中的资源编号, 规定每个进程必须按编号递增的顺序请求资源, 同类资源一次申请完。",
    "chunk_order_index": 0,
    "full_doc_id": "doc-6de1df73d142ee13cb1e9512464e4e80",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:9e9d60ceb56c7353a2f0f64cd3f71667",
      "default:extract:99ffd98f5b1ac00b04d4d637ff23cebb"
    ],
    "create_time": 1761794050,
    "update_time": 1761794100,
    "_id": "chunk-6de1df73d142ee13cb1e9512464e4e80"
  },
  "chunk-fd195ae7c40727c5b83fa7b77d72095e": {
    "tokens": 748,
    "content": "1. 进程的概念和特征 进程的概念 在多道程序环境下, 允许多个程序并发执行, 此时它们将失去封闭性, 并具有间断性及不可再现性的特征。为此引入了进程(Process)的概念, 以便更好地描述和控制程序的并发执行, 实现操作系统的并发性和共享性(最基本的两个特性)。 为了使参与并发执行的每个程序(含数据)都能独立地运行, 必须为之配置一个专门的数据结构, 称为进程控制块(Process Control Block,PCB)。系统利用PCB来描述进程的基本情况和运行状态, 进而控制和管理进程。相应地, 由程序段、相关数据段和PCB 三部分构成了进程实体(也称进程映像)。所谓创建进程, 就是创建进程的PCB; 而撤销进程, 就是撤销进程的PCB。 从不同的角度, 进程可以有不同的定义, 比较典型的定义有: 进程是一个正在执行程序的实例。 进程是一个程序及其数据从磁盘加载到内存后, 在CPU上的执行过程。 进程是一个具有独立功能的程序在一个数据集合上运行的过程。 引入进程实体的概念后, 我们可将传统操作系统中的进程定义为:“进程是进程实体的运行过程, 是系统进行资源分配和调度的一个独立单位。” 读者要准确理解这里说的系统资源。它指CPU、存储器和其他设备服务于某个进程的“时间”, 例如将CPU资源理解为CPU的时间片才是准确的。因为进程是这些资源分配和调度的独立单位, 即“时间片”分配的独立单位, 这就决定了进程一定是一个动态的、过程性的概念。 进程的特征 进程是由多道程序的并发执行而引出的, 它和程序是两个截然不同的概念。程序是静态的, 进程是动态的, 进程的基本特征是对比单个程序的顺序执行提出的。 动态性。进程是程序的一次执行, 它有着创建、活动、暂停、终止等过程, 具有一定的生命周期, 是动态地产生、变化和消亡的。动态性是进程最基本的特征。 并发性。指多个进程同存于内存中, 能在一段时间内同时运行。引入进程的目的就是使进程能和其他进程并发执行。并发性是进程的重要特征, 也是操作系统的重要特征。 独立性。指进程是一个能独立运行、独立获得资源和独立接受调度的基本单位。凡未建立PCB的程序, 都不能作为一个独立的单位参与运行。 异步性。由于进程的相互制约, 使得进程按各自独立的、不可预知的速度向前推进。异步性会导致执行结果的不可再现性, 为此在操作系统中必须配置相应的进程同步机制。",
    "chunk_order_index": 0,
    "full_doc_id": "doc-fd195ae7c40727c5b83fa7b77d72095e",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:82110729606cb997a3a99f3f0e9cb925",
      "default:extract:edfd69bf4a2a2f59f53ee810f03fced6"
    ],
    "create_time": 1761794105,
    "update_time": 1761794199,
    "_id": "chunk-fd195ae7c40727c5b83fa7b77d72095e"
  },
  "chunk-b7f639a9301d2ec0568bcbcad2dc3725": {
    "tokens": 499,
    "content": "10. 进程切换 对通常的进程而言, 其创建、撤销及要求由系统设备完成的I/O操作, 都是利用系统调用而进入内核, 再由内核中的相应处理程序予以完成的。进程切换同样是在内核的支持下实现的, 因此可以说, 任何进程都是在操作系统内核的支持下运行的, 是与内核紧密相关的。 (1) 上下文切换 切换 CPU到另一个进程需要保存当前进程状态并恢复另一个进程的状态, 这个任务称为上下文切换。进程上下文采用进程PCB表示, 包括CPU寄存器的值、进程状态和内存管理信息等。上下文切换的流程如下: 挂起一个进程, 将CPU上下文保存到PCB, 包括程序计数器和其他寄存器。 将进程的PCB移入相应的队列, 如就绪、在某事件阻塞等队列。 选择另一个进程执行, 并更新其PCB。 恢复新进程的CPU上下文。 跳转到新进程PCB中的程序计数器所指向的位置执行。 (2) 上下文切换的消耗 上下文切换通常是计算密集型的, 即它需要相当可观的CPU时间, 所以上下文切换对系统来说意味着消耗大量的CPU时间。 (3) 上下文切换与模式切换 模式切换与上下文切换是不同的, 模式切换时, CPU逻辑上可能还在执行同一进程。用户态和内核态之间的切换称为模式切换, 而不是上下文切换, 因为没有改变当前的进程。上下文切换只能发生在内核态, 它是多任务操作系统中的一个必需的特性。 调度和切换的区别:调度是指决定资源分配给哪个进程的行为, 是一种决策行为;切换是指实际分配的行为, 是执行行为。一般来说, 先有资源的调度, 然后才有进程的切换。",
    "chunk_order_index": 0,
    "full_doc_id": "doc-b7f639a9301d2ec0568bcbcad2dc3725",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:30fc8ab8c52780415c1cc1a87e0d7e35",
      "default:extract:fe9e41cf13e07560946bad74394bdcaf"
    ],
    "create_time": 1761794165,
    "update_time": 1761794241,
    "_id": "chunk-b7f639a9301d2ec0568bcbcad2dc3725"
  },
  "chunk-76ab4199a2aae3d8b4b3b6c270c34a12": {
    "tokens": 323,
    "content": "9. 调度的目标 为了比较CPU调度算法的性能, 人们提出了很多评价标准, 下面介绍其中主要的几种: CPU利用率。CPU是计算机系统中最重要和昂贵的资源之一, 所以应尽可能使CPU保持“忙”状态, 使这一资源利用率最高。 系统吞吐量。表示单位时间内CPU完成作业的数量。长作业需要消耗较长的CPU时间, 因此会降低系统的吞吐量。而对于短作业, 需要消耗的CPU时间较短, 因此能提高系统的吞吐量。 周转时间。指从作业提交到作业完成所经历的时间, 是作业等待、在就绪队列中排队、在CPU上运行及I/O操作所花费时间的总和。 周转时间 = 作业完成时间 - 作业提交时间 带权周转时间 = 作业周转时间 / 作业实际运行时间 等待时间。指进程处于等待CPU的时间之和, 等待时间越长, 用户满意度越低。CPU调度算法实际上并不影响作业执行或I/O操作的时间, 只影响作业在就绪队列中等待所花的时间。 响应时间。指从用户提交请求到系统首次产生响应所用的时间。在交互式系统中, 一般采用响应时间作为衡量调度算法的重要准则之一。",
    "chunk_order_index": 0,
    "full_doc_id": "doc-76ab4199a2aae3d8b4b3b6c270c34a12",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:b330153ffeaad486cdf07954c1f8a294",
      "default:extract:a1fd7fa95f418cc6d936d4d9e18b54e8"
    ],
    "create_time": 1761794217,
    "update_time": 1761794297,
    "_id": "chunk-76ab4199a2aae3d8b4b3b6c270c34a12"
  }
}