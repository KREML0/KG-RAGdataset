<?xml version='1.0' encoding='utf-8'?>
<graphml xmlns="http://graphml.graphdrawing.org/xmlns" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://graphml.graphdrawing.org/xmlns http://graphml.graphdrawing.org/xmlns/1.0/graphml.xsd">
  <key id="d11" for="edge" attr.name="created_at" attr.type="long" />
  <key id="d10" for="edge" attr.name="file_path" attr.type="string" />
  <key id="d9" for="edge" attr.name="source_id" attr.type="string" />
  <key id="d8" for="edge" attr.name="keywords" attr.type="string" />
  <key id="d7" for="edge" attr.name="description" attr.type="string" />
  <key id="d6" for="edge" attr.name="weight" attr.type="double" />
  <key id="d5" for="node" attr.name="created_at" attr.type="long" />
  <key id="d4" for="node" attr.name="file_path" attr.type="string" />
  <key id="d3" for="node" attr.name="source_id" attr.type="string" />
  <key id="d2" for="node" attr.name="description" attr.type="string" />
  <key id="d1" for="node" attr.name="entity_type" attr.type="string" />
  <key id="d0" for="node" attr.name="entity_id" attr.type="string" />
  <graph edgedefault="undirected">
    <node id="磁盘">
      <data key="d0">磁盘</data>
      <data key="d1">artifact</data>
      <data key="d2">A magnetic storage device that requires initialization and formatting before it can store data.&lt;SEP&gt;Disk is a storage device that supports high-speed data transfer and random access, classified as a block device and shared device in operating systems.</data>
      <data key="d3">chunk-c2534a02f1b3f01bcdf887749e6526e4&lt;SEP&gt;chunk-b97ef22d499b3d442bd72f94c0600b3e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796542</data>
    </node>
    <node id="扇区">
      <data key="d0">扇区</data>
      <data key="d1">artifact</data>
      <data key="d2">A small unit of storage on a disk, typically composed of a header, data area, and trailer, used for read/write operations.</data>
      <data key="d3">chunk-c2534a02f1b3f01bcdf887749e6526e4</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796227</data>
    </node>
    <node id="低级格式化">
      <data key="d0">低级格式化</data>
      <data key="d1">method</data>
      <data key="d2">A process that divides a disk into sectors, enabling the disk controller to perform read/write operations (also known as physical formatting).</data>
      <data key="d3">chunk-c2534a02f1b3f01bcdf887749e6526e4</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796227</data>
    </node>
    <node id="分区">
      <data key="d0">分区</data>
      <data key="d1">concept</data>
      <data key="d2">The process of dividing a disk into one or more logical sections called partitions, each defined by a starting sector and size.</data>
      <data key="d3">chunk-c2534a02f1b3f01bcdf887749e6526e4</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796227</data>
    </node>
    <node id="柱面">
      <data key="d0">柱面</data>
      <data key="d1">artifact</data>
      <data key="d2">A set of corresponding tracks on multiple disk platters, used in disk partitioning.</data>
      <data key="d3">chunk-c2534a02f1b3f01bcdf887749e6526e4</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796227</data>
    </node>
    <node id="磁盘主引导记录">
      <data key="d0">磁盘主引导记录</data>
      <data key="d1">artifact</data>
      <data key="d2">A special sector at the beginning of a disk that contains a partition table, boot code, and a flag indicating which partition to boot from.</data>
      <data key="d3">chunk-c2534a02f1b3f01bcdf887749e6526e4</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796227</data>
    </node>
    <node id="逻辑格式化">
      <data key="d0">逻辑格式化</data>
      <data key="d1">method</data>
      <data key="d2">A process that sets up a file system on a partition, including initializing free and allocated space, root directory, and managing free block information (also known as high-level formatting).</data>
      <data key="d3">chunk-c2534a02f1b3f01bcdf887749e6526e4</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796227</data>
    </node>
    <node id="簇">
      <data key="d0">簇</data>
      <data key="d1">concept</data>
      <data key="d2">A group of adjacent sectors combined to improve efficiency in data storage and access (called a block in Linux).</data>
      <data key="d3">chunk-c2534a02f1b3f01bcdf887749e6526e4</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796227</data>
    </node>
    <node id="自举程序">
      <data key="d0">自举程序</data>
      <data key="d1">artifact</data>
      <data key="d2">A small program that initializes hardware and loads the operating system kernel into memory during system startup.</data>
      <data key="d3">chunk-c2534a02f1b3f01bcdf887749e6526e4</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796228</data>
    </node>
    <node id="引导块">
      <data key="d0">引导块</data>
      <data key="d1">artifact</data>
      <data key="d2">A fixed-position area on a disk that stores the full boot program, enabling system startup after initial ROM code execution.</data>
      <data key="d3">chunk-c2534a02f1b3f01bcdf887749e6526e4</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796229</data>
    </node>
    <node id="启动磁盘">
      <data key="d0">启动磁盘</data>
      <data key="d1">artifact</data>
      <data key="d2">A disk with a bootable partition that can be used to start the operating system.</data>
      <data key="d3">chunk-c2534a02f1b3f01bcdf887749e6526e4</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796229</data>
    </node>
    <node id="系统磁盘">
      <data key="d0">系统磁盘</data>
      <data key="d1">artifact</data>
      <data key="d2">A synonym for a bootable disk that contains the operating system and can initiate system startup.</data>
      <data key="d3">chunk-c2534a02f1b3f01bcdf887749e6526e4</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796229</data>
    </node>
    <node id="主引导记录">
      <data key="d0">主引导记录</data>
      <data key="d1">artifact</data>
      <data key="d2">A sector at the beginning of a disk (sector 0) containing boot code, partition table, and boot flag (used in Windows systems).</data>
      <data key="d3">chunk-c2534a02f1b3f01bcdf887749e6526e4</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796229</data>
    </node>
    <node id="引导扇区">
      <data key="d0">引导扇区</data>
      <data key="d1">artifact</data>
      <data key="d2">The first sector of a bootable partition, loaded after the MBR, to continue the boot process.</data>
      <data key="d3">chunk-c2534a02f1b3f01bcdf887749e6526e4</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796229</data>
    </node>
    <node id="坏块">
      <data key="d0">坏块</data>
      <data key="d1">artifact</data>
      <data key="d2">A damaged sector on a disk that cannot be used for data storage.</data>
      <data key="d3">chunk-c2534a02f1b3f01bcdf887749e6526e4</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796229</data>
    </node>
    <node id="备用块">
      <data key="d0">备用块</data>
      <data key="d1">artifact</data>
      <data key="d2">A reserved sector used to replace a bad sector, maintaining data integrity through logical replacement.</data>
      <data key="d3">chunk-c2534a02f1b3f01bcdf887749e6526e4</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796229</data>
    </node>
    <node id="FAT表">
      <data key="d0">FAT表</data>
      <data key="d1">data</data>
      <data key="d2">A data structure used to track allocated and free clusters on a disk, particularly in FAT-based file systems.</data>
      <data key="d3">chunk-c2534a02f1b3f01bcdf887749e6526e4</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796230</data>
    </node>
    <node id="ROM">
      <data key="d0">ROM</data>
      <data key="d1">artifact</data>
      <data key="d2">A non-volatile memory chip that stores the initial bootstrap code used during system startup.&lt;SEP&gt;ROM (Read-Only Memory) is a type of non-volatile memory used to store fixed code, such as basic device driver functions.</data>
      <data key="d3">chunk-c2534a02f1b3f01bcdf887749e6526e4&lt;SEP&gt;chunk-264fa4087fad0830a27723388157eee3</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796330</data>
    </node>
    <node id="Windows系统">
      <data key="d0">Windows系统</data>
      <data key="d1">organization</data>
      <data key="d2">A computer operating system that stores boot code in the first sector of a disk, known as the Master Boot Record (MBR).</data>
      <data key="d3">chunk-c2534a02f1b3f01bcdf887749e6526e4</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796230</data>
    </node>
    <node id="Device Allocation">
      <data key="d0">Device Allocation</data>
      <data key="d1">concept</data>
      <data key="d2">Device allocation is the process of assigning physical devices to user I/O requests, aiming to maximize device utilization while preventing deadlock.</data>
      <data key="d3">chunk-8a037d4e5404d755e89072cf77091d2b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796243</data>
    </node>
    <node id="Device Control Table">
      <data key="d0">Device Control Table</data>
      <data key="d1">data</data>
      <data key="d2">Device Control Table (DCT) is a data structure that stores attributes of each physical device, including device type, identifier, status, pointer to controller table, retry count or time, and queue head pointer.</data>
      <data key="d3">chunk-8a037d4e5404d755e89072cf77091d2b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796243</data>
    </node>
    <node id="Controller Control Table">
      <data key="d0">Controller Control Table</data>
      <data key="d1">data</data>
      <data key="d2">Controller Control Table (COCT) is a data structure that stores information for managing each device controller, enabling the operating system to control and monitor controllers.</data>
      <data key="d3">chunk-8a037d4e5404d755e89072cf77091d2b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796243</data>
    </node>
    <node id="Channel Control Table">
      <data key="d0">Channel Control Table</data>
      <data key="d1">data</data>
      <data key="d2">Channel Control Table (CHCT) is a data structure that records the status and configuration of each I/O channel, allowing the operating system to manage channels efficiently.</data>
      <data key="d3">chunk-8a037d4e5404d755e89072cf77091d2b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796243</data>
    </node>
    <node id="System Device Table">
      <data key="d0">System Device Table</data>
      <data key="d1">data</data>
      <data key="d2">The system device table is a centralized record that tracks all physical devices available in the system, used in conjunction with user-specific LUTs.&lt;SEP&gt;System Device Table (SDT) is a global data structure that records all physical devices connected to the system, with one entry per physical device.</data>
      <data key="d3">chunk-1d93c6dce65e857b6ccef73c51291bd2&lt;SEP&gt;chunk-8a037d4e5404d755e89072cf77091d2b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796243</data>
    </node>
    <node id="Logical Unit Table">
      <data key="d0">Logical Unit Table</data>
      <data key="d1">data</data>
      <data key="d2">The Logical Unit Table (LUT) is a system component that maps logical device names to physical device names and device driver entry addresses.&lt;SEP&gt;Logical Unit Table (LUT) maps logical device names to physical device names and contains the entry address of the device driver.</data>
      <data key="d3">chunk-1d93c6dce65e857b6ccef73c51291bd2&lt;SEP&gt;chunk-8a037d4e5404d755e89072cf77091d2b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796243</data>
    </node>
    <node id="Physical Device">
      <data key="d0">Physical Device</data>
      <data key="d1">artifact</data>
      <data key="d2">Physical Device is a tangible hardware component connected to the system that can be allocated for I/O operations.</data>
      <data key="d3">chunk-8a037d4e5404d755e89072cf77091d2b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796243</data>
    </node>
    <node id="Controller">
      <data key="d0">Controller</data>
      <data key="d1">artifact</data>
      <data key="d2">Controller is a hardware component that manages one or more physical devices and interfaces between the processor and devices.</data>
      <data key="d3">chunk-8a037d4e5404d755e89072cf77091d2b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796243</data>
    </node>
    <node id="Channel">
      <data key="d0">Channel</data>
      <data key="d1">artifact</data>
      <data key="d2">Channel is a communication path between the processor and device controller, enabling data transfer.</data>
      <data key="d3">chunk-8a037d4e5404d755e89072cf77091d2b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796244</data>
    </node>
    <node id="Process Control Block">
      <data key="d0">Process Control Block</data>
      <data key="d1">data</data>
      <data key="d2">Process Control Block (PCB) is a data structure that stores the state and information of a process, including its I/O wait status.</data>
      <data key="d3">chunk-8a037d4e5404d755e89072cf77091d2b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796244</data>
    </node>
    <node id="I/O Request">
      <data key="d0">I/O Request</data>
      <data key="d1">concept</data>
      <data key="d2">I/O Request is a user-level or system-level request for input/output operations on a device, triggering device allocation.</data>
      <data key="d3">chunk-8a037d4e5404d755e89072cf77091d2b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796244</data>
    </node>
    <node id="Exclusive Device">
      <data key="d0">Exclusive Device</data>
      <data key="d1">concept</data>
      <data key="d2">Exclusive Device is a type of device that can be allocated to only one process at a time and remains with that process until released.</data>
      <data key="d3">chunk-8a037d4e5404d755e89072cf77091d2b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796244</data>
    </node>
    <node id="Shared Device">
      <data key="d0">Shared Device</data>
      <data key="d1">concept</data>
      <data key="d2">Shared Device is a type of device that can be concurrently accessed by multiple processes, requiring proper scheduling.</data>
      <data key="d3">chunk-8a037d4e5404d755e89072cf77091d2b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796244</data>
    </node>
    <node id="Virtual Device">
      <data key="d0">Virtual Device</data>
      <data key="d1">concept</data>
      <data key="d2">Virtual Device is a software-implemented device that behaves like a shared device, allowing multiple processes to use it simultaneously.</data>
      <data key="d3">chunk-8a037d4e5404d755e89072cf77091d2b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796244</data>
    </node>
    <node id="FCFS Algorithm">
      <data key="d0">FCFS Algorithm</data>
      <data key="d1">method</data>
      <data key="d2">FCFS Algorithm is a device allocation strategy that assigns devices to processes based on the order of their I/O requests, first-come, first-served.</data>
      <data key="d3">chunk-8a037d4e5404d755e89072cf77091d2b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796244</data>
    </node>
    <node id="Highest Priority First Algorithm">
      <data key="d0">Highest Priority First Algorithm</data>
      <data key="d1">method</data>
      <data key="d2">Highest Priority First Algorithm is a device allocation method that prioritizes processes with higher priority, using FCFS among equal-priority requests.</data>
      <data key="d3">chunk-8a037d4e5404d755e89072cf77091d2b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796244</data>
    </node>
    <node id="Safe Allocation Method">
      <data key="d0">Safe Allocation Method</data>
      <data key="d1">method</data>
      <data key="d2">Safe Allocation Method ensures deadlock prevention by blocking a process until its I/O operation completes, resulting in serial CPU and I/O execution.</data>
      <data key="d3">chunk-8a037d4e5404d755e89072cf77091d2b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796246</data>
    </node>
    <node id="Unsafe Allocation Method">
      <data key="d0">Unsafe Allocation Method</data>
      <data key="d1">method</data>
      <data key="d2">Unsafe Allocation Method allows processes to continue running after sending I/O requests, potentially leading to deadlock but enabling concurrent device usage.</data>
      <data key="d3">chunk-8a037d4e5404d755e89072cf77091d2b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796246</data>
    </node>
    <node id="Device Queue">
      <data key="d0">Device Queue</data>
      <data key="d1">data</data>
      <data key="d2">Device Queue is a waiting list for processes that are awaiting device allocation, managed based on allocation strategy.&lt;SEP&gt;Device queue is a waiting list for I/O requests when a device is busy, managed by the device driver.</data>
      <data key="d3">chunk-264fa4087fad0830a27723388157eee3&lt;SEP&gt;chunk-8a037d4e5404d755e89072cf77091d2b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796330</data>
    </node>
    <node id="Controller Queue">
      <data key="d0">Controller Queue</data>
      <data key="d1">concept</data>
      <data key="d2">Controller Queue is a waiting list for processes waiting for a controller to become available.</data>
      <data key="d3">chunk-8a037d4e5404d755e89072cf77091d2b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796246</data>
    </node>
    <node id="Channel Queue">
      <data key="d0">Channel Queue</data>
      <data key="d1">concept</data>
      <data key="d2">Channel Queue is a waiting list for processes awaiting channel availability during device allocation.</data>
      <data key="d3">chunk-8a037d4e5404d755e89072cf77091d2b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796246</data>
    </node>
    <node id="Logical Device Name">
      <data key="d0">Logical Device Name</data>
      <data key="d1">concept</data>
      <data key="d2">The logical device name is a user-defined identifier for a device that is used to reference the device in the system.&lt;SEP&gt;Logical Device Name is an abstract identifier used by processes to request I/O operations, independent of physical device identity.</data>
      <data key="d3">chunk-1d93c6dce65e857b6ccef73c51291bd2&lt;SEP&gt;chunk-8a037d4e5404d755e89072cf77091d2b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796246</data>
    </node>
    <node id="Physical Device Name">
      <data key="d0">Physical Device Name</data>
      <data key="d1">data</data>
      <data key="d2">The physical device name refers to the actual hardware device name recognized by the system.&lt;SEP&gt;Physical Device Name is the real, unique identifier of a physical hardware device recognized by the operating system.&lt;SEP&gt;Physical device name is the actual identifier of a hardware device used to access its driver.</data>
      <data key="d3">chunk-1d93c6dce65e857b6ccef73c51291bd2&lt;SEP&gt;chunk-264fa4087fad0830a27723388157eee3&lt;SEP&gt;chunk-8a037d4e5404d755e89072cf77091d2b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796330</data>
    </node>
    <node id="Device Driver">
      <data key="d0">Device Driver</data>
      <data key="d1">method</data>
      <data key="d2">Device Driver is a software component that enables communication between the operating system and a physical device.&lt;SEP&gt;Device driver is a communication program between the I/O system and device controller, responsible for translating abstract I/O requests into specific commands and managing device operations.</data>
      <data key="d3">chunk-264fa4087fad0830a27723388157eee3&lt;SEP&gt;chunk-8a037d4e5404d755e89072cf77091d2b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796329</data>
    </node>
    <node id="System Device Table Entry">
      <data key="d0">System Device Table Entry</data>
      <data key="d1">data</data>
      <data key="d2">System Device Table Entry is a record in the System Device Table that describes a single physical device's configuration and status.</data>
      <data key="d3">chunk-8a037d4e5404d755e89072cf77091d2b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796246</data>
    </node>
    <node id="Device Driver Entry Address">
      <data key="d0">Device Driver Entry Address</data>
      <data key="d1">concept</data>
      <data key="d2">The device driver entry address is the memory location where the device driver code begins, enabling system access to the physical device.</data>
      <data key="d3">chunk-1d93c6dce65e857b6ccef73c51291bd2</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796247</data>
    </node>
    <node id="Single System LUT">
      <data key="d0">Single System LUT</data>
      <data key="d1">method</data>
      <data key="d2">The single system LUT is a configuration where only one LUT exists for the entire system, sharing device assignments across all processes.</data>
      <data key="d3">chunk-1d93c6dce65e857b6ccef73c51291bd2</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796248</data>
    </node>
    <node id="User-Specific LUT">
      <data key="d0">User-Specific LUT</data>
      <data key="d1">method</data>
      <data key="d2">The user-specific LUT is a configuration where each user has an individual LUT, allowing independent device naming and assignment.</data>
      <data key="d3">chunk-1d93c6dce65e857b6ccef73c51291bd2</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796248</data>
    </node>
    <node id="Single User System">
      <data key="d0">Single User System</data>
      <data key="d1">concept</data>
      <data key="d2">A single user system is an environment where only one user operates at a time, requiring unique logical device names to avoid conflicts.</data>
      <data key="d3">chunk-1d93c6dce65e857b6ccef73c51291bd2</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796248</data>
    </node>
    <node id="Multi User System">
      <data key="d0">Multi User System</data>
      <data key="d1">concept</data>
      <data key="d2">A multi user system is an environment where multiple users operate simultaneously, allowing duplicate logical device names when using separate LUTs per user.</data>
      <data key="d3">chunk-1d93c6dce65e857b6ccef73c51291bd2</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796248</data>
    </node>
    <node id="设备独立性软件">
      <data key="d0">设备独立性软件</data>
      <data key="d1">softwarelayer</data>
      <data key="d2">设备独立性软件，也称与设备无关的软件，是I/O系统的最高层软件，负责执行所有设备的公有操作。&lt;SEP&gt;Device independence software offers a uniform interface between user programs and device drivers, manages device naming, protection, allocation, and release, and supports device management and data transfer.</data>
      <data key="d3">chunk-1e6791234c2dc9ee6f432df1989fc60b&lt;SEP&gt;chunk-f8acab16bd51fe8f837419ef179fc637</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796532</data>
    </node>
    <node id="设备驱动程序">
      <data key="d0">设备驱动程序</data>
      <data key="d1">softwarelayer</data>
      <data key="d2">设备驱动程序是I/O系统中位于设备独立性软件下层的软件组件，负责与特定硬件设备交互。&lt;SEP&gt;Device driver is a hardware-specific program that executes system commands to drive I/O devices and serves as the communication bridge between I/O processes and device controllers.</data>
      <data key="d3">chunk-1e6791234c2dc9ee6f432df1989fc60b&lt;SEP&gt;chunk-f8acab16bd51fe8f837419ef179fc637</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796532</data>
    </node>
    <node id="I/O系统">
      <data key="d0">I/O系统</data>
      <data key="d1">concept</data>
      <data key="d2">I/O系统是计算机系统中负责管理输入与输出操作的核心架构。</data>
      <data key="d3">chunk-f8acab16bd51fe8f837419ef179fc637</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796257</data>
    </node>
    <node id="操作系统">
      <data key="d0">操作系统</data>
      <data key="d1">organization</data>
      <data key="d2">操作系统是管理计算机硬件与软件资源的系统软件，影响设备独立性软件与设备驱动程序的实现方式。</data>
      <data key="d3">chunk-f8acab16bd51fe8f837419ef179fc637</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796257</data>
    </node>
    <node id="运行效率">
      <data key="d0">运行效率</data>
      <data key="d1">concept</data>
      <data key="d2">运行效率是评估操作系统、设备独立性软件和设备驱动程序性能的重要指标。</data>
      <data key="d3">chunk-f8acab16bd51fe8f837419ef179fc637</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796257</data>
    </node>
    <node id="设备公有操作">
      <data key="d0">设备公有操作</data>
      <data key="d1">concept</data>
      <data key="d2">设备公有操作是指所有设备共有的基本操作，如读、写、控制等，由设备独立性软件统一处理。</data>
      <data key="d3">chunk-f8acab16bd51fe8f837419ef179fc637</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796257</data>
    </node>
    <node id="功能实现差异">
      <data key="d0">功能实现差异</data>
      <data key="d1">concept</data>
      <data key="d2">功能实现差异指某些本应由设备独立性软件实现的功能可能被分配给设备驱动程序实现，取决于系统设计权衡。</data>
      <data key="d3">chunk-f8acab16bd51fe8f837419ef179fc637</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796257</data>
    </node>
    <node id="I/O Control">
      <data key="d0">I/O Control</data>
      <data key="d1">concept</data>
      <data key="d2">I/O control refers to the management of data transfer between devices and the host computer.</data>
      <data key="d3">chunk-7b1bf538616277d755ad8617bf408c12</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796285</data>
    </node>
    <node id="Program Direct Control Method">
      <data key="d0">Program Direct Control Method</data>
      <data key="d1">method</data>
      <data key="d2">The program direct control method involves CPU-controlled I/O operations through polling, where the CPU continuously checks the device status until data is ready.</data>
      <data key="d3">chunk-7b1bf538616277d755ad8617bf408c12</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796285</data>
    </node>
    <node id="Interrupt Driven Method">
      <data key="d0">Interrupt Driven Method</data>
      <data key="d1">method</data>
      <data key="d2">The interrupt driven method allows I/O devices to signal the CPU when data is ready, enabling the CPU to perform other tasks while waiting.</data>
      <data key="d3">chunk-7b1bf538616277d755ad8617bf408c12</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796285</data>
    </node>
    <node id="CPU">
      <data key="d0">CPU</data>
      <data key="d1">naturalobject</data>
      <data key="d2">The CPU is the central processing unit responsible for executing instructions and managing I/O operations.&lt;SEP&gt;CPU (Central Processing Unit) is the primary processor in a computer system responsible for executing instructions and managing operations.&lt;SEP&gt;CPU is the central processing unit responsible for executing instructions and processing data.&lt;SEP&gt;CPU refers to the central processing unit, known for its high-speed operations in computing systems.</data>
      <data key="d3">chunk-b309162a426d62e33a3be632483b375d&lt;SEP&gt;chunk-1b86b922e001d35ad4f0f4fe7d20ef03&lt;SEP&gt;chunk-2d306019ab3891600b9be43a126d8c4e&lt;SEP&gt;chunk-7b1bf538616277d755ad8617bf408c12</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796582</data>
    </node>
    <node id="I/O Device">
      <data key="d0">I/O Device</data>
      <data key="d1">artifact</data>
      <data key="d2">An I/O device is a hardware component that sends or receives data to/from the host system.&lt;SEP&gt;An I/O device is a peripheral component that sends or receives data to or from a computer system, involved in data transfer operations.&lt;SEP&gt;I/O Device refers to any hardware component that transfers data between the computer and external systems, such as disk drives or network interfaces.</data>
      <data key="d3">chunk-7b1bf538616277d755ad8617bf408c12&lt;SEP&gt;chunk-1b86b922e001d35ad4f0f4fe7d20ef03&lt;SEP&gt;chunk-2d306019ab3891600b9be43a126d8c4e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796441</data>
    </node>
    <node id="Device Controller">
      <data key="d0">Device Controller</data>
      <data key="d1">artifact</data>
      <data key="d2">The device controller manages data transfer between an I/O device and the CPU or memory.&lt;SEP&gt;Device controller is a hardware component responsible for managing and executing commands sent by the device driver.</data>
      <data key="d3">chunk-264fa4087fad0830a27723388157eee3&lt;SEP&gt;chunk-7b1bf538616277d755ad8617bf408c12</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796329</data>
    </node>
    <node id="Data Register">
      <data key="d0">Data Register</data>
      <data key="d1">artifact</data>
      <data key="d2">The data register in the device controller temporarily stores data read from or written to an I/O device.&lt;SEP&gt;The Data Register (DR) temporarily stores data during the transfer between I/O devices and memory in the DMA process.</data>
      <data key="d3">chunk-1b86b922e001d35ad4f0f4fe7d20ef03&lt;SEP&gt;chunk-7b1bf538616277d755ad8617bf408c12</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796288</data>
    </node>
    <node id="Interrupt Signal">
      <data key="d0">Interrupt Signal</data>
      <data key="d1">artifact</data>
      <data key="d2">An interrupt signal is a notification sent from a device controller to the CPU indicating that data is ready.&lt;SEP&gt;An interrupt signal is a hardware signal sent by a device (e.g., DMA controller or I/O channel) to request CPU attention, typically after completing a task.</data>
      <data key="d3">chunk-1b86b922e001d35ad4f0f4fe7d20ef03&lt;SEP&gt;chunk-7b1bf538616277d755ad8617bf408c12</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796290</data>
    </node>
    <node id="Memory">
      <data key="d0">Memory</data>
      <data key="d1">naturalobject</data>
      <data key="d2">Memory is the storage component in a computer system where data is stored for processing.&lt;SEP&gt;Memory refers to the main storage in a computer system where data and instructions are held temporarily during processing.&lt;SEP&gt;Memory refers to the physical RAM used to house temporary data, including disk cache and buffers.</data>
      <data key="d3">chunk-7b1bf538616277d755ad8617bf408c12&lt;SEP&gt;chunk-1b86b922e001d35ad4f0f4fe7d20ef03&lt;SEP&gt;chunk-2d306019ab3891600b9be43a126d8c4e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796439</data>
    </node>
    <node id="Context">
      <data key="d0">Context</data>
      <data key="d1">concept</data>
      <data key="d2">Context refers to the state of a running process, including registers and program counter, saved during interrupt handling.</data>
      <data key="d3">chunk-7b1bf538616277d755ad8617bf408c12</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796287</data>
    </node>
    <node id="Instruction Cycle">
      <data key="d0">Instruction Cycle</data>
      <data key="d1">concept</data>
      <data key="d2">The instruction cycle is the sequence of steps a CPU follows to execute an instruction.</data>
      <data key="d3">chunk-7b1bf538616277d755ad8617bf408c12</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796287</data>
    </node>
    <node id="Data Transfer">
      <data key="d0">Data Transfer</data>
      <data key="d1">concept</data>
      <data key="d2">Data transfer is the process of moving data between devices, controllers, and memory.</data>
      <data key="d3">chunk-7b1bf538616277d755ad8617bf408c12</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796287</data>
    </node>
    <node id="Word (Byte)">
      <data key="d0">Word (Byte)</data>
      <data key="d1">artifact</data>
      <data key="d2">A word or byte is the basic unit of data transferred during I/O operations, typically handled by the CPU and device controller.</data>
      <data key="d3">chunk-7b1bf538616277d755ad8617bf408c12</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796287</data>
    </node>
    <node id="Serial Operation">
      <data key="d0">Serial Operation</data>
      <data key="d1">concept</data>
      <data key="d2">Serial operation refers to the sequential execution of tasks, such as CPU waiting for I/O completion, which limits parallel processing.</data>
      <data key="d3">chunk-7b1bf538616277d755ad8617bf408c12</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796287</data>
    </node>
    <node id="DMA Way">
      <data key="d0">DMA Way</data>
      <data key="d1">method</data>
      <data key="d2">DMA (Direct Memory Access) is a method that allows I/O devices to transfer data directly to and from memory without CPU intervention, improving efficiency and enabling parallel operations.</data>
      <data key="d3">chunk-1b86b922e001d35ad4f0f4fe7d20ef03</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796288</data>
    </node>
    <node id="DMA Controller">
      <data key="d0">DMA Controller</data>
      <data key="d1">artifact</data>
      <data key="d2">A DMA controller is a hardware component that manages data transfer between I/O devices and memory independently of the CPU.</data>
      <data key="d3">chunk-1b86b922e001d35ad4f0f4fe7d20ef03</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796288</data>
    </node>
    <node id="Command/Status Register">
      <data key="d0">Command/Status Register</data>
      <data key="d1">artifact</data>
      <data key="d2">The Command/Status Register (CR) is a register in the DMA controller used to store commands and the current status of data transfer operations.</data>
      <data key="d3">chunk-1b86b922e001d35ad4f0f4fe7d20ef03</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796288</data>
    </node>
    <node id="Memory Address Register">
      <data key="d0">Memory Address Register</data>
      <data key="d1">artifact</data>
      <data key="d2">The Memory Address Register (MAR) in the DMA controller holds the memory address to which data will be read from or written to.</data>
      <data key="d3">chunk-1b86b922e001d35ad4f0f4fe7d20ef03</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796288</data>
    </node>
    <node id="Data Counter">
      <data key="d0">Data Counter</data>
      <data key="d1">artifact</data>
      <data key="d2">The Data Counter (DC) in a DMA controller tracks the number of data units remaining to be transferred.</data>
      <data key="d3">chunk-1b86b922e001d35ad4f0f4fe7d20ef03</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796290</data>
    </node>
    <node id="I/O Channel">
      <data key="d0">I/O Channel</data>
      <data key="d1">artifact</data>
      <data key="d2">An I/O channel is a special-purpose processor that executes channel programs to manage I/O operations independently of the CPU.</data>
      <data key="d3">chunk-1b86b922e001d35ad4f0f4fe7d20ef03</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796290</data>
    </node>
    <node id="Channel Program">
      <data key="d0">Channel Program</data>
      <data key="d1">content</data>
      <data key="d2">A channel program is a sequence of channel instructions stored in memory that defines the I/O operations to be executed by the I/O channel.</data>
      <data key="d3">chunk-1b86b922e001d35ad4f0f4fe7d20ef03</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796290</data>
    </node>
    <node id="Channel Instruction">
      <data key="d0">Channel Instruction</data>
      <data key="d1">method</data>
      <data key="d2">A channel instruction is a specific command executed by the I/O channel to perform a defined I/O task.</data>
      <data key="d3">chunk-1b86b922e001d35ad4f0f4fe7d20ef03</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796290</data>
    </node>
    <node id="Data Block">
      <data key="d0">Data Block</data>
      <data key="d1">concept</data>
      <data key="d2">A data block is the basic unit of data transfer in DMA and channel operations, representing a group of contiguous data words or bytes.</data>
      <data key="d3">chunk-1b86b922e001d35ad4f0f4fe7d20ef03</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796290</data>
    </node>
    <node id="Direct Memory Access">
      <data key="d0">Direct Memory Access</data>
      <data key="d1">concept</data>
      <data key="d2">Direct Memory Access is a data transfer method that enables high-speed I/O operations by allowing devices to access memory directly without CPU involvement.</data>
      <data key="d3">chunk-1b86b922e001d35ad4f0f4fe7d20ef03</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796290</data>
    </node>
    <node id="Parallel Operation">
      <data key="d0">Parallel Operation</data>
      <data key="d1">concept</data>
      <data key="d2">Parallel operation refers to the ability of multiple components (CPU, I/O devices, DMA, channel) to perform tasks concurrently to improve system efficiency.</data>
      <data key="d3">chunk-1b86b922e001d35ad4f0f4fe7d20ef03</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796290</data>
    </node>
    <node id="I/O System">
      <data key="d0">I/O System</data>
      <data key="d1">concept</data>
      <data key="d2">I/O system is the layer that manages input and output operations in a computer system, interfacing with device drivers and applications.</data>
      <data key="d3">chunk-264fa4087fad0830a27723388157eee3</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796329</data>
    </node>
    <node id="Abstract I/O Request">
      <data key="d0">Abstract I/O Request</data>
      <data key="d1">concept</data>
      <data key="d2">Abstract I/O request refers to high-level commands like read or write issued by upper-layer software, which need translation into device-specific operations.</data>
      <data key="d3">chunk-264fa4087fad0830a27723388157eee3</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796329</data>
    </node>
    <node id="Read Command">
      <data key="d0">Read Command</data>
      <data key="d1">concept</data>
      <data key="d2">Read command is an abstract I/O request used to retrieve data from a device.</data>
      <data key="d3">chunk-264fa4087fad0830a27723388157eee3</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796329</data>
    </node>
    <node id="Write Command">
      <data key="d0">Write Command</data>
      <data key="d1">concept</data>
      <data key="d2">Write command is an abstract I/O request used to send data to a device.</data>
      <data key="d3">chunk-264fa4087fad0830a27723388157eee3</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796329</data>
    </node>
    <node id="Device Status">
      <data key="d0">Device Status</data>
      <data key="d1">data</data>
      <data key="d2">Device status is information about the current operational condition of a device, monitored and reported by the device driver.</data>
      <data key="d3">chunk-264fa4087fad0830a27723388157eee3</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796329</data>
    </node>
    <node id="Interrupt Request">
      <data key="d0">Interrupt Request</data>
      <data key="d1">event</data>
      <data key="d2">Interrupt request is a signal sent by a device controller to notify the system of an event such as task completion or error.&lt;SEP&gt;An interrupt request is a signal sent by a hardware device (like the keyboard) to the CPU to request immediate attention.</data>
      <data key="d3">chunk-cae68eac226893284aa15ffc3283cc80&lt;SEP&gt;chunk-264fa4087fad0830a27723388157eee3</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796412</data>
    </node>
    <node id="Interrupt Handling">
      <data key="d0">Interrupt Handling</data>
      <data key="d1">concept</data>
      <data key="d2">Interrupt handling is the process by which the device driver responds to interrupt signals from the device controller and initiates appropriate actions.&lt;SEP&gt;Interrupt handling is the process by which the operating system responds to hardware interrupts, such as those from the keyboard, to manage I/O events.</data>
      <data key="d3">chunk-cae68eac226893284aa15ffc3283cc80&lt;SEP&gt;chunk-264fa4087fad0830a27723388157eee3</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796413</data>
    </node>
    <node id="PCB">
      <data key="d0">PCB</data>
      <data key="d1">artifact</data>
      <data key="d2">PCB (Process Control Block) is a data structure that stores information about a process, including its state, scheduling details, and pending I/O requests.</data>
      <data key="d3">chunk-264fa4087fad0830a27723388157eee3</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796330</data>
    </node>
    <node id="Unified Interface">
      <data key="d0">Unified Interface</data>
      <data key="d1">concept</data>
      <data key="d2">Unified interface is a standardized communication method between device drivers and the operating system.</data>
      <data key="d3">chunk-264fa4087fad0830a27723388157eee3</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796330</data>
    </node>
    <node id="Device Driver Entry Point">
      <data key="d0">Device Driver Entry Point</data>
      <data key="d1">artifact</data>
      <data key="d2">Device driver entry point is the starting address or function used to access a specific device driver in the system.</data>
      <data key="d3">chunk-264fa4087fad0830a27723388157eee3</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796330</data>
    </node>
    <node id="Disk">
      <data key="d0">Disk</data>
      <data key="d1">artifact</data>
      <data key="d2">Disk is a physical disk with a magnetic coating used for data storage, where data is stored in concentric tracks and sectors.&lt;SEP&gt;Disk is a block device used for storing data in blocks, supporting high-speed and random access.</data>
      <data key="d3">chunk-d38f67d322a4adb7d87a544b297f1adb&lt;SEP&gt;chunk-5eca8429d9d2d195386ae7d415efa68b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796374</data>
    </node>
    <node id="Magnetic Head">
      <data key="d0">Magnetic Head</data>
      <data key="d1">artifact</data>
      <data key="d2">Magnetic Head is a conductive coil responsible for reading and writing data on a disk during operation.</data>
      <data key="d3">chunk-5eca8429d9d2d195386ae7d415efa68b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796337</data>
    </node>
    <node id="Magnetic Track">
      <data key="d0">Magnetic Track</data>
      <data key="d1">concept</data>
      <data key="d2">Magnetic Track is a concentric circle on a disk surface where data is stored, each as wide as the magnetic head.</data>
      <data key="d3">chunk-5eca8429d9d2d195386ae7d415efa68b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796337</data>
    </node>
    <node id="Sector">
      <data key="d0">Sector</data>
      <data key="d1">artifact</data>
      <data key="d2">Sector is a fixed-size unit of storage on a magnetic track, typically 1KB in size, and is the smallest addressable unit on a disk.&lt;SEP&gt;A sector is a subdivision of a track on a disk, storing a fixed amount of data and used as the smallest unit for read/write operations.</data>
      <data key="d3">chunk-5eca8429d9d2d195386ae7d415efa68b&lt;SEP&gt;chunk-316f7e90e1f3c434878bc3dd44e3b172</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796383</data>
    </node>
    <node id="Disk Drive">
      <data key="d0">Disk Drive</data>
      <data key="d1">artifact</data>
      <data key="d2">Disk Drive is a device containing the magnetic head arm, spindle for rotation, and electronic components for data input/output.</data>
      <data key="d3">chunk-5eca8429d9d2d195386ae7d415efa68b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796337</data>
    </node>
    <node id="Disk Platter">
      <data key="d0">Disk Platter</data>
      <data key="d1">artifact</data>
      <data key="d2">Disk Platter is a single physical disk with a magnetic surface used in disk storage systems.</data>
      <data key="d3">chunk-5eca8429d9d2d195386ae7d415efa68b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796337</data>
    </node>
    <node id="Cylinder">
      <data key="d0">Cylinder</data>
      <data key="d1">concept</data>
      <data key="d2">Cylinder is a set of tracks with the same radius across multiple disk surfaces in a stacked disk assembly.</data>
      <data key="d3">chunk-5eca8429d9d2d195386ae7d415efa68b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796337</data>
    </node>
    <node id="Fixed Head Disk">
      <data key="d0">Fixed Head Disk</data>
      <data key="d1">artifact</data>
      <data key="d2">Fixed Head Disk is a type of disk where each track has a dedicated magnetic head.</data>
      <data key="d3">chunk-5eca8429d9d2d195386ae7d415efa68b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796337</data>
    </node>
    <node id="Moving Head Disk">
      <data key="d0">Moving Head Disk</data>
      <data key="d1">artifact</data>
      <data key="d2">Moving Head Disk is a disk with a single magnetic head that moves radially to access different tracks.</data>
      <data key="d3">chunk-5eca8429d9d2d195386ae7d415efa68b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796338</data>
    </node>
    <node id="Fixed Disk">
      <data key="d0">Fixed Disk</data>
      <data key="d1">artifact</data>
      <data key="d2">Fixed Disk is a disk where the platters are permanently enclosed within the disk drive.</data>
      <data key="d3">chunk-5eca8429d9d2d195386ae7d415efa68b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796338</data>
    </node>
    <node id="Removable Disk">
      <data key="d0">Removable Disk</data>
      <data key="d1">artifact</data>
      <data key="d2">Removable Disk is a disk system where the platters can be removed and replaced.</data>
      <data key="d3">chunk-5eca8429d9d2d195386ae7d415efa68b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796338</data>
    </node>
    <node id="Winchester Disk">
      <data key="d0">Winchester Disk</data>
      <data key="d1">artifact</data>
      <data key="d2">Winchester Disk is an early type of disk invented by IBM, featuring movable heads and fixed platters.</data>
      <data key="d3">chunk-5eca8429d9d2d195386ae7d415efa68b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796338</data>
    </node>
    <node id="IBM">
      <data key="d0">IBM</data>
      <data key="d1">organization</data>
      <data key="d2">IBM is the organization credited with developing the first Winchester disk.</data>
      <data key="d3">chunk-5eca8429d9d2d195386ae7d415efa68b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796338</data>
    </node>
    <node id="Data Access Process">
      <data key="d0">Data Access Process</data>
      <data key="d1">method</data>
      <data key="d2">Data Access Process involves moving the head arm to the target cylinder, activating the appropriate head, and reading/writing data as the disk rotates under the head.</data>
      <data key="d3">chunk-5eca8429d9d2d195386ae7d415efa68b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796338</data>
    </node>
    <node id="Data Storage Density">
      <data key="d0">Data Storage Density</data>
      <data key="d1">concept</data>
      <data key="d2">Data Storage Density refers to the amount of data that can be stored per unit area on a disk, which increases from the outer to the inner tracks due to fixed angular division of sectors.</data>
      <data key="d3">chunk-5eca8429d9d2d195386ae7d415efa68b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796338</data>
    </node>
    <node id="Disk Addressing">
      <data key="d0">Disk Addressing</data>
      <data key="d1">method</data>
      <data key="d2">Disk Addressing uses a three-part identifier (Cylinder Number · Surface Number · Sector Number) to locate specific data blocks on a disk.</data>
      <data key="d3">chunk-5eca8429d9d2d195386ae7d415efa68b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796338</data>
    </node>
    <node id="Inter-Track Gap">
      <data key="d0">Inter-Track Gap</data>
      <data key="d1">concept</data>
      <data key="d2">Inter-Track Gap is the physical spacing between adjacent magnetic tracks to prevent read/write interference and ensure data accuracy.</data>
      <data key="d3">chunk-5eca8429d9d2d195386ae7d415efa68b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796339</data>
    </node>
    <node id="Inter-Sector Gap">
      <data key="d0">Inter-Sector Gap</data>
      <data key="d1">concept</data>
      <data key="d2">Inter-Sector Gap is the space between adjacent sectors on a track, used to avoid overlap and ensure correct data sector recognition.</data>
      <data key="d3">chunk-5eca8429d9d2d195386ae7d415efa68b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796340</data>
    </node>
    <node id="Surface">
      <data key="d0">Surface</data>
      <data key="d3">chunk-5eca8429d9d2d195386ae7d415efa68b</data>
      <data key="d2">Disk addressing includes the surface number to identify the specific disk face where data resides.</data>
      <data key="d1">UNKNOWN</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796343</data>
    </node>
    <node id="I/O Interface">
      <data key="d0">I/O Interface</data>
      <data key="d1">concept</data>
      <data key="d2">I/O interface is the interface between the I/O system and higher-level components, facilitating communication and data transfer.</data>
      <data key="d3">chunk-d38f67d322a4adb7d87a544b297f1adb</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796372</data>
    </node>
    <node id="Character Device Interface">
      <data key="d0">Character Device Interface</data>
      <data key="d1">interface</data>
      <data key="d2">Character device interface is used for devices that transfer data in character units, such as keyboards and printers, and supports operations like get, put, and in-control instructions.</data>
      <data key="d3">chunk-d38f67d322a4adb7d87a544b297f1adb</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796372</data>
    </node>
    <node id="Block Device Interface">
      <data key="d0">Block Device Interface</data>
      <data key="d1">interface</data>
      <data key="d2">Block device interface manages devices that transfer data in blocks, such as disk drives, and supports operations like open, read, write, and close.</data>
      <data key="d3">chunk-d38f67d322a4adb7d87a544b297f1adb</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796372</data>
    </node>
    <node id="Network Device Interface">
      <data key="d0">Network Device Interface</data>
      <data key="d1">interface</data>
      <data key="d2">Network device interface provides network connectivity and communication capabilities, often implemented through socket interfaces.</data>
      <data key="d3">chunk-d38f67d322a4adb7d87a544b297f1adb</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796372</data>
    </node>
    <node id="Interrupt Driven I/O">
      <data key="d0">Interrupt Driven I/O</data>
      <data key="d1">method</data>
      <data key="d2">Interrupt driven I/O is a common method used by character devices, where the CPU is interrupted upon I/O completion.</data>
      <data key="d3">chunk-d38f67d322a4adb7d87a544b297f1adb</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796372</data>
    </node>
    <node id="DMA I/O">
      <data key="d0">DMA I/O</data>
      <data key="d1">method</data>
      <data key="d2">DMA I/O is a method used by block devices, allowing direct data transfer between memory and device without CPU intervention.</data>
      <data key="d3">chunk-d38f67d322a4adb7d87a544b297f1adb</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796372</data>
    </node>
    <node id="Memory Mapped Interface">
      <data key="d0">Memory Mapped Interface</data>
      <data key="d1">interface</data>
      <data key="d2">Memory mapped interface allows access to disk via memory byte arrays instead of traditional read/write operations.</data>
      <data key="d3">chunk-d38f67d322a4adb7d87a544b297f1adb</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796372</data>
    </node>
    <node id="Blocking I/O">
      <data key="d0">Blocking I/O</data>
      <data key="d1">method</data>
      <data key="d2">Blocking I/O is a mode where the calling process is suspended until I/O operation completes, then it is resumed.</data>
      <data key="d3">chunk-d38f67d322a4adb7d87a544b297f1adb</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796372</data>
    </node>
    <node id="Non Blocking I/O">
      <data key="d0">Non Blocking I/O</data>
      <data key="d1">method</data>
      <data key="d2">Non blocking I/O is a mode where the process is not suspended during I/O and periodically checks the status of the operation.</data>
      <data key="d3">chunk-d38f67d322a4adb7d87a544b297f1adb</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796374</data>
    </node>
    <node id="Character Device">
      <data key="d0">Character Device</data>
      <data key="d1">artifact</data>
      <data key="d2">Character device is a type of hardware device that transfers data in individual characters, such as keyboards and printers.</data>
      <data key="d3">chunk-d38f67d322a4adb7d87a544b297f1adb</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796374</data>
    </node>
    <node id="Block Device">
      <data key="d0">Block Device</data>
      <data key="d1">artifact</data>
      <data key="d2">Block device is a type of storage device that transfers data in fixed-size blocks, such as hard drives and SSDs.</data>
      <data key="d3">chunk-d38f67d322a4adb7d87a544b297f1adb</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796374</data>
    </node>
    <node id="Network Device">
      <data key="d0">Network Device</data>
      <data key="d1">artifact</data>
      <data key="d2">Network device is a hardware component enabling network connectivity, such as network interface cards.</data>
      <data key="d3">chunk-d38f67d322a4adb7d87a544b297f1adb</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796374</data>
    </node>
    <node id="Keyboard">
      <data key="d0">Keyboard</data>
      <data key="d1">artifact</data>
      <data key="d2">Keyboard is a character device used for input, transmitting data one character at a time.</data>
      <data key="d3">chunk-d38f67d322a4adb7d87a544b297f1adb</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796374</data>
    </node>
    <node id="Printer">
      <data key="d0">Printer</data>
      <data key="d1">artifact</data>
      <data key="d2">Printer is a character device used for output, processing data in character units.&lt;SEP&gt;Printer is a non-shared device managed through SPOOLing to allow multiple users to submit print jobs simultaneously.</data>
      <data key="d3">chunk-b309162a426d62e33a3be632483b375d&lt;SEP&gt;chunk-d38f67d322a4adb7d87a544b297f1adb</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796584</data>
    </node>
    <node id="Socket Interface">
      <data key="d0">Socket Interface</data>
      <data key="d1">artifact</data>
      <data key="d2">Socket interface is a standardized network communication mechanism used by operating systems.</data>
      <data key="d3">chunk-d38f67d322a4adb7d87a544b297f1adb</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796374</data>
    </node>
    <node id="Character Buffer">
      <data key="d0">Character Buffer</data>
      <data key="d1">data</data>
      <data key="d2">Character buffer is a memory area used to store data temporarily when dealing with character devices due to their sequential access nature.</data>
      <data key="d3">chunk-d38f67d322a4adb7d87a544b297f1adb</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796375</data>
    </node>
    <node id="In-Control Instruction">
      <data key="d0">In-Control Instruction</data>
      <data key="d1">method</data>
      <data key="d2">In-control instruction is a generic command provided in the character device interface to handle the diverse operations of various character devices.</data>
      <data key="d3">chunk-d38f67d322a4adb7d87a544b297f1adb</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796375</data>
    </node>
    <node id="Open and Close Operations">
      <data key="d0">Open and Close Operations</data>
      <data key="d1">method</data>
      <data key="d2">Open and close operations are provided in the character device interface to manage exclusive access and mutual sharing of devices.</data>
      <data key="d3">chunk-d38f67d322a4adb7d87a544b297f1adb</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796375</data>
    </node>
    <node id="Disk Scheduling Algorithm">
      <data key="d0">Disk Scheduling Algorithm</data>
      <data key="d1">method</data>
      <data key="d2">Disk scheduling algorithm is a technique used to manage the order of disk I/O requests to minimize seek time and improve performance.</data>
      <data key="d3">chunk-316f7e90e1f3c434878bc3dd44e3b172</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796380</data>
    </node>
    <node id="Seek Time">
      <data key="d0">Seek Time</data>
      <data key="d1">concept</data>
      <data key="d2">Seek time is the time required for the disk read/write head to move to the specified track.</data>
      <data key="d3">chunk-316f7e90e1f3c434878bc3dd44e3b172</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796380</data>
    </node>
    <node id="Rotational Latency">
      <data key="d0">Rotational Latency</data>
      <data key="d1">concept</data>
      <data key="d2">Rotational latency is the time it takes for the desired sector to rotate under the read/write head after the head reaches the correct track.</data>
      <data key="d3">chunk-316f7e90e1f3c434878bc3dd44e3b172</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796380</data>
    </node>
    <node id="Transfer Time">
      <data key="d0">Transfer Time</data>
      <data key="d1">concept</data>
      <data key="d2">Transfer time is the time needed to read or write data from or to the disk once the head is positioned.</data>
      <data key="d3">chunk-316f7e90e1f3c434878bc3dd44e3b172</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796380</data>
    </node>
    <node id="First Come First Served">
      <data key="d0">First Come First Served</data>
      <data key="d1">method</data>
      <data key="d2">First Come First Served (FCFS) is a simple disk scheduling algorithm that processes requests in the order they arrive.</data>
      <data key="d3">chunk-316f7e90e1f3c434878bc3dd44e3b172</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796380</data>
    </node>
    <node id="Shortest Seek Time First">
      <data key="d0">Shortest Seek Time First</data>
      <data key="d1">method</data>
      <data key="d2">Shortest Seek Time First (SSTF) is a disk scheduling algorithm that selects the request closest to the current head position to minimize seek time.</data>
      <data key="d3">chunk-316f7e90e1f3c434878bc3dd44e3b172</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796380</data>
    </node>
    <node id="Scan Algorithm">
      <data key="d0">Scan Algorithm</data>
      <data key="d1">method</data>
      <data key="d2">Scan algorithm, also known as the elevator algorithm, moves the disk head in one direction until it reaches the end of the disk, then reverses direction and serves requests.</data>
      <data key="d3">chunk-316f7e90e1f3c434878bc3dd44e3b172</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796380</data>
    </node>
    <node id="Circular Scan Algorithm">
      <data key="d0">Circular Scan Algorithm</data>
      <data key="d1">method</data>
      <data key="d2">Circular Scan (C-SCAN) algorithm moves the disk head in a single direction, servicing requests until it reaches the end, then quickly returns to the beginning without servicing requests.</data>
      <data key="d3">chunk-316f7e90e1f3c434878bc3dd44e3b172</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796380</data>
    </node>
    <node id="Look Algorithm">
      <data key="d0">Look Algorithm</data>
      <data key="d1">method</data>
      <data key="d2">Look algorithm is an improved version of the Scan algorithm that stops moving when it reaches the last request in the current direction, rather than reaching the disk end.</data>
      <data key="d3">chunk-316f7e90e1f3c434878bc3dd44e3b172</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796382</data>
    </node>
    <node id="C-Look Algorithm">
      <data key="d0">C-Look Algorithm</data>
      <data key="d1">method</data>
      <data key="d2">C-Look algorithm is a variation of C-SCAN that stops at the last request in a single direction before returning to the starting point.</data>
      <data key="d3">chunk-316f7e90e1f3c434878bc3dd44e3b172</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796382</data>
    </node>
    <node id="Sector Interleaving">
      <data key="d0">Sector Interleaving</data>
      <data key="d1">method</data>
      <data key="d2">Sector interleaving is a technique to alternate physical sector numbering so that multiple consecutive logical blocks are physically spaced apart to reduce rotational latency.</data>
      <data key="d3">chunk-316f7e90e1f3c434878bc3dd44e3b172</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796382</data>
    </node>
    <node id="Disk Surface Skew">
      <data key="d0">Disk Surface Skew</data>
      <data key="d1">method</data>
      <data key="d2">Disk surface skew is a method where sectors on adjacent disk surfaces are offset to allow immediate read access when switching between surfaces.</data>
      <data key="d3">chunk-316f7e90e1f3c434878bc3dd44e3b172</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796382</data>
    </node>
    <node id="Disk Cache">
      <data key="d0">Disk Cache</data>
      <data key="d1">concept</data>
      <data key="d2">Disk cache is a memory buffer used to temporarily store frequently accessed data to speed up disk I/O operations.&lt;SEP&gt;Disk Cache is a technology used by operating systems to improve disk I/O performance by storing frequently accessed data in memory, reducing direct disk access.</data>
      <data key="d3">chunk-316f7e90e1f3c434878bc3dd44e3b172&lt;SEP&gt;chunk-2d306019ab3891600b9be43a126d8c4e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796439</data>
    </node>
    <node id="Pre-reading">
      <data key="d0">Pre-reading</data>
      <data key="d1">method</data>
      <data key="d2">Pre-reading involves loading the next block into memory while the current block is being processed to reduce future access delays.</data>
      <data key="d3">chunk-316f7e90e1f3c434878bc3dd44e3b172</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796382</data>
    </node>
    <node id="Delayed Writing">
      <data key="d0">Delayed Writing</data>
      <data key="d1">method</data>
      <data key="d2">Delayed writing stores data in a buffer with a delay flag, releasing the buffer until it is actually written to disk.</data>
      <data key="d3">chunk-316f7e90e1f3c434878bc3dd44e3b172</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796382</data>
    </node>
    <node id="Physical Block Arrangement">
      <data key="d0">Physical Block Arrangement</data>
      <data key="d1">method</data>
      <data key="d2">Physical block arrangement optimizes the placement of file blocks on the disk to minimize seek time, especially for contiguous files.</data>
      <data key="d3">chunk-316f7e90e1f3c434878bc3dd44e3b172</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796382</data>
    </node>
    <node id="Virtual Disk">
      <data key="d0">Virtual Disk</data>
      <data key="d1">artifact</data>
      <data key="d2">Virtual disk, also known as a RAM disk, uses memory space to emulate a disk drive for faster access.</data>
      <data key="d3">chunk-316f7e90e1f3c434878bc3dd44e3b172</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796383</data>
    </node>
    <node id="RAID">
      <data key="d0">RAID</data>
      <data key="d1">artifact</data>
      <data key="d2">RAID (Redundant Array of Independent Disks) is a data storage technology that combines multiple physical disks into a single logical unit for improved performance and reliability.</data>
      <data key="d3">chunk-316f7e90e1f3c434878bc3dd44e3b172</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796383</data>
    </node>
    <node id="Average Seek Time">
      <data key="d0">Average Seek Time</data>
      <data key="d1">concept</data>
      <data key="d2">Average seek time is the mean time required for the disk head to move to the desired track across all possible tracks.</data>
      <data key="d3">chunk-316f7e90e1f3c434878bc3dd44e3b172</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796383</data>
    </node>
    <node id="Disk Rotation Speed">
      <data key="d0">Disk Rotation Speed</data>
      <data key="d1">concept</data>
      <data key="d2">Disk rotation speed is the rate at which the disk platters spin, affecting rotational latency and data transfer time.</data>
      <data key="d3">chunk-316f7e90e1f3c434878bc3dd44e3b172</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796383</data>
    </node>
    <node id="Disk Read/Write Operation">
      <data key="d0">Disk Read/Write Operation</data>
      <data key="d1">concept</data>
      <data key="d2">A disk read/write operation refers to the process of reading data from or writing data to a disk, encompassing seek time, rotational latency, and transfer time components.</data>
      <data key="d3">chunk-316f7e90e1f3c434878bc3dd44e3b172</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796383</data>
    </node>
    <node id="Disk Head">
      <data key="d0">Disk Head</data>
      <data key="d1">artifact</data>
      <data key="d2">The disk head is the mechanical component that reads from or writes to the disk surface, responsible for moving to the correct track and aligning with the correct sector.</data>
      <data key="d3">chunk-316f7e90e1f3c434878bc3dd44e3b172</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796383</data>
    </node>
    <node id="Track">
      <data key="d0">Track</data>
      <data key="d1">artifact</data>
      <data key="d2">A track is a concentric circle on a disk surface where data is stored, and the disk head moves to access data on a specific track.</data>
      <data key="d3">chunk-316f7e90e1f3c434878bc3dd44e3b172</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796383</data>
    </node>
    <node id="Platter">
      <data key="d0">Platter</data>
      <data key="d1">naturalobject</data>
      <data key="d2">A platter is a disk-shaped component in a hard drive that stores data magnetically, with one or more surfaces used for data storage.</data>
      <data key="d3">chunk-316f7e90e1f3c434878bc3dd44e3b172</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796383</data>
    </node>
    <node id="I/O Operation">
      <data key="d0">I/O Operation</data>
      <data key="d1">concept</data>
      <data key="d2">I/O operation refers to input/output activities between a program and external devices, involving data transfer between user space and kernel space.</data>
      <data key="d3">chunk-cae68eac226893284aa15ffc3283cc80</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796410</data>
    </node>
    <node id="Kernel Buffer">
      <data key="d0">Kernel Buffer</data>
      <data key="d1">artifact</data>
      <data key="d2">The kernel buffer is a buffer located in kernel space used to temporarily store data during I/O operations.</data>
      <data key="d3">chunk-cae68eac226893284aa15ffc3283cc80</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796410</data>
    </node>
    <node id="User Buffer">
      <data key="d0">User Buffer</data>
      <data key="d1">artifact</data>
      <data key="d2">The user buffer is a buffer located in user space, associated with functions like scanf, for storing input data before processing.</data>
      <data key="d3">chunk-cae68eac226893284aa15ffc3283cc80</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796410</data>
    </node>
    <node id="scanf">
      <data key="d0">scanf</data>
      <data key="d1">function</data>
      <data key="d2">scanf is a C library function used to read formatted input from standard input, associated with a user buffer.</data>
      <data key="d3">chunk-cae68eac226893284aa15ffc3283cc80</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796410</data>
    </node>
    <node id="read">
      <data key="d0">read</data>
      <data key="d1">systemcall</data>
      <data key="d2">read is a system call that performs low-level I/O operations, taking file descriptor, user buffer, and count as parameters.</data>
      <data key="d3">chunk-cae68eac226893284aa15ffc3283cc80</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796410</data>
    </node>
    <node id="File Descriptor">
      <data key="d0">File Descriptor</data>
      <data key="d1">data</data>
      <data key="d2">File descriptor (fd) is an identifier used by the operating system to access open files or I/O devices.</data>
      <data key="d3">chunk-cae68eac226893284aa15ffc3283cc80</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796410</data>
    </node>
    <node id="Count">
      <data key="d0">Count</data>
      <data key="d1">data</data>
      <data key="d2">Count specifies the maximum number of bytes to be read during a system call.</data>
      <data key="d3">chunk-cae68eac226893284aa15ffc3283cc80</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796410</data>
    </node>
    <node id="Trap Instruction">
      <data key="d0">Trap Instruction</data>
      <data key="d1">artifact</data>
      <data key="d2">A trap instruction is a mechanism that switches the CPU from user mode to kernel mode to execute system calls.</data>
      <data key="d3">chunk-cae68eac226893284aa15ffc3283cc80</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796410</data>
    </node>
    <node id="Kernel Mode">
      <data key="d0">Kernel Mode</data>
      <data key="d1">state</data>
      <data key="d2">Kernel mode is a privileged execution state of the CPU where system calls and device drivers operate.</data>
      <data key="d3">chunk-cae68eac226893284aa15ffc3283cc80</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796412</data>
    </node>
    <node id="User Mode">
      <data key="d0">User Mode</data>
      <data key="d1">state</data>
      <data key="d2">User mode is a restricted execution state where user programs run, requiring system calls to access kernel resources.</data>
      <data key="d3">chunk-cae68eac226893284aa15ffc3283cc80</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796412</data>
    </node>
    <node id="Process P">
      <data key="d0">Process P</data>
      <data key="d1">process</data>
      <data key="d2">Process P is the executing process that initiates an I/O operation and gets blocked during the I/O wait phase.</data>
      <data key="d3">chunk-cae68eac226893284aa15ffc3283cc80</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796412</data>
    </node>
    <node id="Keyboard I/O Interface">
      <data key="d0">Keyboard I/O Interface</data>
      <data key="d1">artifact</data>
      <data key="d2">The Keyboard I/O Interface is hardware that receives input from the keyboard and forwards data to the CPU via interrupt.</data>
      <data key="d3">chunk-cae68eac226893284aa15ffc3283cc80</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796412</data>
    </node>
    <node id="Keyboard Interrupt Handler">
      <data key="d0">Keyboard Interrupt Handler</data>
      <data key="d1">function</data>
      <data key="d2">The keyboard interrupt handler is a kernel-level routine that processes incoming keyboard input and transfers data to the kernel buffer.</data>
      <data key="d3">chunk-cae68eac226893284aa15ffc3283cc80</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796412</data>
    </node>
    <node id="Ready Queue">
      <data key="d0">Ready Queue</data>
      <data key="d1">datastructure</data>
      <data key="d2">The ready queue is a data structure that holds processes waiting to be scheduled for execution.</data>
      <data key="d3">chunk-cae68eac226893284aa15ffc3283cc80</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796412</data>
    </node>
    <node id="Device Driver Layer">
      <data key="d0">Device Driver Layer</data>
      <data key="d1">artifact</data>
      <data key="d2">The device driver layer is the kernel component responsible for directly controlling hardware devices during I/O operations.</data>
      <data key="d3">chunk-cae68eac226893284aa15ffc3283cc80</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796412</data>
    </node>
    <node id="C Language Function Library">
      <data key="d0">C Language Function Library</data>
      <data key="d1">artifact</data>
      <data key="d2">The C language function library is a collection of standard functions, including scanf, that provide high-level interfaces for system operations.</data>
      <data key="d3">chunk-cae68eac226893284aa15ffc3283cc80</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796413</data>
    </node>
    <node id="System Call Service Routine">
      <data key="d0">System Call Service Routine</data>
      <data key="d1">function</data>
      <data key="d2">The system call service routine is a kernel-level function that handles system calls, manages transitions between user and kernel modes, and coordinates I/O operations.</data>
      <data key="d3">chunk-cae68eac226893284aa15ffc3283cc80</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796413</data>
    </node>
    <node id="Blocked State">
      <data key="d0">Blocked State</data>
      <data key="d3">chunk-cae68eac226893284aa15ffc3283cc80</data>
      <data key="d2">Process P enters the blocked state when it waits for I/O completion.</data>
      <data key="d1">UNKNOWN</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796414</data>
    </node>
    <node id="Level 1 Cache">
      <data key="d0">Level 1 Cache</data>
      <data key="d1">artifact</data>
      <data key="d2">Level 1 Cache is a small, high-speed memory located within the CPU core to store frequently accessed data.</data>
      <data key="d3">chunk-2d306019ab3891600b9be43a126d8c4e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796439</data>
    </node>
    <node id="Level 2 Cache">
      <data key="d0">Level 2 Cache</data>
      <data key="d1">artifact</data>
      <data key="d2">Level 2 Cache is a larger, slightly slower cache than Level 1, located outside the CPU core but still on the processor chip.</data>
      <data key="d3">chunk-2d306019ab3891600b9be43a126d8c4e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796439</data>
    </node>
    <node id="Block">
      <data key="d0">Block</data>
      <data key="d1">data</data>
      <data key="d2">Block refers to a fixed-size unit of data used in disk storage and memory operations.&lt;SEP&gt;A block is a unit of data organization in flash memory, composed of multiple pages, where data is erased at the block level.</data>
      <data key="d3">chunk-8189302c7787e74dde6623016361fc8f&lt;SEP&gt;chunk-2d306019ab3891600b9be43a126d8c4e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796578</data>
    </node>
    <node id="Buffer">
      <data key="d0">Buffer</data>
      <data key="d1">concept</data>
      <data key="d2">Buffer is a temporary storage area used to hold data during transfer between devices or processes, helping to manage speed mismatches.&lt;SEP&gt;A buffer is a block of memory used to temporarily hold data during transfer between devices or processes.</data>
      <data key="d3">chunk-e821a4c1e8eeab3120a42bec02ee8587&lt;SEP&gt;chunk-2d306019ab3891600b9be43a126d8c4e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796439</data>
    </node>
    <node id="Single Buffer">
      <data key="d0">Single Buffer</data>
      <data key="d1">method</data>
      <data key="d2">Single Buffer is a buffering technique where one buffer is allocated per I/O request to manage data input and output.</data>
      <data key="d3">chunk-2d306019ab3891600b9be43a126d8c4e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796439</data>
    </node>
    <node id="Double Buffer">
      <data key="d0">Double Buffer</data>
      <data key="d1">method</data>
      <data key="d2">Double Buffer is a buffering technique that uses two buffers to allow overlapping of I/O operations with data processing.</data>
      <data key="d3">chunk-2d306019ab3891600b9be43a126d8c4e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796441</data>
    </node>
    <node id="Circular Buffer">
      <data key="d0">Circular Buffer</data>
      <data key="d1">method</data>
      <data key="d2">Circular Buffer is a data structure consisting of multiple buffers linked in a loop, used to manage continuous data flow with in and out pointers.</data>
      <data key="d3">chunk-2d306019ab3891600b9be43a126d8c4e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796441</data>
    </node>
    <node id="Input">
      <data key="d0">Input</data>
      <data key="d1">process</data>
      <data key="d2">Input refers to the operation of receiving data from a device into the system.</data>
      <data key="d3">chunk-2d306019ab3891600b9be43a126d8c4e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796441</data>
    </node>
    <node id="Output">
      <data key="d0">Output</data>
      <data key="d1">process</data>
      <data key="d2">Output refers to the operation of sending data from the system to a device.</data>
      <data key="d3">chunk-2d306019ab3891600b9be43a126d8c4e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796441</data>
    </node>
    <node id="Device Management Subsystem">
      <data key="d0">Device Management Subsystem</data>
      <data key="d1">concept</data>
      <data key="d2">Device Management Subsystem is a component of the operating system responsible for handling I/O device operations.</data>
      <data key="d3">chunk-2d306019ab3891600b9be43a126d8c4e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796441</data>
    </node>
    <node id="Interrupt">
      <data key="d0">Interrupt</data>
      <data key="d1">concept</data>
      <data key="d2">Interrupt is a signal sent to the CPU to indicate that an I/O operation has completed or requires attention.</data>
      <data key="d3">chunk-2d306019ab3891600b9be43a126d8c4e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796441</data>
    </node>
    <node id="Data Granularity">
      <data key="d0">Data Granularity</data>
      <data key="d1">concept</data>
      <data key="d2">Data Granularity refers to the size of data units processed in a system, which may differ between devices and memory.</data>
      <data key="d3">chunk-2d306019ab3891600b9be43a126d8c4e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796441</data>
    </node>
    <node id="System Memory">
      <data key="d0">System Memory</data>
      <data key="d1">naturalobject</data>
      <data key="d2">System Memory is the primary working memory of the computer, used by processes and system components including buffers and caches.</data>
      <data key="d3">chunk-2d306019ab3891600b9be43a126d8c4e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796442</data>
    </node>
    <node id="Circular Queue">
      <data key="d0">Circular Queue</data>
      <data key="d1">concept</data>
      <data key="d2">A circular queue is a data structure where multiple buffers are linked in a loop, with each buffer pointing to the next, and the last pointing back to the first.</data>
      <data key="d3">chunk-e821a4c1e8eeab3120a42bec02ee8587</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796443</data>
    </node>
    <node id="In Pointer">
      <data key="d0">In Pointer</data>
      <data key="d1">artifact</data>
      <data key="d2">The in pointer tracks the first available empty buffer where new data can be written.</data>
      <data key="d3">chunk-e821a4c1e8eeab3120a42bec02ee8587</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796443</data>
    </node>
    <node id="Out Pointer">
      <data key="d0">Out Pointer</data>
      <data key="d1">artifact</data>
      <data key="d2">The out pointer tracks the first full buffer from which data can be read.</data>
      <data key="d3">chunk-e821a4c1e8eeab3120a42bec02ee8587</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796443</data>
    </node>
    <node id="Buffer Pool">
      <data key="d0">Buffer Pool</data>
      <data key="d1">concept</data>
      <data key="d2">A buffer pool is a management mechanism that oversees multiple buffers, containing a control data structure and operational functions, and allows shared access across multiple processes.</data>
      <data key="d3">chunk-e821a4c1e8eeab3120a42bec02ee8587</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796443</data>
    </node>
    <node id="Empty Buffer Queue">
      <data key="d0">Empty Buffer Queue</data>
      <data key="d1">concept</data>
      <data key="d2">The empty buffer queue is a list of unused buffers ready to be filled with data.</data>
      <data key="d3">chunk-e821a4c1e8eeab3120a42bec02ee8587</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796443</data>
    </node>
    <node id="Input Queue">
      <data key="d0">Input Queue</data>
      <data key="d1">concept</data>
      <data key="d2">The input queue holds buffers that have been filled with incoming data and are ready for processing.</data>
      <data key="d3">chunk-e821a4c1e8eeab3120a42bec02ee8587</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796443</data>
    </node>
    <node id="Output Queue">
      <data key="d0">Output Queue</data>
      <data key="d1">concept</data>
      <data key="d2">The output queue holds buffers containing data to be transmitted to an output device.</data>
      <data key="d3">chunk-e821a4c1e8eeab3120a42bec02ee8587</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796443</data>
    </node>
    <node id="Hin Work Buffer">
      <data key="d0">Hin Work Buffer</data>
      <data key="d1">artifact</data>
      <data key="d2">The hin work buffer is used to receive and store incoming data during input operations.</data>
      <data key="d3">chunk-e821a4c1e8eeab3120a42bec02ee8587</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796443</data>
    </node>
    <node id="Sin Work Buffer">
      <data key="d0">Sin Work Buffer</data>
      <data key="d1">artifact</data>
      <data key="d2">The sin work buffer is used to extract data from input buffers for processing.</data>
      <data key="d3">chunk-e821a4c1e8eeab3120a42bec02ee8587</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796444</data>
    </node>
    <node id="Hout Work Buffer">
      <data key="d0">Hout Work Buffer</data>
      <data key="d1">artifact</data>
      <data key="d2">The hout work buffer is used to store output data until it is sent.</data>
      <data key="d3">chunk-e821a4c1e8eeab3120a42bec02ee8587</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796444</data>
    </node>
    <node id="Sout Work Buffer">
      <data key="d0">Sout Work Buffer</data>
      <data key="d1">artifact</data>
      <data key="d2">The sout work buffer is used to retrieve output data from a filled buffer for transmission.</data>
      <data key="d3">chunk-e821a4c1e8eeab3120a42bec02ee8587</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796444</data>
    </node>
    <node id="Data Input Process">
      <data key="d0">Data Input Process</data>
      <data key="d1">method</data>
      <data key="d2">The data input process involves taking an empty buffer from the empty queue, filling it with data, and moving it to the input queue.</data>
      <data key="d3">chunk-e821a4c1e8eeab3120a42bec02ee8587</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796444</data>
    </node>
    <node id="Data Extraction Process">
      <data key="d0">Data Extraction Process</data>
      <data key="d1">method</data>
      <data key="d2">The data extraction process involves retrieving a buffer from the input queue, reading its data, and returning it to the empty queue after use.</data>
      <data key="d3">chunk-e821a4c1e8eeab3120a42bec02ee8587</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796444</data>
    </node>
    <node id="Data Output Process">
      <data key="d0">Data Output Process</data>
      <data key="d1">method</data>
      <data key="d2">The data output process involves taking an empty buffer, filling it with output data, and placing it onto the output queue.</data>
      <data key="d3">chunk-e821a4c1e8eeab3120a42bec02ee8587</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796444</data>
    </node>
    <node id="Output Retrieval Process">
      <data key="d0">Output Retrieval Process</data>
      <data key="d1">method</data>
      <data key="d2">The output retrieval process involves taking a filled buffer from the output queue, extracting its data, and returning it to the empty queue.</data>
      <data key="d3">chunk-e821a4c1e8eeab3120a42bec02ee8587</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796444</data>
    </node>
    <node id="Cache">
      <data key="d0">Cache</data>
      <data key="d1">artifact</data>
      <data key="d2">A cache is a high-speed storage that holds copies of data for faster access, located between high-speed and low-speed devices.</data>
      <data key="d3">chunk-e821a4c1e8eeab3120a42bec02ee8587</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796444</data>
    </node>
    <node id="High-Speed Device">
      <data key="d0">High-Speed Device</data>
      <data key="d1">naturalobject</data>
      <data key="d2">A high-speed device is a component with fast access time, such as a processor or memory.</data>
      <data key="d3">chunk-e821a4c1e8eeab3120a42bec02ee8587</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796444</data>
    </node>
    <node id="Low-Speed Device">
      <data key="d0">Low-Speed Device</data>
      <data key="d1">naturalobject</data>
      <data key="d2">A low-speed device is a peripheral or storage device with slower access times, such as a disk or network interface.</data>
      <data key="d3">chunk-e821a4c1e8eeab3120a42bec02ee8587</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796446</data>
    </node>
    <node id="I/O软件层次结构">
      <data key="d0">I/O软件层次结构</data>
      <data key="d1">concept</data>
      <data key="d2">I/O software hierarchy is a structured approach to designing input/output software with clarity, portability, and adaptability, consisting of four distinct layers.</data>
      <data key="d3">chunk-1e6791234c2dc9ee6f432df1989fc60b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796532</data>
    </node>
    <node id="用户层软件">
      <data key="d0">用户层软件</data>
      <data key="d1">softwarelayer</data>
      <data key="d2">User layer software provides an interface for user interaction, enabling users to invoke I/O-related library functions to operate devices through system calls.</data>
      <data key="d3">chunk-1e6791234c2dc9ee6f432df1989fc60b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796532</data>
    </node>
    <node id="中断处理程序">
      <data key="d0">中断处理程序</data>
      <data key="d1">softwarelayer</data>
      <data key="d2">Interrupt handler is a program triggered when an I/O operation completes, responsible for context switching, testing interrupt sources, reading device status, and updating process state.</data>
      <data key="d3">chunk-1e6791234c2dc9ee6f432df1989fc60b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796532</data>
    </node>
    <node id="用户层">
      <data key="d0">用户层</data>
      <data key="d1">layer</data>
      <data key="d2">User layer is the highest level of the I/O software hierarchy, where user applications interact with the system through library functions.</data>
      <data key="d3">chunk-1e6791234c2dc9ee6f432df1989fc60b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796532</data>
    </node>
    <node id="设备独立性">
      <data key="d0">设备独立性</data>
      <data key="d1">concept</data>
      <data key="d2">Device independence, also referred to as device independence, enables applications to use logical device names without being tied to specific physical devices.</data>
      <data key="d3">chunk-1e6791234c2dc9ee6f432df1989fc60b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796532</data>
    </node>
    <node id="逻辑设备名">
      <data key="d0">逻辑设备名</data>
      <data key="d1">concept</data>
      <data key="d2">Logical device name is a abstract identifier used in device-independent software, allowing flexible device assignment and I/O redirection.</data>
      <data key="d3">chunk-1e6791234c2dc9ee6f432df1989fc60b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796532</data>
    </node>
    <node id="物理设备名">
      <data key="d0">物理设备名</data>
      <data key="d1">concept</data>
      <data key="d2">Physical device name refers to the specific identifier of a physical hardware device, which is mapped from a logical device name during device operations.</data>
      <data key="d3">chunk-1e6791234c2dc9ee6f432df1989fc60b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796533</data>
    </node>
    <node id="系统调用">
      <data key="d0">系统调用</data>
      <data key="d1">method</data>
      <data key="d2">System calls are interfaces that allow user-level software to request services from the operating system.</data>
      <data key="d3">chunk-1e6791234c2dc9ee6f432df1989fc60b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796533</data>
    </node>
    <node id="缓冲管理">
      <data key="d0">缓冲管理</data>
      <data key="d1">function</data>
      <data key="d2">Buffer management is the process of managing memory buffers to facilitate efficient data transfer between devices and memory.</data>
      <data key="d3">chunk-1e6791234c2dc9ee6f432df1989fc60b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796533</data>
    </node>
    <node id="差错控制">
      <data key="d0">差错控制</data>
      <data key="d1">function</data>
      <data key="d2">Error control is the mechanism responsible for detecting and handling errors during device I/O operations.</data>
      <data key="d3">chunk-1e6791234c2dc9ee6f432df1989fc60b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796533</data>
    </node>
    <node id="设备分配">
      <data key="d0">设备分配</data>
      <data key="d1">function</data>
      <data key="d2">Device allocation refers to the process of assigning a device to a requesting process, managed through device independence software.</data>
      <data key="d3">chunk-1e6791234c2dc9ee6f432df1989fc60b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796533</data>
    </node>
    <node id="设备释放">
      <data key="d0">设备释放</data>
      <data key="d1">function</data>
      <data key="d2">Device release is the process of freeing a device after use, ensuring availability for other processes.</data>
      <data key="d3">chunk-1e6791234c2dc9ee6f432df1989fc60b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796533</data>
    </node>
    <node id="进程上下文切换">
      <data key="d0">进程上下文切换</data>
      <data key="d1">function</data>
      <data key="d2">Process context switching involves saving and restoring the state of a process when handling interrupts or system calls.</data>
      <data key="d3">chunk-1e6791234c2dc9ee6f432df1989fc60b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796533</data>
    </node>
    <node id="设备状态">
      <data key="d0">设备状态</data>
      <data key="d1">data</data>
      <data key="d2">Device state is the current operational status of a device, including readiness, error, or busy conditions, which is monitored by the interrupt handler.</data>
      <data key="d3">chunk-1e6791234c2dc9ee6f432df1989fc60b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796533</data>
    </node>
    <node id="设备命名">
      <data key="d0">设备命名</data>
      <data key="d1">function</data>
      <data key="d2">Device naming is the process of assigning names to devices to support identification and access in device-independent operations.</data>
      <data key="d3">chunk-1e6791234c2dc9ee6f432df1989fc60b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796535</data>
    </node>
    <node id="设备保护">
      <data key="d0">设备保护</data>
      <data key="d1">function</data>
      <data key="d2">Device protection ensures that access to devices is controlled and secure based on user permissions and system policies.</data>
      <data key="d3">chunk-1e6791234c2dc9ee6f432df1989fc60b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796535</data>
    </node>
    <node id="I/O进程">
      <data key="d0">I/O进程</data>
      <data key="d1">concept</data>
      <data key="d2">I/O process refers to the logical entity responsible for managing input and output operations in the system.</data>
      <data key="d3">chunk-1e6791234c2dc9ee6f432df1989fc60b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796535</data>
    </node>
    <node id="设备控制器">
      <data key="d0">设备控制器</data>
      <data key="d1">artifact</data>
      <data key="d2">Device controller is the hardware component responsible for managing the operation of a specific device and communicating with the CPU.&lt;SEP&gt;Device controller is a hardware component responsible for managing interaction between the CPU and I/O devices, consisting of interfaces and logic for command processing.</data>
      <data key="d3">chunk-1e6791234c2dc9ee6f432df1989fc60b&lt;SEP&gt;chunk-b97ef22d499b3d442bd72f94c0600b3e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796538</data>
    </node>
    <node id="中断信号">
      <data key="d0">中断信号</data>
      <data key="d1">data</data>
      <data key="d2">Interrupt signal is a notification sent by a device controller to the CPU to indicate the completion of an I/O operation.</data>
      <data key="d3">chunk-1e6791234c2dc9ee6f432df1989fc60b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796535</data>
    </node>
    <node id="I/O设备">
      <data key="d0">I/O设备</data>
      <data key="d1">artifact</data>
      <data key="d2">I/O devices are external devices that either input data into a computer or output data from a computer, encompassing a wide variety of hardware with different functionalities.</data>
      <data key="d3">chunk-b97ef22d499b3d442bd72f94c0600b3e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796536</data>
    </node>
    <node id="操作系统设计">
      <data key="d0">操作系统设计</data>
      <data key="d1">concept</data>
      <data key="d2">Operating system design involves the development and structuring of system software to efficiently manage hardware resources, particularly focusing on complexity in I/O device management.</data>
      <data key="d3">chunk-b97ef22d499b3d442bd72f94c0600b3e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796536</data>
    </node>
    <node id="块设备">
      <data key="d0">块设备</data>
      <data key="d1">artifact</data>
      <data key="d2">Block devices are storage devices that transfer data in fixed-size blocks, such as hard drives and magnetic tapes, characterized by high transfer rates and random access capabilities.</data>
      <data key="d3">chunk-b97ef22d499b3d442bd72f94c0600b3e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796536</data>
    </node>
    <node id="字符设备">
      <data key="d0">字符设备</data>
      <data key="d1">artifact</data>
      <data key="d2">Character devices transfer data one character at a time, typically featuring low transfer rates, non-random access, and commonly using interrupt-based I/O methods, such as keyboards and printers.</data>
      <data key="d3">chunk-b97ef22d499b3d442bd72f94c0600b3e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796536</data>
    </node>
    <node id="低速设备">
      <data key="d0">低速设备</data>
      <data key="d1">artifact</data>
      <data key="d2">Low-speed devices have data transfer rates ranging from a few bytes to hundreds of bytes per second, including input devices like keyboards and mice.</data>
      <data key="d3">chunk-b97ef22d499b3d442bd72f94c0600b3e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796536</data>
    </node>
    <node id="中速设备">
      <data key="d0">中速设备</data>
      <data key="d1">artifact</data>
      <data key="d2">Medium-speed devices transfer data at rates from thousands to tens of thousands of bytes per second, such as laser printers.</data>
      <data key="d3">chunk-b97ef22d499b3d442bd72f94c0600b3e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796536</data>
    </node>
    <node id="高速设备">
      <data key="d0">高速设备</data>
      <data key="d1">artifact</data>
      <data key="d2">High-speed devices transfer data at rates from hundreds of kilobytes to gigabytes per second, including storage devices like disks and optical drives.</data>
      <data key="d3">chunk-b97ef22d499b3d442bd72f94c0600b3e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796536</data>
    </node>
    <node id="人机交互设备">
      <data key="d0">人机交互设备</data>
      <data key="d1">artifact</data>
      <data key="d2">Human-computer interaction devices enable communication between users and computers, such as keyboards, displays, and printers.</data>
      <data key="d3">chunk-b97ef22d499b3d442bd72f94c0600b3e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796536</data>
    </node>
    <node id="存储设备">
      <data key="d0">存储设备</data>
      <data key="d1">artifact</data>
      <data key="d2">Storage devices are used for preserving data, including magnetic disks, tapes, and optical discs.</data>
      <data key="d3">chunk-b97ef22d499b3d442bd72f94c0600b3e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796537</data>
    </node>
    <node id="网络通信设备">
      <data key="d0">网络通信设备</data>
      <data key="d1">artifact</data>
      <data key="d2">Network communication devices facilitate data exchange between computers, such as network interface cards and modems.</data>
      <data key="d3">chunk-b97ef22d499b3d442bd72f94c0600b3e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796538</data>
    </node>
    <node id="独占设备">
      <data key="d0">独占设备</data>
      <data key="d1">artifact</data>
      <data key="d2">Dedicated devices can only be used by one process at a time, typically low-speed devices like printers, until they are released.</data>
      <data key="d3">chunk-b97ef22d499b3d442bd72f94c0600b3e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796538</data>
    </node>
    <node id="共享设备">
      <data key="d0">共享设备</data>
      <data key="d1">artifact</data>
      <data key="d2">Shared devices allow multiple processes to access them simultaneously, generally utilizing time-sharing mechanisms, such as disk drives.</data>
      <data key="d3">chunk-b97ef22d499b3d442bd72f94c0600b3e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796538</data>
    </node>
    <node id="虚拟设备">
      <data key="d0">虚拟设备</data>
      <data key="d1">artifact</data>
      <data key="d2">Virtual devices are created by transforming dedicated devices into shared ones through SPOOLing technology, allowing multiple logical devices to be derived from one physical device.</data>
      <data key="d3">chunk-b97ef22d499b3d442bd72f94c0600b3e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796538</data>
    </node>
    <node id="I/O接口">
      <data key="d0">I/O接口</data>
      <data key="d1">artifact</data>
      <data key="d2">I/O interface, also known as a device controller, acts as a bridge between the CPU and external devices, managing data exchange and device control.</data>
      <data key="d3">chunk-b97ef22d499b3d442bd72f94c0600b3e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796538</data>
    </node>
    <node id="数据线">
      <data key="d0">数据线</data>
      <data key="d1">artifact</data>
      <data key="d2">Data lines are signal lines used to transfer data between the CPU and the device controller.</data>
      <data key="d3">chunk-b97ef22d499b3d442bd72f94c0600b3e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796538</data>
    </node>
    <node id="地址线">
      <data key="d0">地址线</data>
      <data key="d1">artifact</data>
      <data key="d2">Address lines are signal lines used to specify the memory or I/O device address during communication between CPU and device controller.</data>
      <data key="d3">chunk-b97ef22d499b3d442bd72f94c0600b3e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796539</data>
    </node>
    <node id="控制线">
      <data key="d0">控制线</data>
      <data key="d1">artifact</data>
      <data key="d2">Control lines are used to carry command and status signals between the CPU and the device controller.</data>
      <data key="d3">chunk-b97ef22d499b3d442bd72f94c0600b3e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796539</data>
    </node>
    <node id="I/O逻辑">
      <data key="d0">I/O逻辑</data>
      <data key="d1">artifact</data>
      <data key="d2">I/O logic is a component within the device controller responsible for decoding I/O commands received from the CPU and managing device operations.</data>
      <data key="d3">chunk-b97ef22d499b3d442bd72f94c0600b3e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796539</data>
    </node>
    <node id="数据寄存器">
      <data key="d0">数据寄存器</data>
      <data key="d1">artifact</data>
      <data key="d2">Data registers are used to temporarily store input data from devices or output data to be sent to devices.</data>
      <data key="d3">chunk-b97ef22d499b3d442bd72f94c0600b3e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796539</data>
    </node>
    <node id="状态寄存器">
      <data key="d0">状态寄存器</data>
      <data key="d1">artifact</data>
      <data key="d2">Status registers hold device execution results or current state information, accessible by the CPU for monitoring.</data>
      <data key="d3">chunk-b97ef22d499b3d442bd72f94c0600b3e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796539</data>
    </node>
    <node id="控制寄存器">
      <data key="d0">控制寄存器</data>
      <data key="d1">artifact</data>
      <data key="d2">Control registers are writable by the CPU to initiate commands or modify device operation modes.</data>
      <data key="d3">chunk-b97ef22d499b3d442bd72f94c0600b3e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796539</data>
    </node>
    <node id="独立编址">
      <data key="d0">独立编址</data>
      <data key="d1">method</data>
      <data key="d2">Independent addressing is a method where I/O ports have their own address space separate from main memory, using dedicated I/O instructions.</data>
      <data key="d3">chunk-b97ef22d499b3d442bd72f94c0600b3e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796540</data>
    </node>
    <node id="统一编址">
      <data key="d0">统一编址</data>
      <data key="d1">method</data>
      <data key="d2">Unified addressing, also called memory-mapped I/O, integrates I/O port addresses into the main memory address space, allowing I/O devices to be accessed using standard memory instructions.</data>
      <data key="d3">chunk-b97ef22d499b3d442bd72f94c0600b3e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796540</data>
    </node>
    <node id="并行接口">
      <data key="d0">并行接口</data>
      <data key="d1">artifact</data>
      <data key="d2">Parallel interface is a type of I/O interface that transmits multiple bits simultaneously over multiple lines.</data>
      <data key="d3">chunk-b97ef22d499b3d442bd72f94c0600b3e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796541</data>
    </node>
    <node id="串行接口">
      <data key="d0">串行接口</data>
      <data key="d1">artifact</data>
      <data key="d2">Serial interface is a type of I/O interface that transmits data bit by bit over a single line.</data>
      <data key="d3">chunk-b97ef22d499b3d442bd72f94c0600b3e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796541</data>
    </node>
    <node id="程序查询接口">
      <data key="d0">程序查询接口</data>
      <data key="d1">artifact</data>
      <data key="d2">Programmed I/O interface is a control method where the CPU continuously polls the device to check its status before data transfer.</data>
      <data key="d3">chunk-b97ef22d499b3d442bd72f94c0600b3e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796541</data>
    </node>
    <node id="中断接口">
      <data key="d0">中断接口</data>
      <data key="d1">artifact</data>
      <data key="d2">Interrupt interface is a control method where the device signals the CPU via interrupts when it is ready for data transfer.</data>
      <data key="d3">chunk-b97ef22d499b3d442bd72f94c0600b3e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796541</data>
    </node>
    <node id="DMA接口">
      <data key="d0">DMA接口</data>
      <data key="d1">artifact</data>
      <data key="d2">DMA interface is a control method that allows direct memory access, enabling data transfer between memory and devices without CPU intervention.</data>
      <data key="d3">chunk-b97ef22d499b3d442bd72f94c0600b3e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796541</data>
    </node>
    <node id="可编程接口">
      <data key="d0">可编程接口</data>
      <data key="d1">artifact</data>
      <data key="d2">Programmable interface is an interface that can be configured or reprogrammed by software to adapt to different devices or operations.</data>
      <data key="d3">chunk-b97ef22d499b3d442bd72f94c0600b3e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796541</data>
    </node>
    <node id="不可编程接口">
      <data key="d0">不可编程接口</data>
      <data key="d1">artifact</data>
      <data key="d2">Non-programmable interface is an interface with fixed functionality that cannot be modified by software.</data>
      <data key="d3">chunk-b97ef22d499b3d442bd72f94c0600b3e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796542</data>
    </node>
    <node id="磁带">
      <data key="d0">磁带</data>
      <data key="d1">artifact</data>
      <data key="d2">Magnetic tape is a sequential storage device used for data backup and archival, classified as a block device with high capacity but slow access time.</data>
      <data key="d3">chunk-b97ef22d499b3d442bd72f94c0600b3e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796542</data>
    </node>
    <node id="光盘">
      <data key="d0">光盘</data>
      <data key="d1">artifact</data>
      <data key="d2">Optical disc is a storage medium that uses laser technology to read and write data, typically classified as a block device.</data>
      <data key="d3">chunk-b97ef22d499b3d442bd72f94c0600b3e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796542</data>
    </node>
    <node id="调制解调器">
      <data key="d0">调制解调器</data>
      <data key="d1">artifact</data>
      <data key="d2">Modem is a network communication device that converts digital signals into analog signals for transmission over telephone lines and vice versa.</data>
      <data key="d3">chunk-b97ef22d499b3d442bd72f94c0600b3e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796543</data>
    </node>
    <node id="网卡">
      <data key="d0">网卡</data>
      <data key="d1">artifact</data>
      <data key="d2">Network interface card (NIC) is a hardware component that connects a computer to a network, enabling communication over wired or wireless connections.</data>
      <data key="d3">chunk-b97ef22d499b3d442bd72f94c0600b3e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796543</data>
    </node>
    <node id="I/O Port Decoding">
      <data key="d0">I/O Port Decoding</data>
      <data key="d1">concept</data>
      <data key="d2">I/O port decoding refers to the process of interpreting I/O port addresses for device communication, which is simpler in isolated addressing schemes.</data>
      <data key="d3">chunk-24e218fe981e25857a4b5fef1ad3838d</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796543</data>
    </node>
    <node id="Address Space">
      <data key="d0">Address Space</data>
      <data key="d1">concept</data>
      <data key="d2">Address space represents the range of addresses available for memory and I/O devices in a computer system, with two types: independent and unified.</data>
      <data key="d3">chunk-24e218fe981e25857a4b5fef1ad3838d</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796543</data>
    </node>
    <node id="Independent Addressing">
      <data key="d0">Independent Addressing</data>
      <data key="d1">method</data>
      <data key="d2">Independent addressing separates I/O ports and memory into distinct address spaces, requiring dedicated I/O instructions and control signals.</data>
      <data key="d3">chunk-24e218fe981e25857a4b5fef1ad3838d</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796543</data>
    </node>
    <node id="Unified Addressing">
      <data key="d0">Unified Addressing</data>
      <data key="d1">method</data>
      <data key="d2">Unified addressing, also known as memory-mapped I/O, integrates I/O ports into the main memory address space, allowing shared access via standard memory instructions.</data>
      <data key="d3">chunk-24e218fe981e25857a4b5fef1ad3838d</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796543</data>
    </node>
    <node id="Main Memory Address Space">
      <data key="d0">Main Memory Address Space</data>
      <data key="d1">concept</data>
      <data key="d2">The main memory address space is a portion of the total address space allocated for memory storage, partially used for I/O port addresses in unified addressing.</data>
      <data key="d3">chunk-24e218fe981e25857a4b5fef1ad3838d</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796543</data>
    </node>
    <node id="Speed of Addressing">
      <data key="d0">Speed of Addressing</data>
      <data key="d1">concept</data>
      <data key="d2">Speed of addressing refers to the efficiency with which addresses are accessed, faster in independent addressing due to simpler decoding.</data>
      <data key="d3">chunk-24e218fe981e25857a4b5fef1ad3838d</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796544</data>
    </node>
    <node id="Dedicated I/O Instructions">
      <data key="d0">Dedicated I/O Instructions</data>
      <data key="d1">method</data>
      <data key="d2">Dedicated I/O instructions are specialized CPU instructions used to access I/O ports, which are present only in independent addressing.</data>
      <data key="d3">chunk-24e218fe981e25857a4b5fef1ad3838d</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796544</data>
    </node>
    <node id="Control Signal Complexity">
      <data key="d0">Control Signal Complexity</data>
      <data key="d1">concept</data>
      <data key="d2">Control signal complexity refers to the number of distinct control signals required by the CPU, higher in independent addressing due to separate I/O and memory signals.</data>
      <data key="d3">chunk-24e218fe981e25857a4b5fef1ad3838d</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796544</data>
    </node>
    <node id="Flexibility in Programming">
      <data key="d0">Flexibility in Programming</data>
      <data key="d1">concept</data>
      <data key="d2">Flexibility in programming is enhanced in unified addressing since I/O operations use the same instructions as memory operations.</data>
      <data key="d3">chunk-24e218fe981e25857a4b5fef1ad3838d</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796545</data>
    </node>
    <node id="Address Space Occupancy">
      <data key="d0">Address Space Occupancy</data>
      <data key="d1">concept</data>
      <data key="d2">Address space occupancy indicates how much of the main memory space is used for I/O port addresses, reducing available memory in unified addressing.</data>
      <data key="d3">chunk-24e218fe981e25857a4b5fef1ad3838d</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796545</data>
    </node>
    <node id="Decoding Circuit Complexity">
      <data key="d0">Decoding Circuit Complexity</data>
      <data key="d1">concept</data>
      <data key="d2">Decoding circuit complexity refers to the intricacy of circuits used to map addresses to devices, higher in unified addressing due to overlapping address mapping.</data>
      <data key="d3">chunk-24e218fe981e25857a4b5fef1ad3838d</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796545</data>
    </node>
    <node id="Two Independent Address Spaces">
      <data key="d0">Two Independent Address Spaces</data>
      <data key="d1">concept</data>
      <data key="d2">Two independent address spaces refer to the separation of memory and I/O address ranges, a fundamental characteristic of independent addressing.</data>
      <data key="d3">chunk-24e218fe981e25857a4b5fef1ad3838d</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796545</data>
    </node>
    <node id="Memory-Mapped I/O">
      <data key="d0">Memory-Mapped I/O</data>
      <data key="d1">method</data>
      <data key="d2">Memory-mapped I/O is another term for unified addressing, where I/O ports are treated as part of the main memory address space.</data>
      <data key="d3">chunk-24e218fe981e25857a4b5fef1ad3838d</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796545</data>
    </node>
    <node id="打印机">
      <data key="d0">打印机</data>
      <data key="d3">chunk-b97ef22d499b3d442bd72f94c0600b3e</data>
      <data key="d2">Printers are typical examples of dedicated devices that can only be used by one process at a time.</data>
      <data key="d1">UNKNOWN</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796547</data>
    </node>
    <node id="SPOOLing技术">
      <data key="d0">SPOOLing技术</data>
      <data key="d3">chunk-b97ef22d499b3d442bd72f94c0600b3e</data>
      <data key="d2">Virtual devices are created using SPOOLing technology, transforming dedicated devices into shared ones.</data>
      <data key="d1">UNKNOWN</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796548</data>
    </node>
    <node id="修改进程状态">
      <data key="d0">修改进程状态</data>
      <data key="d3">chunk-1e6791234c2dc9ee6f432df1989fc60b</data>
      <data key="d2">Interrupt handler updates the process state to reflect I/O completion and enables resumption of the interrupted process.</data>
      <data key="d1">UNKNOWN</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796550</data>
    </node>
    <node id="统一接口">
      <data key="d0">统一接口</data>
      <data key="d3">chunk-1e6791234c2dc9ee6f432df1989fc60b</data>
      <data key="d2">Device independence software provides a unified interface to the user layer or file layer, enabling device-independent operations.</data>
      <data key="d1">UNKNOWN</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796550</data>
    </node>
    <node id="Solid State Disk">
      <data key="d0">Solid State Disk</data>
      <data key="d1">artifact</data>
      <data key="d2">Solid State Disk (SSD) is a storage device based on flash memory technology, consisting of one or more flash memory chips and a flash translation layer.</data>
      <data key="d3">chunk-8189302c7787e74dde6623016361fc8f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796578</data>
    </node>
    <node id="Flash Memory Chip">
      <data key="d0">Flash Memory Chip</data>
      <data key="d1">artifact</data>
      <data key="d2">A flash memory chip is a component of SSDs that stores data and replaces the mechanical drive in traditional hard disks.</data>
      <data key="d3">chunk-8189302c7787e74dde6623016361fc8f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796578</data>
    </node>
    <node id="Flash Translation Layer">
      <data key="d0">Flash Translation Layer</data>
      <data key="d1">artifact</data>
      <data key="d2">The flash translation layer translates logical block read/write requests from the CPU into physical read/write control signals for the underlying flash memory device, functioning as a disk controller.</data>
      <data key="d3">chunk-8189302c7787e74dde6623016361fc8f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796578</data>
    </node>
    <node id="Page">
      <data key="d0">Page</data>
      <data key="d1">data</data>
      <data key="d2">A page is the smallest unit of data that can be read from or written to a flash memory device, with data written on a page-by-page basis.</data>
      <data key="d3">chunk-8189302c7787e74dde6623016361fc8f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796578</data>
    </node>
    <node id="Wear Leveling">
      <data key="d0">Wear Leveling</data>
      <data key="d1">method</data>
      <data key="d2">Wear leveling is a technique used in SSDs to distribute write and erase operations evenly across all flash memory blocks to prevent premature wear and extend device lifespan.</data>
      <data key="d3">chunk-8189302c7787e74dde6623016361fc8f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796578</data>
    </node>
    <node id="Dynamic Wear Leveling">
      <data key="d0">Dynamic Wear Leveling</data>
      <data key="d1">method</data>
      <data key="d2">Dynamic wear leveling is a type of wear leveling that prioritizes writing data to flash blocks with fewer erase cycles, thereby balancing wear across blocks.</data>
      <data key="d3">chunk-8189302c7787e74dde6623016361fc8f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796578</data>
    </node>
    <node id="Static Wear Leveling">
      <data key="d0">Static Wear Leveling</data>
      <data key="d1">method</data>
      <data key="d2">Static wear leveling is a technique that reassigns data in idle blocks for read operations, allowing newer blocks to handle writing tasks and improving wear distribution.</data>
      <data key="d3">chunk-8189302c7787e74dde6623016361fc8f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796578</data>
    </node>
    <node id="Random Write">
      <data key="d0">Random Write</data>
      <data key="d1">concept</data>
      <data key="d2">Random write refers to the process of writing data to non-sequential locations in storage, which is slow in SSDs due to the need to erase entire blocks before rewriting.</data>
      <data key="d3">chunk-8189302c7787e74dde6623016361fc8f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796580</data>
    </node>
    <node id="Erase Cycle">
      <data key="d0">Erase Cycle</data>
      <data key="d1">concept</data>
      <data key="d2">An erase cycle is the process of clearing data from a flash memory block, which is a slow operation and contributes to wear in SSDs.</data>
      <data key="d3">chunk-8189302c7787e74dde6623016361fc8f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796580</data>
    </node>
    <node id="Flash Memory Lifetime">
      <data key="d0">Flash Memory Lifetime</data>
      <data key="d1">concept</data>
      <data key="d2">Flash memory lifetime refers to the finite number of write/erase cycles a flash memory block can endure before failing.</data>
      <data key="d3">chunk-8189302c7787e74dde6623016361fc8f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796580</data>
    </node>
    <node id="Mechanical Drive">
      <data key="d0">Mechanical Drive</data>
      <data key="d1">artifact</data>
      <data key="d2">A mechanical drive is a traditional hard disk with moving parts used for data storage, replaced by SSDs in modern systems.</data>
      <data key="d3">chunk-8189302c7787e74dde6623016361fc8f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796580</data>
    </node>
    <node id="Semiconductor Storage">
      <data key="d0">Semiconductor Storage</data>
      <data key="d1">artifact</data>
      <data key="d2">Semiconductor storage refers to memory technology based on integrated circuits, such as flash memory used in SSDs.</data>
      <data key="d3">chunk-8189302c7787e74dde6623016361fc8f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796580</data>
    </node>
    <node id="SPOOLing Technology">
      <data key="d0">SPOOLing Technology</data>
      <data key="d1">method</data>
      <data key="d2">SPOOLing technology is an operating system technique that resolves the speed mismatch between CPU and I/O devices by converting exclusive-use devices into shared ones using disk storage and buffer management.</data>
      <data key="d3">chunk-b309162a426d62e33a3be632483b375d</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796582</data>
    </node>
    <node id="I/O Devices">
      <data key="d0">I/O Devices</data>
      <data key="d1">artifact</data>
      <data key="d2">I/O devices are input/output peripherals with lower operational speeds compared to the CPU.</data>
      <data key="d3">chunk-b309162a426d62e33a3be632483b375d</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796582</data>
    </node>
    <node id="Peripheral Control Machine">
      <data key="d0">Peripheral Control Machine</data>
      <data key="d1">artifact</data>
      <data key="d2">A specialized machine used in SPOOLing systems to manage data transfers between devices and storage.</data>
      <data key="d3">chunk-b309162a426d62e33a3be632483b375d</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796582</data>
    </node>
    <node id="Input井">
      <data key="d0">Input井</data>
      <data key="d1">artifact</data>
      <data key="d2">Input井is a storage area on disk simulating offline input, used to receive data from input devices.</data>
      <data key="d3">chunk-b309162a426d62e33a3be632483b375d</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796582</data>
    </node>
    <node id="Output井">
      <data key="d0">Output井</data>
      <data key="d1">artifact</data>
      <data key="d2">Output井is a storage area on disk simulating offline output, used to hold output data from programs.</data>
      <data key="d3">chunk-b309162a426d62e33a3be632483b375d</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796582</data>
    </node>
    <node id="Input Buffer">
      <data key="d0">Input Buffer</data>
      <data key="d1">artifact</data>
      <data key="d2">Input Buffer is a memory area that temporarily holds data from input devices before being transferred to the input井.</data>
      <data key="d3">chunk-b309162a426d62e33a3be632483b375d</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796582</data>
    </node>
    <node id="Output Buffer">
      <data key="d0">Output Buffer</data>
      <data key="d1">artifact</data>
      <data key="d2">Output Buffer is a memory area that temporarily holds data from output井before sending it to the output device.</data>
      <data key="d3">chunk-b309162a426d62e33a3be632483b375d</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796582</data>
    </node>
    <node id="Input Process">
      <data key="d0">Input Process</data>
      <data key="d1">method</data>
      <data key="d2">Input Process simulates a peripheral control machine by transferring data from input devices to the input buffer and then to the input井.</data>
      <data key="d3">chunk-b309162a426d62e33a3be632483b375d</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796584</data>
    </node>
    <node id="Output Process">
      <data key="d0">Output Process</data>
      <data key="d1">method</data>
      <data key="d2">Output Process simulates a peripheral control machine by transferring data from memory to output井and then to the output device via output buffer.</data>
      <data key="d3">chunk-b309162a426d62e33a3be632483b375d</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796584</data>
    </node>
    <node id="井管理程序">
      <data key="d0">井管理程序</data>
      <data key="d1">method</data>
      <data key="d2">井管理程序controls the exchange of information between jobs and disk井, coordinating SPOOLing operations.</data>
      <data key="d3">chunk-b309162a426d62e33a3be632483b375d</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796584</data>
    </node>
    <node id="SPOOLing Management Process">
      <data key="d0">SPOOLing Management Process</data>
      <data key="d1">method</data>
      <data key="d2">SPOOLing Management Process handles print job requests by allocating disk space and managing job queues.</data>
      <data key="d3">chunk-b309162a426d62e33a3be632483b375d</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796584</data>
    </node>
    <node id="User Request Print Table">
      <data key="d0">User Request Print Table</data>
      <data key="d1">artifact</data>
      <data key="d2">User Request Print Table is a data structure that stores print job details and is linked to the SPOOLing file queue.</data>
      <data key="d3">chunk-b309162a426d62e33a3be632483b375d</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796584</data>
    </node>
    <node id="SPOOLing File Queue">
      <data key="d0">SPOOLing File Queue</data>
      <data key="d1">artifact</data>
      <data key="d2">SPOOLing File Queue is a list of print job entries awaiting processing, managed by the SPOOLing system.</data>
      <data key="d3">chunk-b309162a426d62e33a3be632483b375d</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796584</data>
    </node>
    <node id="Disk Buffer Area">
      <data key="d0">Disk Buffer Area</data>
      <data key="d1">artifact</data>
      <data key="d2">Disk Buffer Area is a reserved portion of disk space used to temporarily hold data during SPOOLing operations.</data>
      <data key="d3">chunk-b309162a426d62e33a3be632483b375d</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796584</data>
    </node>
    <node id="Virtual Device Function">
      <data key="d0">Virtual Device Function</data>
      <data key="d1">concept</data>
      <data key="d2">Virtual Device Function is a capability enabled by SPOOLing, allowing exclusive devices to be used concurrently by multiple users.</data>
      <data key="d3">chunk-b309162a426d62e33a3be632483b375d</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796585</data>
    </node>
    <node id="Space for Time">
      <data key="d0">Space for Time</data>
      <data key="d1">concept</data>
      <data key="d2">Space for Time is a design principle where storage space is used to improve processing speed and efficiency.</data>
      <data key="d3">chunk-b309162a426d62e33a3be632483b375d</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761796586</data>
    </node>
    <edge source="磁盘" target="低级格式化">
      <data key="d6">1.0</data>
      <data key="d7">The disk must undergo low-level formatting to divide it into sectors before it can be used for data storage.</data>
      <data key="d8">initialization,physical preparation</data>
      <data key="d9">chunk-c2534a02f1b3f01bcdf887749e6526e4</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796231</data>
    </edge>
    <edge source="磁盘" target="分区">
      <data key="d6">1.0</data>
      <data key="d7">A disk is divided into partitions, each consisting of one or more cylinders, to manage data independently.</data>
      <data key="d8">logical division,storage organization</data>
      <data key="d9">chunk-c2534a02f1b3f01bcdf887749e6526e4</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796231</data>
    </edge>
    <edge source="磁盘" target="共享设备">
      <data key="d6">2.0</data>
      <data key="d7">Disk drives are classic examples of shared devices that support concurrent access by multiple processes.&lt;SEP&gt;Disk is classified as a shared device because it allows multiple processes to access its storage simultaneously through time-sharing.</data>
      <data key="d8">concurrent access,device classification,device example,simultaneous access</data>
      <data key="d9">chunk-b97ef22d499b3d442bd72f94c0600b3e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796548</data>
    </edge>
    <edge source="扇区" target="簇">
      <data key="d6">1.0</data>
      <data key="d7">A cluster is formed by combining multiple adjacent sectors to improve I/O efficiency.</data>
      <data key="d8">efficiency optimization,storage grouping</data>
      <data key="d9">chunk-c2534a02f1b3f01bcdf887749e6526e4</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796231</data>
    </edge>
    <edge source="分区" target="磁盘主引导记录">
      <data key="d6">1.0</data>
      <data key="d7">The partition table within the disk master boot record records the starting sector and size of each partition.</data>
      <data key="d8">boot configuration,partitioning metadata</data>
      <data key="d9">chunk-c2534a02f1b3f01bcdf887749e6526e4</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796232</data>
    </edge>
    <edge source="分区" target="引导扇区">
      <data key="d6">1.0</data>
      <data key="d7">The first sector of a partition (the boot sector) is read as part of the boot process after the system selects a boot partition.</data>
      <data key="d8">boot sector access,system startup</data>
      <data key="d9">chunk-c2534a02f1b3f01bcdf887749e6526e4</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796233</data>
    </edge>
    <edge source="分区" target="逻辑格式化">
      <data key="d6">1.0</data>
      <data key="d7">Each partition must be logically formatted to install a file system, including root directory and space management structures.</data>
      <data key="d8">file system setup,logical initialization</data>
      <data key="d9">chunk-c2534a02f1b3f01bcdf887749e6526e4</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796233</data>
    </edge>
    <edge source="磁盘主引导记录" target="主引导记录">
      <data key="d6">1.0</data>
      <data key="d7">The MBR is synonymous with the master boot record and serves as the first sector of the disk.</data>
      <data key="d8">boot sector redundancy,file system marker</data>
      <data key="d9">chunk-c2534a02f1b3f01bcdf887749e6526e4</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796232</data>
    </edge>
    <edge source="自举程序" target="ROM">
      <data key="d6">1.0</data>
      <data key="d7">The self-boot program runs from ROM to initialize hardware components such as CPU, registers, and controllers.</data>
      <data key="d8">hardware initialization,initial boot code execution</data>
      <data key="d9">chunk-c2534a02f1b3f01bcdf887749e6526e4</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796231</data>
    </edge>
    <edge source="自举程序" target="引导块">
      <data key="d6">1.0</data>
      <data key="d7">The full boot program is stored on the boot block of the disk and loaded after the ROM code runs.</data>
      <data key="d8">boot code execution,system loading</data>
      <data key="d9">chunk-c2534a02f1b3f01bcdf887749e6526e4</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796231</data>
    </edge>
    <edge source="引导块" target="启动磁盘">
      <data key="d6">1.0</data>
      <data key="d7">A boot block is a key component of a bootable or system disk, enabling the system to start.</data>
      <data key="d8">bootable storage,system startup</data>
      <data key="d9">chunk-c2534a02f1b3f01bcdf887749e6526e4</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796232</data>
    </edge>
    <edge source="主引导记录" target="Windows系统">
      <data key="d6">1.0</data>
      <data key="d7">Windows System stores the boot code in the Master Boot Record (sector 0), which is used to initiate the boot process.</data>
      <data key="d8">boot code storage,operating system integration</data>
      <data key="d9">chunk-c2534a02f1b3f01bcdf887749e6526e4</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796232</data>
    </edge>
    <edge source="坏块" target="FAT表">
      <data key="d6">1.0</data>
      <data key="d7">Bad blocks are marked in the FAT table to ensure they are not used for data storage.</data>
      <data key="d8">allocation avoidance,data integrity tracking</data>
      <data key="d9">chunk-c2534a02f1b3f01bcdf887749e6526e4</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796231</data>
    </edge>
    <edge source="坏块" target="备用块">
      <data key="d6">1.0</data>
      <data key="d7">Bad blocks are logically replaced with spare blocks to maintain disk reliability.</data>
      <data key="d8">error recovery,logical replacement</data>
      <data key="d9">chunk-c2534a02f1b3f01bcdf887749e6526e4</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796232</data>
    </edge>
    <edge source="ROM" target="Device Driver">
      <data key="d6">1.0</data>
      <data key="d7">Device driver functions are often stored in ROM, especially for basic or hardware-specific components.</data>
      <data key="d8">code固化,firmware storage</data>
      <data key="d9">chunk-264fa4087fad0830a27723388157eee3</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796335</data>
    </edge>
    <edge source="Device Allocation" target="Device Control Table">
      <data key="d6">1.0</data>
      <data key="d7">The Device Control Table (DCT) is used to manage the state and attributes of each physical device during device allocation.</data>
      <data key="d8">data structure,device state management</data>
      <data key="d9">chunk-8a037d4e5404d755e89072cf77091d2b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796249</data>
    </edge>
    <edge source="Device Allocation" target="Controller Control Table">
      <data key="d6">1.0</data>
      <data key="d7">The Controller Control Table (COCT) is referenced during device allocation to manage controller status and assignment.</data>
      <data key="d8">controller management,data structure</data>
      <data key="d9">chunk-8a037d4e5404d755e89072cf77091d2b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796249</data>
    </edge>
    <edge source="Device Allocation" target="Channel Control Table">
      <data key="d6">1.0</data>
      <data key="d7">The Channel Control Table (CHCT) is consulted in device allocation to determine channel availability.</data>
      <data key="d8">channel management,data structure</data>
      <data key="d9">chunk-8a037d4e5404d755e89072cf77091d2b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796249</data>
    </edge>
    <edge source="Device Allocation" target="System Device Table">
      <data key="d6">1.0</data>
      <data key="d7">The System Device Table (SDT) is used to locate and verify the existence and state of physical devices during allocation.</data>
      <data key="d8">device discovery,global data reference</data>
      <data key="d9">chunk-8a037d4e5404d755e89072cf77091d2b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796250</data>
    </edge>
    <edge source="Device Allocation" target="Logical Unit Table">
      <data key="d6">1.0</data>
      <data key="d7">The Logical Unit Table (LUT) maps logical device names to physical device names, enabling device independence.</data>
      <data key="d8">logical-to-physical translation,mapping</data>
      <data key="d9">chunk-8a037d4e5404d755e89072cf77091d2b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796250</data>
    </edge>
    <edge source="Device Allocation" target="Exclusive Device">
      <data key="d6">1.0</data>
      <data key="d7">Exclusive devices are allocated using strategies that ensure only one process uses the device at a time.</data>
      <data key="d8">allocation strategy,exclusive access</data>
      <data key="d9">chunk-8a037d4e5404d755e89072cf77091d2b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796250</data>
    </edge>
    <edge source="Device Allocation" target="Shared Device">
      <data key="d6">1.0</data>
      <data key="d7">Shared devices are allocated using scheduling mechanisms to allow multiple processes to access them simultaneously.</data>
      <data key="d8">allocation strategy,concurrent access</data>
      <data key="d9">chunk-8a037d4e5404d755e89072cf77091d2b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796251</data>
    </edge>
    <edge source="Device Allocation" target="Virtual Device">
      <data key="d6">1.0</data>
      <data key="d7">Virtual devices are allocated across multiple processes using shared allocation principles.</data>
      <data key="d8">allocation strategy,shared virtualization</data>
      <data key="d9">chunk-8a037d4e5404d755e89072cf77091d2b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796251</data>
    </edge>
    <edge source="Device Allocation" target="FCFS Algorithm">
      <data key="d6">1.0</data>
      <data key="d7">The FCFS algorithm is applied during device allocation to ensure fair and orderly request processing.</data>
      <data key="d8">fairness,scheduling</data>
      <data key="d9">chunk-8a037d4e5404d755e89072cf77091d2b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796252</data>
    </edge>
    <edge source="Device Allocation" target="Highest Priority First Algorithm">
      <data key="d6">1.0</data>
      <data key="d7">The Highest Priority First algorithm is used to prioritize high-priority processes in device allocation.</data>
      <data key="d8">priority-based allocation,scheduling</data>
      <data key="d9">chunk-8a037d4e5404d755e89072cf77091d2b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796253</data>
    </edge>
    <edge source="Device Allocation" target="Safe Allocation Method">
      <data key="d6">1.0</data>
      <data key="d7">The Safe Allocation Method prevents deadlock by blocking processes until I/O completion.</data>
      <data key="d8">deadlock prevention,safety</data>
      <data key="d9">chunk-8a037d4e5404d755e89072cf77091d2b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796253</data>
    </edge>
    <edge source="Device Allocation" target="Unsafe Allocation Method">
      <data key="d6">1.0</data>
      <data key="d7">The Unsafe Allocation Method allows concurrent I/O operations but increases the risk of deadlock.</data>
      <data key="d8">concurrency,risk of deadlock</data>
      <data key="d9">chunk-8a037d4e5404d755e89072cf77091d2b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796254</data>
    </edge>
    <edge source="Device Control Table" target="Process Control Block">
      <data key="d6">1.0</data>
      <data key="d7">The Process Control Block (PCB) is linked to the Device Control Table when a process waits for device assignment.</data>
      <data key="d8">I/O waiting,resource tracking</data>
      <data key="d9">chunk-8a037d4e5404d755e89072cf77091d2b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796249</data>
    </edge>
    <edge source="Device Control Table" target="Physical Device">
      <data key="d6">1.0</data>
      <data key="d7">The Device Control Table holds attributes and current state of the physical device it represents.</data>
      <data key="d8">attribute tracking,device state</data>
      <data key="d9">chunk-8a037d4e5404d755e89072cf77091d2b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796250</data>
    </edge>
    <edge source="Device Control Table" target="Controller">
      <data key="d6">1.0</data>
      <data key="d7">The Device Control Table contains a pointer to the Controller Control Table for the controller managing the device.</data>
      <data key="d8">device-controller linkage</data>
      <data key="d9">chunk-8a037d4e5404d755e89072cf77091d2b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796252</data>
    </edge>
    <edge source="Controller Control Table" target="Process Control Block">
      <data key="d6">1.0</data>
      <data key="d7">The Process Control Block records the status of a process waiting for controller allocation.</data>
      <data key="d8">controller waiting,state tracking</data>
      <data key="d9">chunk-8a037d4e5404d755e89072cf77091d2b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796249</data>
    </edge>
    <edge source="Controller Control Table" target="Controller">
      <data key="d6">1.0</data>
      <data key="d7">The Controller Control Table maintains operational status and state of the controller it represents.</data>
      <data key="d8">management,status tracking</data>
      <data key="d9">chunk-8a037d4e5404d755e89072cf77091d2b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796251</data>
    </edge>
    <edge source="Controller Control Table" target="Channel">
      <data key="d6">1.0</data>
      <data key="d7">The Controller Control Table is linked to the Channel Control Table, reflecting the hierarchical control path.</data>
      <data key="d8">controller-channel relationship</data>
      <data key="d9">chunk-8a037d4e5404d755e89072cf77091d2b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796252</data>
    </edge>
    <edge source="Channel Control Table" target="Process Control Block">
      <data key="d6">1.0</data>
      <data key="d7">The Process Control Block contains information about a process waiting for channel availability.</data>
      <data key="d8">I/O queueing,channel waiting</data>
      <data key="d9">chunk-8a037d4e5404d755e89072cf77091d2b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796250</data>
    </edge>
    <edge source="Channel Control Table" target="Channel">
      <data key="d6">1.0</data>
      <data key="d7">The Channel Control Table tracks the status and activity of the channel it references.</data>
      <data key="d8">management,status monitoring</data>
      <data key="d9">chunk-8a037d4e5404d755e89072cf77091d2b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796251</data>
    </edge>
    <edge source="System Device Table" target="User-Specific LUT">
      <data key="d6">1.0</data>
      <data key="d7">In multi user systems, user-specific LUTs are paired with a centralized system device table to manage shared physical resources.</data>
      <data key="d8">complementary,system integration</data>
      <data key="d9">chunk-1d93c6dce65e857b6ccef73c51291bd2</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796253</data>
    </edge>
    <edge source="Logical Unit Table" target="Logical Device Name">
      <data key="d6">2.0</data>
      <data key="d7">The Logical Unit Table contains entries that map logical device names to their corresponding physical devices and driver addresses.&lt;SEP&gt;The Logical Unit Table maps logical device names to physical identifiers, supporting device independence.</data>
      <data key="d8">abstraction,identification,mapping</data>
      <data key="d9">chunk-1d93c6dce65e857b6ccef73c51291bd2&lt;SEP&gt;chunk-8a037d4e5404d755e89072cf77091d2b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796251</data>
    </edge>
    <edge source="Logical Unit Table" target="Physical Device Name">
      <data key="d6">2.0</data>
      <data key="d7">The Logical Unit Table links logical device names to the actual physical device names for system access.&lt;SEP&gt;The Logical Unit Table resolves logical device names to physical device names in system requests.</data>
      <data key="d8">identification,mapping,resolution</data>
      <data key="d9">chunk-1d93c6dce65e857b6ccef73c51291bd2&lt;SEP&gt;chunk-8a037d4e5404d755e89072cf77091d2b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796252</data>
    </edge>
    <edge source="Logical Unit Table" target="Device Driver">
      <data key="d6">1.0</data>
      <data key="d7">The Logical Unit Table contains the entry address of the device driver associated with the mapped physical device.</data>
      <data key="d8">binding,driver access</data>
      <data key="d9">chunk-8a037d4e5404d755e89072cf77091d2b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796252</data>
    </edge>
    <edge source="Logical Unit Table" target="Device Driver Entry Address">
      <data key="d6">1.0</data>
      <data key="d7">The Logical Unit Table includes device driver entry addresses to enable system calls to device drivers.</data>
      <data key="d8">access point,mapping</data>
      <data key="d9">chunk-1d93c6dce65e857b6ccef73c51291bd2</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796253</data>
    </edge>
    <edge source="Device Queue" target="Device Driver">
      <data key="d6">1.0</data>
      <data key="d7">Device driver uses the device queue to manage pending I/O requests when a device is busy.</data>
      <data key="d8">request waiting,scheduling</data>
      <data key="d9">chunk-264fa4087fad0830a27723388157eee3</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796334</data>
    </edge>
    <edge source="Physical Device Name" target="Device Driver">
      <data key="d6">1.0</data>
      <data key="d7">Device driver maps abstract device names to physical device names for access.</data>
      <data key="d8">device identification,mapping</data>
      <data key="d9">chunk-264fa4087fad0830a27723388157eee3</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796335</data>
    </edge>
    <edge source="Device Driver" target="I/O System">
      <data key="d6">1.0</data>
      <data key="d7">Device driver acts as an intermediary between the I/O system and device controller, translating abstract requests into specific commands.</data>
      <data key="d8">communication layer,request translation</data>
      <data key="d9">chunk-264fa4087fad0830a27723388157eee3</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796332</data>
    </edge>
    <edge source="Device Driver" target="Device Controller">
      <data key="d6">1.0</data>
      <data key="d7">Device driver sends commands to the device controller and receives status updates and completion signals.</data>
      <data key="d8">command execution,status feedback</data>
      <data key="d9">chunk-264fa4087fad0830a27723388157eee3</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796332</data>
    </edge>
    <edge source="Device Driver" target="Abstract I/O Request">
      <data key="d6">1.0</data>
      <data key="d7">Device driver receives and converts abstract I/O requests into device-specific operations.</data>
      <data key="d8">conversion,request processing</data>
      <data key="d9">chunk-264fa4087fad0830a27723388157eee3</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796332</data>
    </edge>
    <edge source="Device Driver" target="Read Command">
      <data key="d6">1.0</data>
      <data key="d7">Device driver processes read commands by instructing the device to retrieve data.</data>
      <data key="d8">command handling,data retrieval</data>
      <data key="d9">chunk-264fa4087fad0830a27723388157eee3</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796333</data>
    </edge>
    <edge source="Device Driver" target="Write Command">
      <data key="d6">1.0</data>
      <data key="d7">Device driver processes write commands by instructing the device to store data.</data>
      <data key="d8">command handling,data transmission</data>
      <data key="d9">chunk-264fa4087fad0830a27723388157eee3</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796333</data>
    </edge>
    <edge source="Device Driver" target="Device Status">
      <data key="d6">1.0</data>
      <data key="d7">Device driver checks and reports the operational status of a device.</data>
      <data key="d8">reporting,status monitoring</data>
      <data key="d9">chunk-264fa4087fad0830a27723388157eee3</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796333</data>
    </edge>
    <edge source="Device Driver" target="Interrupt Request">
      <data key="d6">1.0</data>
      <data key="d7">Device driver responds to interrupt requests from the device controller and invokes appropriate handlers.</data>
      <data key="d8">interrupt processing,response</data>
      <data key="d9">chunk-264fa4087fad0830a27723388157eee3</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796334</data>
    </edge>
    <edge source="Device Driver" target="Interrupt Handling">
      <data key="d6">1.0</data>
      <data key="d7">Device driver manages interrupt processing and ensures timely response to device events.</data>
      <data key="d8">interrupt management,system coordination</data>
      <data key="d9">chunk-264fa4087fad0830a27723388157eee3</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796334</data>
    </edge>
    <edge source="Device Driver" target="PCB">
      <data key="d6">1.0</data>
      <data key="d7">Device driver manages I/O requests by placing blocked processes on a queue via their PCBs.</data>
      <data key="d8">process management,request queueing</data>
      <data key="d9">chunk-264fa4087fad0830a27723388157eee3</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796334</data>
    </edge>
    <edge source="Device Driver" target="Unified Interface">
      <data key="d6">1.0</data>
      <data key="d7">Device driver uses a unified interface to ensure consistent interaction with the operating system.</data>
      <data key="d8">standardization,system compatibility</data>
      <data key="d9">chunk-264fa4087fad0830a27723388157eee3</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796335</data>
    </edge>
    <edge source="Device Driver" target="Device Driver Entry Point">
      <data key="d6">1.0</data>
      <data key="d7">Device driver entry point serves as the entry location for accessing the driver’s functionality within the system.</data>
      <data key="d8">access mechanism,driver invocation</data>
      <data key="d9">chunk-264fa4087fad0830a27723388157eee3</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796336</data>
    </edge>
    <edge source="Single System LUT" target="Single User System">
      <data key="d6">1.0</data>
      <data key="d7">The single system LUT method is suitable for single user systems where only one user is active, eliminating the need for name isolation.</data>
      <data key="d8">compatibility,deployment</data>
      <data key="d9">chunk-1d93c6dce65e857b6ccef73c51291bd2</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796252</data>
    </edge>
    <edge source="User-Specific LUT" target="Multi User System">
      <data key="d6">1.0</data>
      <data key="d7">The user-specific LUT method is used in multi user systems to allow independent device naming across users.</data>
      <data key="d8">compatibility,deployment</data>
      <data key="d9">chunk-1d93c6dce65e857b6ccef73c51291bd2</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796253</data>
    </edge>
    <edge source="设备独立性软件" target="设备驱动程序">
      <data key="d6">1.0</data>
      <data key="d7">设备独立性软件位于设备驱动程序之上，形成I/O系统的分层结构。</data>
      <data key="d8">hierarchical dependency,layered architecture</data>
      <data key="d9">chunk-f8acab16bd51fe8f837419ef179fc637</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796258</data>
    </edge>
    <edge source="设备独立性软件" target="I/O系统">
      <data key="d6">1.0</data>
      <data key="d7">设备独立性软件是I/O系统最高层的组件，负责所有设备的公有操作。</data>
      <data key="d8">component,system-level role</data>
      <data key="d9">chunk-f8acab16bd51fe8f837419ef179fc637</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796258</data>
    </edge>
    <edge source="设备独立性软件" target="设备公有操作">
      <data key="d6">1.0</data>
      <data key="d7">设备独立性软件负责执行所有设备的公有操作。</data>
      <data key="d8">functional responsibility,operation execution</data>
      <data key="d9">chunk-f8acab16bd51fe8f837419ef179fc637</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796259</data>
    </edge>
    <edge source="设备独立性软件" target="操作系统">
      <data key="d6">1.0</data>
      <data key="d7">设备独立性软件的设计与实现受操作系统影响，并需权衡运行效率。</data>
      <data key="d8">efficiency consideration,system integration</data>
      <data key="d9">chunk-f8acab16bd51fe8f837419ef179fc637</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796259</data>
    </edge>
    <edge source="设备独立性软件" target="功能实现差异">
      <data key="d6">1.0</data>
      <data key="d7">功能实现差异主要体现在设备独立性软件与设备驱动程序之间的功能划分上。</data>
      <data key="d8">design flexibility,implementation strategy</data>
      <data key="d9">chunk-f8acab16bd51fe8f837419ef179fc637</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796259</data>
    </edge>
    <edge source="设备独立性软件" target="逻辑设备名">
      <data key="d6">1.0</data>
      <data key="d7">Device independence software uses logical device names to map to physical devices, enabling device independence.</data>
      <data key="d8">abstraction,device mapping</data>
      <data key="d9">chunk-1e6791234c2dc9ee6f432df1989fc60b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796537</data>
    </edge>
    <edge source="设备独立性软件" target="物理设备名">
      <data key="d6">1.0</data>
      <data key="d7">Device independence software manages the translation of logical device names into physical device identifiers.</data>
      <data key="d8">abstraction,device mapping</data>
      <data key="d9">chunk-1e6791234c2dc9ee6f432df1989fc60b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796539</data>
    </edge>
    <edge source="设备独立性软件" target="设备分配">
      <data key="d6">1.0</data>
      <data key="d7">Device independence software performs device allocation and release to manage device access.</data>
      <data key="d8">device management,process coordination</data>
      <data key="d9">chunk-1e6791234c2dc9ee6f432df1989fc60b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796541</data>
    </edge>
    <edge source="设备独立性软件" target="I/O软件层次结构">
      <data key="d6">1.0</data>
      <data key="d7">I/O software hierarchy includes device independence software as a core layer enabling abstraction between user programs and physical devices.</data>
      <data key="d8">abstraction layer,system architecture</data>
      <data key="d9">chunk-1e6791234c2dc9ee6f432df1989fc60b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796542</data>
    </edge>
    <edge source="设备独立性软件" target="设备释放">
      <data key="d6">1.0</data>
      <data key="d7">Device independence software handles device release to make devices available for other processes.</data>
      <data key="d8">device management,process coordination</data>
      <data key="d9">chunk-1e6791234c2dc9ee6f432df1989fc60b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796544</data>
    </edge>
    <edge source="设备独立性软件" target="设备命名">
      <data key="d6">1.0</data>
      <data key="d7">Device independence software supports device naming for consistent device identification and access.</data>
      <data key="d8">device management,identification</data>
      <data key="d9">chunk-1e6791234c2dc9ee6f432df1989fc60b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796545</data>
    </edge>
    <edge source="设备独立性软件" target="设备保护">
      <data key="d6">1.0</data>
      <data key="d7">Device independence software implements device protection to control access and ensure secure operations.</data>
      <data key="d8">access control,security</data>
      <data key="d9">chunk-1e6791234c2dc9ee6f432df1989fc60b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796546</data>
    </edge>
    <edge source="设备独立性软件" target="缓冲管理">
      <data key="d6">1.0</data>
      <data key="d7">Device independence software performs buffer management to optimize data transfer performance.</data>
      <data key="d8">data management,performance optimization</data>
      <data key="d9">chunk-1e6791234c2dc9ee6f432df1989fc60b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796548</data>
    </edge>
    <edge source="设备独立性软件" target="差错控制">
      <data key="d6">1.0</data>
      <data key="d7">Device independence software ensures reliability through error control mechanisms.</data>
      <data key="d8">error handling,reliability</data>
      <data key="d9">chunk-1e6791234c2dc9ee6f432df1989fc60b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796548</data>
    </edge>
    <edge source="设备独立性软件" target="统一接口">
      <data key="d6">1.0</data>
      <data key="d7">Device independence software provides a unified interface to the user layer or file layer, enabling device-independent operations.</data>
      <data key="d8">abstraction,standardization</data>
      <data key="d9">chunk-1e6791234c2dc9ee6f432df1989fc60b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796550</data>
    </edge>
    <edge source="设备驱动程序" target="I/O软件层次结构">
      <data key="d6">1.0</data>
      <data key="d7">I/O software hierarchy includes device driver as a layer that directly interfaces with hardware to control I/O operations.</data>
      <data key="d8">hardware interface,system architecture</data>
      <data key="d9">chunk-1e6791234c2dc9ee6f432df1989fc60b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796544</data>
    </edge>
    <edge source="设备驱动程序" target="设备控制器">
      <data key="d6">1.0</data>
      <data key="d7">Device driver communicates directly with the device controller to issue commands and control device behavior.</data>
      <data key="d8">hardware interface,operational control</data>
      <data key="d9">chunk-1e6791234c2dc9ee6f432df1989fc60b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796545</data>
    </edge>
    <edge source="设备驱动程序" target="I/O进程">
      <data key="d6">1.0</data>
      <data key="d7">Device driver serves as the communication bridge between I/O processes and the device controller to execute I/O operations.</data>
      <data key="d8">command execution,communication</data>
      <data key="d9">chunk-1e6791234c2dc9ee6f432df1989fc60b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796546</data>
    </edge>
    <edge source="I/O Control" target="Program Direct Control Method">
      <data key="d6">1.0</data>
      <data key="d7">The program direct control method is one of the I/O control techniques used to manage data transfer between I/O devices and the host.</data>
      <data key="d8">control method,data transfer</data>
      <data key="d9">chunk-7b1bf538616277d755ad8617bf408c12</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796289</data>
    </edge>
    <edge source="I/O Control" target="Interrupt Driven Method">
      <data key="d6">1.0</data>
      <data key="d7">The interrupt driven method is another I/O control technique that improves CPU efficiency during data transfer.</data>
      <data key="d8">control method,data transfer</data>
      <data key="d9">chunk-7b1bf538616277d755ad8617bf408c12</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796291</data>
    </edge>
    <edge source="Program Direct Control Method" target="CPU">
      <data key="d6">1.0</data>
      <data key="d7">In the program direct control method, the CPU continuously polls the device until data is ready, reducing CPU efficiency.</data>
      <data key="d8">CPU utilization,polling loop</data>
      <data key="d9">chunk-7b1bf538616277d755ad8617bf408c12</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796291</data>
    </edge>
    <edge source="Program Direct Control Method" target="Word (Byte)">
      <data key="d6">1.0</data>
      <data key="d7">In the program direct control method, data is transferred one word or byte at a time between the device controller and memory.</data>
      <data key="d8">data handling,unit of transfer</data>
      <data key="d9">chunk-7b1bf538616277d755ad8617bf408c12</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796292</data>
    </edge>
    <edge source="Interrupt Driven Method" target="Device Controller">
      <data key="d6">1.0</data>
      <data key="d7">The device controller sends an interrupt signal to the CPU when data is ready for transfer.</data>
      <data key="d8">data readiness,signal generation</data>
      <data key="d9">chunk-7b1bf538616277d755ad8617bf408c12</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796289</data>
    </edge>
    <edge source="Interrupt Driven Method" target="CPU">
      <data key="d6">1.0</data>
      <data key="d7">The interrupt driven method allows the CPU to perform other tasks while waiting for device data, improving utilization.</data>
      <data key="d8">interrupt handling,parallel operation</data>
      <data key="d9">chunk-7b1bf538616277d755ad8617bf408c12</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796292</data>
    </edge>
    <edge source="Interrupt Driven Method" target="Serial Operation">
      <data key="d6">1.0</data>
      <data key="d7">Although interrupt driven method improves CPU utilization, data transfer still occurs serially at the byte level, limiting full parallelism.</data>
      <data key="d8">efficiency constraint,parallelism limitation</data>
      <data key="d9">chunk-7b1bf538616277d755ad8617bf408c12</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796293</data>
    </edge>
    <edge source="CPU" target="Memory">
      <data key="d6">1.0</data>
      <data key="d7">The CPU transfers data from the device controller's data register into a memory location after receiving the interrupt.</data>
      <data key="d8">data transfer,memory write</data>
      <data key="d9">chunk-7b1bf538616277d755ad8617bf408c12</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796293</data>
    </edge>
    <edge source="CPU" target="Instruction Cycle">
      <data key="d6">1.0</data>
      <data key="d7">At the end of each instruction cycle, the CPU checks for pending interrupt signals.</data>
      <data key="d8">instruction processing,interrupt check</data>
      <data key="d9">chunk-7b1bf538616277d755ad8617bf408c12</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796294</data>
    </edge>
    <edge source="CPU" target="DMA Way">
      <data key="d6">1.0</data>
      <data key="d7">The DMA Way reduces CPU involvement in data transfers, allowing the CPU to perform other tasks while data is moved directly between memory and I/O devices.</data>
      <data key="d8">data transfer efficiency,processor offload</data>
      <data key="d9">chunk-1b86b922e001d35ad4f0f4fe7d20ef03</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796296</data>
    </edge>
    <edge source="CPU" target="I/O Channel">
      <data key="d6">1.0</data>
      <data key="d7">The I/O Channel allows the CPU to delegate I/O tasks, enabling concurrent operation between CPU, channel, and I/O devices.</data>
      <data key="d8">parallel processing,task delegation</data>
      <data key="d9">chunk-1b86b922e001d35ad4f0f4fe7d20ef03</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796297</data>
    </edge>
    <edge source="CPU" target="Disk Cache">
      <data key="d6">1.0</data>
      <data key="d7">Disk Cache supports faster data delivery to the CPU by pre-loading data into memory.</data>
      <data key="d8">data access,performance enhancement</data>
      <data key="d9">chunk-2d306019ab3891600b9be43a126d8c4e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796447</data>
    </edge>
    <edge source="CPU" target="Buffer">
      <data key="d6">1.0</data>
      <data key="d7">Buffer helps resolve speed differences between CPU and I/O devices.</data>
      <data key="d8">processing coordination,speed matching</data>
      <data key="d9">chunk-2d306019ab3891600b9be43a126d8c4e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796447</data>
    </edge>
    <edge source="CPU" target="Level 1 Cache">
      <data key="d6">1.0</data>
      <data key="d7">Level 1 Cache provides the fastest access to frequently used data within the CPU.</data>
      <data key="d8">data access speed,performance</data>
      <data key="d9">chunk-2d306019ab3891600b9be43a126d8c4e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796448</data>
    </edge>
    <edge source="CPU" target="Level 2 Cache">
      <data key="d6">1.0</data>
      <data key="d7">Level 2 Cache provides intermediate access speed between memory and Level 1 Cache.</data>
      <data key="d8">data access speed,performance</data>
      <data key="d9">chunk-2d306019ab3891600b9be43a126d8c4e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796449</data>
    </edge>
    <edge source="CPU" target="SPOOLing Technology">
      <data key="d6">1.0</data>
      <data key="d7">SPOOLing technology is implemented to balance the high speed of the CPU with the low speed of I/O devices.</data>
      <data key="d8">speed synchronization,system optimization</data>
      <data key="d9">chunk-b309162a426d62e33a3be632483b375d</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796586</data>
    </edge>
    <edge source="I/O Device" target="DMA Way">
      <data key="d6">1.0</data>
      <data key="d7">The DMA Way enables direct data transfer from I/O devices to memory without CPU intermediation.</data>
      <data key="d8">I/O control,direct data transfer</data>
      <data key="d9">chunk-1b86b922e001d35ad4f0f4fe7d20ef03</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796292</data>
    </edge>
    <edge source="I/O Device" target="I/O Channel">
      <data key="d6">1.0</data>
      <data key="d7">An I/O Channel can control multiple I/O devices simultaneously, enabling shared data transfer with memory.</data>
      <data key="d8">multi-device control,parallel I/O</data>
      <data key="d9">chunk-1b86b922e001d35ad4f0f4fe7d20ef03</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796295</data>
    </edge>
    <edge source="I/O Device" target="DMA Controller">
      <data key="d6">1.0</data>
      <data key="d7">The DMA Controller manages data transfers between the I/O Device and memory without CPU intervention.</data>
      <data key="d8">data transfer management,direct access</data>
      <data key="d9">chunk-1b86b922e001d35ad4f0f4fe7d20ef03</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796295</data>
    </edge>
    <edge source="I/O Device" target="Single Buffer">
      <data key="d6">1.0</data>
      <data key="d7">Single Buffer handles data input from the I/O device in a sequential and isolated manner.</data>
      <data key="d8">I/O operation management</data>
      <data key="d9">chunk-2d306019ab3891600b9be43a126d8c4e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796448</data>
    </edge>
    <edge source="I/O Device" target="Buffer">
      <data key="d6">1.0</data>
      <data key="d7">Buffer acts as an intermediate storage to handle data flow between the I/O device and the system, reducing speed mismatches.</data>
      <data key="d8">data transfer mediation,speed matching</data>
      <data key="d9">chunk-2d306019ab3891600b9be43a126d8c4e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796449</data>
    </edge>
    <edge source="I/O Device" target="Double Buffer">
      <data key="d6">1.0</data>
      <data key="d7">Double Buffer enables continuous data transfer from the I/O device while allowing CPU processing to occur in parallel.</data>
      <data key="d8">device utilization,parallel I/O processing</data>
      <data key="d9">chunk-2d306019ab3891600b9be43a126d8c4e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796449</data>
    </edge>
    <edge source="I/O Device" target="Circular Buffer">
      <data key="d6">1.0</data>
      <data key="d7">Circular Buffer supports high-speed data streams from I/O devices by enabling buffered data cycling.</data>
      <data key="d8">continuous data handling,high-throughput I/O</data>
      <data key="d9">chunk-2d306019ab3891600b9be43a126d8c4e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796450</data>
    </edge>
    <edge source="I/O Device" target="Disk Cache">
      <data key="d6">1.0</data>
      <data key="d7">Disk Cache improves performance by reducing direct access to the I/O device (e.g., disk).</data>
      <data key="d8">I/O optimization,data access acceleration</data>
      <data key="d9">chunk-2d306019ab3891600b9be43a126d8c4e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796450</data>
    </edge>
    <edge source="Device Controller" target="Interrupt Signal">
      <data key="d6">1.0</data>
      <data key="d7">The device controller generates an interrupt signal to notify the CPU that data is available.</data>
      <data key="d8">event notification,signal transmission</data>
      <data key="d9">chunk-7b1bf538616277d755ad8617bf408c12</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796292</data>
    </edge>
    <edge source="Device Controller" target="Data Register">
      <data key="d6">1.0</data>
      <data key="d7">The device controller uses a data register to hold data read from the I/O device before transfer to memory.</data>
      <data key="d8">data management,data storage</data>
      <data key="d9">chunk-7b1bf538616277d755ad8617bf408c12</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796293</data>
    </edge>
    <edge source="Data Register" target="DMA Controller">
      <data key="d6">1.0</data>
      <data key="d7">The Data Register holds data temporarily during DMA transfers between I/O devices and memory.</data>
      <data key="d8">data buffering,transfer staging</data>
      <data key="d9">chunk-1b86b922e001d35ad4f0f4fe7d20ef03</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796294</data>
    </edge>
    <edge source="Interrupt Signal" target="Context">
      <data key="d6">1.0</data>
      <data key="d7">When an interrupt signal is received, the CPU saves the current process context before handling the interrupt.</data>
      <data key="d8">interrupt handling,process state</data>
      <data key="d9">chunk-7b1bf538616277d755ad8617bf408c12</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796291</data>
    </edge>
    <edge source="Interrupt Signal" target="DMA Way">
      <data key="d6">1.0</data>
      <data key="d7">After a DMA transfer is complete, the DMA Controller sends an interrupt signal to notify the CPU.</data>
      <data key="d8">CPU resumption,completion notification</data>
      <data key="d9">chunk-1b86b922e001d35ad4f0f4fe7d20ef03</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796294</data>
    </edge>
    <edge source="Interrupt Signal" target="I/O Channel">
      <data key="d6">1.0</data>
      <data key="d7">Upon completion of I/O tasks, the I/O Channel sends an interrupt signal to the CPU.</data>
      <data key="d8">CPU notification,task completion alert</data>
      <data key="d9">chunk-1b86b922e001d35ad4f0f4fe7d20ef03</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796295</data>
    </edge>
    <edge source="Memory" target="DMA Way">
      <data key="d6">1.0</data>
      <data key="d7">In the DMA Way, data is transferred directly from I/O devices to memory or vice versa without passing through CPU registers.</data>
      <data key="d8">data movement,direct access</data>
      <data key="d9">chunk-1b86b922e001d35ad4f0f4fe7d20ef03</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796292</data>
    </edge>
    <edge source="Memory" target="DMA Controller">
      <data key="d6">1.0</data>
      <data key="d7">The DMA Controller directly routes data between I/O devices and memory using the Memory Address Register.</data>
      <data key="d8">data routing,direct access</data>
      <data key="d9">chunk-1b86b922e001d35ad4f0f4fe7d20ef03</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796296</data>
    </edge>
    <edge source="Memory" target="I/O Channel">
      <data key="d6">1.0</data>
      <data key="d7">The I/O Channel accesses and executes programs stored in the main memory, sharing memory space with the CPU.</data>
      <data key="d8">program execution,shared access</data>
      <data key="d9">chunk-1b86b922e001d35ad4f0f4fe7d20ef03</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796296</data>
    </edge>
    <edge source="Memory" target="Disk Cache">
      <data key="d6">1.0</data>
      <data key="d7">Disk Cache is logically part of the disk but physically resides in memory to enhance data access speed.</data>
      <data key="d8">performance optimization,storage location</data>
      <data key="d9">chunk-2d306019ab3891600b9be43a126d8c4e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796446</data>
    </edge>
    <edge source="DMA Way" target="Data Block">
      <data key="d6">1.0</data>
      <data key="d7">The basic unit of data transfer in DMA is the data block, which allows efficient handling of large data sets.</data>
      <data key="d8">batch processing,transfer unit</data>
      <data key="d9">chunk-1b86b922e001d35ad4f0f4fe7d20ef03</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796293</data>
    </edge>
    <edge source="DMA Way" target="Parallel Operation">
      <data key="d6">1.0</data>
      <data key="d7">The DMA Way supports parallel operation between CPU, I/O devices, and memory by reducing CPU overhead.</data>
      <data key="d8">concurrent processing,system efficiency</data>
      <data key="d9">chunk-1b86b922e001d35ad4f0f4fe7d20ef03</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796295</data>
    </edge>
    <edge source="DMA Controller" target="Command/Status Register">
      <data key="d6">1.0</data>
      <data key="d7">The DMA controller uses the Command/Status Register to store control commands and report the current status of data transfer.</data>
      <data key="d8">control register,operational state</data>
      <data key="d9">chunk-1b86b922e001d35ad4f0f4fe7d20ef03</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796292</data>
    </edge>
    <edge source="DMA Controller" target="Memory Address Register">
      <data key="d6">1.0</data>
      <data key="d7">The DMA Controller uses the Memory Address Register to specify the memory location for data transfer.</data>
      <data key="d8">address control,memory access</data>
      <data key="d9">chunk-1b86b922e001d35ad4f0f4fe7d20ef03</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796293</data>
    </edge>
    <edge source="DMA Controller" target="Data Counter">
      <data key="d6">1.0</data>
      <data key="d7">The Data Counter keeps track of the number of data units remaining to be transferred, enabling precise block handling.</data>
      <data key="d8">block management,transfer tracking</data>
      <data key="d9">chunk-1b86b922e001d35ad4f0f4fe7d20ef03</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796294</data>
    </edge>
    <edge source="I/O Channel" target="Channel Program">
      <data key="d6">1.0</data>
      <data key="d7">The I/O Channel executes the Channel Program, which contains a sequence of instructions to manage I/O operations.</data>
      <data key="d8">instruction execution,task automation</data>
      <data key="d9">chunk-1b86b922e001d35ad4f0f4fe7d20ef03</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796292</data>
    </edge>
    <edge source="I/O Channel" target="Data Block">
      <data key="d6">1.0</data>
      <data key="d7">The I/O Channel manages I/O operations using data blocks to transfer information in bulk.</data>
      <data key="d8">block-based operations,efficient I/O handling</data>
      <data key="d9">chunk-1b86b922e001d35ad4f0f4fe7d20ef03</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796294</data>
    </edge>
    <edge source="I/O Channel" target="Parallel Operation">
      <data key="d6">1.0</data>
      <data key="d7">The I/O Channel enables parallel work among CPU, channel, and I/O devices, enhancing overall system throughput.</data>
      <data key="d8">performance enhancement,three-way parallelism</data>
      <data key="d9">chunk-1b86b922e001d35ad4f0f4fe7d20ef03</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796296</data>
    </edge>
    <edge source="Channel Program" target="Channel Instruction">
      <data key="d6">1.0</data>
      <data key="d7">The Channel Program consists of multiple Channel Instructions that define specific I/O actions.</data>
      <data key="d8">command execution,program component</data>
      <data key="d9">chunk-1b86b922e001d35ad4f0f4fe7d20ef03</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796293</data>
    </edge>
    <edge source="Interrupt Request" target="Keyboard I/O Interface">
      <data key="d6">1.0</data>
      <data key="d7">The keyboard I/O interface generates an interrupt request to notify the CPU of input arrival.</data>
      <data key="d8">device signaling,hardware interrupt</data>
      <data key="d9">chunk-cae68eac226893284aa15ffc3283cc80</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796414</data>
    </edge>
    <edge source="Interrupt Request" target="Keyboard Interrupt Handler">
      <data key="d6">1.0</data>
      <data key="d7">The interrupt request triggers the keyboard interrupt handler to process input data.</data>
      <data key="d8">interrupt handling,signal processing</data>
      <data key="d9">chunk-cae68eac226893284aa15ffc3283cc80</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796415</data>
    </edge>
    <edge source="Interrupt Handling" target="Keyboard Interrupt Handler">
      <data key="d6">1.0</data>
      <data key="d7">Interrupt handling encompasses the role of the keyboard interrupt handler in processing keyboard input events.</data>
      <data key="d8">interrupt management,process</data>
      <data key="d9">chunk-cae68eac226893284aa15ffc3283cc80</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796416</data>
    </edge>
    <edge source="Disk" target="Magnetic Head">
      <data key="d6">1.0</data>
      <data key="d7">The magnetic head reads and writes data on the disk surface during read/write operations.</data>
      <data key="d8">data access,physical interaction</data>
      <data key="d9">chunk-5eca8429d9d2d195386ae7d415efa68b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796340</data>
    </edge>
    <edge source="Disk" target="Magnetic Track">
      <data key="d6">1.0</data>
      <data key="d7">Data on the disk is organized into magnetic tracks, which are concentric circles.</data>
      <data key="d8">data organization,storage structure</data>
      <data key="d9">chunk-5eca8429d9d2d195386ae7d415efa68b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796341</data>
    </edge>
    <edge source="Disk" target="Data Storage Density">
      <data key="d6">1.0</data>
      <data key="d7">The disk's storage capacity is limited by the maximum recording density at the innermost track, where data density is highest.</data>
      <data key="d8">performance constraint,physical limitation</data>
      <data key="d9">chunk-5eca8429d9d2d195386ae7d415efa68b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796342</data>
    </edge>
    <edge source="Disk" target="Inter-Track Gap">
      <data key="d6">1.0</data>
      <data key="d7">The inter-track gap is essential for preventing data interference between adjacent magnetic tracks during read/write operations.</data>
      <data key="d8">physical separation,precision control</data>
      <data key="d9">chunk-5eca8429d9d2d195386ae7d415efa68b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796343</data>
    </edge>
    <edge source="Disk" target="Inter-Sector Gap">
      <data key="d6">1.0</data>
      <data key="d7">The inter-sector gap ensures correct sector boundary detection and prevents data overlap during disk rotation.</data>
      <data key="d8">data integrity,sector alignment</data>
      <data key="d9">chunk-5eca8429d9d2d195386ae7d415efa68b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796343</data>
    </edge>
    <edge source="Magnetic Head" target="Fixed Head Disk">
      <data key="d6">1.0</data>
      <data key="d7">Each track in a fixed head disk has one dedicated magnetic head.</data>
      <data key="d8">mechanical design,track-specific head</data>
      <data key="d9">chunk-5eca8429d9d2d195386ae7d415efa68b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796341</data>
    </edge>
    <edge source="Magnetic Track" target="Sector">
      <data key="d6">1.0</data>
      <data key="d7">Each magnetic track is divided into multiple sectors, which are the smallest addressable storage units.</data>
      <data key="d8">data storage unit,structural hierarchy</data>
      <data key="d9">chunk-5eca8429d9d2d195386ae7d415efa68b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796340</data>
    </edge>
    <edge source="Sector" target="Disk Addressing">
      <data key="d6">1.0</data>
      <data key="d7">Disk addressing uses the sector number to pinpoint the exact storage block within a track.</data>
      <data key="d8">addressing system,data location</data>
      <data key="d9">chunk-5eca8429d9d2d195386ae7d415efa68b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796344</data>
    </edge>
    <edge source="Sector" target="Track">
      <data key="d6">1.0</data>
      <data key="d7">A track is divided into sectors, forming a logical structure for data storage on a disk surface.</data>
      <data key="d8">data layout,hierarchical organization</data>
      <data key="d9">chunk-316f7e90e1f3c434878bc3dd44e3b172</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796388</data>
    </edge>
    <edge source="Sector" target="Disk Head">
      <data key="d6">1.0</data>
      <data key="d7">The disk head aligns with a specific sector once the correct track is reached to perform a read or write operation.</data>
      <data key="d8">data access,physical alignment</data>
      <data key="d9">chunk-316f7e90e1f3c434878bc3dd44e3b172</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796389</data>
    </edge>
    <edge source="Disk Drive" target="Disk Platter">
      <data key="d6">1.0</data>
      <data key="d7">Multiple disk platters are stacked inside a disk drive to form a disk group.</data>
      <data key="d8">component integration,mechanical assembly</data>
      <data key="d9">chunk-5eca8429d9d2d195386ae7d415efa68b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796340</data>
    </edge>
    <edge source="Disk Drive" target="Moving Head Disk">
      <data key="d6">1.0</data>
      <data key="d7">The moving head disk uses a movable head arm within the disk drive to access different tracks.</data>
      <data key="d8">head movement,mechanical design</data>
      <data key="d9">chunk-5eca8429d9d2d195386ae7d415efa68b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796341</data>
    </edge>
    <edge source="Disk Drive" target="Fixed Disk">
      <data key="d6">1.0</data>
      <data key="d7">The fixed disk is permanently installed within the disk drive enclosure.</data>
      <data key="d8">integration,physical enclosure</data>
      <data key="d9">chunk-5eca8429d9d2d195386ae7d415efa68b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796342</data>
    </edge>
    <edge source="Disk Platter" target="Cylinder">
      <data key="d6">1.0</data>
      <data key="d7">Cylinders are formed by aligning tracks of the same radius across multiple disk platters.</data>
      <data key="d8">storage alignment,structural relationship</data>
      <data key="d9">chunk-5eca8429d9d2d195386ae7d415efa68b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796341</data>
    </edge>
    <edge source="Disk Platter" target="Removable Disk">
      <data key="d6">1.0</data>
      <data key="d7">The removable disk allows the disk platter to be replaced, enabling data portability.</data>
      <data key="d8">disk exchange,physical modularity</data>
      <data key="d9">chunk-5eca8429d9d2d195386ae7d415efa68b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796342</data>
    </edge>
    <edge source="Cylinder" target="Disk Addressing">
      <data key="d6">1.0</data>
      <data key="d7">Disk addressing uses the cylinder as a primary coordinate to identify the radial position of data.</data>
      <data key="d8">addressing system,data location</data>
      <data key="d9">chunk-5eca8429d9d2d195386ae7d415efa68b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796342</data>
    </edge>
    <edge source="Moving Head Disk" target="Winchester Disk">
      <data key="d6">1.0</data>
      <data key="d7">The Winchester Disk is a type of moving head disk with fixed platters.</data>
      <data key="d8">design type,technological classification</data>
      <data key="d9">chunk-5eca8429d9d2d195386ae7d415efa68b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796342</data>
    </edge>
    <edge source="Winchester Disk" target="IBM">
      <data key="d6">1.0</data>
      <data key="d7">The Winchester Disk was invented by IBM and introduced as a pioneering disk technology.</data>
      <data key="d8">invention,origin</data>
      <data key="d9">chunk-5eca8429d9d2d195386ae7d415efa68b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796341</data>
    </edge>
    <edge source="Disk Addressing" target="Surface">
      <data key="d6">1.0</data>
      <data key="d7">Disk addressing includes the surface number to identify the specific disk face where data resides.</data>
      <data key="d8">addressing system,data location</data>
      <data key="d9">chunk-5eca8429d9d2d195386ae7d415efa68b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796343</data>
    </edge>
    <edge source="I/O Interface" target="Character Device Interface">
      <data key="d6">1.0</data>
      <data key="d7">The I/O interface is classified into character device interface based on device type.</data>
      <data key="d8">classification,hierarchical interface</data>
      <data key="d9">chunk-d38f67d322a4adb7d87a544b297f1adb</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796376</data>
    </edge>
    <edge source="I/O Interface" target="Block Device Interface">
      <data key="d6">1.0</data>
      <data key="d7">The I/O interface includes block device interface for block-oriented devices.</data>
      <data key="d8">classification,hierarchical interface</data>
      <data key="d9">chunk-d38f67d322a4adb7d87a544b297f1adb</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796376</data>
    </edge>
    <edge source="I/O Interface" target="Network Device Interface">
      <data key="d6">1.0</data>
      <data key="d7">The I/O interface incorporates network device interface for network-related operations.</data>
      <data key="d8">classification,hierarchical interface</data>
      <data key="d9">chunk-d38f67d322a4adb7d87a544b297f1adb</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796377</data>
    </edge>
    <edge source="I/O Interface" target="Blocking I/O">
      <data key="d6">1.0</data>
      <data key="d7">The I/O interface supports blocking I/O as one of its two primary operation modes.</data>
      <data key="d8">I/O handling,operation mode</data>
      <data key="d9">chunk-d38f67d322a4adb7d87a544b297f1adb</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796377</data>
    </edge>
    <edge source="I/O Interface" target="Non Blocking I/O">
      <data key="d6">1.0</data>
      <data key="d7">The I/O interface supports non blocking I/O as a complementary mode to blocking I/O.</data>
      <data key="d8">I/O handling,operation mode</data>
      <data key="d9">chunk-d38f67d322a4adb7d87a544b297f1adb</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796378</data>
    </edge>
    <edge source="Character Device Interface" target="Interrupt Driven I/O">
      <data key="d6">1.0</data>
      <data key="d7">Character device interface often uses interrupt driven I/O for handling input/output events.</data>
      <data key="d8">data transfer,operational mode</data>
      <data key="d9">chunk-d38f67d322a4adb7d87a544b297f1adb</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796376</data>
    </edge>
    <edge source="Character Device Interface" target="Character Device">
      <data key="d6">1.0</data>
      <data key="d7">The character device interface is used to manage and communicate with character devices like keyboards and printers.</data>
      <data key="d8">device type,interface attachment</data>
      <data key="d9">chunk-d38f67d322a4adb7d87a544b297f1adb</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796377</data>
    </edge>
    <edge source="Character Device Interface" target="Socket Interface">
      <data key="d6">1.0</data>
      <data key="d7">While not directly related, socket interface falls under network I/O and is sometimes used in software handling.</data>
      <data key="d8">interface relation,software layer</data>
      <data key="d9">chunk-d38f67d322a4adb7d87a544b297f1adb</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796377</data>
    </edge>
    <edge source="Character Device Interface" target="Character Buffer">
      <data key="d6">1.0</data>
      <data key="d7">Character buffer is used by the character device interface to manage sequential data flow.</data>
      <data key="d8">data management,temporary storage</data>
      <data key="d9">chunk-d38f67d322a4adb7d87a544b297f1adb</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796378</data>
    </edge>
    <edge source="Character Device Interface" target="In-Control Instruction">
      <data key="d6">1.0</data>
      <data key="d7">The character device interface includes an in-control instruction to handle the variety of character devices.</data>
      <data key="d8">command provision,device management</data>
      <data key="d9">chunk-d38f67d322a4adb7d87a544b297f1adb</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796378</data>
    </edge>
    <edge source="Character Device Interface" target="Open and Close Operations">
      <data key="d6">1.0</data>
      <data key="d7">The character device interface provides open and close operations to ensure mutual exclusion when accessing shared character devices.</data>
      <data key="d8">exclusive access,resource management</data>
      <data key="d9">chunk-d38f67d322a4adb7d87a544b297f1adb</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796379</data>
    </edge>
    <edge source="Block Device Interface" target="DMA I/O">
      <data key="d6">1.0</data>
      <data key="d7">Block device interface commonly employs DMA I/O to enhance data transfer efficiency.</data>
      <data key="d8">data transfer,operational mode</data>
      <data key="d9">chunk-d38f67d322a4adb7d87a544b297f1adb</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796377</data>
    </edge>
    <edge source="Block Device Interface" target="Memory Mapped Interface">
      <data key="d6">1.0</data>
      <data key="d7">Block device interface provides memory-mapped access as an alternative to traditional read/write operations.</data>
      <data key="d8">abstraction method,access mechanism</data>
      <data key="d9">chunk-d38f67d322a4adb7d87a544b297f1adb</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796377</data>
    </edge>
    <edge source="Block Device Interface" target="Block Device">
      <data key="d6">1.0</data>
      <data key="d7">The block device interface is used to control block devices such as disks.</data>
      <data key="d8">device type,interface attachment</data>
      <data key="d9">chunk-d38f67d322a4adb7d87a544b297f1adb</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796378</data>
    </edge>
    <edge source="Network Device Interface" target="Network Device">
      <data key="d6">1.0</data>
      <data key="d7">The network device interface connects to and manages network devices like NICs.</data>
      <data key="d8">device type,interface attachment</data>
      <data key="d9">chunk-d38f67d322a4adb7d87a544b297f1adb</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796377</data>
    </edge>
    <edge source="Disk Scheduling Algorithm" target="Seek Time">
      <data key="d6">1.0</data>
      <data key="d7">The main goal of disk scheduling algorithms is to reduce the average seek time.</data>
      <data key="d8">performance optimization,primary objective</data>
      <data key="d9">chunk-316f7e90e1f3c434878bc3dd44e3b172</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796385</data>
    </edge>
    <edge source="Disk Scheduling Algorithm" target="Average Seek Time">
      <data key="d6">1.0</data>
      <data key="d7">Different disk scheduling algorithms directly affect the average seek time experienced by disk I/O operations.</data>
      <data key="d8">algorithm impact,performance metric</data>
      <data key="d9">chunk-316f7e90e1f3c434878bc3dd44e3b172</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796385</data>
    </edge>
    <edge source="Disk Scheduling Algorithm" target="First Come First Served">
      <data key="d6">1.0</data>
      <data key="d7">First Come First Served is a fundamental disk scheduling algorithm that processes requests in arrival order.</data>
      <data key="d8">algorithm type,basic implementation</data>
      <data key="d9">chunk-316f7e90e1f3c434878bc3dd44e3b172</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796386</data>
    </edge>
    <edge source="Disk Scheduling Algorithm" target="Shortest Seek Time First">
      <data key="d6">1.0</data>
      <data key="d7">Shortest Seek Time First is designed to reduce seek time by selecting the closest track first.</data>
      <data key="d8">algorithm type,seek time minimization</data>
      <data key="d9">chunk-316f7e90e1f3c434878bc3dd44e3b172</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796387</data>
    </edge>
    <edge source="Disk Scheduling Algorithm" target="Scan Algorithm">
      <data key="d6">1.0</data>
      <data key="d7">Scan Algorithm introduces directionality to the head movement, resembling elevator motion.</data>
      <data key="d8">algorithm type,directional movement</data>
      <data key="d9">chunk-316f7e90e1f3c434878bc3dd44e3b172</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796387</data>
    </edge>
    <edge source="Disk Scheduling Algorithm" target="Circular Scan Algorithm">
      <data key="d6">1.0</data>
      <data key="d7">Circular Scan Algorithm ensures the head moves in a single direction and returns quickly without servicing requests.</data>
      <data key="d8">algorithm type,unidirectional movement</data>
      <data key="d9">chunk-316f7e90e1f3c434878bc3dd44e3b172</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796388</data>
    </edge>
    <edge source="Disk Scheduling Algorithm" target="Delayed Writing">
      <data key="d6">1.0</data>
      <data key="d7">Delayed writing improves scheduling efficiency by deferring actual writes until the buffer is reused.</data>
      <data key="d8">buffer management,write optimization</data>
      <data key="d9">chunk-316f7e90e1f3c434878bc3dd44e3b172</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796388</data>
    </edge>
    <edge source="Disk Scheduling Algorithm" target="RAID">
      <data key="d6">1.0</data>
      <data key="d7">RAID improves disk performance and reliability, influencing how scheduling can be optimized across multiple drives.</data>
      <data key="d8">scalability,storage enhancement</data>
      <data key="d9">chunk-316f7e90e1f3c434878bc3dd44e3b172</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796389</data>
    </edge>
    <edge source="Seek Time" target="Physical Block Arrangement">
      <data key="d6">1.0</data>
      <data key="d7">Arranging physical blocks contiguously or adjacent helps minimize seek time for files stored sequentially.</data>
      <data key="d8">access time reduction,disk optimization</data>
      <data key="d9">chunk-316f7e90e1f3c434878bc3dd44e3b172</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796386</data>
    </edge>
    <edge source="Seek Time" target="Disk Read/Write Operation">
      <data key="d6">1.0</data>
      <data key="d7">Seek time is a fundamental component of a disk read/write operation, representing the time elapsed during head movement.</data>
      <data key="d8">access phase,operation component</data>
      <data key="d9">chunk-316f7e90e1f3c434878bc3dd44e3b172</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796387</data>
    </edge>
    <edge source="Rotational Latency" target="Sector Interleaving">
      <data key="d6">1.0</data>
      <data key="d7">Sector interleaving reduces rotational latency by spacing adjacent logical blocks apart physically.</data>
      <data key="d8">rotational optimization,timing reduction</data>
      <data key="d9">chunk-316f7e90e1f3c434878bc3dd44e3b172</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796385</data>
    </edge>
    <edge source="Rotational Latency" target="Disk Surface Skew">
      <data key="d6">1.0</data>
      <data key="d7">Disk surface skew minimizes delay when switching between disk surfaces by aligning sector positions.</data>
      <data key="d8">surface transition optimization,timing reduction</data>
      <data key="d9">chunk-316f7e90e1f3c434878bc3dd44e3b172</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796386</data>
    </edge>
    <edge source="Rotational Latency" target="Disk Read/Write Operation">
      <data key="d6">1.0</data>
      <data key="d7">Rotational latency is a key phase in a disk read/write operation, occurring after seek time when waiting for the correct sector to rotate under the head.</data>
      <data key="d8">access phase,operation component</data>
      <data key="d9">chunk-316f7e90e1f3c434878bc3dd44e3b172</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796387</data>
    </edge>
    <edge source="Transfer Time" target="Disk Cache">
      <data key="d6">1.0</data>
      <data key="d7">Disk cache reduces effective transfer time by storing frequently accessed data in faster memory.</data>
      <data key="d8">performance enhancement,speed improvement</data>
      <data key="d9">chunk-316f7e90e1f3c434878bc3dd44e3b172</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796386</data>
    </edge>
    <edge source="Transfer Time" target="Pre-reading">
      <data key="d6">1.0</data>
      <data key="d7">Pre-reading reduces waiting time by fetching the next block in advance during current read operations.</data>
      <data key="d8">latency reduction,predictive I/O</data>
      <data key="d9">chunk-316f7e90e1f3c434878bc3dd44e3b172</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796386</data>
    </edge>
    <edge source="Transfer Time" target="Disk Read/Write Operation">
      <data key="d6">1.0</data>
      <data key="d7">Transfer time is the final phase of a disk read/write operation, during which data is read from or written to the disk.</data>
      <data key="d8">data transfer,operation component</data>
      <data key="d9">chunk-316f7e90e1f3c434878bc3dd44e3b172</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796388</data>
    </edge>
    <edge source="Scan Algorithm" target="Look Algorithm">
      <data key="d6">1.0</data>
      <data key="d7">Look Algorithm improves upon the Scan Algorithm by stopping at the farthest requested track instead of the disk end.</data>
      <data key="d8">algorithm variant,improved efficiency</data>
      <data key="d9">chunk-316f7e90e1f3c434878bc3dd44e3b172</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796385</data>
    </edge>
    <edge source="Circular Scan Algorithm" target="C-Look Algorithm">
      <data key="d6">1.0</data>
      <data key="d7">C-Look Algorithm enhances C-SCAN by stopping at the last request before returning, avoiding unnecessary movement.</data>
      <data key="d8">algorithm variant,enhanced performance</data>
      <data key="d9">chunk-316f7e90e1f3c434878bc3dd44e3b172</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796388</data>
    </edge>
    <edge source="Disk Cache" target="Virtual Disk">
      <data key="d6">1.0</data>
      <data key="d7">Virtual disk uses memory to emulate a disk, similar to a cache, enabling faster I/O operations.</data>
      <data key="d8">memory emulation,performance acceleration</data>
      <data key="d9">chunk-316f7e90e1f3c434878bc3dd44e3b172</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796387</data>
    </edge>
    <edge source="Disk Cache" target="Block">
      <data key="d6">1.0</data>
      <data key="d7">Disk Cache stores data blocks from the disk to reduce I/O latency.</data>
      <data key="d8">caching,data unit handling</data>
      <data key="d9">chunk-2d306019ab3891600b9be43a126d8c4e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796447</data>
    </edge>
    <edge source="Disk Cache" target="Level 1 Cache">
      <data key="d6">1.0</data>
      <data key="d7">Disk Cache is part of a broader caching hierarchy and feeds data into higher-level caches.</data>
      <data key="d8">caching hierarchy,data transfer</data>
      <data key="d9">chunk-2d306019ab3891600b9be43a126d8c4e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796448</data>
    </edge>
    <edge source="Disk Cache" target="Level 2 Cache">
      <data key="d6">1.0</data>
      <data key="d7">Disk Cache supports Level 2 Cache by providing data from storage before it reaches higher CPU caches.</data>
      <data key="d8">caching hierarchy,data transfer</data>
      <data key="d9">chunk-2d306019ab3891600b9be43a126d8c4e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796448</data>
    </edge>
    <edge source="Disk Cache" target="System Memory">
      <data key="d6">1.0</data>
      <data key="d7">System Memory hosts the Disk Cache, serving as the physical storage layer for cached disk data.</data>
      <data key="d8">data staging,physical storage</data>
      <data key="d9">chunk-2d306019ab3891600b9be43a126d8c4e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796451</data>
    </edge>
    <edge source="Disk Head" target="Track">
      <data key="d6">1.0</data>
      <data key="d7">The disk head moves to a specific track to access data stored on that track.</data>
      <data key="d8">access control,physical positioning</data>
      <data key="d9">chunk-316f7e90e1f3c434878bc3dd44e3b172</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796387</data>
    </edge>
    <edge source="Track" target="Platter">
      <data key="d6">1.0</data>
      <data key="d7">Tracks are concentric circles on a platter, serving as the primary data storage medium in a hard disk drive.</data>
      <data key="d8">data storage layer,physical structure</data>
      <data key="d9">chunk-316f7e90e1f3c434878bc3dd44e3b172</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796389</data>
    </edge>
    <edge source="Kernel Buffer" target="Keyboard Interrupt Handler">
      <data key="d6">1.0</data>
      <data key="d7">The keyboard interrupt handler copies input characters from the I/O interface into the kernel buffer.</data>
      <data key="d8">data transfer,input routing</data>
      <data key="d9">chunk-cae68eac226893284aa15ffc3283cc80</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796415</data>
    </edge>
    <edge source="Kernel Buffer" target="User Buffer">
      <data key="d6">1.0</data>
      <data key="d7">The kernel buffer serves as a temporary storage location through which data is copied to the user buffer after I/O completion.</data>
      <data key="d8">data transfer,intermediate storage</data>
      <data key="d9">chunk-cae68eac226893284aa15ffc3283cc80</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796416</data>
    </edge>
    <edge source="Kernel Buffer" target="Device Driver Layer">
      <data key="d6">1.0</data>
      <data key="d7">The device driver layer interacts with the kernel buffer during the execution of I/O operations.</data>
      <data key="d8">I/O handling,data routing</data>
      <data key="d9">chunk-cae68eac226893284aa15ffc3283cc80</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796417</data>
    </edge>
    <edge source="Kernel Buffer" target="System Call Service Routine">
      <data key="d6">1.0</data>
      <data key="d7">The system call service routine allocates and manages the kernel buffer during I/O operations.</data>
      <data key="d8">I/O coordination,buffer management</data>
      <data key="d9">chunk-cae68eac226893284aa15ffc3283cc80</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796417</data>
    </edge>
    <edge source="User Buffer" target="scanf">
      <data key="d6">1.0</data>
      <data key="d7">scanf uses a user buffer to store input data after reading it from standard input.</data>
      <data key="d8">buffer management,input handling</data>
      <data key="d9">chunk-cae68eac226893284aa15ffc3283cc80</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796414</data>
    </edge>
    <edge source="User Buffer" target="read">
      <data key="d6">1.0</data>
      <data key="d7">The read system call transfers data from kernel space into the provided user buffer.</data>
      <data key="d8">data transfer,user space access</data>
      <data key="d9">chunk-cae68eac226893284aa15ffc3283cc80</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796416</data>
    </edge>
    <edge source="User Buffer" target="System Call Service Routine">
      <data key="d6">1.0</data>
      <data key="d7">The system call service routine facilitates the copying of data from kernel buffer to user buffer after I/O completion.</data>
      <data key="d8">data transfer,system call execution</data>
      <data key="d9">chunk-cae68eac226893284aa15ffc3283cc80</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796417</data>
    </edge>
    <edge source="scanf" target="C Language Function Library">
      <data key="d6">1.0</data>
      <data key="d7">The scanf function is part of the C language function library and relies on its implementation for execution.</data>
      <data key="d8">function dependency,library linkage</data>
      <data key="d9">chunk-cae68eac226893284aa15ffc3283cc80</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796416</data>
    </edge>
    <edge source="read" target="File Descriptor">
      <data key="d6">1.0</data>
      <data key="d7">The read system call uses the file descriptor to identify the source of data to be read.</data>
      <data key="d8">resource access,system call parameters</data>
      <data key="d9">chunk-cae68eac226893284aa15ffc3283cc80</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796414</data>
    </edge>
    <edge source="read" target="Count">
      <data key="d6">1.0</data>
      <data key="d7">The count parameter defines the maximum number of bytes the read system call will attempt to read.</data>
      <data key="d8">data limit,system call parameters</data>
      <data key="d9">chunk-cae68eac226893284aa15ffc3283cc80</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796415</data>
    </edge>
    <edge source="read" target="Kernel Mode">
      <data key="d6">1.0</data>
      <data key="d7">The read system call executes in kernel mode after the CPU transitions from user mode via trap instruction.</data>
      <data key="d8">execution context,privilege transition</data>
      <data key="d9">chunk-cae68eac226893284aa15ffc3283cc80</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796415</data>
    </edge>
    <edge source="Kernel Mode" target="Process P">
      <data key="d6">1.0</data>
      <data key="d7">Process P enters kernel mode when a system call is invoked to perform I/O.</data>
      <data key="d8">execution state,system call execution</data>
      <data key="d9">chunk-cae68eac226893284aa15ffc3283cc80</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796416</data>
    </edge>
    <edge source="Process P" target="Blocked State">
      <data key="d6">1.0</data>
      <data key="d7">Process P enters the blocked state when it waits for I/O completion.</data>
      <data key="d8">I/O waiting,process state</data>
      <data key="d9">chunk-cae68eac226893284aa15ffc3283cc80</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796414</data>
    </edge>
    <edge source="Process P" target="Ready Queue">
      <data key="d6">1.0</data>
      <data key="d7">After being woken up by I/O completion, Process P is inserted into the ready queue to await CPU scheduling.</data>
      <data key="d8">process state transition,scheduling</data>
      <data key="d9">chunk-cae68eac226893284aa15ffc3283cc80</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796416</data>
    </edge>
    <edge source="Device Driver Layer" target="System Call Service Routine">
      <data key="d6">1.0</data>
      <data key="d7">The system call service routine invokes the device driver layer to perform the actual hardware-level I/O operation.</data>
      <data key="d8">kernel subsystem coordination,system call flow</data>
      <data key="d9">chunk-cae68eac226893284aa15ffc3283cc80</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796417</data>
    </edge>
    <edge source="Level 1 Cache" target="Level 2 Cache">
      <data key="d6">1.0</data>
      <data key="d7">Level 1 Cache and Level 2 Cache form a multi-level hierarchy where data is staged from Level 2 to Level 1 for faster access.</data>
      <data key="d8">cache hierarchy,data staging</data>
      <data key="d9">chunk-2d306019ab3891600b9be43a126d8c4e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796450</data>
    </edge>
    <edge source="Block" target="Page">
      <data key="d6">1.0</data>
      <data key="d7">A block is composed of multiple pages, where pages are the smallest read/write units within a block.</data>
      <data key="d8">data unit,hierarchical structure</data>
      <data key="d9">chunk-8189302c7787e74dde6623016361fc8f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796581</data>
    </edge>
    <edge source="Buffer" target="Device Management Subsystem">
      <data key="d6">1.0</data>
      <data key="d7">Buffer is a core part of the device management subsystem used to mediate I/O operations.</data>
      <data key="d8">I/O management,system component</data>
      <data key="d9">chunk-2d306019ab3891600b9be43a126d8c4e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796446</data>
    </edge>
    <edge source="Buffer" target="Interrupt">
      <data key="d6">1.0</data>
      <data key="d7">Buffer reduces interrupt frequency by batching I/O operations.</data>
      <data key="d8">interrupt reduction,system responsiveness</data>
      <data key="d9">chunk-2d306019ab3891600b9be43a126d8c4e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796448</data>
    </edge>
    <edge source="Buffer" target="Data Granularity">
      <data key="d6">1.0</data>
      <data key="d7">Buffer resolves mismatches in data granularity between I/O devices and higher-level processing.</data>
      <data key="d8">data alignment,unit synchronization</data>
      <data key="d9">chunk-2d306019ab3891600b9be43a126d8c4e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796449</data>
    </edge>
    <edge source="Buffer" target="System Memory">
      <data key="d6">1.0</data>
      <data key="d7">System Memory provides the physical space where buffers are allocated and managed dynamically.</data>
      <data key="d8">dynamic allocation,physical storage</data>
      <data key="d9">chunk-2d306019ab3891600b9be43a126d8c4e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796450</data>
    </edge>
    <edge source="Buffer" target="Circular Queue">
      <data key="d6">1.0</data>
      <data key="d7">A circular queue is composed of multiple buffers linked in a circular fashion.</data>
      <data key="d8">data structure,linked memory</data>
      <data key="d9">chunk-e821a4c1e8eeab3120a42bec02ee8587</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796451</data>
    </edge>
    <edge source="Buffer" target="High-Speed Device">
      <data key="d6">1.0</data>
      <data key="d7">Buffers serve as an interface for data transfer between high-speed and low-speed devices.</data>
      <data key="d8">data transfer intermediate,interface</data>
      <data key="d9">chunk-e821a4c1e8eeab3120a42bec02ee8587</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796453</data>
    </edge>
    <edge source="Buffer" target="Low-Speed Device">
      <data key="d6">1.0</data>
      <data key="d7">Buffers temporarily store data during communication between high-speed and low-speed devices.</data>
      <data key="d8">data transfer intermediate,interface</data>
      <data key="d9">chunk-e821a4c1e8eeab3120a42bec02ee8587</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796454</data>
    </edge>
    <edge source="Single Buffer" target="Input">
      <data key="d6">1.0</data>
      <data key="d7">Single Buffer manages input and processes data in a sequential manner, affecting average processing time.</data>
      <data key="d8">I/O operation,processing timing</data>
      <data key="d9">chunk-2d306019ab3891600b9be43a126d8c4e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796446</data>
    </edge>
    <edge source="Single Buffer" target="Double Buffer">
      <data key="d6">1.0</data>
      <data key="d7">Double Buffer improves upon Single Buffer by enabling overlapping of I/O and processing.</data>
      <data key="d8">performance improvement,technological progression</data>
      <data key="d9">chunk-2d306019ab3891600b9be43a126d8c4e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796447</data>
    </edge>
    <edge source="Double Buffer" target="Output">
      <data key="d6">1.0</data>
      <data key="d7">Double Buffer enables concurrent input and output operations by using two buffers.</data>
      <data key="d8">I/O efficiency,parallelism</data>
      <data key="d9">chunk-2d306019ab3891600b9be43a126d8c4e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796446</data>
    </edge>
    <edge source="Double Buffer" target="Circular Buffer">
      <data key="d6">1.0</data>
      <data key="d7">Circular Buffer represents a more advanced buffering method suitable for mismatched data speeds.</data>
      <data key="d8">scalability,technological evolution</data>
      <data key="d9">chunk-2d306019ab3891600b9be43a126d8c4e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796448</data>
    </edge>
    <edge source="Circular Buffer" target="Input">
      <data key="d6">1.0</data>
      <data key="d7">Circular Buffer is used to manage continuous input streams by cycling through multiple buffer slots.</data>
      <data key="d8">buffering logic,data flow management</data>
      <data key="d9">chunk-2d306019ab3891600b9be43a126d8c4e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796447</data>
    </edge>
    <edge source="Circular Buffer" target="Output">
      <data key="d6">1.0</data>
      <data key="d7">Circular Buffer supports continuous output by using in and out pointers to track available and pending data.</data>
      <data key="d8">buffering logic,data flow management</data>
      <data key="d9">chunk-2d306019ab3891600b9be43a126d8c4e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796448</data>
    </edge>
    <edge source="Circular Queue" target="In Pointer">
      <data key="d6">1.0</data>
      <data key="d7">The in pointer identifies the next buffer where data can be written in the circular queue.</data>
      <data key="d8">data input,memory tracking</data>
      <data key="d9">chunk-e821a4c1e8eeab3120a42bec02ee8587</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796450</data>
    </edge>
    <edge source="Circular Queue" target="Out Pointer">
      <data key="d6">1.0</data>
      <data key="d7">The out pointer identifies the next buffer from which data can be read in the circular queue.</data>
      <data key="d8">data output,memory tracking</data>
      <data key="d9">chunk-e821a4c1e8eeab3120a42bec02ee8587</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796450</data>
    </edge>
    <edge source="Buffer Pool" target="Empty Buffer Queue">
      <data key="d6">1.0</data>
      <data key="d7">The buffer pool manages the empty buffer queue as part of its buffer allocation system.</data>
      <data key="d8">queue organization,resource management</data>
      <data key="d9">chunk-e821a4c1e8eeab3120a42bec02ee8587</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796450</data>
    </edge>
    <edge source="Buffer Pool" target="Input Queue">
      <data key="d6">1.0</data>
      <data key="d7">The buffer pool manages the input queue for storing filled input buffers.</data>
      <data key="d8">queue organization,resource management</data>
      <data key="d9">chunk-e821a4c1e8eeab3120a42bec02ee8587</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796451</data>
    </edge>
    <edge source="Buffer Pool" target="Output Queue">
      <data key="d6">1.0</data>
      <data key="d7">The buffer pool manages the output queue for storing filled output buffers.</data>
      <data key="d8">queue organization,resource management</data>
      <data key="d9">chunk-e821a4c1e8eeab3120a42bec02ee8587</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796451</data>
    </edge>
    <edge source="Buffer Pool" target="Hin Work Buffer">
      <data key="d6">1.0</data>
      <data key="d7">The buffer pool assigns buffers from the empty queue as hin work buffers during input operations.</data>
      <data key="d8">input handling,work buffer assignment</data>
      <data key="d9">chunk-e821a4c1e8eeab3120a42bec02ee8587</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796452</data>
    </edge>
    <edge source="Buffer Pool" target="Sin Work Buffer">
      <data key="d6">1.0</data>
      <data key="d7">The buffer pool assigns buffers from the input queue as sin work buffers for data retrieval.</data>
      <data key="d8">input extraction,work buffer assignment</data>
      <data key="d9">chunk-e821a4c1e8eeab3120a42bec02ee8587</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796452</data>
    </edge>
    <edge source="Buffer Pool" target="Hout Work Buffer">
      <data key="d6">1.0</data>
      <data key="d7">The buffer pool assigns buffers from the empty queue as hout work buffers during output operations.</data>
      <data key="d8">output handling,work buffer assignment</data>
      <data key="d9">chunk-e821a4c1e8eeab3120a42bec02ee8587</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796453</data>
    </edge>
    <edge source="Buffer Pool" target="Sout Work Buffer">
      <data key="d6">1.0</data>
      <data key="d7">The buffer pool assigns buffers from the output queue as sout work buffers for output transfer.</data>
      <data key="d8">output extraction,work buffer assignment</data>
      <data key="d9">chunk-e821a4c1e8eeab3120a42bec02ee8587</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796454</data>
    </edge>
    <edge source="Empty Buffer Queue" target="Data Input Process">
      <data key="d6">1.0</data>
      <data key="d7">The data input process takes a buffer from the empty buffer queue to store incoming data.</data>
      <data key="d8">buffer allocation,input operation</data>
      <data key="d9">chunk-e821a4c1e8eeab3120a42bec02ee8587</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796451</data>
    </edge>
    <edge source="Empty Buffer Queue" target="Data Output Process">
      <data key="d6">1.0</data>
      <data key="d7">The data output process takes a buffer from the empty buffer queue to store outgoing data.</data>
      <data key="d8">buffer allocation,output operation</data>
      <data key="d9">chunk-e821a4c1e8eeab3120a42bec02ee8587</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796452</data>
    </edge>
    <edge source="Empty Buffer Queue" target="Data Extraction Process">
      <data key="d6">1.0</data>
      <data key="d7">After use, the buffer is returned to the empty buffer queue.</data>
      <data key="d8">buffer return,reuse</data>
      <data key="d9">chunk-e821a4c1e8eeab3120a42bec02ee8587</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796453</data>
    </edge>
    <edge source="Empty Buffer Queue" target="Output Retrieval Process">
      <data key="d6">1.0</data>
      <data key="d7">After data is extracted, the buffer is returned to the empty buffer queue.</data>
      <data key="d8">buffer return,reuse</data>
      <data key="d9">chunk-e821a4c1e8eeab3120a42bec02ee8587</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796453</data>
    </edge>
    <edge source="Input Queue" target="Data Extraction Process">
      <data key="d6">1.0</data>
      <data key="d7">The data extraction process retrieves buffers from the input queue for reading.</data>
      <data key="d8">data access,source retrieval</data>
      <data key="d9">chunk-e821a4c1e8eeab3120a42bec02ee8587</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796452</data>
    </edge>
    <edge source="Input Queue" target="Data Input Process">
      <data key="d6">1.0</data>
      <data key="d7">After being filled, the buffer is moved to the input queue.</data>
      <data key="d8">buffer transfer,data filling</data>
      <data key="d9">chunk-e821a4c1e8eeab3120a42bec02ee8587</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796452</data>
    </edge>
    <edge source="Output Queue" target="Output Retrieval Process">
      <data key="d6">1.0</data>
      <data key="d7">The output retrieval process retrieves a buffer from the output queue for transmission.</data>
      <data key="d8">data access,source retrieval</data>
      <data key="d9">chunk-e821a4c1e8eeab3120a42bec02ee8587</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796452</data>
    </edge>
    <edge source="Output Queue" target="Data Output Process">
      <data key="d6">1.0</data>
      <data key="d7">Once filled, the buffer is moved to the output queue.</data>
      <data key="d8">buffer transfer,data filling</data>
      <data key="d9">chunk-e821a4c1e8eeab3120a42bec02ee8587</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796453</data>
    </edge>
    <edge source="Cache" target="High-Speed Device">
      <data key="d6">1.0</data>
      <data key="d7">A cache improves data access speed by storing copies of data closer to a high-speed device.</data>
      <data key="d8">caching layer,data access speed</data>
      <data key="d9">chunk-e821a4c1e8eeab3120a42bec02ee8587</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796453</data>
    </edge>
    <edge source="Cache" target="Low-Speed Device">
      <data key="d6">1.0</data>
      <data key="d7">A cache holds copies of data from a low-speed device to optimize access times.</data>
      <data key="d8">data copying,performance optimization</data>
      <data key="d9">chunk-e821a4c1e8eeab3120a42bec02ee8587</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796453</data>
    </edge>
    <edge source="I/O软件层次结构" target="用户层软件">
      <data key="d6">1.0</data>
      <data key="d7">I/O software hierarchy includes user layer software as its topmost layer, providing user-facing I/O interfaces.</data>
      <data key="d8">system architecture,user interface</data>
      <data key="d9">chunk-1e6791234c2dc9ee6f432df1989fc60b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796537</data>
    </edge>
    <edge source="I/O软件层次结构" target="中断处理程序">
      <data key="d6">1.0</data>
      <data key="d7">I/O software hierarchy includes interrupt handler as a layer responsible for responding to device-generated interrupts.</data>
      <data key="d8">system architecture,system response</data>
      <data key="d9">chunk-1e6791234c2dc9ee6f432df1989fc60b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796545</data>
    </edge>
    <edge source="用户层软件" target="系统调用">
      <data key="d6">1.0</data>
      <data key="d7">User layer software relies on system calls to access operating system services for I/O operations.</data>
      <data key="d8">inter-layer communication,service request</data>
      <data key="d9">chunk-1e6791234c2dc9ee6f432df1989fc60b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796539</data>
    </edge>
    <edge source="中断处理程序" target="中断信号">
      <data key="d6">1.0</data>
      <data key="d7">Interrupt handler responds to interrupt signals generated by device controllers to manage the completion of I/O operations.</data>
      <data key="d8">event handling,system notification</data>
      <data key="d9">chunk-1e6791234c2dc9ee6f432df1989fc60b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796546</data>
    </edge>
    <edge source="中断处理程序" target="进程上下文切换">
      <data key="d6">1.0</data>
      <data key="d7">Interrupt handler performs context switching to preserve and restore process state during interrupt handling.</data>
      <data key="d8">process recovery,system state management</data>
      <data key="d9">chunk-1e6791234c2dc9ee6f432df1989fc60b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796548</data>
    </edge>
    <edge source="中断处理程序" target="设备状态">
      <data key="d6">1.0</data>
      <data key="d7">Interrupt handler reads device status to determine the outcome of an I/O operation.</data>
      <data key="d8">device feedback,status monitoring</data>
      <data key="d9">chunk-1e6791234c2dc9ee6f432df1989fc60b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796548</data>
    </edge>
    <edge source="中断处理程序" target="修改进程状态">
      <data key="d6">1.0</data>
      <data key="d7">Interrupt handler updates the process state to reflect I/O completion and enables resumption of the interrupted process.</data>
      <data key="d8">process state management,scheduling</data>
      <data key="d9">chunk-1e6791234c2dc9ee6f432df1989fc60b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796550</data>
    </edge>
    <edge source="设备控制器" target="I/O接口">
      <data key="d6">1.0</data>
      <data key="d7">I/O interface and device controller refer to the same physical component responsible for CPU-device communication.</data>
      <data key="d8">functional identity,hardware synonym</data>
      <data key="d9">chunk-b97ef22d499b3d442bd72f94c0600b3e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796548</data>
    </edge>
    <edge source="设备控制器" target="I/O逻辑">
      <data key="d6">1.0</data>
      <data key="d7">I/O logic is a core functional component within the device controller responsible for command processing.</data>
      <data key="d8">component relationship,functional hierarchy</data>
      <data key="d9">chunk-b97ef22d499b3d442bd72f94c0600b3e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796550</data>
    </edge>
    <edge source="设备控制器" target="数据线">
      <data key="d6">1.0</data>
      <data key="d7">Data lines are part of the interface between the device controller and the CPU for transmitting data.</data>
      <data key="d8">data transmission,physical interface</data>
      <data key="d9">chunk-b97ef22d499b3d442bd72f94c0600b3e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796551</data>
    </edge>
    <edge source="设备控制器" target="地址线">
      <data key="d6">1.0</data>
      <data key="d7">Address lines are used by the device controller to communicate the target address to the CPU during data transfer.</data>
      <data key="d8">addressing,physical interface</data>
      <data key="d9">chunk-b97ef22d499b3d442bd72f94c0600b3e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796551</data>
    </edge>
    <edge source="设备控制器" target="控制线">
      <data key="d6">1.0</data>
      <data key="d7">Control lines transmit control signals between the device controller and the CPU to manage device operations.</data>
      <data key="d8">control signaling,physical interface</data>
      <data key="d9">chunk-b97ef22d499b3d442bd72f94c0600b3e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796552</data>
    </edge>
    <edge source="设备控制器" target="数据寄存器">
      <data key="d6">1.0</data>
      <data key="d7">Data registers are internal components of the device controller used to buffer input and output data.</data>
      <data key="d8">data buffering,device component</data>
      <data key="d9">chunk-b97ef22d499b3d442bd72f94c0600b3e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796553</data>
    </edge>
    <edge source="设备控制器" target="状态寄存器">
      <data key="d6">1.0</data>
      <data key="d7">Status registers in the device controller hold device status information for CPU read access.</data>
      <data key="d8">device component,status reporting</data>
      <data key="d9">chunk-b97ef22d499b3d442bd72f94c0600b3e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796554</data>
    </edge>
    <edge source="设备控制器" target="控制寄存器">
      <data key="d6">1.0</data>
      <data key="d7">Control registers in the device controller allow the CPU to initiate operations or change device modes.</data>
      <data key="d8">command configuration,device component</data>
      <data key="d9">chunk-b97ef22d499b3d442bd72f94c0600b3e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796554</data>
    </edge>
    <edge source="I/O设备" target="操作系统设计">
      <data key="d6">1.0</data>
      <data key="d7">I/O device management is a central and complex aspect of operating system design due to the diversity of devices.</data>
      <data key="d8">device management,system complexity</data>
      <data key="d9">chunk-b97ef22d499b3d442bd72f94c0600b3e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796547</data>
    </edge>
    <edge source="块设备" target="高速设备">
      <data key="d6">1.0</data>
      <data key="d7">Block devices are typically high-speed devices due to their ability to transfer data in large, random-accessible blocks.</data>
      <data key="d8">data transfer,performance categorization</data>
      <data key="d9">chunk-b97ef22d499b3d442bd72f94c0600b3e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796547</data>
    </edge>
    <edge source="块设备" target="存储设备">
      <data key="d6">1.0</data>
      <data key="d7">Storage devices like disk drives are commonly classified as block devices because of their block-based data access.</data>
      <data key="d8">data organization,type classification</data>
      <data key="d9">chunk-b97ef22d499b3d442bd72f94c0600b3e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796548</data>
    </edge>
    <edge source="块设备" target="磁带">
      <data key="d6">1.0</data>
      <data key="d7">Magnetic tape is classified as a block device due to its ability to transfer data in fixed-size blocks, although access is sequential.</data>
      <data key="d8">device type,storage organization</data>
      <data key="d9">chunk-b97ef22d499b3d442bd72f94c0600b3e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796552</data>
    </edge>
    <edge source="块设备" target="光盘">
      <data key="d6">1.0</data>
      <data key="d7">Optical disc functions as a block device, transferring data in blocks and supporting random access.</data>
      <data key="d8">data transfer unit,device type</data>
      <data key="d9">chunk-b97ef22d499b3d442bd72f94c0600b3e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796553</data>
    </edge>
    <edge source="字符设备" target="低速设备">
      <data key="d6">1.0</data>
      <data key="d7">Character devices are generally low-speed devices used for interactive data exchange, such as keyboards and printers.</data>
      <data key="d8">interaction type,transfer speed</data>
      <data key="d9">chunk-b97ef22d499b3d442bd72f94c0600b3e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796547</data>
    </edge>
    <edge source="字符设备" target="人机交互设备">
      <data key="d6">1.0</data>
      <data key="d7">Human-computer interaction devices often fall under the category of character devices due to their sequential data transfer.</data>
      <data key="d8">category inclusion,functional overlap</data>
      <data key="d9">chunk-b97ef22d499b3d442bd72f94c0600b3e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796548</data>
    </edge>
    <edge source="网络通信设备" target="共享设备">
      <data key="d6">1.0</data>
      <data key="d7">Network communication devices function as shared devices, enabling multiple processes to communicate simultaneously.</data>
      <data key="d8">concurrent access,usage pattern</data>
      <data key="d9">chunk-b97ef22d499b3d442bd72f94c0600b3e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796547</data>
    </edge>
    <edge source="网络通信设备" target="调制解调器">
      <data key="d6">1.0</data>
      <data key="d7">Modem is a type of network communication device used for connecting to external networks.</data>
      <data key="d8">device categorization,function</data>
      <data key="d9">chunk-b97ef22d499b3d442bd72f94c0600b3e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796552</data>
    </edge>
    <edge source="网络通信设备" target="网卡">
      <data key="d6">1.0</data>
      <data key="d7">Network interface card is a fundamental example of a network communication device that enables computer network connectivity.</data>
      <data key="d8">device categorization,network connection</data>
      <data key="d9">chunk-b97ef22d499b3d442bd72f94c0600b3e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796553</data>
    </edge>
    <edge source="独占设备" target="打印机">
      <data key="d6">1.0</data>
      <data key="d7">Printers are typical examples of dedicated devices that can only be used by one process at a time.</data>
      <data key="d8">access restriction,device example</data>
      <data key="d9">chunk-b97ef22d499b3d442bd72f94c0600b3e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796547</data>
    </edge>
    <edge source="虚拟设备" target="SPOOLing技术">
      <data key="d6">1.0</data>
      <data key="d7">Virtual devices are created using SPOOLing technology, transforming dedicated devices into shared ones.</data>
      <data key="d8">device virtualization,technology implementation</data>
      <data key="d9">chunk-b97ef22d499b3d442bd72f94c0600b3e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796548</data>
    </edge>
    <edge source="独立编址" target="统一编址">
      <data key="d6">1.0</data>
      <data key="d7">Independent addressing and unified addressing are two contrasting methods for managing I/O port addressing in computer systems.</data>
      <data key="d8">addressing method,system architecture</data>
      <data key="d9">chunk-b97ef22d499b3d442bd72f94c0600b3e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796550</data>
    </edge>
    <edge source="并行接口" target="串行接口">
      <data key="d6">1.0</data>
      <data key="d7">Parallel and serial interfaces differ by the number of data lines and speed of data transfer.</data>
      <data key="d8">data transmission type,interface mode</data>
      <data key="d9">chunk-b97ef22d499b3d442bd72f94c0600b3e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796551</data>
    </edge>
    <edge source="程序查询接口" target="中断接口">
      <data key="d6">1.0</data>
      <data key="d7">Programmed I/O and interrupt-driven I/O are contrasting methods, with interrupts offering higher efficiency by reducing CPU polling.</data>
      <data key="d8">I/O control strategy,efficiency comparison</data>
      <data key="d9">chunk-b97ef22d499b3d442bd72f94c0600b3e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796551</data>
    </edge>
    <edge source="中断接口" target="DMA接口">
      <data key="d6">1.0</data>
      <data key="d7">Interrupt-driven I/O and DMA interface differ in CPU involvement, with DMA enabling full CPU offloading during data transfer.</data>
      <data key="d8">CPU involvement,I/O control strategy</data>
      <data key="d9">chunk-b97ef22d499b3d442bd72f94c0600b3e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796552</data>
    </edge>
    <edge source="可编程接口" target="不可编程接口">
      <data key="d6">1.0</data>
      <data key="d7">Programmable interfaces support software reconfiguration, unlike fixed-function non-programmable interfaces.</data>
      <data key="d8">flexibility,software adaptability</data>
      <data key="d9">chunk-b97ef22d499b3d442bd72f94c0600b3e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796552</data>
    </edge>
    <edge source="I/O Port Decoding" target="Independent Addressing">
      <data key="d6">1.0</data>
      <data key="d7">Independent addressing allows simpler I/O port decoding and faster addressing due to dedicated control pathways.</data>
      <data key="d8">faster access,simpler decoding</data>
      <data key="d9">chunk-24e218fe981e25857a4b5fef1ad3838d</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796553</data>
    </edge>
    <edge source="I/O Port Decoding" target="Unified Addressing">
      <data key="d6">1.0</data>
      <data key="d7">Unified addressing integrates I/O port decoding into memory decoding, increasing circuit complexity.</data>
      <data key="d8">higher complexity,integrated decoding</data>
      <data key="d9">chunk-24e218fe981e25857a4b5fef1ad3838d</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796555</data>
    </edge>
    <edge source="Address Space" target="Speed of Addressing">
      <data key="d6">1.0</data>
      <data key="d7">The structure of the address space (independent vs. unified) directly impacts the speed of address resolution.</data>
      <data key="d8">addressing efficiency</data>
      <data key="d9">chunk-24e218fe981e25857a4b5fef1ad3838d</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796554</data>
    </edge>
    <edge source="Independent Addressing" target="Dedicated I/O Instructions">
      <data key="d6">1.0</data>
      <data key="d7">Independent addressing requires specialized I/O instructions, limiting programming flexibility.</data>
      <data key="d8">instruction requirement,limited flexibility</data>
      <data key="d9">chunk-24e218fe981e25857a4b5fef1ad3838d</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796554</data>
    </edge>
    <edge source="Independent Addressing" target="Control Signal Complexity">
      <data key="d6">1.0</data>
      <data key="d7">Independent addressing necessitates two separate sets of control signals, increasing system complexity.</data>
      <data key="d8">increased control demands</data>
      <data key="d9">chunk-24e218fe981e25857a4b5fef1ad3838d</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796554</data>
    </edge>
    <edge source="Independent Addressing" target="Speed of Addressing">
      <data key="d6">1.0</data>
      <data key="d7">Independent addressing enables faster addressing by avoiding overlap and using dedicated paths for I/O.</data>
      <data key="d8">faster access due to simpler structures</data>
      <data key="d9">chunk-24e218fe981e25857a4b5fef1ad3838d</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796555</data>
    </edge>
    <edge source="Independent Addressing" target="Two Independent Address Spaces">
      <data key="d6">1.0</data>
      <data key="d7">Independent addressing is defined by the existence of two distinct address spaces for memory and I/O.</data>
      <data key="d8">structural definition</data>
      <data key="d9">chunk-24e218fe981e25857a4b5fef1ad3838d</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796555</data>
    </edge>
    <edge source="Unified Addressing" target="Main Memory Address Space">
      <data key="d6">1.0</data>
      <data key="d7">Unified addressing uses a portion of the main memory address space for I/O ports, reducing available memory.</data>
      <data key="d8">shared usage,space consumption</data>
      <data key="d9">chunk-24e218fe981e25857a4b5fef1ad3838d</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796553</data>
    </edge>
    <edge source="Unified Addressing" target="Flexibility in Programming">
      <data key="d6">1.0</data>
      <data key="d7">Unified addressing increases programming flexibility by allowing I/O operations to use standard memory instructions.</data>
      <data key="d8">enhanced programming versatility</data>
      <data key="d9">chunk-24e218fe981e25857a4b5fef1ad3838d</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796554</data>
    </edge>
    <edge source="Unified Addressing" target="Decoding Circuit Complexity">
      <data key="d6">1.0</data>
      <data key="d7">Unified addressing increases decoding circuit complexity due to overlapping mapping between memory and I/O addresses.</data>
      <data key="d8">complex signal mapping</data>
      <data key="d9">chunk-24e218fe981e25857a4b5fef1ad3838d</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796555</data>
    </edge>
    <edge source="Unified Addressing" target="Address Space Occupancy">
      <data key="d6">1.0</data>
      <data key="d7">Unified addressing reduces the available memory space by allocating address space to I/O ports.</data>
      <data key="d8">resource trade-off</data>
      <data key="d9">chunk-24e218fe981e25857a4b5fef1ad3838d</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796555</data>
    </edge>
    <edge source="Unified Addressing" target="Memory-Mapped I/O">
      <data key="d6">1.0</data>
      <data key="d7">Unified addressing is synonymous with memory-mapped I/O, representing the same technical approach.</data>
      <data key="d8">equivalent method,synonymy</data>
      <data key="d9">chunk-24e218fe981e25857a4b5fef1ad3838d</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796556</data>
    </edge>
    <edge source="Solid State Disk" target="Flash Memory Chip">
      <data key="d6">1.0</data>
      <data key="d7">The Solid State Disk is composed of one or more flash memory chips as its primary storage medium.</data>
      <data key="d8">component,storage architecture</data>
      <data key="d9">chunk-8189302c7787e74dde6623016361fc8f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796581</data>
    </edge>
    <edge source="Solid State Disk" target="Flash Translation Layer">
      <data key="d6">1.0</data>
      <data key="d7">The flash translation layer is an integral component of the SSD that manages data mapping and translates CPU requests.</data>
      <data key="d8">component,data interface</data>
      <data key="d9">chunk-8189302c7787e74dde6623016361fc8f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796582</data>
    </edge>
    <edge source="Solid State Disk" target="Random Write">
      <data key="d6">1.0</data>
      <data key="d7">Random write operations are slow in SSDs due to the need to erase full blocks and relocate valid data.</data>
      <data key="d8">performance limitation,write behavior</data>
      <data key="d9">chunk-8189302c7787e74dde6623016361fc8f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796583</data>
    </edge>
    <edge source="Solid State Disk" target="Mechanical Drive">
      <data key="d6">1.0</data>
      <data key="d7">SSDs replace mechanical drives by eliminating moving parts and improving access speed and durability.</data>
      <data key="d8">storage comparison,technology replacement</data>
      <data key="d9">chunk-8189302c7787e74dde6623016361fc8f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796585</data>
    </edge>
    <edge source="Solid State Disk" target="Semiconductor Storage">
      <data key="d6">1.0</data>
      <data key="d7">SSDs are built using semiconductor storage technology, which enables fast, reliable, and durable data storage.</data>
      <data key="d8">design principle,technology foundation</data>
      <data key="d9">chunk-8189302c7787e74dde6623016361fc8f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796586</data>
    </edge>
    <edge source="Wear Leveling" target="Flash Memory Lifetime">
      <data key="d6">1.0</data>
      <data key="d7">Wear leveling improves the lifespan of flash memory by evenly distributing write/erase cycles across blocks.</data>
      <data key="d8">performance extension,wear management</data>
      <data key="d9">chunk-8189302c7787e74dde6623016361fc8f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796581</data>
    </edge>
    <edge source="Wear Leveling" target="Dynamic Wear Leveling">
      <data key="d6">1.0</data>
      <data key="d7">Dynamic wear leveling is a subtype of wear leveling that selects blocks with fewer erase cycles for new writes.</data>
      <data key="d8">algorithm type,variant</data>
      <data key="d9">chunk-8189302c7787e74dde6623016361fc8f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796582</data>
    </edge>
    <edge source="Wear Leveling" target="Static Wear Leveling">
      <data key="d6">1.0</data>
      <data key="d7">Static wear leveling is a subtype of wear leveling that manages idle blocks for read operations to balance wear.</data>
      <data key="d8">algorithm type,variant</data>
      <data key="d9">chunk-8189302c7787e74dde6623016361fc8f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796582</data>
    </edge>
    <edge source="SPOOLing Technology" target="I/O Devices">
      <data key="d6">1.0</data>
      <data key="d7">SPOOLing technology improves I/O device utilization by transforming them from exclusive-use to shared resources.</data>
      <data key="d8">device abstraction,performance enhancement</data>
      <data key="d9">chunk-b309162a426d62e33a3be632483b375d</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796587</data>
    </edge>
    <edge source="SPOOLing Technology" target="Peripheral Control Machine">
      <data key="d6">1.0</data>
      <data key="d7">SPOOLing technology employs a peripheral control machine to manage data between devices and storage.</data>
      <data key="d8">data transfer,system design</data>
      <data key="d9">chunk-b309162a426d62e33a3be632483b375d</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796588</data>
    </edge>
    <edge source="SPOOLing Technology" target="Virtual Device Function">
      <data key="d6">1.0</data>
      <data key="d7">SPOOLing Technology enables the Virtual Device Function, allowing exclusive devices to be shared among multiple users.</data>
      <data key="d8">functionality enhancement,resource sharing</data>
      <data key="d9">chunk-b309162a426d62e33a3be632483b375d</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796588</data>
    </edge>
    <edge source="SPOOLing Technology" target="Space for Time">
      <data key="d6">1.0</data>
      <data key="d7">SPOOLing Technology operates on the principle of "space for time," using disk space to improve I/O performance.</data>
      <data key="d8">design philosophy,efficiency trade-off</data>
      <data key="d9">chunk-b309162a426d62e33a3be632483b375d</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796589</data>
    </edge>
    <edge source="Input井" target="Input Buffer">
      <data key="d6">1.0</data>
      <data key="d7">Input data flows from input devices to the Input Buffer before being written to Input井.</data>
      <data key="d8">data flow,intermediate storage</data>
      <data key="d9">chunk-b309162a426d62e33a3be632483b375d</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796586</data>
    </edge>
    <edge source="Input井" target="井管理程序">
      <data key="d6">1.0</data>
      <data key="d7">井管理程序controls the exchange of data between jobs and the input井.</data>
      <data key="d8">data coordination,storage management</data>
      <data key="d9">chunk-b309162a426d62e33a3be632483b375d</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796588</data>
    </edge>
    <edge source="Output井" target="Output Buffer">
      <data key="d6">1.0</data>
      <data key="d7">Data is transferred from Output井to Output Buffer before being sent to the output device.</data>
      <data key="d8">data flow,intermediate storage</data>
      <data key="d9">chunk-b309162a426d62e33a3be632483b375d</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796586</data>
    </edge>
    <edge source="Output井" target="井管理程序">
      <data key="d6">1.0</data>
      <data key="d7">井管理程序controls the exchange of data between jobs and the output井.</data>
      <data key="d8">data coordination,storage management</data>
      <data key="d9">chunk-b309162a426d62e33a3be632483b375d</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796587</data>
    </edge>
    <edge source="Input Buffer" target="Input Process">
      <data key="d6">1.0</data>
      <data key="d7">Input Process receives data from input devices and stores it in the Input Buffer for later transfer to Input井.</data>
      <data key="d8">data forwarding,data reception</data>
      <data key="d9">chunk-b309162a426d62e33a3be632483b375d</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796587</data>
    </edge>
    <edge source="Output Buffer" target="Output Process">
      <data key="d6">1.0</data>
      <data key="d7">Output Process retrieves data from Output井, stores it in the Output Buffer, and sends it to the output device.</data>
      <data key="d8">data reception,data transmission</data>
      <data key="d9">chunk-b309162a426d62e33a3be632483b375d</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796587</data>
    </edge>
    <edge source="SPOOLing Management Process" target="Disk Buffer Area">
      <data key="d6">1.0</data>
      <data key="d7">SPOOLing Management Process allocates disk space in the Disk Buffer Area for incoming print jobs.</data>
      <data key="d8">resource allocation,temporary storage</data>
      <data key="d9">chunk-b309162a426d62e33a3be632483b375d</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796587</data>
    </edge>
    <edge source="SPOOLing Management Process" target="User Request Print Table">
      <data key="d6">1.0</data>
      <data key="d7">SPOOLing Management Process creates and populates a User Request Print Table to record print job details.</data>
      <data key="d8">data recording,job tracking</data>
      <data key="d9">chunk-b309162a426d62e33a3be632483b375d</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796588</data>
    </edge>
    <edge source="User Request Print Table" target="SPOOLing File Queue">
      <data key="d6">1.0</data>
      <data key="d7">User Request Print Table entries are linked to the SPOOLing File Queue for orderly processing.</data>
      <data key="d8">job scheduling,queue management</data>
      <data key="d9">chunk-b309162a426d62e33a3be632483b375d</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761796588</data>
    </edge>
  </graph>
</graphml>
