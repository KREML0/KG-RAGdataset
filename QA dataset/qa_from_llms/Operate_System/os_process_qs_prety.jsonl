{"id": "Q1", "type": "单项选择题", "question": "关于进程与程序的根本区别，以下描述最准确的是： A. 程序是静态的，进程是动态的； B. 程序是可执行文件，进程是运行中的程序实例； C. 程序包含数据段，进程不包含； D. 程序可被多个进程共享，进程不能共享程序", "answer_label": "A", "answer_explain": "程序是静态的代码集合，而进程是程序的一次执行过程，具有生命周期，体现动态性。B虽正确但非最本质区别，C、D错误。", "answer": "A || 解析：程序是静态的代码集合，而进程是程序的一次执行过程，具有生命周期，体现动态性。B虽正确但非最本质区别，C、D错误。"}
{"id": "Q2", "type": "单项选择题", "question": "在多道程序系统中，进程的异步性主要源于： A. CPU时间片的分配不均； B. 进程间相互制约及运行环境变化； C. 多个进程共享同一内存空间； D. 进程调度算法的随机性", "answer_label": "B", "answer_explain": "异步性由进程间相互制约和系统环境变化导致，使进程以不可预知速度推进，引发不可再现性。", "answer": "B || 解析：异步性由进程间相互制约和系统环境变化导致，使进程以不可预知速度推进，引发不可再现性。"}
{"id": "Q3", "type": "单项选择题", "question": "以下关于PCB的说法中，错误的是： A. PCB是进程存在的唯一标志； B. PCB中包含CPU上下文信息； C. PCB在进程终止后立即被释放； D. PCB用于实现进程的调度与同步", "answer_label": "C", "answer_explain": "PCB在进程终止后需经系统回收处理，不能立即释放，需完成资源清理后才可删除。", "answer": "C || 解析：PCB在进程终止后需经系统回收处理，不能立即释放，需完成资源清理后才可删除。"}
{"id": "Q4", "type": "单项选择题", "question": "当一个进程从运行态转为阻塞态时，其PCB中必须保存的信息是： A. 程序计数器和寄存器值； B. 进程优先级和状态； C. 打开文件列表和内存地址； D. 数据段内容和程序段地址", "answer_label": "A", "answer_explain": "进程被阻塞时需保存CPU上下文（如寄存器、程序计数器），以便恢复执行时从断点继续。", "answer": "A || 解析：进程被阻塞时需保存CPU上下文（如寄存器、程序计数器），以便恢复执行时从断点继续。"}
{"id": "Q5", "type": "单项选择题", "question": "在可剥夺型调度系统中，运行态进程转为就绪态的最可能原因是： A. 时间片用完； B. 请求I/O操作； C. 等待资源分配； D. 有更高优先级进程就绪", "answer_label": "D", "answer_explain": "在可剥夺系统中，高优先级进程就绪会立即抢占当前运行进程，使其转为就绪态。", "answer": "D || 解析：在可剥夺系统中，高优先级进程就绪会立即抢占当前运行进程，使其转为就绪态。"}
{"id": "Q6", "type": "单项选择题", "question": "下列关于进程状态转换的描述，正确的是： A. 阻塞态→就绪态是主动行为； B. 就绪态→运行态由调度程序完成； C. 运行态→阻塞态由中断处理程序触发； D. 创建态→就绪态需等待资源释放", "answer_label": "B", "answer_explain": "就绪态→运行态由调度程序根据优先级和时间片分配决定，是调度行为。A、C、D错误。", "answer": "B || 解析：就绪态→运行态由调度程序根据优先级和时间片分配决定，是调度行为。A、C、D错误。"}
{"id": "Q7", "type": "单项选择题", "question": "在系统中，多个进程共享同一程序段，以下说法正确的是： A. 每个进程必须拥有独立的PCB； B. 所有进程共享同一个数据段； C. 程序段必须被复制到每个进程的内存中； D. 程序段的执行必须在单个CPU上完成", "answer_label": "A", "answer_explain": "每个进程必须有独立PCB以实现独立控制和管理，即使共享程序段。B、C、D错误。", "answer": "A || 解析：每个进程必须有独立PCB以实现独立控制和管理，即使共享程序段。B、C、D错误。"}
{"id": "Q8", "type": "简答题", "question": "请结合进程的动态性、并发性与PCB的作用，说明为何进程是资源分配与调度的独立单位。", "answer": "进程具有动态性，其生命周期由创建、运行、终止构成；并发性使其可与其他进程并行执行。PCB作为进程存在的唯一标志，保存其状态、资源分配清单和CPU上下文，使系统能独立调度和分配CPU时间片与资源，实现资源的独立分配与调度，故进程是基本单位。"}
{"id": "Q9", "type": "简答题", "question": "为何进程从运行态转为阻塞态是主动行为，而从阻塞态转为就绪态是被动行为？请结合状态转换机制说明。", "answer": "运行态转阻塞态由进程主动请求资源或等待事件（如I/O），是自身行为。阻塞态转就绪态需外部事件（如I/O完成）触发中断处理程序，由系统完成，进程无法自主恢复，故为被动行为。PCB中状态信息由系统维护，体现这一机制。"}
{"id": "Q10", "type": "简答题", "question": "若系统中多个进程处于阻塞态，为何要按阻塞原因建立多个阻塞队列？请从资源管理与调度效率角度分析。", "answer": "按阻塞原因分队列可提高资源分配效率。当特定事件（如I/O完成）发生时，系统可快速定位相关进程，将其从对应队列移至就绪队列，避免遍历所有阻塞进程。这提升了调度响应速度，减少资源等待时间，增强系统并发性能。"}
{"id": "Q11", "type": "单项选择题", "question": "关于进程与程序的根本区别，以下描述最准确的是： A. 程序是静态的，进程是动态的； B. 程序是可执行文件，进程是运行中的程序； C. 程序包含数据段，进程不包含； D. 程序可被多个用户共享，进程不能被共享", "answer_label": "A", "answer_explain": "程序是静态的代码集合，而进程是程序在内存中的一次执行实例，具有生命周期和状态变化，体现动态性，是根本区别。", "answer": "A || 解析：程序是静态的代码集合，而进程是程序在内存中的一次执行实例，具有生命周期和状态变化，体现动态性，是根本区别。"}
{"id": "Q12", "type": "单项选择题", "question": "在多道程序系统中，进程的异步性主要导致的问题是： A. 进程无法创建； B. 程序无法加载； C. 执行结果不可再现； D. CPU无法调度", "answer_label": "C", "answer_explain": "异步性使进程推进速度不可预知，导致相同输入可能产生不同结果，因此必须引入同步机制保证可再现性。", "answer": "C || 解析：异步性使进程推进速度不可预知，导致相同输入可能产生不同结果，因此必须引入同步机制保证可再现性。"}
{"id": "Q13", "type": "单项选择题", "question": "下列关于PCB的说法中，错误的是： A. PCB是进程存在的唯一标志； B. PCB中包含CPU上下文信息； C. PCB在进程终止后立即被销毁； D. PCB用于实现进程的资源分配和调度", "answer_label": "C", "answer_explain": "PCB在进程终止后需先完成资源回收与状态清理，再被销毁，不能立即删除，否则可能引发系统错误。", "answer": "C || 解析：PCB在进程终止后需先完成资源回收与状态清理，再被销毁，不能立即删除，否则可能引发系统错误。"}
{"id": "Q14", "type": "单项选择题", "question": "当一个进程因等待I/O操作完成而被阻塞时，其状态转换应为： A. 就绪态→运行态； B. 运行态→阻塞态； C. 阻塞态→就绪态； D. 运行态→就绪态", "answer_label": "B", "answer_explain": "进程在运行中请求I/O资源或等待事件，主动放弃CPU，进入阻塞态，因此是运行态→阻塞态。", "answer": "B || 解析：进程在运行中请求I/O资源或等待事件，主动放弃CPU，进入阻塞态，因此是运行态→阻塞态。"}
{"id": "Q15", "type": "单项选择题", "question": "在可剥夺型调度系统中，一个高优先级进程就绪后，正在运行的低优先级进程会被中断，该转换属于： A. 就绪态→运行态； B. 运行态→就绪态； C. 阻塞态→就绪态； D. 运行态→阻塞态", "answer_label": "B", "answer_explain": "高优先级进程就绪后，调度器会剥夺当前运行进程的CPU，使其返回就绪队列，故为运行态→就绪态。", "answer": "B || 解析：高优先级进程就绪后，调度器会剥夺当前运行进程的CPU，使其返回就绪队列，故为运行态→就绪态。"}
{"id": "Q16", "type": "单项选择题", "question": "下列哪项不是进程控制块（PCB）中包含的信息？ A. 进程标识符； B. 程序计数器； C. 程序源代码； D. 优先级", "answer_label": "C", "answer_explain": "PCB存储运行时状态信息，程序源代码属于程序段，存于内存中，不包含在PCB内。", "answer": "C || 解析：PCB存储运行时状态信息，程序源代码属于程序段，存于内存中，不包含在PCB内。"}
{"id": "Q17", "type": "简答题", "question": "请结合进程的动态性、并发性与PCB的作用，说明为什么操作系统必须通过PCB来管理进程？", "answer": "进程是动态的执行过程，具有生命周期，需通过PCB记录其状态、资源、CPU上下文等信息；并发执行时，系统需调度多个进程，PCB提供调度依据；PCB是进程存在的唯一标识，系统仅通过PCB感知和控制进程，确保资源分配与调度的正确性。"}
{"id": "Q18", "type": "简答题", "question": "若一个进程在运行过程中请求I/O操作，其状态将如何变化？该过程中PCB承担了哪些关键作用？", "answer": "进程从运行态转为阻塞态，因请求I/O而等待事件。PCB在此过程中保存CPU上下文（如寄存器值），记录阻塞原因，更新状态信息，并将进程插入阻塞队列，确保中断后能恢复执行。"}
{"id": "Q19", "type": "简答题", "question": "为何说‘进程是资源分配和调度的独立单位’？请从系统资源、PCB和状态转换角度说明。", "answer": "进程是资源分配单位，系统以进程为单位分配内存、设备等资源；调度单位，调度器基于PCB中的优先级、状态等信息分配CPU时间片；状态转换（如运行→阻塞）体现资源依赖，PCB全程记录状态与资源使用，确保独立性。"}
{"id": "Q20", "type": "简答题", "question": "在创建一个新进程时，为何必须先创建其PCB？请结合进程的独立性与资源分配机制说明。", "answer": "PCB是进程存在的唯一标志，没有PCB则系统无法感知该进程；进程的独立性依赖PCB记录其标识、资源清单和状态；资源分配和调度均基于PCB进行，因此必须先创建PCB，才能完成资源分配与状态初始化，使进程具备独立运行能力。"}
{"id": "Q21", "type": "单项选择题", "question": "关于进程与程序的根本区别，以下描述最准确的是： A. 程序是静态的，进程是动态的； B. 程序是可执行文件，进程是运行中的程序； C. 程序包含数据段，进程包含PCB； D. 程序可被多个进程共享，进程不能共享程序", "answer_label": "A", "answer_explain": "程序是静态的代码集合，而进程是程序的一次执行实例，具有生命周期和状态变化，体现动态性。其他选项虽部分正确，但未触及根本区别。", "answer": "A || 解析：程序是静态的代码集合，而进程是程序的一次执行实例，具有生命周期和状态变化，体现动态性。其他选项虽部分正确，但未触及根本区别。"}
{"id": "Q22", "type": "单项选择题", "question": "在多道程序系统中，进程的异步性主要导致的问题是： A. 程序无法并发执行； B. 进程间资源竞争； C. 执行结果不可再现； D. CPU利用率下降", "answer_label": "C", "answer_explain": "异步性使进程按不可预知速度推进，导致相同输入可能产生不同结果，即不可再现性，需通过同步机制解决。", "answer": "C || 解析：异步性使进程按不可预知速度推进，导致相同输入可能产生不同结果，即不可再现性，需通过同步机制解决。"}
{"id": "Q23", "type": "单项选择题", "question": "下列关于PCB的描述中，错误的是： A. PCB是进程存在的唯一标志； B. PCB中包含CPU上下文信息； C. PCB在进程终止后立即被销毁； D. PCB用于实现进程的资源分配与调度", "answer_label": "C", "answer_explain": "PCB在进程终止后需由系统回收并清理，但并非立即销毁，可能需等待资源释放或状态更新，故‘立即’错误。", "answer": "C || 解析：PCB在进程终止后需由系统回收并清理，但并非立即销毁，可能需等待资源释放或状态更新，故‘立即’错误。"}
{"id": "Q24", "type": "单项选择题", "question": "当一个进程从运行态转为阻塞态时，以下哪项操作不会发生？ A. 保存CPU上下文到PCB； B. 将PCB插入阻塞队列； C. 释放CPU时间片； D. 修改进程状态为阻塞态", "answer_label": "C", "answer_explain": "时间片是CPU资源的分配单位，进程阻塞时CPU空闲，但时间片本身不被‘释放’，而是由调度器重新分配给其他进程。", "answer": "C || 解析：时间片是CPU资源的分配单位，进程阻塞时CPU空闲，但时间片本身不被‘释放’，而是由调度器重新分配给其他进程。"}
{"id": "Q25", "type": "单项选择题", "question": "在可剥夺调度系统中，一个高优先级进程就绪时，当前运行的低优先级进程会立即被抢占，该转换属于： A. 运行态→就绪态； B. 就绪态→运行态； C. 运行态→阻塞态； D. 就绪态→阻塞态", "answer_label": "A", "answer_explain": "高优先级进程就绪时，低优先级进程被剥夺CPU，由运行态转为就绪态，等待下次调度。", "answer": "A || 解析：高优先级进程就绪时，低优先级进程被剥夺CPU，由运行态转为就绪态，等待下次调度。"}
{"id": "Q26", "type": "单项选择题", "question": "关于进程的独立性特征，以下说法正确的是： A. 进程可独立运行，但不能独立获得资源； B. 未建立PCB的程序仍可作为独立单位运行； C. 进程是资源分配和调度的独立单位； D. 进程的独立性意味着其执行不受其他进程影响", "answer_label": "C", "answer_explain": "进程是系统进行资源分配和调度的基本单位，具备独立性，即能独立获得资源并被调度，这是其核心特征。", "answer": "C || 解析：进程是系统进行资源分配和调度的基本单位，具备独立性，即能独立获得资源并被调度，这是其核心特征。"}
{"id": "Q27", "type": "单项选择题", "question": "在创建进程的过程中，以下哪一步是必须的？ A. 为程序段分配内存； B. 为数据段分配内存； C. 申请一个空白PCB； D. 将程序加载到CPU", "answer_label": "C", "answer_explain": "创建进程的第一步是申请空白PCB，它是进程存在的唯一标志，后续资源分配和状态设置均基于PCB。", "answer": "C || 解析：创建进程的第一步是申请空白PCB，它是进程存在的唯一标志，后续资源分配和状态设置均基于PCB。"}
{"id": "Q28", "type": "简答题", "question": "请结合进程的动态性、并发性与异步性，说明为何操作系统必须引入进程概念并依赖PCB进行管理。", "answer": "多道程序并发执行导致程序失去封闭性，产生间断性和不可再现性。进程作为程序的一次执行实例，具有动态生命周期，支持并发运行。异步性使进程推进不可预知，需通过PCB统一管理其状态、资源和上下文，实现调度、同步与资源回收，确保系统稳定与可控制。"}
{"id": "Q29", "type": "简答题", "question": "若某进程在运行中请求I/O操作，系统如何通过PCB实现状态转换与资源管理？请说明关键步骤。", "answer": "进程请求I/O时，系统将其运行态转为阻塞态，保存CPU上下文至PCB，更新状态信息。PCB中记录阻塞原因，将该进程的PCB插入对应阻塞队列。I/O完成后，中断处理程序将PCB从阻塞队列移出，状态改为就绪，插入就绪队列，等待调度。"}
{"id": "Q30", "type": "简答题", "question": "为何说‘进程是资源分配和调度的独立单位’？请从资源分配、调度机制和PCB作用三方面解释。", "answer": "进程是资源分配单位，因系统以进程为单位分配内存、文件、设备等资源；是调度单位，调度器基于PCB中的优先级、状态等信息分配CPU时间片；PCB作为进程的唯一标识，集中存储资源清单与CPU上下文，使系统能全过程控制进程的创建、运行、切换与终止，实现资源与调度的独立性。"}
{"id": "Q31", "type": "单项选择题", "question": "关于进程与程序的本质区别，下列说法正确的是： A. 程序是动态的，进程是静态的； B. 程序是进程的运行实例，进程是程序的静态形式； C. 进程是程序的一次执行，具有生命周期，程序是静态的代码集合； D. 程序和进程在概念上完全等价，仅名称不同", "answer_label": "C", "answer_explain": "程序是静态的代码，进程是程序的一次执行过程，具有动态性、生命周期，二者本质不同。C正确描述了这一核心区别。", "answer": "C || 解析：程序是静态的代码，进程是程序的一次执行过程，具有动态性、生命周期，二者本质不同。C正确描述了这一核心区别。"}
{"id": "Q32", "type": "单项选择题", "question": "在多道程序系统中，进程的异步性主要源于： A. CPU速度过快； B. 进程间相互制约及运行环境变化； C. 内存容量不足； D. I/O设备响应时间固定", "answer_label": "B", "answer_explain": "异步性由进程间相互制约和系统环境变化导致，使得进程以不可预知速度推进，引发不可再现性。", "answer": "B || 解析：异步性由进程间相互制约和系统环境变化导致，使得进程以不可预知速度推进，引发不可再现性。"}
{"id": "Q33", "type": "单项选择题", "question": "下列关于进程控制块（PCB）的说法中，错误的是： A. PCB是进程存在的唯一标志； B. PCB中包含CPU上下文信息； C. PCB在进程创建时生成，运行结束后立即销毁； D. PCB用于存储进程的优先级和资源分配清单", "answer_label": "C", "answer_explain": "PCB在进程结束时才被销毁，不是‘运行结束后立即销毁’，可能需等待资源回收等后续处理。", "answer": "C || 解析：PCB在进程结束时才被销毁，不是‘运行结束后立即销毁’，可能需等待资源回收等后续处理。"}
{"id": "Q34", "type": "单项选择题", "question": "当一个进程请求I/O操作后，其状态将从运行态转换为： A. 就绪态； B. 阻塞态； C. 终止态； D. 创建态", "answer_label": "B", "answer_explain": "进程请求I/O等资源时，需等待事件完成，故从运行态转为阻塞态，属于主动行为。", "answer": "B || 解析：进程请求I/O等资源时，需等待事件完成，故从运行态转为阻塞态，属于主动行为。"}
{"id": "Q35", "type": "单项选择题", "question": "在可剥夺操作系统中，一个高优先级进程就绪时，正在运行的低优先级进程将被剥夺CPU，其状态应转换为： A. 运行态； B. 就绪态； C. 阻塞态； D. 终止态", "answer_label": "B", "answer_explain": "被剥夺CPU的进程未因等待资源而阻塞，仅因调度被暂停，应转入就绪态，等待再次调度。", "answer": "B || 解析：被剥夺CPU的进程未因等待资源而阻塞，仅因调度被暂停，应转入就绪态，等待再次调度。"}
{"id": "Q36", "type": "单项选择题", "question": "下列哪项不是进程控制块（PCB）中包含的信息？ A. 进程标识符； B. 程序计数器； C. 程序源代码； D. 优先级", "answer_label": "C", "answer_explain": "PCB存储运行时状态信息，不包含程序源代码，程序本身存于程序段中。", "answer": "C || 解析：PCB存储运行时状态信息，不包含程序源代码，程序本身存于程序段中。"}
{"id": "Q37", "type": "简答题", "question": "请结合进程的动态性与PCB的作用，说明为何操作系统必须通过PCB来感知进程的存在。", "answer": "进程是动态的执行过程，其状态随时间变化。PCB作为进程的唯一标识和运行时信息载体，持续记录进程的控制、资源、CPU上下文等信息。操作系统仅通过PCB获取进程状态，实现调度、管理与切换，故必须依赖PCB感知进程存在。"}
{"id": "Q38", "type": "简答题", "question": "若一个进程在运行中因等待I/O完成而进入阻塞态，其CPU上下文信息应保存在何处？并说明该信息在后续恢复运行时的作用。", "answer": "CPU上下文信息应保存在该进程的PCB中。当I/O完成后，中断处理程序将进程状态转为就绪态，调度器根据PCB中的上下文恢复CPU寄存器值，使进程从断点继续执行，保证执行连续性。"}
{"id": "Q39", "type": "简答题", "question": "为何说‘进程是资源分配和调度的独立单位’？请结合‘时间片’分配与PCB的作用进行解释。", "answer": "进程是系统分配CPU时间片（资源）的独立单位。PCB记录进程优先级、状态和CPU上下文，使操作系统能根据其信息进行调度。时间片分配以进程为单位，确保每个进程独立获得运行时间，体现其作为资源调度与分配的基本单位。"}
{"id": "Q40", "type": "简答题", "question": "请说明为何‘就绪态’与‘阻塞态’的本质区别在于‘是否缺少CPU’，并举例说明其在调度策略中的意义。", "answer": "就绪态仅缺CPU，可立即运行；阻塞态缺其他资源或事件，即使CPU空闲也无法运行。调度器仅从就绪队列中选择进程，阻塞进程无法被调度。例如，I/O完成唤醒阻塞进程至就绪队列，才可被调度，体现调度的合理性与资源依赖性。"}
{"id": "Q41", "type": "单项选择题", "question": "关于进程与程序的根本区别，以下描述最准确的是： A. 程序是静态的，进程是动态的； B. 程序是可执行文件，进程是运行中的程序； C. 程序包含数据，进程不包含数据； D. 程序可被多个用户共享，进程不能被共享", "answer_label": "A", "answer_explain": "程序是静态的代码集合，而进程是程序的一次执行实例，具有生命周期，体现动态性，是操作系统管理的基本单位。", "answer": "A || 解析：程序是静态的代码集合，而进程是程序的一次执行实例，具有生命周期，体现动态性，是操作系统管理的基本单位。"}
{"id": "Q42", "type": "单项选择题", "question": "在多道程序系统中，引入进程的主要目的是： A. 提高程序执行速度； B. 实现程序的并发执行和资源的共享； C. 使程序能被多个用户同时运行； D. 降低内存占用", "answer_label": "B", "answer_explain": "引入进程的核心目标是实现并发执行与资源共享，这是操作系统最基本的两个特性，与程序的顺序执行形成对比。", "answer": "B || 解析：引入进程的核心目标是实现并发执行与资源共享，这是操作系统最基本的两个特性，与程序的顺序执行形成对比。"}
{"id": "Q43", "type": "单项选择题", "question": "下列关于进程控制块（PCB）的说法中，错误的是： A. PCB是进程存在的唯一标志； B. PCB中包含进程的优先级信息； C. PCB仅在进程运行时才存在； D. PCB保存CPU上下文信息", "answer_label": "C", "answer_explain": "PCB在进程创建时建立，直至进程终止才被删除，贯穿整个生命周期，即使进程未运行也存在。", "answer": "C || 解析：PCB在进程创建时建立，直至进程终止才被删除，贯穿整个生命周期，即使进程未运行也存在。"}
{"id": "Q44", "type": "单项选择题", "question": "当一个进程请求I/O操作并等待结果时，其状态应由运行态转变为： A. 就绪态； B. 创建态； C. 阻塞态； D. 终止态", "answer_label": "C", "answer_explain": "进程因等待I/O等事件而暂停运行，需主动进入阻塞态，等待事件完成后再转为就绪态。", "answer": "C || 解析：进程因等待I/O等事件而暂停运行，需主动进入阻塞态，等待事件完成后再转为就绪态。"}
{"id": "Q45", "type": "单项选择题", "question": "在可剥夺型调度系统中，一个高优先级进程就绪后，正在运行的低优先级进程会被剥夺CPU，该进程的状态将变为： A. 运行态； B. 就绪态； C. 阻塞态； D. 终止态", "answer_label": "B", "answer_explain": "在可剥夺系统中，高优先级进程就绪会抢占CPU，原运行进程被剥夺后进入就绪队列，等待再次调度。", "answer": "B || 解析：在可剥夺系统中，高优先级进程就绪会抢占CPU，原运行进程被剥夺后进入就绪队列，等待再次调度。"}
{"id": "Q46", "type": "单项选择题", "question": "以下哪项最准确地描述了进程的独立性特征？ A. 进程可以独立于系统运行； B. 进程可以独立分配内存； C. 进程是能独立运行、独立获得资源和接受调度的基本单位； D. 进程可以独立访问所有文件", "answer_label": "C", "answer_explain": "独立性指进程能独立运行、申请资源并被调度，其核心在于拥有PCB，是资源分配与调度的基本单位。", "answer": "C || 解析：独立性指进程能独立运行、申请资源并被调度，其核心在于拥有PCB，是资源分配与调度的基本单位。"}
{"id": "Q47", "type": "单项选择题", "question": "关于进程的异步性，以下说法正确的是： A. 异步性意味着进程执行速度完全随机； B. 异步性导致执行结果不可再现，需通过同步机制解决； C. 异步性是进程并发执行的必要条件； D. 异步性仅出现在多核系统中", "answer_label": "B", "answer_explain": "异步性由进程间相互制约引起，导致执行顺序不可预知，结果不可再现，必须通过同步机制控制。", "answer": "B || 解析：异步性由进程间相互制约引起，导致执行顺序不可预知，结果不可再现，必须通过同步机制控制。"}
{"id": "Q48", "type": "简答题", "question": "请结合进程的组成与状态转换，说明为何PCB是操作系统管理进程的核心？", "answer": "PCB是进程存在的唯一标志，包含进程状态、优先级、资源清单和CPU上下文等信息。操作系统通过PCB实现进程调度、状态转换、资源分配与恢复，如运行态转阻塞态需保存现场，阻塞态转就绪态需恢复状态，故PCB是管理进程的核心数据结构。"}
{"id": "Q49", "type": "简答题", "question": "若某进程在运行中因请求I/O而阻塞，其PCB中哪些信息会被更新？请说明原因。", "answer": "PCB中进程状态由运行态改为阻塞态，CPU上下文（寄存器值）被保存，资源分配清单中I/O请求信息被记录。因进程暂停运行，需保存断点以便恢复，同时系统需记录其等待事件，故PCB必须更新状态与上下文信息。"}
{"id": "Q50", "type": "简答题", "question": "为何说‘进程是资源分配和调度的独立单位’？请从资源分配与调度两个角度说明。", "answer": "资源分配上，进程是独立申请内存、文件、设备等资源的单位，PCB记录其资源清单；调度上，进程是CPU时间片分配的独立单位，调度程序根据PCB中的优先级和状态决定执行顺序。因进程具有动态性，其生命周期内资源与调度权均独立，故为基本单位。"}
{"id": "Q51", "type": "单项选择题", "question": "关于进程与程序的根本区别，以下描述最准确的是： A. 程序是静态的，进程是动态的； B. 程序可被多个用户共享，进程不能； C. 程序包含数据段，进程不包含； D. 程序运行时不需要PCB，进程需要PCB", "answer_label": "A", "answer_explain": "程序是静态的代码集合，而进程是程序的一次执行实例，具有生命周期和运行状态，体现动态性。B错误，进程可共享程序；C错误，进程包含数据段；D错误，程序运行需PCB，但非‘程序运行时不需要’，表述不准确。", "answer": "A || 解析：程序是静态的代码集合，而进程是程序的一次执行实例，具有生命周期和运行状态，体现动态性。B错误，进程可共享程序；C错误，进程包含数据段；D错误，程序运行需PCB，但非‘程序运行时不需要’，表述不准确。"}
{"id": "Q52", "type": "单项选择题", "question": "在多道程序系统中，进程的异步性主要导致的问题是： A. 进程无法创建； B. 进程状态无法转换； C. 执行结果不可再现； D. CPU利用率下降", "answer_label": "C", "answer_explain": "异步性指进程以不可预知的速度推进，受其他进程制约，导致多次运行结果不一致，即不可再现性。A、B错误，创建和状态转换正常；D非直接结果，CPU利用率可能因并发提高。", "answer": "C || 解析：异步性指进程以不可预知的速度推进，受其他进程制约，导致多次运行结果不一致，即不可再现性。A、B错误，创建和状态转换正常；D非直接结果，CPU利用率可能因并发提高。"}
{"id": "Q53", "type": "单项选择题", "question": "下列关于PCB的说法中，正确的是： A. PCB仅在进程运行时存在； B. PCB中不包含程序的地址信息； C. PCB是进程存在的唯一标志； D. PCB可被多个进程共享", "answer_label": "C", "answer_explain": "PCB是进程实体的一部分，是进程存在的唯一标志，常驻内存，从创建到终止始终存在。A错误，PCB在创建时即存在；B错误，PCB含程序内存始址；D错误，PCB不可共享。", "answer": "C || 解析：PCB是进程实体的一部分，是进程存在的唯一标志，常驻内存，从创建到终止始终存在。A错误，PCB在创建时即存在；B错误，PCB含程序内存始址；D错误，PCB不可共享。"}
{"id": "Q54", "type": "单项选择题", "question": "当一个进程从运行态转为阻塞态时，系统必须保存的信息是： A. 程序计数器和寄存器内容； B. 进程优先级和状态； C. 所有内存数据； D. 文件打开列表", "answer_label": "A", "answer_explain": "进程被中断时，需保存CPU上下文（如程序计数器、寄存器值）至PCB，以便恢复执行。B、D虽在PCB中，但非切换时需保存的关键信息；C错误，非全部内存数据需保存。", "answer": "A || 解析：进程被中断时，需保存CPU上下文（如程序计数器、寄存器值）至PCB，以便恢复执行。B、D虽在PCB中，但非切换时需保存的关键信息；C错误，非全部内存数据需保存。"}
{"id": "Q55", "type": "单项选择题", "question": "在可剥夺调度系统中，运行态进程被剥夺CPU的可能原因不包括： A. 时间片用完； B. 有更高优先级进程就绪； C. 进程主动请求I/O； D. 系统调用完成", "answer_label": "D", "answer_explain": "系统调用完成是执行结果，不会触发剥夺；而A、B、C均是剥夺的典型原因。C中请求I/O会主动放弃CPU，进入阻塞态，属于剥夺行为。", "answer": "D || 解析：系统调用完成是执行结果，不会触发剥夺；而A、B、C均是剥夺的典型原因。C中请求I/O会主动放弃CPU，进入阻塞态，属于剥夺行为。"}
{"id": "Q56", "type": "单项选择题", "question": "进程由创建态进入就绪态的前提是： A. 已分配到CPU； B. 已分配到所需资源； C. 已创建PCB； D. 已完成程序加载", "answer_label": "B", "answer_explain": "创建态进程需完成资源分配（如内存）后才能转入就绪态。C虽必要，但非充分条件；A错误，创建态未分配CPU；D不完整，加载后仍需资源分配。", "answer": "B || 解析：创建态进程需完成资源分配（如内存）后才能转入就绪态。C虽必要，但非充分条件；A错误，创建态未分配CPU；D不完整，加载后仍需资源分配。"}
{"id": "Q57", "type": "简答题", "question": "请结合进程的动态性、独立性与资源分配机制，说明为何进程是系统资源分配和调度的独立单位。", "answer": "进程具有动态性，有创建、运行、终止的生命周期；独立性使其能独立获得资源并接受调度；系统以时间片为单位分配CPU资源，PCB记录资源使用情况，确保每个进程独立调度。因此，进程是资源分配与调度的独立单位。"}
{"id": "Q58", "type": "简答题", "question": "若某进程因等待I/O完成而进入阻塞态，中断处理程序如何将其恢复为就绪态？请结合PCB和状态转换机制说明。", "answer": "当I/O完成时，中断处理程序检测到相关进程阻塞，将其状态由阻塞态改为就绪态，并将其PCB插入就绪队列。PCB中保存的断点信息用于后续恢复执行。该过程依赖PCB实现状态管理与调度准备。"}
{"id": "Q59", "type": "简答题", "question": "为何说‘进程是程序的一次执行’这一定义体现了进程的动态性？请结合进程状态转换和PCB的作用进行解释。", "answer": "‘程序的一次执行’强调进程随时间变化，具有生命周期。从创建态→就绪态→运行态→阻塞态或终止态，状态转换体现动态过程。PCB实时记录状态、寄存器等信息，系统通过PCB感知并控制进程运行，确保其动态性。"}
{"id": "Q60", "type": "简答题", "question": "在链接方式组织PCB时，为何要将阻塞态进程按阻塞原因分队列？请结合进程同步与资源管理说明其必要性。", "answer": "不同阻塞原因（如等待I/O、信号量、文件）需不同处理。按原因分队列可提高调度效率，中断处理程序能快速定位并唤醒对应进程。这有助于实现进程同步与资源管理的精准控制，避免误唤醒或延迟响应。"}
{"id": "Q61", "type": "单项选择题", "question": "关于进程与程序的根本区别，以下描述最准确的是： A. 程序是静态的，进程是动态的； B. 程序是可执行文件，进程是运行中的程序实例； C. 程序包含数据段，进程包含PCB； D. 程序可被多个进程共享，进程不能共享程序", "answer_label": "A", "answer_explain": "程序是静态的代码集合，而进程是程序的一次执行实例，具有生命周期，体现动态性。B虽正确但不完整；C混淆了组成结构；D错误，进程可共享程序。", "answer": "A || 解析：程序是静态的代码集合，而进程是程序的一次执行实例，具有生命周期，体现动态性。B虽正确但不完整；C混淆了组成结构；D错误，进程可共享程序。"}
{"id": "Q62", "type": "单项选择题", "question": "在多道程序系统中，进程的异步性主要导致的问题是： A. 进程无法并发执行； B. 进程的执行结果不可再现； C. 进程无法被调度； D. 进程无法创建PCB", "answer_label": "B", "answer_explain": "异步性使进程按不可预知速度推进，导致相同输入可能产生不同结果，故执行结果不可再现，需同步机制解决。", "answer": "B || 解析：异步性使进程按不可预知速度推进，导致相同输入可能产生不同结果，故执行结果不可再现，需同步机制解决。"}
{"id": "Q63", "type": "单项选择题", "question": "下列关于PCB的说法中，错误的是： A. PCB是进程存在的唯一标志； B. PCB中包含CPU上下文信息； C. PCB在进程终止后立即被删除； D. PCB用于实现进程的资源分配与调度", "answer_label": "C", "answer_explain": "PCB在进程终止后需先进行资源回收与状态清理，再删除，不能立即删除，否则可能引发系统错误。", "answer": "C || 解析：PCB在进程终止后需先进行资源回收与状态清理，再删除，不能立即删除，否则可能引发系统错误。"}
{"id": "Q64", "type": "单项选择题", "question": "当一个进程从运行态转为阻塞态时，以下哪项操作不会发生？ A. 保存CPU寄存器状态至PCB； B. 将进程插入阻塞队列； C. 释放CPU时间片； D. 修改进程状态为阻塞态", "answer_label": "C", "answer_explain": "时间片释放是运行态→就绪态的特征，阻塞态转换不涉及时间片释放，而是因等待事件而暂停。", "answer": "C || 解析：时间片释放是运行态→就绪态的特征，阻塞态转换不涉及时间片释放，而是因等待事件而暂停。"}
{"id": "Q65", "type": "单项选择题", "question": "在可剥夺操作系统中，一个高优先级进程就绪后，正在运行的低优先级进程会立即被剥夺CPU，这属于： A. 就绪态→运行态； B. 运行态→就绪态； C. 运行态→阻塞态； D. 阻塞态→就绪态", "answer_label": "B", "answer_explain": "高优先级进程就绪导致低优先级进程被剥夺CPU，其状态由运行态转为就绪态，等待下次调度。", "answer": "B || 解析：高优先级进程就绪导致低优先级进程被剥夺CPU，其状态由运行态转为就绪态，等待下次调度。"}
{"id": "Q66", "type": "单项选择题", "question": "以下关于进程独立性的描述，正确的是： A. 进程可以不依赖PCB独立运行； B. 未建立PCB的程序也可作为独立单位参与运行； C. 进程是资源分配和调度的独立单位； D. 进程可共享其他进程的PCB", "answer_label": "C", "answer_explain": "进程是资源分配和调度的基本单位，必须通过PCB管理，未建PCB的程序不能独立运行，PCB不可共享。", "answer": "C || 解析：进程是资源分配和调度的基本单位，必须通过PCB管理，未建PCB的程序不能独立运行，PCB不可共享。"}
{"id": "Q67", "type": "单项选择题", "question": "进程在运行过程中请求I/O操作，其状态应由运行态转为： A. 就绪态； B. 阻塞态； C. 终止态； D. 创建态", "answer_label": "B", "answer_explain": "进程请求I/O操作属于等待外部事件，需暂停运行，因此从运行态转为阻塞态，等待I/O完成。", "answer": "B || 解析：进程请求I/O操作属于等待外部事件，需暂停运行，因此从运行态转为阻塞态，等待I/O完成。"}
{"id": "Q68", "type": "简答题", "question": "请结合进程的动态性、独立性与异步性，说明为何操作系统必须通过PCB来管理进程？", "answer": "进程具有动态性（生命周期变化）、独立性（需独立资源与调度）和异步性（执行不可预知）。PCB作为进程唯一标识，记录其状态、资源、CPU上下文等信息，使系统能感知进程存在、控制其状态转换、实现资源分配与调度，并在异步环境下恢复断点，确保并发执行的可控性。"}
{"id": "Q69", "type": "简答题", "question": "若某进程在运行中因请求资源失败而进入阻塞态，系统如何通过PCB实现该进程的后续恢复？", "answer": "进程阻塞时，系统将CPU寄存器状态保存至PCB，将其状态设为阻塞并插入对应阻塞队列。当资源可用或事件发生时，中断处理程序将该进程状态改为就绪，并移入就绪队列。调度时，系统从PCB中恢复CPU上下文，使进程从断点继续执行。"}
{"id": "Q70", "type": "简答题", "question": "为什么说‘进程是系统进行资源分配和调度的独立单位’？请从资源分配与调度两个角度解释。", "answer": "资源分配上，系统以进程为单位分配内存、文件、设备等资源，PCB记录资源清单，确保独立性；调度上，CPU时间片按进程分配，调度程序依据PCB中的优先级与状态决定执行顺序。因此，进程是资源分配与调度的最小独立单位，具备动态性与独立性。"}
{"id": "Q71", "type": "单项选择题", "question": "关于进程与程序的根本区别，以下说法最准确的是： A. 程序是静态的，进程是动态的； B. 程序是可执行文件，进程是运行中的程序实例； C. 程序包含代码和数据，进程还包含PCB； D. 程序可被多个进程共享，进程不能共享程序", "answer_label": "A", "answer_explain": "程序是静态的代码集合，进程是程序的一次执行实例，具有生命周期和状态变化，体现动态性。B虽正确但不全面，C混淆了组成与本质，D错误（进程可共享程序）。", "answer": "A || 解析：程序是静态的代码集合，进程是程序的一次执行实例，具有生命周期和状态变化，体现动态性。B虽正确但不全面，C混淆了组成与本质，D错误（进程可共享程序）。"}
{"id": "Q72", "type": "单项选择题", "question": "在多道程序系统中，进程的异步性主要导致的问题是： A. 进程无法并发执行； B. 进程执行结果不可再现； C. 进程无法获得CPU资源； D. 进程无法创建PCB", "answer_label": "B", "answer_explain": "异步性使进程以不可预知的速度推进，导致相同输入可能产生不同结果，即不可再现性，需通过同步机制解决。", "answer": "B || 解析：异步性使进程以不可预知的速度推进，导致相同输入可能产生不同结果，即不可再现性，需通过同步机制解决。"}
{"id": "Q73", "type": "单项选择题", "question": "下列关于PCB的说法中，错误的是： A. PCB是进程存在的唯一标志； B. PCB中保存有CPU上下文信息； C. PCB在进程创建时生成，终止时销毁； D. PCB中不包含进程的程序代码", "answer_label": "D", "answer_explain": "PCB不包含程序代码，程序段是独立部分。D错误，其余均正确。PCB仅管理控制信息，不存储可执行代码。", "answer": "D || 解析：PCB不包含程序代码，程序段是独立部分。D错误，其余均正确。PCB仅管理控制信息，不存储可执行代码。"}
{"id": "Q74", "type": "单项选择题", "question": "当一个进程从运行态转为阻塞态时，以下哪项操作不会发生？ A. 保存CPU寄存器状态到PCB； B. 将进程插入阻塞队列； C. 释放其占用的内存资源； D. 由系统调用触发状态转换", "answer_label": "C", "answer_explain": "阻塞时仅暂停执行，资源仍被占用，不释放内存。A、B、D均为正确操作，C错误，资源释放在终止态进行。", "answer": "C || 解析：阻塞时仅暂停执行，资源仍被占用，不释放内存。A、B、D均为正确操作，C错误，资源释放在终止态进行。"}
{"id": "Q75", "type": "单项选择题", "question": "在可剥夺型调度系统中，一个高优先级就绪进程被调度执行，此时原运行进程的状态应变为： A. 就绪态； B. 阻塞态； C. 运行态； D. 终止态", "answer_label": "A", "answer_explain": "在可剥夺系统中，高优先级进程就绪时，当前运行进程被剥夺CPU，转为就绪态，等待再次调度。阻塞态需等待事件，非剥夺原因。", "answer": "A || 解析：在可剥夺系统中，高优先级进程就绪时，当前运行进程被剥夺CPU，转为就绪态，等待再次调度。阻塞态需等待事件，非剥夺原因。"}
{"id": "Q76", "type": "单项选择题", "question": "下列哪项最能体现进程的独立性特征？ A. 进程可被多个用户共享； B. 进程拥有独立的PCB； C. 进程可并发执行； D. 进程可被调度", "answer_label": "B", "answer_explain": "独立性指进程能独立运行、获取资源和接受调度，其根本标志是拥有独立的PCB。A涉及共享，非独立；C、D为并发与调度结果。", "answer": "B || 解析：独立性指进程能独立运行、获取资源和接受调度，其根本标志是拥有独立的PCB。A涉及共享，非独立；C、D为并发与调度结果。"}
{"id": "Q77", "type": "简答题", "question": "请结合进程的生命周期与PCB的作用，说明为何系统必须通过PCB来感知进程的存在。", "answer": "进程是动态实体，其状态随运行变化。PCB作为进程的唯一标识，记录其状态、资源、CPU上下文等信息。系统通过PCB实现调度、控制、同步与资源回收。无PCB则无法感知进程，无法管理其生命周期，故必须依赖PCB感知进程存在。"}
{"id": "Q78", "type": "简答题", "question": "若一个进程在运行过程中请求I/O操作，其状态将如何变化？请说明该过程中PCB所承担的关键作用。", "answer": "进程请求I/O后，由运行态转为阻塞态。PCB保存其CPU上下文（寄存器值），并将其插入阻塞队列。当I/O完成，中断处理程序将PCB状态改为就绪态，恢复执行。PCB是状态转换与资源管理的核心依据。"}
{"id": "Q79", "type": "单项选择题", "question": "关于进程的创建态，以下说法正确的是： A. 创建态进程已分配全部资源； B. 创建态进程已拥有PCB； C. 创建态进程可被调度执行； D. 创建态进程因资源不足而无法进入就绪态", "answer_label": "D", "answer_explain": "创建态是创建过程中的中间状态，若资源不足（如内存），无法完成创建，进程停留在创建态。B正确但不完整，A、C错误，创建态未完成资源分配，不可调度。", "answer": "D || 解析：创建态是创建过程中的中间状态，若资源不足（如内存），无法完成创建，进程停留在创建态。B正确但不完整，A、C错误，创建态未完成资源分配，不可调度。"}
{"id": "Q80", "type": "简答题", "question": "请解释为何‘进程是资源分配和调度的独立单位’中的‘资源’应理解为‘时间片’而非物理资源。", "answer": "进程是调度单位，调度本质是分配CPU时间片。资源分配指时间片的分配，而非内存、设备等物理资源。进程作为独立单位，其调度与资源分配均以时间片为单位进行，故‘资源’应理解为时间片，体现进程的动态性与调度独立性。"}
{"id": "Q81", "type": "单项选择题", "question": "关于进程的动态性特征，以下说法正确的是： A. 进程的生命周期仅包括创建、运行和终止三个阶段；； B. 进程的动态性体现在其状态可随系统环境变化而转换；； C. 进程的动态性意味着程序代码在内存中不断改变；； D. 进程的动态性是指其PCB在内存中不断移动位置；", "answer_label": "B", "answer_explain": "动态性指进程具有创建、活动、暂停、终止等过程，状态可随环境变化而转换。A忽略了创建态与终止态的中间状态；C错误，程序段是静态的；D错误，PCB位置固定，不移动。", "answer": "B || 解析：动态性指进程具有创建、活动、暂停、终止等过程，状态可随环境变化而转换。A忽略了创建态与终止态的中间状态；C错误，程序段是静态的；D错误，PCB位置固定，不移动。"}
{"id": "Q82", "type": "单项选择题", "question": "在多道程序系统中，进程能并发执行的根本原因是： A. 程序具有独立性；； B. 系统为每个程序分配了独立的CPU；； C. 操作系统通过PCB对进程进行管理与调度；； D. 程序段和数据段可被多个进程共享；", "answer_label": "C", "answer_explain": "PCB是进程存在的唯一标志，系统通过PCB实现资源分配、调度和状态控制，是并发执行的基础。A错，程序无独立性；B错，单CPU无法分配多个CPU；D是共享特性，非并发根本原因。", "answer": "C || 解析：PCB是进程存在的唯一标志，系统通过PCB实现资源分配、调度和状态控制，是并发执行的基础。A错，程序无独立性；B错，单CPU无法分配多个CPU；D是共享特性，非并发根本原因。"}
{"id": "Q83", "type": "单项选择题", "question": "当一个进程因请求I/O设备而进入阻塞态时，以下哪项操作不会发生？ A. 保存当前CPU上下文到PCB；； B. 将进程状态由运行态改为阻塞态；； C. 将该进程插入阻塞队列；； D. 释放其占用的内存空间；", "answer_label": "D", "answer_explain": "阻塞时仅保存现场、修改状态、入队，不释放内存。内存空间在进程终止时才回收，故D错误。A、B、C均为阻塞过程的标准操作。", "answer": "D || 解析：阻塞时仅保存现场、修改状态、入队，不释放内存。内存空间在进程终止时才回收，故D错误。A、B、C均为阻塞过程的标准操作。"}
{"id": "Q84", "type": "单项选择题", "question": "关于PCB的作用，下列说法错误的是： A. PCB是进程存在的唯一标志；； B. PCB中包含进程的优先级信息；； C. PCB中保存了程序段和数据段的地址；； D. PCB在进程运行期间可被动态删除；", "answer_label": "D", "answer_explain": "PCB在进程创建时建立，结束时才删除，运行期间必须常驻内存。A、B、C均正确。D错误，PCB不可在运行中删除，否则系统无法管理该进程。", "answer": "D || 解析：PCB在进程创建时建立，结束时才删除，运行期间必须常驻内存。A、B、C均正确。D错误，PCB不可在运行中删除，否则系统无法管理该进程。"}
{"id": "Q85", "type": "单项选择题", "question": "在可剥夺调度系统中，一个高优先级进程就绪后，正在运行的低优先级进程被剥夺CPU，该低优先级进程的状态将变为： A. 阻塞态；； B. 运行态；； C. 就绪态；； D. 终止态；", "answer_label": "C", "answer_explain": "高优先级进程就绪时，调度程序将当前运行进程剥夺CPU，其状态由运行态转为就绪态，等待下次调度。阻塞态需等待事件，终止态为结束状态，故选C。", "answer": "C || 解析：高优先级进程就绪时，调度程序将当前运行进程剥夺CPU，其状态由运行态转为就绪态，等待下次调度。阻塞态需等待事件，终止态为结束状态，故选C。"}
{"id": "Q86", "type": "单项选择题", "question": "进程从阻塞态转为就绪态的必要条件是： A. CPU空闲；； B. 该进程的优先级高于其他就绪进程；； C. 等待的事件已发生；； D. 系统已为其分配内存空间；", "answer_label": "C", "answer_explain": "阻塞态转就绪态的直接原因是等待事件完成，如I/O完成或信号量释放。A、B、D虽可能影响调度，但非必要条件。C是唯一直接触发转换的条件。", "answer": "C || 解析：阻塞态转就绪态的直接原因是等待事件完成，如I/O完成或信号量释放。A、B、D虽可能影响调度，但非必要条件。C是唯一直接触发转换的条件。"}
{"id": "Q87", "type": "单项选择题", "question": "下列关于进程实体的描述，正确的是： A. 进程实体由程序段、数据段和PCB组成；； B. 程序段和数据段必须在内存中独立存在；； C. PCB是进程实体的运行过程；； D. 进程实体在创建后立即进入运行态；", "answer_label": "A", "answer_explain": "进程实体=程序段+数据段+PCB，A正确。B错误，程序段可共享；C错误，PCB是数据结构，非运行过程；D错误，创建后进入创建态，再转就绪态。", "answer": "A || 解析：进程实体=程序段+数据段+PCB，A正确。B错误，程序段可共享；C错误，PCB是数据结构，非运行过程；D错误，创建后进入创建态，再转就绪态。"}
{"id": "Q88", "type": "简答题", "question": "请结合进程的动态性、状态转换与PCB的作用，说明一个进程从创建到终止的完整生命周期中，系统如何通过PCB实现对进程的控制与管理。", "answer": "进程创建时，系统分配PCB并填写标识符、状态等信息，进入创建态；资源满足后转入就绪态，PCB记录优先级与内存地址；调度时由就绪转运行，PCB保存CPU上下文；运行中请求I/O则转阻塞态，现场保存于PCB；事件完成后由阻塞转就绪，PCB更新状态；终止时系统回收PCB，释放资源。全程依赖PCB实现控制与管理。"}
{"id": "Q89", "type": "简答题", "question": "为何说进程是资源分配和调度的独立单位？请结合PCB中的资源分配清单与CPU相关信息，说明其在调度过程中的作用。", "answer": "进程是资源分配和调度的独立单位，因系统以进程为单位分配CPU时间片、内存、设备等资源。PCB中的资源分配清单记录内存地址、打开文件、设备使用情况；CPU相关信息（上下文）用于保存和恢复执行现场。调度时，系统根据PCB中的优先级、状态和资源信息决定是否分配CPU，实现资源的独立分配与调度。"}
{"id": "Q90", "type": "简答题", "question": "请分析在多道程序系统中，进程的异步性如何导致执行结果不可再现，并说明操作系统如何通过PCB和同步机制加以解决。", "answer": "异步性使进程以不可预知速度推进，导致执行顺序不确定，结果不可再现。PCB保存各进程状态与上下文，确保中断或切换后能恢复执行。操作系统通过同步机制（如信号量、互斥锁）协调进程间访问共享资源，避免竞争，保证执行结果的可再现性。PCB是实现同步与恢复的关键支撑。"}
{"id": "Q91", "type": "单项选择题", "question": "关于进程与程序的根本区别，以下描述最准确的是： A. 程序是静态的，进程是动态的；； B. 程序是可执行的代码，进程是运行中的程序；； C. 程序包含数据段，进程不包含；； D. 程序可被多个进程共享，进程不能被共享；", "answer_label": "A", "answer_explain": "程序是静态的代码集合，而进程是程序的一次执行实例，具有生命周期和状态变化，体现动态性，是根本区别。B虽正确但不完整，C、D错误。", "answer": "A || 解析：程序是静态的代码集合，而进程是程序的一次执行实例，具有生命周期和状态变化，体现动态性，是根本区别。B虽正确但不完整，C、D错误。"}
{"id": "Q92", "type": "单项选择题", "question": "在多道程序系统中，进程的异步性主要源于： A. CPU速度过快；； B. 进程间相互制约及运行环境变化；； C. 程序段过大；； D. PCB存储空间不足；", "answer_label": "B", "answer_explain": "异步性由进程间制约和环境变化导致，使进程以不可预知速度推进，引发不可再现性，需同步机制应对。", "answer": "B || 解析：异步性由进程间制约和环境变化导致，使进程以不可预知速度推进，引发不可再现性，需同步机制应对。"}
{"id": "Q93", "type": "单项选择题", "question": "下列关于PCB的说法中，错误的是： A. PCB是进程存在的唯一标志；； B. PCB中包含CPU上下文信息；； C. PCB在进程创建时分配，终止时释放；； D. PCB中不包含程序段和数据段的地址信息；", "answer_label": "D", "answer_explain": "PCB中包含程序和数据的内存始址，用于定位执行代码和数据，D错误。其余均正确。", "answer": "D || 解析：PCB中包含程序和数据的内存始址，用于定位执行代码和数据，D错误。其余均正确。"}
{"id": "Q94", "type": "单项选择题", "question": "当一个进程因请求I/O设备而无法继续执行时，它将从运行态转为阻塞态，这一转换的直接原因是： A. CPU资源不足；； B. 进程优先级降低；； C. 等待非CPU资源；； D. 时间片用完；", "answer_label": "C", "answer_explain": "阻塞态是因等待I/O等非CPU资源或事件发生，与CPU无关。A、D导致运行→就绪，B不直接引发阻塞。", "answer": "C || 解析：阻塞态是因等待I/O等非CPU资源或事件发生，与CPU无关。A、D导致运行→就绪，B不直接引发阻塞。"}
{"id": "Q95", "type": "单项选择题", "question": "在可剥夺型操作系统中，一个高优先级进程就绪后，正在运行的低优先级进程被剥夺CPU，该进程的状态将变为： A. 就绪态；； B. 阻塞态；； C. 终止态；； D. 创建态；", "answer_label": "A", "answer_explain": "在可剥夺系统中，高优先级就绪进程抢占CPU，原运行进程被剥夺，转为就绪态，等待再次调度。", "answer": "A || 解析：在可剥夺系统中，高优先级就绪进程抢占CPU，原运行进程被剥夺，转为就绪态，等待再次调度。"}
{"id": "Q96", "type": "单项选择题", "question": "系统通过PCB实现对进程的控制和管理，以下哪项不是PCB中包含的信息？ A. 进程标识符；； B. 进程优先级；； C. 程序段的执行代码；； D. CPU寄存器状态；", "answer_label": "C", "answer_explain": "PCB不存储程序代码，仅保存其在内存中的地址。程序段代码本身存于内存，PCB仅记录位置。", "answer": "C || 解析：PCB不存储程序代码，仅保存其在内存中的地址。程序段代码本身存于内存，PCB仅记录位置。"}
{"id": "Q97", "type": "简答题", "question": "请结合进程的动态性、独立性与资源分配机制，说明为何进程是资源分配和调度的独立单位。", "answer": "进程具有动态生命周期，可独立创建与终止；其PCB记录资源分配清单（如内存、设备），并作为调度依据。系统以进程为单位分配CPU时间片与资源，确保其独立运行与调度，体现其作为资源分配与调度独立单位的本质。"}
{"id": "Q98", "type": "简答题", "question": "为何进程从阻塞态转为就绪态是被动行为？请结合进程状态转换机制说明。", "answer": "阻塞态进程需等待外部事件（如I/O完成）才能恢复，其自身无法主动唤醒。当事件发生后，中断处理程序将该进程状态改为就绪态，属于被动响应，依赖其他进程或系统事件，故为被动行为。"}
{"id": "Q99", "type": "简答题", "question": "若系统中多个进程共享同一程序段，为何仍需为每个进程创建独立的PCB？请从进程控制与资源管理角度分析。", "answer": "虽然程序段可共享，但每个进程有独立的数据段、资源分配清单和运行状态。PCB用于记录各进程的独立信息（如内存地址、优先级、CPU上下文），确保系统能独立调度、控制和管理每个进程，实现并发与资源隔离。"}
{"id": "Q100", "type": "简答题", "question": "在进程创建过程中，若内存资源不足导致无法分配，进程将处于何种状态？该状态与创建态有何区别？", "answer": "内存不足时，进程处于创建态但未完成。创建态是创建过程的初始阶段，若资源满足则转入就绪态；若资源不足，创建过程停滞，仍属创建态，但未完成资源分配，区别在于资源是否就绪。"}
{"id": "Q101", "type": "单项选择题", "question": "关于进程与程序的根本区别，以下描述最准确的是： A. 程序是静态的，进程是动态的； B. 程序是可执行文件，进程是运行中的程序； C. 程序包含数据段，进程不包含； D. 程序可并发执行，进程不能并发执行", "answer_label": "A", "answer_explain": "程序是静态的代码集合，而进程是程序的一次执行实例，具有生命周期和运行状态，体现动态性。B虽正确但不本质，C错误（进程包含数据段），D错误（进程才能并发执行）。", "answer": "A || 解析：程序是静态的代码集合，而进程是程序的一次执行实例，具有生命周期和运行状态，体现动态性。B虽正确但不本质，C错误（进程包含数据段），D错误（进程才能并发执行）。"}
{"id": "Q102", "type": "单项选择题", "question": "在多道程序系统中，进程的异步性主要源于： A. CPU执行速度过快； B. 进程间相互制约及运行环境变化； C. 程序代码长度不同； D. 内存分配策略差异", "answer_label": "B", "answer_explain": "异步性指进程以不可预知的速度推进，源于进程间资源竞争、同步依赖及系统环境变化，导致执行结果不可再现，需同步机制保障。", "answer": "B || 解析：异步性指进程以不可预知的速度推进，源于进程间资源竞争、同步依赖及系统环境变化，导致执行结果不可再现，需同步机制保障。"}
{"id": "Q103", "type": "单项选择题", "question": "下列关于进程控制块（PCB）的说法中，错误的是： A. PCB是进程存在的唯一标志； B. PCB中包含进程优先级信息； C. PCB在进程终止后立即被销毁； D. PCB中保存CPU上下文信息", "answer_label": "C", "answer_explain": "PCB在进程终止后需先置为终止态，再由系统回收资源并删除，非立即销毁。其他选项均符合教材描述。", "answer": "C || 解析：PCB在进程终止后需先置为终止态，再由系统回收资源并删除，非立即销毁。其他选项均符合教材描述。"}
{"id": "Q104", "type": "单项选择题", "question": "当一个进程因请求I/O设备而暂停运行时，其状态应由运行态转为： A. 就绪态； B. 阻塞态； C. 创建态； D. 终止态", "answer_label": "B", "answer_explain": "进程请求I/O或等待事件时，需等待资源或事件完成，此时不能运行，故转入阻塞态。就绪态仅缺CPU，不涉及I/O等待。", "answer": "B || 解析：进程请求I/O或等待事件时，需等待资源或事件完成，此时不能运行，故转入阻塞态。就绪态仅缺CPU，不涉及I/O等待。"}
{"id": "Q105", "type": "单项选择题", "question": "在可剥夺型调度系统中，一个高优先级进程就绪时，当前运行的低优先级进程将： A. 继续运行直至时间片用完； B. 立即被中断并转为就绪态； C. 被直接终止； D. 被转入阻塞态", "answer_label": "B", "answer_explain": "在可剥夺系统中，高优先级进程就绪时，调度程序会抢占当前运行进程，将其转为就绪态，以保证高优先级进程优先执行。", "answer": "B || 解析：在可剥夺系统中，高优先级进程就绪时，调度程序会抢占当前运行进程，将其转为就绪态，以保证高优先级进程优先执行。"}
{"id": "Q106", "type": "单项选择题", "question": "下列哪项不是进程实体（进程映像）的组成部分？ A. 程序段； B. 数据段； C. PCB； D. 系统调用接口", "answer_label": "D", "answer_explain": "进程实体由程序段、数据段和PCB三部分构成。系统调用接口是操作系统提供的服务接口，不属于进程实体组成部分。", "answer": "D || 解析：进程实体由程序段、数据段和PCB三部分构成。系统调用接口是操作系统提供的服务接口，不属于进程实体组成部分。"}
{"id": "Q107", "type": "单项选择题", "question": "在进程创建过程中，若内存资源不足，进程将处于： A. 就绪态； B. 运行态； C. 创建态； D. 阻塞态", "answer_label": "C", "answer_explain": "创建态指进程正在被创建但资源未完全满足（如内存不足），尚未转入就绪态。阻塞态是运行中等待事件，与创建过程无关。", "answer": "C || 解析：创建态指进程正在被创建但资源未完全满足（如内存不足），尚未转入就绪态。阻塞态是运行中等待事件，与创建过程无关。"}
{"id": "Q108", "type": "单项选择题", "question": "系统通过PCB对进程进行控制和管理，其根本原因是： A. PCB存储在磁盘中； B. PCB是进程的唯一标识； C. PCB包含进程的全部代码； D. PCB可被多个进程共享", "answer_label": "B", "answer_explain": "PCB是进程存在的唯一标志，系统通过PCB获取进程状态、资源、调度信息，实现对进程的控制与管理，其他选项均错误。", "answer": "B || 解析：PCB是进程存在的唯一标志，系统通过PCB获取进程状态、资源、调度信息，实现对进程的控制与管理，其他选项均错误。"}
{"id": "Q109", "type": "简答题", "question": "请结合进程的动态性、独立性与异步性，说明为何操作系统必须引入进程这一概念？", "answer": "多道程序并发执行导致程序失去封闭性，产生间断性与不可再现性。为实现并发与共享，必须引入进程。进程具有动态性（生命周期）、独立性（资源分配单位）和异步性（不可预知推进），使系统能有效控制和管理并发执行的程序，保障资源合理分配与调度，是实现操作系统并发性与共享性的基础。"}
{"id": "Q110", "type": "简答题", "question": "当一个进程从阻塞态转为就绪态时，为何必须由中断处理程序完成状态转换？请结合PCB和CPU上下文说明原因。", "answer": "阻塞态进程等待的事件（如I/O完成）由中断触发。中断处理程序检测到事件完成，将对应进程状态由阻塞转为就绪，并更新PCB中的状态信息。由于中断发生时CPU上下文已保存在PCB中，处理程序可安全访问PCB，无需进程主动参与，确保转换的原子性与系统一致性。"}
{"id": "Q111", "type": "单项选择题", "question": "关于进程与程序的根本区别，以下描述最准确的是： A. 程序是静态的，进程是动态的； B. 程序可被多个用户共享，进程不能； C. 程序包含数据段，进程不包含； D. 程序运行时才创建进程，但进程结束程序就消失", "answer_label": "A", "answer_explain": "程序是静态的代码集合，而进程是程序的一次执行实例，具有生命周期，体现动态性。B错，进程可共享程序；C错，进程包含数据段；D错，程序可独立存在。", "answer": "A || 解析：程序是静态的代码集合，而进程是程序的一次执行实例，具有生命周期，体现动态性。B错，进程可共享程序；C错，进程包含数据段；D错，程序可独立存在。"}
{"id": "Q112", "type": "单项选择题", "question": "在多道程序系统中，进程的异步性主要导致： A. 程序执行速度加快； B. 进程间资源竞争加剧； C. 执行结果不可再现； D. CPU利用率下降", "answer_label": "C", "answer_explain": "异步性使进程按不可预知速度推进，导致执行顺序不确定，结果不可再现。A、B、D虽相关但非异步性直接后果。", "answer": "C || 解析：异步性使进程按不可预知速度推进，导致执行顺序不确定，结果不可再现。A、B、D虽相关但非异步性直接后果。"}
{"id": "Q113", "type": "单项选择题", "question": "下列关于PCB的说法中，错误的是： A. PCB是进程存在的唯一标志； B. PCB中保存CPU寄存器值用于现场保护； C. PCB在进程运行期间可被删除； D. PCB包含进程状态和优先级信息", "answer_label": "C", "answer_explain": "PCB在进程创建时建立，运行中常驻内存，仅在进程终止时才被删除。运行期间删除将导致系统失控。", "answer": "C || 解析：PCB在进程创建时建立，运行中常驻内存，仅在进程终止时才被删除。运行期间删除将导致系统失控。"}
{"id": "Q114", "type": "单项选择题", "question": "当一个进程请求I/O操作并进入阻塞态时，以下哪项不会发生？ A. 保存CPU上下文到PCB； B. 将PCB从就绪队列移出； C. 将PCB插入阻塞队列； D. 释放CPU资源", "answer_label": "B", "answer_explain": "进程在运行态请求I/O后变为阻塞态，此时应保存现场（A）、释放CPU（D）、插入阻塞队列（C），但不会从就绪队列移出（B），因它本不在就绪队列。", "answer": "B || 解析：进程在运行态请求I/O后变为阻塞态，此时应保存现场（A）、释放CPU（D）、插入阻塞队列（C），但不会从就绪队列移出（B），因它本不在就绪队列。"}
{"id": "Q115", "type": "单项选择题", "question": "在可剥夺调度系统中，高优先级进程就绪时，正在运行的低优先级进程被剥夺CPU，该转换属于： A. 就绪态→运行态； B. 运行态→就绪态； C. 运行态→阻塞态； D. 阻塞态→就绪态", "answer_label": "B", "answer_explain": "高优先级进程就绪时，调度程序剥夺当前运行进程的CPU，使其返回就绪队列，故为运行态→就绪态。", "answer": "B || 解析：高优先级进程就绪时，调度程序剥夺当前运行进程的CPU，使其返回就绪队列，故为运行态→就绪态。"}
{"id": "Q116", "type": "单项选择题", "question": "进程由程序段、数据段和PCB三部分组成，以下哪项最能体现‘进程是资源分配和调度的独立单位’？ A. 程序段可被多个进程共享； B. PCB中包含进程优先级； C. 每个进程拥有独立的PCB； D. 数据段存储进程运行结果", "answer_label": "C", "answer_explain": "独立性依赖于唯一PCB，PCB是资源分配和调度的依据。A体现共享，B体现调度策略，D是数据属性，C最直接体现独立性。", "answer": "C || 解析：独立性依赖于唯一PCB，PCB是资源分配和调度的依据。A体现共享，B体现调度策略，D是数据属性，C最直接体现独立性。"}
{"id": "Q117", "type": "简答题", "question": "请结合进程状态转换与PCB作用，说明为何‘系统仅通过PCB感知进程存在’？要求至少整合3个知识点。", "answer": "系统通过PCB掌握进程状态（如运行/就绪/阻塞）、调度优先级、资源分配情况及CPU上下文。进程切换时，系统保存现场于PCB；调度时，从PCB读取信息恢复执行。无PCB则无法识别进程，故系统仅通过PCB感知进程存在。"}
{"id": "Q118", "type": "简答题", "question": "若某进程在运行中因请求I/O而阻塞，其PCB将经历哪些关键操作？请结合状态转换与PCB信息说明。", "answer": "进程从运行态→阻塞态时，系统保存其CPU上下文至PCB；将PCB从运行队列移出，插入对应阻塞队列；更新PCB中状态为阻塞，并记录阻塞原因。后续I/O完成时，中断处理程序将PCB从阻塞队列移至就绪队列。"}
{"id": "Q119", "type": "简答题", "question": "为何说‘进程是动态的、过程性的概念’？请从生命周期与资源分配角度作答。", "answer": "进程具有创建、就绪、运行、阻塞、终止等生命周期，状态不断变化，体现动态性。其作为资源分配和调度单位，资源（如CPU时间片）按过程分配，非静态分配，故为过程性概念。"}
{"id": "Q120", "type": "简答题", "question": "在链接方式组织PCB时，为何要按阻塞原因设置多个阻塞队列？请结合进程异步性与资源管理说明。", "answer": "因进程异步性，阻塞原因多样（如I/O、资源等待）。按原因分队列可提高调度效率，使中断处理程序能快速定位并唤醒特定阻塞进程，避免遍历所有阻塞进程，提升系统响应性能。"}
{"id": "Q121", "type": "单项选择题", "question": "关于进程与程序的根本区别，下列说法正确的是： A. 程序是动态的，进程是静态的； B. 程序是进程的运行实例，进程是程序的静态形式； C. 进程是程序的一次执行过程，具有生命周期； D. 进程和程序在内存中均以相同方式存储，仅名称不同", "answer_label": "C", "answer_explain": "程序是静态的代码集合，而进程是程序在内存中的一次动态执行过程，具有创建、运行、终止等生命周期，体现动态性特征。A、B、D均混淆了二者本质。", "answer": "C || 解析：程序是静态的代码集合，而进程是程序在内存中的一次动态执行过程，具有创建、运行、终止等生命周期，体现动态性特征。A、B、D均混淆了二者本质。"}
{"id": "Q122", "type": "单项选择题", "question": "在多道程序系统中，引入进程的主要目的是： A. 提高程序执行速度； B. 实现程序的并发执行与资源的共享； C. 简化程序编写； D. 降低内存使用量", "answer_label": "B", "answer_explain": "进程的引入正是为了解决多道程序并发执行带来的封闭性、间断性问题，实现操作系统的并发性和共享性，这是其核心目的。", "answer": "B || 解析：进程的引入正是为了解决多道程序并发执行带来的封闭性、间断性问题，实现操作系统的并发性和共享性，这是其核心目的。"}
{"id": "Q123", "type": "单项选择题", "question": "下列关于进程控制块（PCB）的描述，错误的是： A. PCB是进程存在的唯一标志； B. PCB中包含进程的优先级和状态信息； C. PCB仅在进程运行时才存在于内存中； D. 系统通过PCB对进程进行控制和管理", "answer_label": "C", "answer_explain": "PCB在进程创建时即被创建并常驻内存，直至进程终止才被删除，无论进程处于就绪、运行或阻塞状态，PCB始终存在。", "answer": "C || 解析：PCB在进程创建时即被创建并常驻内存，直至进程终止才被删除，无论进程处于就绪、运行或阻塞状态，PCB始终存在。"}
{"id": "Q124", "type": "单项选择题", "question": "当一个进程从运行态转为阻塞态时，以下哪项操作是必须的？ A. 保存该进程的CPU寄存器值到PCB； B. 将其从就绪队列移除； C. 释放其所有资源； D. 修改其进程标识符", "answer_label": "A", "answer_explain": "进程从运行态转为阻塞态时，需保存CPU上下文（寄存器值）至PCB，以便后续恢复执行时能从断点继续，这是进程切换的基本要求。", "answer": "A || 解析：进程从运行态转为阻塞态时，需保存CPU上下文（寄存器值）至PCB，以便后续恢复执行时能从断点继续，这是进程切换的基本要求。"}
{"id": "Q125", "type": "单项选择题", "question": "在可剥夺型调度系统中，一个运行中的进程被更高优先级进程抢占，该进程将进入： A. 就绪态； B. 阻塞态； C. 终止态； D. 创建态", "answer_label": "A", "answer_explain": "在可剥夺系统中，高优先级进程就绪时，当前运行进程被剥夺CPU，但其资源未被释放，仅缺少CPU，故转入就绪态等待调度。", "answer": "A || 解析：在可剥夺系统中，高优先级进程就绪时，当前运行进程被剥夺CPU，但其资源未被释放，仅缺少CPU，故转入就绪态等待调度。"}
{"id": "Q126", "type": "单项选择题", "question": "关于进程的独立性特征，下列说法正确的是： A. 进程可以不依赖PCB独立运行； B. 未建立PCB的程序也能作为独立单位参与运行； C. 进程是能独立获得资源和接受调度的基本单位； D. 独立性意味着进程之间互不干扰，完全隔离", "answer_label": "C", "answer_explain": "独立性指进程能独立获得资源和接受调度，而PCB是实现这一特性的基础，未建PCB的程序无法成为独立单位，故A、B错；D中“完全隔离”不准确。", "answer": "C || 解析：独立性指进程能独立获得资源和接受调度，而PCB是实现这一特性的基础，未建PCB的程序无法成为独立单位，故A、B错；D中“完全隔离”不准确。"}
{"id": "Q127", "type": "简答题", "question": "请结合进程的动态性、并发性与PCB的作用，说明为何操作系统必须通过PCB来管理进程。", "answer": "进程具有动态性（生命周期变化）和并发性（多进程共存运行），系统需实时掌握各进程状态。PCB作为进程唯一标识，存储其状态、优先级、资源分配及CPU上下文，使系统能调度、切换、恢复进程，实现资源分配与调度，故必须通过PCB管理进程。"}
{"id": "Q128", "type": "简答题", "question": "一个进程从阻塞态转为就绪态的过程，为何是‘被动行为’？请结合状态转换机制与PCB信息说明。", "answer": "进程阻塞后无法自主恢复，必须等待外部事件（如I/O完成）触发中断。中断处理程序检查PCB中阻塞原因，确认事件已发生后，将状态由阻塞改为就绪，并插入就绪队列。此过程由系统主动完成，进程本身无能为力，故为被动行为。"}
{"id": "Q129", "type": "简答题", "question": "若某进程在运行中请求资源失败（如内存不足），其状态应如何变化？请结合创建态与资源分配机制说明。", "answer": "若运行中进程请求资源失败（如内存不足），系统不会直接终止，而是将其状态转为创建态（或维持创建态），等待资源满足后重新尝试创建。因创建态包含资源申请与分配阶段，此时进程尚未完全建立，需系统协调资源后才能转入就绪态。"}
{"id": "Q130", "type": "简答题", "question": "为何说‘进程是资源分配和调度的独立单位’？请从时间片分配与PCB角度解释。", "answer": "进程是资源分配和调度的独立单位，其核心是‘时间片’的分配。系统通过PCB中的优先级、状态和CPU上下文信息，决定何时分配时间片、调度哪个进程。PCB保存CPU寄存器值，确保时间片切换后能恢复执行，体现了进程作为调度与资源分配单位的完整性。"}
{"id": "Q131", "type": "单项选择题", "question": "下列关于进程与程序关系的描述中，最准确的是： A. 程序是进程的静态体现，进程是程序的动态执行； B. 进程是程序的副本，程序是进程的实例； C. 程序和进程是同一概念的不同表述； D. 进程是程序在内存中的存储形式，程序是进程的运行结果", "answer_label": "A", "answer_explain": "程序是静态的代码集合，进程是程序的一次执行实例，具有动态性。A项准确表达了二者关系。B、C、D均存在概念混淆。", "answer": "A || 解析：程序是静态的代码集合，进程是程序的一次执行实例，具有动态性。A项准确表达了二者关系。B、C、D均存在概念混淆。"}
{"id": "Q132", "type": "单项选择题", "question": "在多道程序环境中，引入进程的主要目的是实现： A. 程序的顺序执行； B. 程序的并发执行与资源共享； C. 程序的独立编译； D. 程序的模块化设计", "answer_label": "B", "answer_explain": "多道程序环境导致程序失去封闭性，引入进程以实现并发性和共享性，这是操作系统最基本的两个特性。", "answer": "B || 解析：多道程序环境导致程序失去封闭性，引入进程以实现并发性和共享性，这是操作系统最基本的两个特性。"}
{"id": "Q133", "type": "单项选择题", "question": "关于进程控制块（PCB）的说法，错误的是： A. PCB是进程存在的唯一标志； B. PCB中包含进程的优先级信息； C. PCB仅在进程运行时才存在于内存中； D. PCB用于保存CPU上下文信息", "answer_label": "C", "answer_explain": "PCB在进程创建时就建立并常驻内存，直到进程终止才被删除，因此C错误。", "answer": "C || 解析：PCB在进程创建时就建立并常驻内存，直到进程终止才被删除，因此C错误。"}
{"id": "Q134", "type": "单项选择题", "question": "当一个进程从运行态转为阻塞态时，以下哪项操作不会发生？ A. 保存当前CPU寄存器值到PCB； B. 将进程状态更新为阻塞态； C. 将进程插入就绪队列； D. 释放该进程所占用的资源", "answer_label": "C", "answer_explain": "运行态→阻塞态时，进程应进入阻塞队列，而非就绪队列。C项操作错误。", "answer": "C || 解析：运行态→阻塞态时，进程应进入阻塞队列，而非就绪队列。C项操作错误。"}
{"id": "Q135", "type": "单项选择题", "question": "在可剥夺型调度系统中，一个运行中的进程被剥夺CPU资源的可能原因是： A. 该进程主动请求I/O操作； B. 该进程的时间片用完； C. 有更高优先级的进程变为就绪态； D. 该进程等待某个信号量", "answer_label": "C", "answer_explain": "在可剥夺系统中，高优先级就绪进程可抢占当前运行进程，导致其转为就绪态。B和D导致阻塞，A是运行态→阻塞态。", "answer": "C || 解析：在可剥夺系统中，高优先级就绪进程可抢占当前运行进程，导致其转为就绪态。B和D导致阻塞，A是运行态→阻塞态。"}
{"id": "Q136", "type": "单项选择题", "question": "下列关于进程状态转换的描述中，正确的是： A. 阻塞态→就绪态是主动行为； B. 运行态→就绪态只能由时间片用完引起； C. 就绪态→运行态由调度程序完成； D. 创建态→就绪态无需分配资源", "answer_label": "C", "answer_explain": "就绪态→运行态由调度程序根据优先级和时间片分配CPU，C正确。A为被动，B排除抢占，D创建需资源。", "answer": "C || 解析：就绪态→运行态由调度程序根据优先级和时间片分配CPU，C正确。A为被动，B排除抢占，D创建需资源。"}
{"id": "Q137", "type": "简答题", "question": "请结合进程的动态性、并发性与PCB的作用，说明为何操作系统必须通过PCB来控制和管理进程。", "answer": "进程是动态的执行过程，具有生命周期，需系统持续监控。并发环境下多个进程共享资源，必须通过PCB统一记录其状态、优先级、资源分配及CPU上下文，实现调度、同步与资源回收。PCB是进程存在的唯一标志，系统唯有通过PCB才能感知进程并实施控制，确保并发执行的有序性与安全性。"}
{"id": "Q138", "type": "简答题", "question": "若一个进程在运行过程中请求I/O操作，其状态将如何变化？请说明该过程中PCB所承担的关键作用。", "answer": "进程请求I/O后，从运行态转为阻塞态。此时，系统将CPU寄存器值保存至PCB，更新状态为阻塞，释放CPU。PCB记录断点信息，待I/O完成中断处理后，由中断程序将进程状态改为就绪态并插入就绪队列，实现恢复执行。PCB是状态切换与现场保存的核心载体。"}
{"id": "Q139", "type": "简答题", "question": "为什么说‘进程是资源分配和调度的独立单位’？请从资源类型和时间片角度进行解释。", "answer": "进程是资源分配的独立单位，因其拥有独立的内存空间、打开文件列表和设备资源。同时，它是调度的独立单位，即时间片的分配以进程为单位。CPU资源实质是时间片，进程作为时间片分配的基本单元，确保并发执行中每个进程能获得独立的执行时间，体现了其作为调度与资源分配的最小独立单位的特性。"}
{"id": "Q140", "type": "简答题", "question": "在创建一个新进程时，系统需完成哪些关键步骤？请结合PCB创建、资源分配与状态转换说明。", "answer": "创建进程需：1）申请空白PCB并填写标识符、用户信息等；2）分配内存、打开文件等必要资源；3）将进程状态设为就绪态，插入就绪队列。若资源不足，则维持在创建态。PCB是进程存在的唯一标志，其内容决定调度与管理行为，整个过程体现了进程作为独立运行单位的建立机制。"}
{"id": "Q141", "type": "单项选择题", "question": "关于进程与程序的根本区别，下列说法最准确的是： A. 程序是静态的，进程是动态的； B. 程序可被多个进程共享，进程不能共享程序； C. 程序包含数据段，进程不包含； D. 程序运行时才形成进程，但进程结束程序就消失", "answer_label": "A", "answer_explain": "程序是静态的代码集合，进程是程序的一次执行实例，具有生命周期和状态变化，体现动态性。B错，进程可共享程序；C错，进程包含数据段；D错，程序文件仍存在。", "answer": "A || 解析：程序是静态的代码集合，进程是程序的一次执行实例，具有生命周期和状态变化，体现动态性。B错，进程可共享程序；C错，进程包含数据段；D错，程序文件仍存在。"}
{"id": "Q142", "type": "单项选择题", "question": "在多道程序系统中，进程的异步性主要导致的问题是： A. 进程无法并发执行； B. 进程状态转换不可预测； C. 执行结果可能不可再现； D. 进程无法获得CPU资源", "answer_label": "C", "answer_explain": "异步性导致进程推进速度不可预知，可能因资源竞争或事件等待造成执行顺序变化，使结果不一致。B虽相关但非核心问题，A、D错误。", "answer": "C || 解析：异步性导致进程推进速度不可预知，可能因资源竞争或事件等待造成执行顺序变化，使结果不一致。B虽相关但非核心问题，A、D错误。"}
{"id": "Q143", "type": "单项选择题", "question": "下列关于PCB的说法中，错误的是： A. PCB是进程存在的唯一标志； B. PCB中包含CPU上下文信息； C. PCB在进程运行期间可被删除； D. PCB用于进程调度和资源管理", "answer_label": "C", "answer_explain": "PCB在进程创建后常驻内存，直到进程终止才被删除。运行期间不可删除，否则系统无法管理进程状态。", "answer": "C || 解析：PCB在进程创建后常驻内存，直到进程终止才被删除。运行期间不可删除，否则系统无法管理进程状态。"}
{"id": "Q144", "type": "单项选择题", "question": "当一个进程从运行态转为阻塞态时，操作系统必须保存其： A. 程序计数器和寄存器内容； B. 程序段和数据段地址； C. 进程优先级和用户标识符； D. 所打开文件列表和内存分配信息", "answer_label": "A", "answer_explain": "进程切换时需保存CPU上下文，包括程序计数器和寄存器值，以确保后续能从断点继续执行。其他信息虽在PCB中，但非切换时首要保存内容。", "answer": "A || 解析：进程切换时需保存CPU上下文，包括程序计数器和寄存器值，以确保后续能从断点继续执行。其他信息虽在PCB中，但非切换时首要保存内容。"}
{"id": "Q145", "type": "单项选择题", "question": "在可剥夺调度系统中，一个高优先级进程就绪时，当前运行的低优先级进程被剥夺CPU，该进程的状态将变为： A. 就绪态； B. 阻塞态； C. 创建态； D. 终止态", "answer_label": "A", "answer_explain": "在可剥夺系统中，高优先级进程就绪时，当前运行进程被抢占，转为就绪态，等待下次调度。阻塞态需等待事件，非抢占原因。", "answer": "A || 解析：在可剥夺系统中，高优先级进程就绪时，当前运行进程被抢占，转为就绪态，等待下次调度。阻塞态需等待事件，非抢占原因。"}
{"id": "Q146", "type": "单项选择题", "question": "下列哪项不是进程控制块（PCB）中包含的信息？ A. 进程标识符； B. 程序计数器； C. 程序源代码； D. 资源分配清单", "answer_label": "C", "answer_explain": "PCB存储运行时状态信息，程序源代码存于程序段，不在PCB中。A、B、D均为PCB内容。", "answer": "C || 解析：PCB存储运行时状态信息，程序源代码存于程序段，不在PCB中。A、B、D均为PCB内容。"}
{"id": "Q147", "type": "简答题", "question": "请结合进程的动态性、独立性和资源分配机制，解释为何进程是操作系统进行资源分配和调度的独立单位。", "answer": "进程具有动态性，具备创建、运行、终止的生命周期，是资源分配的载体；其独立性体现在可独立获取资源和接受调度；系统通过PCB管理资源分配清单与CPU状态，实现以进程为单位的时间片调度，故进程是资源分配和调度的独立单位。"}
{"id": "Q148", "type": "简答题", "question": "若一个进程在运行过程中请求I/O操作，它将发生状态转换。请说明该转换过程及系统需完成的关键操作。", "answer": "进程请求I/O后，由运行态转为阻塞态。系统需将CPU上下文（寄存器值）保存至PCB，更新进程状态为阻塞，并将其插入对应阻塞队列。待I/O完成，中断处理程序将其状态改为就绪，插入就绪队列，等待调度。"}
{"id": "Q149", "type": "简答题", "question": "为什么说‘进程是系统进行资源分配和调度的独立单位’中的‘资源’应理解为‘时间片’？请结合进程的动态性和调度机制说明。", "answer": "进程是动态的，其运行依赖于CPU时间片。资源分配的实质是时间片的分配，调度单位是进程。若资源理解为物理设备，则无法解释并发执行。因此，‘资源’应理解为CPU时间片，进程是时间片分配的独立单位。"}
{"id": "Q150", "type": "简答题", "question": "在多道程序系统中，为何必须通过PCB来控制和管理进程？请从PCB的结构与功能角度进行多跳推理分析。", "answer": "PCB包含进程描述、控制、资源清单和CPU上下文信息。系统通过PCB掌握进程状态、优先级、资源使用情况，实现调度、同步、中断处理和上下文切换。无PCB则无法感知进程存在，无法控制其运行，故PCB是进程管理的核心。"}
{"id": "Q151", "type": "单项选择题", "question": "关于进程与程序的根本区别，下列说法正确的是： A. 程序是静态的，进程是动态的； B. 程序可被多个进程共享，而进程不能共享程序； C. 程序包含PCB，进程不包含； D. 程序运行时即为进程，二者无本质区别", "answer_label": "A", "answer_explain": "程序是静态的代码集合，进程是程序的一次执行实例，具有生命周期和状态变化，是动态的。B项错误，进程可共享程序；C项错误，PCB属于进程实体，程序不包含PCB；D项混淆概念。", "answer": "A || 解析：程序是静态的代码集合，进程是程序的一次执行实例，具有生命周期和状态变化，是动态的。B项错误，进程可共享程序；C项错误，PCB属于进程实体，程序不包含PCB；D项混淆概念。"}
{"id": "Q152", "type": "单项选择题", "question": "在多道程序系统中，进程的异步性主要导致的问题是： A. 进程无法并发执行； B. 进程运行结果不可再现； C. 进程无法获得CPU资源； D. 进程无法创建PCB", "answer_label": "B", "answer_explain": "异步性导致进程以不可预知的速度推进，相互制约，使相同输入可能产生不同结果，即不可再现性。A错，异步性正是并发的基础；C、D与异步性无关。", "answer": "B || 解析：异步性导致进程以不可预知的速度推进，相互制约，使相同输入可能产生不同结果，即不可再现性。A错，异步性正是并发的基础；C、D与异步性无关。"}
{"id": "Q153", "type": "单项选择题", "question": "下列关于PCB的说法中，错误的是： A. PCB是进程存在的唯一标志； B. PCB中包含CPU上下文信息； C. PCB在进程终止后立即被释放； D. PCB用于实现进程的调度与同步", "answer_label": "C", "answer_explain": "PCB在进程终止后需经系统回收处理，可能延迟释放，不能保证立即释放。A、B、D均正确，PCB是进程核心，保存上下文，支持调度与同步。", "answer": "C || 解析：PCB在进程终止后需经系统回收处理，可能延迟释放，不能保证立即释放。A、B、D均正确，PCB是进程核心，保存上下文，支持调度与同步。"}
{"id": "Q154", "type": "单项选择题", "question": "当一个进程从运行态转为阻塞态时，其PCB中必须保存的信息是： A. 程序计数器和寄存器状态； B. 进程优先级和用户标识符； C. 打开文件列表和内存地址空间； D. 进程状态和资源分配清单", "answer_label": "A", "answer_explain": "进程从运行态转阻塞态时，需保存CPU现场（包括程序计数器和寄存器值）至PCB，以便后续恢复执行。B、C、D虽在PCB中，但非切换时必须保存的核心现场信息。", "answer": "A || 解析：进程从运行态转阻塞态时，需保存CPU现场（包括程序计数器和寄存器值）至PCB，以便后续恢复执行。B、C、D虽在PCB中，但非切换时必须保存的核心现场信息。"}
{"id": "Q155", "type": "单项选择题", "question": "在可剥夺型调度系统中，一个运行中的进程被剥夺CPU资源的可能原因是： A. 它请求I/O操作； B. 它的时间片用完； C. 有更高优先级的进程就绪； D. 它进入阻塞态", "answer_label": "C", "answer_explain": "在可剥夺系统中，高优先级进程就绪时，调度程序可抢占当前运行进程，使其转为就绪态。B是时间片用完的正常切换，A、D是主动阻塞，不涉及剥夺。", "answer": "C || 解析：在可剥夺系统中，高优先级进程就绪时，调度程序可抢占当前运行进程，使其转为就绪态。B是时间片用完的正常切换，A、D是主动阻塞，不涉及剥夺。"}
{"id": "Q156", "type": "单项选择题", "question": "关于进程的创建态，以下说法正确的是： A. 创建态进程已获得全部资源； B. 创建态进程已进入就绪队列； C. 创建态进程尚未建立PCB； D. 创建态进程因资源不足而无法继续创建", "answer_label": "D", "answer_explain": "创建态是进程创建过程中的中间状态，若资源不足（如内存），创建无法完成，进程处于创建态。A错，资源可能未满足；B错，未转入就绪；C错，创建时即申请PCB。", "answer": "D || 解析：创建态是进程创建过程中的中间状态，若资源不足（如内存），创建无法完成，进程处于创建态。A错，资源可能未满足；B错，未转入就绪；C错，创建时即申请PCB。"}
{"id": "Q157", "type": "单项选择题", "question": "在系统中，多个进程共享同一程序段，这体现了进程的哪一特征？ A. 动态性； B. 独立性； C. 并发性； D. 异步性", "answer_label": "C", "answer_explain": "多个进程运行同一程序，体现并发执行，是并发性的直接表现。动态性指生命周期变化，独立性指资源独立，异步性指推进不可预知，均非共享程序的直接体现。", "answer": "C || 解析：多个进程运行同一程序，体现并发执行，是并发性的直接表现。动态性指生命周期变化，独立性指资源独立，异步性指推进不可预知，均非共享程序的直接体现。"}
{"id": "Q158", "type": "简答题", "question": "请结合进程的组成与状态转换，说明一个进程从创建到终止的完整生命周期中，PCB在其中扮演的核心作用。", "answer": "PCB贯穿进程全生命周期：创建时申请并初始化PCB，记录标识符、状态、资源等信息；运行中保存CPU上下文，支持调度与切换；阻塞时保存断点，等待事件；就绪时参与调度；终止时被回收，释放资源。PCB是进程存在的唯一标志，系统通过它实现对进程的控制与管理。"}
{"id": "Q159", "type": "简答题", "question": "为何说进程是资源分配和调度的独立单位？请结合系统资源与进程状态转换进行解释。", "answer": "进程是资源分配和调度的独立单位，因其拥有独立的PCB，可独立获取内存、I/O设备等资源。系统以进程为单位分配时间片（CPU资源），调度时依据PCB中的优先级与状态。进程在运行、就绪、阻塞间转换，体现其对资源的动态需求与释放，确保并发与独立性。"}
{"id": "Q160", "type": "简答题", "question": "在多道程序系统中，为何必须通过PCB来控制进程？请从进程的动态性、状态转换与系统调度三个角度说明。", "answer": "进程具有动态性，PCB记录其创建、运行、终止全过程；状态转换（如运行→阻塞）需保存现场于PCB，确保恢复；系统调度依赖PCB中的状态、优先级等信息，实现就绪队列管理与CPU分配。无PCB则无法感知进程存在，无法实现并发与资源管理。"}
{"id": "Q161", "type": "单项选择题", "question": "关于进程与程序的关系，以下说法正确的是： A. 程序是进程的静态表现，进程是程序的动态执行过程； B. 一个程序只能对应一个进程； C. 进程的PCB在进程结束后立即被销毁，无需系统回收； D. 进程的创建仅需分配内存空间即可", "answer_label": "A", "answer_explain": "程序是静态的代码集合，进程是程序在内存中执行的动态过程。多个进程可运行同一程序，PCB需系统回收，创建进程需先建立PCB并分配资源。", "answer": "A || 解析：程序是静态的代码集合，进程是程序在内存中执行的动态过程。多个进程可运行同一程序，PCB需系统回收，创建进程需先建立PCB并分配资源。"}
{"id": "Q162", "type": "单项选择题", "question": "在多道程序系统中，进程的异步性主要源于： A. CPU执行速度过快； B. 进程间相互制约及资源竞争； C. 程序代码长度不一； D. 内存分配策略不同", "answer_label": "B", "answer_explain": "异步性由进程间相互制约（如同步、互斥）和资源竞争导致，使进程以不可预知速度推进，引发不可再现性，需同步机制解决。", "answer": "B || 解析：异步性由进程间相互制约（如同步、互斥）和资源竞争导致，使进程以不可预知速度推进，引发不可再现性，需同步机制解决。"}
{"id": "Q163", "type": "单项选择题", "question": "下列关于PCB的说法中，错误的是： A. PCB是进程存在的唯一标志； B. PCB中包含CPU上下文信息； C. PCB在进程运行期间可被修改，但不能被删除； D. PCB用于实现进程的资源分配与调度", "answer_label": "C", "answer_explain": "PCB在进程终止时被系统删除，运行期间可修改，但不可删除。删除PCB意味着进程消亡，故C错误。", "answer": "C || 解析：PCB在进程终止时被系统删除，运行期间可修改，但不可删除。删除PCB意味着进程消亡，故C错误。"}
{"id": "Q164", "type": "单项选择题", "question": "当一个进程请求I/O操作并等待结果时，其状态应从运行态转换为： A. 就绪态； B. 终止态； C. 阻塞态； D. 创建态", "answer_label": "C", "answer_explain": "进程请求I/O或等待事件时，需释放CPU并等待资源，故从运行态转为阻塞态，属于主动行为。", "answer": "C || 解析：进程请求I/O或等待事件时，需释放CPU并等待资源，故从运行态转为阻塞态，属于主动行为。"}
{"id": "Q165", "type": "单项选择题", "question": "在可剥夺型调度系统中，一个高优先级进程就绪时，当前运行进程可能被剥夺CPU，其状态将变为： A. 阻塞态； B. 就绪态； C. 运行态； D. 终止态", "answer_label": "B", "answer_explain": "高优先级进程就绪时，当前运行进程被剥夺CPU，但未等待资源，故进入就绪态，等待下次调度。", "answer": "B || 解析：高优先级进程就绪时，当前运行进程被剥夺CPU，但未等待资源，故进入就绪态，等待下次调度。"}
{"id": "Q166", "type": "单项选择题", "question": "下列哪一项不属于进程控制块（PCB）中包含的信息？ A. 进程优先级； B. 程序计数器值； C. 进程所用文件列表； D. 程序源代码", "answer_label": "D", "answer_explain": "PCB存储运行时状态信息，程序源代码在程序段中，不存于PCB。PCB包含寄存器值、资源清单、状态等。", "answer": "D || 解析：PCB存储运行时状态信息，程序源代码在程序段中，不存于PCB。PCB包含寄存器值、资源清单、状态等。"}
{"id": "Q167", "type": "单项选择题", "question": "在系统中，多个进程处于就绪态时，调度程序依据什么决定下一个运行的进程？ A. 进程的创建时间； B. 进程的优先级； C. 进程的内存大小； D. 进程的I/O请求次数", "answer_label": "B", "answer_explain": "调度程序根据进程优先级决定下一个运行进程，优先级高的进程优先获得CPU资源，是调度的核心依据。", "answer": "B || 解析：调度程序根据进程优先级决定下一个运行进程，优先级高的进程优先获得CPU资源，是调度的核心依据。"}
{"id": "Q168", "type": "简答题", "question": "请结合进程的动态性、并发性与PCB的作用，说明为何操作系统必须通过PCB来管理进程。", "answer": "进程是动态的执行过程，具有创建、运行、阻塞、终止等生命周期，需实时追踪状态。并发性要求系统能同时管理多个进程。PCB作为进程唯一标识，保存其状态、优先级、资源分配、CPU上下文等信息，使系统能调度、切换、恢复进程，实现资源分配与调度，是进程管理的核心机制。"}
{"id": "Q169", "type": "简答题", "question": "为何进程从阻塞态转为就绪态是被动行为？请结合进程状态转换机制与PCB作用进行解释。", "answer": "进程阻塞是主动请求资源或等待事件，而从阻塞态转为就绪态需外部事件（如I/O完成）触发中断处理程序，由系统修改PCB状态。该过程不由进程自身控制，依赖其他进程或设备完成，故为被动行为。PCB中状态信息的更新是系统调度的依据。"}
{"id": "Q170", "type": "简答题", "question": "若系统中多个进程共享同一程序段，但各自拥有独立的数据段和PCB，这如何体现进程的独立性与资源分配特性？请结合知识点说明。", "answer": "每个进程拥有独立的PCB，确保其状态、优先级、资源清单可独立管理，是独立运行的基本保障。共享程序段实现代码复用，但各自数据段独立，防止数据污染。系统以进程为单位分配CPU时间片、内存空间等资源，体现资源分配的独立性，符合进程作为调度与资源分配单位的定义。"}
{"id": "Q171", "type": "单项选择题", "question": "关于进程与程序的根本区别，以下描述最准确的是： A. 程序是静态的，进程是动态的； B. 程序可被多个进程共享，进程不能共享程序； C. 程序包含数据段，进程不包含数据段； D. 程序运行时才形成进程，因此程序是进程的前身", "answer_label": "A", "answer_explain": "程序是静态的代码集合，而进程是程序的一次执行实例，具有生命周期和状态变化，体现动态性。B项错误，进程可共享程序；C项错误，进程包含数据段；D项表述不准确，进程由PCB、程序段、数据段构成，非单纯程序的前身。", "answer": "A || 解析：程序是静态的代码集合，而进程是程序的一次执行实例，具有生命周期和状态变化，体现动态性。B项错误，进程可共享程序；C项错误，进程包含数据段；D项表述不准确，进程由PCB、程序段、数据段构成，非单纯程序的前身。"}
{"id": "Q172", "type": "单项选择题", "question": "在多道程序系统中，进程的异步性主要导致的问题是： A. 程序执行效率下降； B. 进程无法被调度； C. 执行结果不可再现； D. CPU利用率降低", "answer_label": "C", "answer_explain": "异步性使进程以不可预知的速度推进，因相互制约导致结果不确定，即不可再现性。A、D与异步性无直接因果；B错误，调度机制正是为解决异步性而设计。", "answer": "C || 解析：异步性使进程以不可预知的速度推进，因相互制约导致结果不确定，即不可再现性。A、D与异步性无直接因果；B错误，调度机制正是为解决异步性而设计。"}
{"id": "Q173", "type": "单项选择题", "question": "下列关于PCB的说法中，错误的是： A. PCB是进程存在的唯一标志； B. PCB中包含CPU上下文信息； C. PCB在进程终止后立即被释放； D. PCB用于实现进程的资源分配与调度", "answer_label": "C", "answer_explain": "PCB在进程终止后需经系统回收处理，如释放资源、更新调度队列等，不会立即释放。A、B、D均正确，符合教材定义。", "answer": "C || 解析：PCB在进程终止后需经系统回收处理，如释放资源、更新调度队列等，不会立即释放。A、B、D均正确，符合教材定义。"}
{"id": "Q174", "type": "单项选择题", "question": "当一个进程从运行态转换为阻塞态时，以下哪项操作是必须执行的？ A. 保存CPU寄存器值到PCB； B. 将进程插入就绪队列； C. 释放所有已分配资源； D. 修改进程优先级为最低", "answer_label": "A", "answer_explain": "运行态转阻塞态时，需保存当前CPU上下文（寄存器值）至PCB，以便后续恢复。B错误，应插入阻塞队列；C错误，资源未释放；D无依据。", "answer": "A || 解析：运行态转阻塞态时，需保存当前CPU上下文（寄存器值）至PCB，以便后续恢复。B错误，应插入阻塞队列；C错误，资源未释放；D无依据。"}
{"id": "Q175", "type": "单项选择题", "question": "在可剥夺调度系统中，一个高优先级就绪进程被调度执行，原运行进程的状态将变为： A. 就绪态； B. 阻塞态； C. 终止态； D. 创建态", "answer_label": "A", "answer_explain": "在可剥夺系统中，高优先级就绪进程就绪后，原运行进程被剥夺CPU，转为就绪态，等待再次调度。阻塞态需等待事件，非因调度剥夺。", "answer": "A || 解析：在可剥夺系统中，高优先级就绪进程就绪后，原运行进程被剥夺CPU，转为就绪态，等待再次调度。阻塞态需等待事件，非因调度剥夺。"}
{"id": "Q176", "type": "单项选择题", "question": "下列关于进程创建态的描述，正确的是： A. 创建态进程已获得所有资源； B. 创建态进程的PCB已分配但未初始化； C. 若内存不足，创建进程将进入创建态； D. 创建态是进程的最终状态", "answer_label": "C", "answer_explain": "创建态是进程创建过程中，因资源不足（如内存）而未完成创建的状态。A错误，资源未完全分配；B错误，PCB已初始化；D错误，终止态才是最终状态。", "answer": "C || 解析：创建态是进程创建过程中，因资源不足（如内存）而未完成创建的状态。A错误，资源未完全分配；B错误，PCB已初始化；D错误，终止态才是最终状态。"}
{"id": "Q177", "type": "简答题", "question": "请结合进程的动态性、独立性和资源分配机制，说明为何进程是操作系统进行资源分配和调度的基本单位。", "answer": "进程具有动态性，能独立运行并拥有生命周期，是资源分配和调度的最小单位。系统以进程为单位分配CPU时间片、内存等资源。PCB记录资源使用情况，调度器基于PCB进行调度。独立性确保进程可独立接受调度，避免资源争用。因此，进程是资源分配与调度的基本单位。"}
{"id": "Q178", "type": "简答题", "question": "当一个进程因请求I/O而从运行态转为阻塞态时，操作系统需要完成哪些关键操作？请结合PCB内容说明。", "answer": "操作系统需保存该进程的CPU上下文（寄存器值）至PCB；更新其状态为阻塞态；将PCB从运行队列移出，插入对应阻塞队列；若I/O请求需资源，更新资源分配清单。待I/O完成，中断处理程序将状态改为就绪，再插入就绪队列。"}
{"id": "Q179", "type": "简答题", "question": "为何说‘进程是系统进行资源分配和调度的独立单位’中的‘资源’应理解为‘时间片’？请结合进程特征与调度机制说明。", "answer": "进程是资源分配和调度的独立单位，其核心是CPU时间片的分配。进程的动态性与并发性要求系统按时间片调度多个进程。PCB中保存CPU上下文，确保时间片切换后可恢复执行。因此，‘资源’本质是CPU时间，进程作为时间片分配的独立单位，体现其调度独立性。"}
{"id": "Q180", "type": "简答题", "question": "请分析阻塞态与就绪态的根本区别，并说明为何阻塞态进程不能被调度到CPU运行。", "answer": "就绪态进程仅缺CPU，可立即运行；阻塞态进程等待资源或事件（如I/O），即使CPU空闲也无法运行。因阻塞态进程未获得所需资源，系统不会将其调度至CPU。PCB中状态信息和资源清单明确区分两者，确保调度正确性。"}
{"id": "Q181", "type": "单项选择题", "question": "关于进程与程序的根本区别，以下描述最准确的是： A. 程序是静态的，进程是动态的； B. 程序可被多个用户共享，进程不能； C. 程序包含数据段，进程不包含； D. 程序运行时才形成进程实体，但进程可脱离程序运行", "answer_label": "A", "answer_explain": "程序是静态的代码集合，进程是程序的一次执行实例，具有生命周期，体现动态性。B错，进程可共享程序；C错，进程包含数据段；D错，进程必须依附于程序实体。", "answer": "A || 解析：程序是静态的代码集合，进程是程序的一次执行实例，具有生命周期，体现动态性。B错，进程可共享程序；C错，进程包含数据段；D错，进程必须依附于程序实体。"}
{"id": "Q182", "type": "单项选择题", "question": "在多道程序系统中，进程的异步性主要导致的问题是： A. 进程无法创建； B. 进程无法调度； C. 执行结果不可再现； D. 进程无法访问内存", "answer_label": "C", "answer_explain": "异步性使进程推进速度不可预知，导致并发执行结果不一致，即不可再现性。这是操作系统必须配置同步机制的原因。", "answer": "C || 解析：异步性使进程推进速度不可预知，导致并发执行结果不一致，即不可再现性。这是操作系统必须配置同步机制的原因。"}
{"id": "Q183", "type": "单项选择题", "question": "下列关于PCB的说法中，错误的是： A. PCB是进程存在的唯一标志； B. PCB中保存CPU寄存器值，用于现场保护； C. PCB在进程终止时立即被删除； D. PCB包含进程优先级和资源分配信息", "answer_label": "C", "answer_explain": "PCB在进程终止后需由系统回收并处理资源释放，不会立即删除，需等待清理工作完成。", "answer": "C || 解析：PCB在进程终止后需由系统回收并处理资源释放，不会立即删除，需等待清理工作完成。"}
{"id": "Q184", "type": "单项选择题", "question": "当一个进程请求I/O操作后，它将从运行态转为阻塞态，这一转换的直接原因是： A. CPU时间片用完； B. 该进程优先级低于其他进程； C. 等待资源或事件完成； D. 系统调度策略改变", "answer_label": "C", "answer_explain": "进程因请求I/O或等待事件（如I/O完成）而暂停，属于主动等待资源或事件，故转入阻塞态。", "answer": "C || 解析：进程因请求I/O或等待事件（如I/O完成）而暂停，属于主动等待资源或事件，故转入阻塞态。"}
{"id": "Q185", "type": "单项选择题", "question": "在可剥夺型调度系统中，一个运行中的进程被剥夺CPU，最可能的原因是： A. 进程主动调用阻塞原语； B. 该进程时间片用完； C. 有更高优先级的进程变为就绪态； D. 系统内存不足", "answer_label": "C", "answer_explain": "可剥夺系统中，高优先级就绪进程可抢占当前运行进程，导致其从运行态转为就绪态，而非因时间片或阻塞。", "answer": "C || 解析：可剥夺系统中，高优先级就绪进程可抢占当前运行进程，导致其从运行态转为就绪态，而非因时间片或阻塞。"}
{"id": "Q186", "type": "单项选择题", "question": "关于进程创建态的描述，正确的是： A. 创建态的进程已获得全部资源； B. 创建态的进程已进入就绪队列； C. 创建态表示进程正在申请PCB并分配资源； D. 创建态的进程可被调度执行", "answer_label": "C", "answer_explain": "创建态是进程创建过程中的中间状态，尚未完成资源分配，若资源不足则无法转入就绪态。", "answer": "C || 解析：创建态是进程创建过程中的中间状态，尚未完成资源分配，若资源不足则无法转入就绪态。"}
{"id": "Q187", "type": "单项选择题", "question": "在进程调度中，系统通过PCB中的哪项信息判断是否可调度该进程？ A. 程序段地址； B. 数据段大小； C. 进程当前状态； D. 进程标识符", "answer_label": "C", "answer_explain": "调度程序依据进程状态（如就绪态）决定是否可调度，状态信息是调度的核心判断依据。", "answer": "C || 解析：调度程序依据进程状态（如就绪态）决定是否可调度，状态信息是调度的核心判断依据。"}
{"id": "Q188", "type": "单项选择题", "question": "进程在运行过程中被中断，其CPU现场信息应保存在： A. 程序段； B. 数据段； C. PCB中； D. 内存管理单元", "answer_label": "C", "answer_explain": "CPU上下文（寄存器值）在进程切换时需保存至PCB，以便恢复执行时能从断点继续运行。", "answer": "C || 解析：CPU上下文（寄存器值）在进程切换时需保存至PCB，以便恢复执行时能从断点继续运行。"}
{"id": "Q189", "type": "简答题", "question": "请结合进程的动态性、并发性与PCB的作用，说明为何进程是资源分配和调度的基本单位。", "answer": "进程具有动态性，能创建、运行、暂停、终止，体现生命周期；并发性要求多个进程共享CPU与资源；PCB作为进程唯一标识，保存状态、优先级、资源清单与CPU上下文，使系统能独立控制每个进程。因此，进程是资源分配与调度的最小单位。"}
{"id": "Q190", "type": "简答题", "question": "若一个进程在运行中因请求I/O而阻塞，其PCB中的哪些信息会被更新？请说明原因。", "answer": "进程状态由运行态变为阻塞态，PCB中“进程当前状态”字段更新；若因I/O请求，资源分配清单中对应设备信息被标记为占用；CPU上下文保存至PCB以备恢复。这些更新确保系统能正确管理资源与调度。"}
{"id": "Q191", "type": "单项选择题", "question": "关于进程与程序的根本区别，以下描述最准确的是： A. 程序是静态的，进程是动态的； B. 程序是可执行文件，进程是运行中的程序实例； C. 程序包含数据段，进程不包含； D. 程序可被多个进程共享，进程不能共享程序", "answer_label": "A", "answer_explain": "程序是静态的代码集合，而进程是程序的一次执行过程，具有生命周期，体现动态性。B虽正确但未突出本质区别，C错误，D混淆共享对象。", "answer": "A || 解析：程序是静态的代码集合，而进程是程序的一次执行过程，具有生命周期，体现动态性。B虽正确但未突出本质区别，C错误，D混淆共享对象。"}
{"id": "Q192", "type": "单项选择题", "question": "在多道程序系统中，进程的异步性主要导致的问题是： A. 程序无法并发执行； B. 进程状态无法转换； C. 执行结果不可再现； D. PCB无法创建", "answer_label": "C", "answer_explain": "异步性使进程推进速度不可预知，导致相同输入可能产生不同结果，即不可再现性，需同步机制解决。", "answer": "C || 解析：异步性使进程推进速度不可预知，导致相同输入可能产生不同结果，即不可再现性，需同步机制解决。"}
{"id": "Q193", "type": "单项选择题", "question": "下列关于进程控制块（PCB）的说法，错误的是： A. PCB是进程存在的唯一标志； B. PCB中包含CPU上下文信息； C. PCB在进程创建时被分配，运行结束后立即释放； D. PCB用于记录进程的优先级和资源分配情况", "answer_label": "C", "answer_explain": "PCB在进程结束后由系统回收，但并非“立即释放”，需完成资源释放等清理工作，因此C错误。", "answer": "C || 解析：PCB在进程结束后由系统回收，但并非“立即释放”，需完成资源释放等清理工作，因此C错误。"}
{"id": "Q194", "type": "单项选择题", "question": "当一个进程请求I/O操作并等待结果时，其状态将从运行态转换为： A. 就绪态； B. 阻塞态； C. 终止态； D. 创建态", "answer_label": "B", "answer_explain": "进程请求I/O或等待事件发生时，因缺少非CPU资源而暂停，必须进入阻塞态，等待事件完成。", "answer": "B || 解析：进程请求I/O或等待事件发生时，因缺少非CPU资源而暂停，必须进入阻塞态，等待事件完成。"}
{"id": "Q195", "type": "单项选择题", "question": "在可剥夺型调度系统中，高优先级进程就绪后，正在运行的低优先级进程会被剥夺CPU，该行为导致的状态转换是： A. 就绪态→运行态； B. 运行态→就绪态； C. 运行态→阻塞态； D. 阻塞态→就绪态", "answer_label": "B", "answer_explain": "高优先级进程就绪后，调度程序会中断当前运行进程，将其从运行态转为就绪态，以让出CPU。", "answer": "B || 解析：高优先级进程就绪后，调度程序会中断当前运行进程，将其从运行态转为就绪态，以让出CPU。"}
{"id": "Q196", "type": "单项选择题", "question": "以下关于进程实体的描述，正确的是： A. 进程实体由程序段、数据段和PCB组成； B. 程序段和数据段必须驻留在内存中； C. PCB可被多个进程共享； D. 进程实体在创建时才生成PCB", "answer_label": "A", "answer_explain": "进程实体即进程映像，由程序段、数据段和PCB三部分构成。B错误，程序段可换入换出；C错误，PCB唯一；D错误，PCB在创建时生成。", "answer": "A || 解析：进程实体即进程映像，由程序段、数据段和PCB三部分构成。B错误，程序段可换入换出；C错误，PCB唯一；D错误，PCB在创建时生成。"}
{"id": "Q197", "type": "单项选择题", "question": "在进程调度中，系统通过PCB中的哪项信息决定是否调度该进程？ A. 进程标识符； B. 进程优先级； C. 程序内存地址； D. 阻塞原因", "answer_label": "B", "answer_explain": "调度程序根据进程优先级判断哪个进程应优先获得CPU，是调度决策的核心依据。", "answer": "B || 解析：调度程序根据进程优先级判断哪个进程应优先获得CPU，是调度决策的核心依据。"}
{"id": "Q198", "type": "单项选择题", "question": "当一个阻塞态进程等待的I/O操作完成，其状态将如何变化？ A. 从阻塞态直接转为运行态； B. 从阻塞态转为就绪态； C. 从阻塞态转为创建态； D. 从阻塞态转为终止态", "answer_label": "B", "answer_explain": "I/O完成时，中断处理程序将进程状态由阻塞态改为就绪态，等待调度运行，不能直接运行。", "answer": "B || 解析：I/O完成时，中断处理程序将进程状态由阻塞态改为就绪态，等待调度运行，不能直接运行。"}
{"id": "Q199", "type": "简答题", "question": "请结合进程的动态性、并发性与PCB的作用，说明为何操作系统必须通过PCB来管理进程。", "answer": "进程是动态的执行过程，具有生命周期，需实时记录其状态、资源占用和CPU上下文。PCB作为进程唯一标识，存储进程控制、资源分配与CPU信息，使系统能感知进程存在、实现调度、保存断点、支持并发与同步。没有PCB，系统无法有效管理进程的动态行为与资源分配，无法实现并发性。"}
{"id": "Q200", "type": "简答题", "question": "一个进程从创建态到终止态经历了哪些状态转换？请结合资源分配与PCB管理说明其过程。", "answer": "创建态：申请空白PCB，填写信息；若资源不足，仍处创建态；资源满足后转入就绪态。就绪态：等待CPU调度。运行态：获得CPU执行。若请求I/O或等待事件，转阻塞态；时间片用完或被剥夺，转就绪态。阻塞态：事件完成后由中断处理程序转就绪态。终止态：进程结束，系统回收PCB与资源。PCB贯穿始终，记录状态与资源，支撑全过程管理。"}
