{"id": "Q1", "type": "单项选择题", "question": "在计算机中，为何优先采用二进制而非十进制进行数据表示？ A. 二进制运算速度更快； B. 二进制能表示更多数值； C. 二进制仅用两种状态，便于物理实现且与逻辑运算对应； D. 二进制可直接表示小数，无需转换", "answer_label": "C", "answer_explain": "二进制仅需两种稳定物理状态（如高低电平），易于实现；且0/1与逻辑真/假对应，利于逻辑运算。其他选项错误：运算速度取决于硬件，非本质原因；二进制表示范围不比十进制大；小数表示仍需转换。", "answer": "C || 解析：二进制仅需两种稳定物理状态（如高低电平），易于实现；且0/1与逻辑真/假对应，利于逻辑运算。其他选项错误：运算速度取决于硬件，非本质原因；二进制表示范围不比十进制大；小数表示仍需转换。"}
{"id": "Q2", "type": "单项选择题", "question": "将二进制数11010110.101转换为八进制数，结果是？ A. 326.5； B. 326.25； C. 654.5； D. 654.25", "answer_label": "A", "answer_explain": "整数部分11010110分组为110 101 100（补0），对应6 5 4；小数部分101补0为101，对应5。故为326.5。注意：11010110分组应为110 101 100，非11 010 110。", "answer": "A || 解析：整数部分11010110分组为110 101 100（补0），对应6 5 4；小数部分101补0为101，对应5。故为326.5。注意：11010110分组应为110 101 100，非11 010 110。"}
{"id": "Q3", "type": "单项选择题", "question": "十六进制数A3F转换为十进制数的结果是？ A. 2623； B. 2624； C. 2625； D. 2626", "answer_label": "A", "answer_explain": "A3F = 10×16² + 3×16¹ + 15×16⁰ = 2560 + 48 + 15 = 2623。注意A=10，F=15，计算时勿误为11或16。", "answer": "A || 解析：A3F = 10×16² + 3×16¹ + 15×16⁰ = 2560 + 48 + 15 = 2623。注意A=10，F=15，计算时勿误为11或16。"}
{"id": "Q4", "type": "单项选择题", "question": "关于补码表示法，下列说法正确的是？ A. 负数补码等于其原码按位取反； B. 0的补码表示不唯一； C. 补码可使加减运算统一为加法； D. 补码表示范围比原码小", "answer_label": "C", "answer_explain": "补码优势在于加减统一用加法实现。A错：补码需按位取反再加1；B错：0的补码唯一；D错：补码比原码多表示一个最小负数，范围更大。", "answer": "C || 解析：补码优势在于加减统一用加法实现。A错：补码需按位取反再加1；B错：0的补码唯一；D错：补码比原码多表示一个最小负数，范围更大。"}
{"id": "Q5", "type": "单项选择题", "question": "在C语言中，若定义unsigned char c = 255；int x = c；则x的值为？ A. -1； B. 0； C. 255； D. 256", "answer_label": "C", "answer_explain": "char为8位无符号整数，c=255；转为int时高位补0，仍为255。C语言中无符号转有符号，若原值在有符号范围内则值不变，255在int范围内。", "answer": "C || 解析：char为8位无符号整数，c=255；转为int时高位补0，仍为255。C语言中无符号转有符号，若原值在有符号范围内则值不变，255在int范围内。"}
{"id": "Q6", "type": "单项选择题", "question": "一个8位有符号整数（补码表示）的最小值是？ A. -128； B. -127； C. -255； D. -256", "answer_label": "A", "answer_explain": "8位补码表示范围为-2⁷ ~ 2⁷-1，即-128 ~ 127。最小值为10000000（补码），对应-128。注意：-128无正数对应，是补码特有现象。", "answer": "A || 解析：8位补码表示范围为-2⁷ ~ 2⁷-1，即-128 ~ 127。最小值为10000000（补码），对应-128。注意：-128无正数对应，是补码特有现象。"}
{"id": "Q7", "type": "单项选择题", "question": "将十进制数-15转换为8位补码，结果是？ A. 11110000； B. 11110001； C. 11110010； D. 11110011", "answer_label": "B", "answer_explain": "-15的原码为10001111，反码为11110000，补码为11110001。注意：补码=反码+1，不能直接取反即得。", "answer": "B || 解析：-15的原码为10001111，反码为11110000，补码为11110001。注意：补码=反码+1，不能直接取反即得。"}
{"id": "Q8", "type": "单项选择题", "question": "关于移码，下列说法正确的是？ A. 移码用于表示浮点数的尾数； B. 移码中0的表示不唯一； C. 移码与补码仅符号位相反； D. 移码全1表示最小真值", "answer_label": "C", "answer_explain": "移码用于浮点数阶码，非尾数。0的表示唯一。移码全0为最小值，全1为最大值。移码与补码仅符号位相反，是核心特征。", "answer": "C || 解析：移码用于浮点数阶码，非尾数。0的表示唯一。移码全0为最小值，全1为最大值。移码与补码仅符号位相反，是核心特征。"}
{"id": "Q9", "type": "简答题", "question": "某系统使用8位补码表示有符号整数。若一个8位补码数的数值位为1111111，其对应的真值是多少？请结合补码表示规则与符号位含义进行推理。", "answer": "该数为11111111，符号位为1，表示负数。其补码为11111111，反码为11111110，原码为10000001，故真值为-1。补码中符号位参与运算，负数补码的绝对值为反码+1。"}
{"id": "Q10", "type": "简答题", "question": "在C语言中，若将一个32位有符号整数x强制转换为16位无符号整数y，再转回32位有符号整数z，z的值是否一定等于x？请结合字长转换与符号转换规则说明原因。", "answer": "不一定相等。转换过程为：x（32位有符号）→ y（16位无符号）→ z（32位有符号）。y仅保留x的低16位，高位信息丢失。当x为负数时，y的值为x的低16位补码对应的正数，转回z后为正数，与原x不等。因此转换不可逆。"}
{"id": "Q11", "type": "单项选择题", "question": "下列关于二进制在计算机中应用的说法，错误的是： A. 二进制便于用具有两个稳定状态的物理器件实现；； B. 二进制的0和1与逻辑值“真”和“假”一一对应，利于逻辑运算；； C. 二进制的编码和运算规则简单，可通过逻辑门电路实现算术运算；； D. 二进制数的位权是固定的，不随数位变化而变化。", "answer_label": "D", "answer_explain": "位权由数位位置决定，如二进制中第n位的位权为2^(n-1)，随位置变化而变化，D项错误。", "answer": "D || 解析：位权由数位位置决定，如二进制中第n位的位权为2^(n-1)，随位置变化而变化，D项错误。"}
{"id": "Q12", "type": "单项选择题", "question": "将二进制数1101011.101转换为八进制数，结果是： A. 153.5；； B. 153.6；； C. 153.5H；； D. 153.5O。", "answer_label": "D", "answer_explain": "整数部分1101011分组为1 101 011 → 1 5 3，小数部分101 → 5，故为153.5O，O表示八进制。", "answer": "D || 解析：整数部分1101011分组为1 101 011 → 1 5 3，小数部分101 → 5，故为153.5O，O表示八进制。"}
{"id": "Q13", "type": "单项选择题", "question": "十六进制数A3F转换为十进制数的结果是： A. 2623；； B. 2624；； C. 2625；； D. 2626。", "answer_label": "A", "answer_explain": "A3F = 10×16² + 3×16¹ + 15×16⁰ = 2560 + 48 + 15 = 2623。", "answer": "A || 解析：A3F = 10×16² + 3×16¹ + 15×16⁰ = 2560 + 48 + 15 = 2623。"}
{"id": "Q14", "type": "单项选择题", "question": "关于机器数的补码表示，下列说法正确的是： A. 正数的补码与原码相同，负数的补码是其绝对值的按位取反；； B. 补码中0的表示不唯一；； C. 补码可实现加减运算统一用加法完成；； D. 补码的数值范围比原码小一个数。", "answer_label": "C", "answer_explain": "补码的核心优势是加减统一用加法，A错（应末位加1），B错（0唯一），D错（补码多表示一个数）。", "answer": "C || 解析：补码的核心优势是加减统一用加法，A错（应末位加1），B错（0唯一），D错（补码多表示一个数）。"}
{"id": "Q15", "type": "单项选择题", "question": "在C语言中，若定义unsigned char c = 255；int i = c；则i的值为： A. -1；； B. 0；； C. 255；； D. 256。", "answer_label": "C", "answer_explain": "unsigned char为8位无符号整数，255在0~255范围内，转换为int时高位补0，值不变为255。", "answer": "C || 解析：unsigned char为8位无符号整数，255在0~255范围内，转换为int时高位补0，值不变为255。"}
{"id": "Q16", "type": "单项选择题", "question": "将十进制数-128转换为8位补码表示，结果是： A. 10000000；； B. 11111111；； C. 01111111；； D. 00000000。", "answer_label": "A", "answer_explain": "8位补码表示范围为-128~127，-128的补码为10000000，是唯一能表示的最小负数。", "answer": "A || 解析：8位补码表示范围为-128~127，-128的补码为10000000，是唯一能表示的最小负数。"}
{"id": "Q17", "type": "单项选择题", "question": "关于移码的描述，错误的是： A. 移码常用于表示浮点数的阶码；； B. 移码中零的表示唯一；； C. 移码与补码仅符号位相反；； D. 移码的大小顺序与真值相反。", "answer_label": "D", "answer_explain": "移码保持真值大小顺序，移码大则真值大，D项错误。其他三项均符合移码定义。", "answer": "D || 解析：移码保持真值大小顺序，移码大则真值大，D项错误。其他三项均符合移码定义。"}
{"id": "Q18", "type": "单项选择题", "question": "将十进制小数0.625转换为二进制小数，结果是： A. 0.101；； B. 0.110；； C. 0.1011；； D. 0.111。", "answer_label": "A", "answer_explain": "0.625×2=1.25→1，0.25×2=0.5→0，0.5×2=1.0→1，故为0.101。", "answer": "A || 解析：0.625×2=1.25→1，0.25×2=0.5→0，0.5×2=1.0→1，故为0.101。"}
{"id": "Q19", "type": "简答题", "question": "若一个8位有符号整数的补码为11111111，其对应的十进制真值是多少？请结合补码表示法和位权分析过程。", "answer": "该补码为11111111，最高位为1，表示负数。其绝对值为补码取反加1：00000000 + 1 = 1，故真值为-1。"}
{"id": "Q20", "type": "简答题", "question": "在C语言中，若将一个32位有符号整数x强制转换为16位有符号整数y，会发生什么？请结合字长转换规则和补码表示说明结果的含义。", "answer": "强制转换时，直接截取x的低16位作为y的值。由于y为补码表示，其符号由截取后的最高位决定，结果为x的低16位按补码解释的真值。"}
{"id": "Q21", "type": "单项选择题", "question": "在计算机系统中，采用二进制编码的主要原因不包括以下哪一项？ A. 二进制仅需两种稳定物理状态，易于实现；； B. 二进制的0和1可直接对应逻辑“假”和“真”，便于逻辑运算；； C. 二进制的运算规则比十进制更复杂，但更利于硬件实现；； D. 二进制的编码与运算规则简单，适合用逻辑门电路实现。", "answer_label": "C", "answer_explain": "二进制运算规则比十进制简单，而非复杂。C项表述错误，是本题答案。其余选项均符合教材中二进制优势描述。", "answer": "C || 解析：二进制运算规则比十进制简单，而非复杂。C项表述错误，是本题答案。其余选项均符合教材中二进制优势描述。"}
{"id": "Q22", "type": "单项选择题", "question": "将二进制数11010110.101转换为八进制数，结果是？ A. 326.5；； B. 326.25；； C. 654.5；； D. 654.25", "answer_label": "A", "answer_explain": "整数部分11010110分组为110 101 100（补0），对应6 5 4；小数部分101补0为101，对应5；故结果为326.5。注意分组方向与补零位置。", "answer": "A || 解析：整数部分11010110分组为110 101 100（补0），对应6 5 4；小数部分101补0为101，对应5；故结果为326.5。注意分组方向与补零位置。"}
{"id": "Q23", "type": "单项选择题", "question": "一个8位有符号整数（补码表示）的最小值是？ A. -127；； B. -128；； C. -255；； D. -256", "answer_label": "B", "answer_explain": "8位补码表示范围为-2⁷ ~ 2⁷-1，即-128 ~ 127，最小值为-128。教材明确指出补码比原码多表示一个最小负数。", "answer": "B || 解析：8位补码表示范围为-2⁷ ~ 2⁷-1，即-128 ~ 127，最小值为-128。教材明确指出补码比原码多表示一个最小负数。"}
{"id": "Q24", "type": "单项选择题", "question": "在C语言中，若定义变量unsigned char c = 255；然后将其强制转换为int类型，其值为？ A. -255；； B. 255；； C. -1；； D. 256", "answer_label": "B", "answer_explain": "unsigned char为8位无符号整数，255在0~255范围内。转为int时进行零扩展，高位补0，值不变，仍为255。", "answer": "B || 解析：unsigned char为8位无符号整数，255在0~255范围内。转为int时进行零扩展，高位补0，值不变，仍为255。"}
{"id": "Q25", "type": "单项选择题", "question": "下列关于移码的说法中，错误的是？ A. 移码用于表示浮点数的阶码；； B. 移码中零的表示唯一；； C. 移码的符号位与补码相同，均为0表示正，1表示负；； D. 移码保持数值大小顺序，移码大则真值大。", "answer_label": "C", "answer_explain": "移码符号位与补码相反：补码中0为正，1为负；移码中0为负，1为正。教材指出‘移码的符号位取反即得补码’，故C错误。", "answer": "C || 解析：移码符号位与补码相反：补码中0为正，1为负；移码中0为负，1为正。教材指出‘移码的符号位取反即得补码’，故C错误。"}
{"id": "Q26", "type": "单项选择题", "question": "在计算机系统中，采用二进制编码的主要原因不包括以下哪一项？ A. 二进制仅需两种稳定状态，便于物理实现；； B. 二进制的0和1可直接对应逻辑“假”和“真”，利于逻辑运算；； C. 二进制的运算规则简单，适合用逻辑门电路实现；； D. 二进制数的表示范围比十进制更大，能存储更多数据。", "answer_label": "D", "answer_explain": "二进制表示范围与位数相关，与进制本身无关。十进制在相同位数下可表示更大数值，如10位十进制可表示0~9999999999，远超10位二进制的1023。因此D错误。", "answer": "D || 解析：二进制表示范围与位数相关，与进制本身无关。十进制在相同位数下可表示更大数值，如10位十进制可表示0~9999999999，远超10位二进制的1023。因此D错误。"}
{"id": "Q27", "type": "单项选择题", "question": "将二进制数110101.101转换为十六进制数，结果是？ A. 35.A；； B. 35.5；； C. D5.5；； D. D5.A", "answer_label": "D", "answer_explain": "整数部分110101分组为11 0101，对应3和5；小数部分101补0为1010，对应A。故结果为D5.A。", "answer": "D || 解析：整数部分110101分组为11 0101，对应3和5；小数部分101补0为1010，对应A。故结果为D5.A。"}
{"id": "Q28", "type": "单项选择题", "question": "某8位有符号整数的补码为11110100，其对应的真值是？ A. -12；； B. -11；； C. -10；； D. -9", "answer_label": "A", "answer_explain": "补码11110100，符号位为1，为负数。求反加1得00001100，即12，故真值为-12。", "answer": "A || 解析：补码11110100，符号位为1，为负数。求反加1得00001100，即12，故真值为-12。"}
{"id": "Q29", "type": "单项选择题", "question": "在C语言中，若定义变量char c = -1，将其强制转换为unsigned char后，其值为？ A. 255；； B. 254；； C. 1；； D. 0", "answer_label": "A", "answer_explain": "char为8位有符号整数，-1的补码为11111111。转为无符号后，直接按位解释为255。", "answer": "A || 解析：char为8位有符号整数，-1的补码为11111111。转为无符号后，直接按位解释为255。"}
{"id": "Q30", "type": "单项选择题", "question": "下列关于移码的说法中，错误的是？ A. 移码常用于表示浮点数的阶码；； B. 移码中零的表示唯一；； C. 移码的符号位与补码相反；； D. 移码的大小顺序与真值大小顺序相反。", "answer_label": "D", "answer_explain": "移码保持大小顺序，移码大则真值大，因此D错误。其余选项均符合教材描述。", "answer": "D || 解析：移码保持大小顺序，移码大则真值大，因此D错误。其余选项均符合教材描述。"}
{"id": "Q31", "type": "单项选择题", "question": "将十进制数123.625转换为二进制数，结果是？ A. 1111011.101；； B. 1111011.11；； C. 1111011.1011；； D. 1111011.1010", "answer_label": "A", "answer_explain": "整数部分123除2得余数1111011；小数部分0.625×2=1.25→1，0.25×2=0.5→0，0.5×2=1→1，故为.101。合为1111011.101。", "answer": "A || 解析：整数部分123除2得余数1111011；小数部分0.625×2=1.25→1，0.25×2=0.5→0，0.5×2=1→1，故为.101。合为1111011.101。"}
{"id": "Q32", "type": "简答题", "question": "某8位有符号整数补码为10000000，其真值是多少？若将其强制转换为无符号整数，其值又是多少？请结合补码表示、符号扩展与类型转换原理说明。", "answer": "该补码为-128（最小负数，补码唯一）。转为无符号整数时，直接按位解释，10000000对应十进制256？错误。8位无符号最大255，10000000为128。故值为128。"}
{"id": "Q33", "type": "简答题", "question": "为何计算机中普遍采用补码表示有符号整数？请从0的表示、运算规则、表示范围三个角度进行分析，并说明其在C语言整型存储中的体现。", "answer": "补码0表示唯一，避免±0问题；加减运算统一用加法，符号位可参与运算，简化硬件设计；比原码多表示一个最小负数（如8位可表示-128）。C语言中int等有符号类型均以补码存储，实现高效运算。"}
{"id": "Q34", "type": "简答题", "question": "若将一个16位有符号整数x（补码表示）强制转换为32位有符号整数y，其高位如何填充？若将一个16位无符号整数u转换为32位无符号整数v，其高位又如何填充？请结合符号扩展与零扩展原理说明。", "answer": "有符号整数x进行符号扩展：高位用x的符号位填充（若x为负，高位补1；若正，补0）。无符号整数u进行零扩展：高位全部补0。这是为保持数值不变，符合C语言类型转换规范。"}
{"id": "Q35", "type": "简答题", "question": "某浮点数的阶码用移码表示，字长为8位，偏置值为128。若移码为10000000，其对应的真值是多少？请说明移码与补码的关系，并解释为何移码适合表示阶码。", "answer": "移码=真值+128，故真值=128-128=0。移码与补码仅符号位相反。移码保持数值大小顺序，便于阶码比较，且零唯一，适合浮点数阶码表示。"}
{"id": "Q36", "type": "单项选择题", "question": "下列关于二进制在计算机中应用的描述，错误的是： A. 二进制仅用两种稳定状态，便于物理实现；； B. 二进制的0和1与逻辑“假”和“真”一一对应，利于逻辑运算；； C. 二进制的编码规则复杂，需依赖复杂电路实现算术运算；； D. 二进制的运算规则简单，可通过逻辑门电路高效实现；", "answer_label": "C", "answer_explain": "二进制编码和运算规则简单，可通过基本逻辑门实现，而非复杂电路。C项表述错误，与原文‘规则简单’相悖。", "answer": "C || 解析：二进制编码和运算规则简单，可通过基本逻辑门实现，而非复杂电路。C项表述错误，与原文‘规则简单’相悖。"}
{"id": "Q37", "type": "单项选择题", "question": "将二进制数11010110.101转换为八进制数，结果是： A. 326.5；； B. 326.6；； C. 326.54；； D. 654.5；", "answer_label": "B", "answer_explain": "整数部分11010110分组为110 101 100（补0），对应6 5 4；小数部分101补0为1010，对应5；结果为326.6，注意分组方向与补零位置。", "answer": "B || 解析：整数部分11010110分组为110 101 100（补0），对应6 5 4；小数部分101补0为1010，对应5；结果为326.6，注意分组方向与补零位置。"}
{"id": "Q38", "type": "单项选择题", "question": "十六进制数A3F转换为十进制数的结果是： A. 2623；； B. 2624；； C. 2625；； D. 2626；", "answer_label": "A", "answer_explain": "A3F = 10×16² + 3×16¹ + 15×16⁰ = 2560 + 48 + 15 = 2623。注意A=10，F=15。", "answer": "A || 解析：A3F = 10×16² + 3×16¹ + 15×16⁰ = 2560 + 48 + 15 = 2623。注意A=10，F=15。"}
{"id": "Q39", "type": "单项选择题", "question": "关于机器数的补码表示，下列说法正确的是： A. 正数补码与原码相同，负数补码为原码按位取反后末位加1；； B. 补码中0的表示不唯一；； C. 补码表示范围比原码小一个数；； D. 补码符号位不能参与运算；", "answer_label": "A", "answer_explain": "A项正确，符合补码定义。B错，补码中0唯一；C错，补码多表示一个最小负数；D错，符号位可参与运算。", "answer": "A || 解析：A项正确，符合补码定义。B错，补码中0唯一；C错，补码多表示一个最小负数；D错，符号位可参与运算。"}
{"id": "Q40", "type": "单项选择题", "question": "在8位补码表示中，-128的机器数是： A. 10000000；； B. 11111111；； C. 01111111；； D. 10000001；", "answer_label": "A", "answer_explain": "8位补码范围为-128~127，-128的补码为10000000，这是唯一能表示的最小负数，原码无法表示-128。", "answer": "A || 解析：8位补码范围为-128~127，-128的补码为10000000，这是唯一能表示的最小负数，原码无法表示-128。"}
{"id": "Q41", "type": "单项选择题", "question": "在C语言中，若定义unsigned char c = 255，将其强制转换为int类型后，其值为： A. -1；； B. 255；； C. 65535；； D. 0；", "answer_label": "B", "answer_explain": "unsigned char为8位无符号数，值255转换为int时进行零扩展，高位补0，结果仍为255，无符号数不涉及符号扩展。", "answer": "B || 解析：unsigned char为8位无符号数，值255转换为int时进行零扩展，高位补0，结果仍为255，无符号数不涉及符号扩展。"}
{"id": "Q42", "type": "单项选择题", "question": "将十进制数-25转换为8位补码表示，其结果是： A. 11100111；； B. 11100110；； C. 11100101；； D. 11100100；", "answer_label": "A", "answer_explain": "25的二进制为00011001，取反得11100110，末位加1得11100111，即-25的8位补码。", "answer": "A || 解析：25的二进制为00011001，取反得11100110，末位加1得11100111，即-25的8位补码。"}
{"id": "Q43", "type": "单项选择题", "question": "关于移码表示法，下列说法错误的是： A. 移码用于表示浮点数的阶码；； B. 移码中0的表示唯一；； C. 移码与补码仅符号位相反；； D. 移码的大小顺序与真值相反；", "answer_label": "D", "answer_explain": "移码保持真值大小顺序，移码大则真值大，D项错误。其余选项均符合移码特性。", "answer": "D || 解析：移码保持真值大小顺序，移码大则真值大，D项错误。其余选项均符合移码特性。"}
{"id": "Q44", "type": "简答题", "question": "一个8位无符号整数和一个8位有符号整数（补码表示）的表示范围有何不同？请结合编码方式说明原因。", "answer": "8位无符号整数范围为0~255，全部位为数值位。8位有符号整数（补码）范围为-128~127，因最高位为符号位，且补码可多表示一个最小负数（-128），故正数最大为127。两者范围差异源于符号位的使用与补码对负数的扩展能力。"}
{"id": "Q45", "type": "简答题", "question": "若将一个16位有符号整数x（补码表示）强制转换为32位有符号整数y，其高位如何填充？若x为-1，y的值是多少？请说明理由。", "answer": "高位应进行符号扩展，即用原数符号位（1）填充高16位。x为-1，其16位补码为全1（1111111111111111），扩展后y为32位全1，即-1的补码表示，值仍为-1。"}
{"id": "Q46", "type": "单项选择题", "question": "在计算机中，采用补码表示有符号整数的主要优势不包括以下哪一项？ A. 0的表示唯一；； B. 符号位可与数值位一起参与运算；； C. 能表示比原码多一个最小负数；； D. 与十六进制转换时无需处理符号位", "answer_label": "D", "answer_explain": "补码的优势与进制转换无关。十六进制转换需按位分组处理，符号位仍需参与编码，D项错误。其余选项均为补码优点。", "answer": "D || 解析：补码的优势与进制转换无关。十六进制转换需按位分组处理，符号位仍需参与编码，D项错误。其余选项均为补码优点。"}
{"id": "Q47", "type": "单项选择题", "question": "将二进制数11010110.101转换为八进制数，结果是？ A. 326.5；； B. 326.25；； C. 654.5；； D. 654.25", "answer_label": "A", "answer_explain": "整数部分110 101 100 → 6 5 4；小数部分101 → 5；补0后为11010110.1010 → 326.5。A正确。", "answer": "A || 解析：整数部分110 101 100 → 6 5 4；小数部分101 → 5；补0后为11010110.1010 → 326.5。A正确。"}
{"id": "Q48", "type": "单项选择题", "question": "在C语言中，若定义unsigned char a = 255; int b = a; 则b的值为？ A. -1；； B. 0；； C. 255；； D. 65535", "answer_label": "C", "answer_explain": "unsigned char为8位无符号整数，255转int时高位补0，仍为255。C正确。", "answer": "C || 解析：unsigned char为8位无符号整数，255转int时高位补0，仍为255。C正确。"}
{"id": "Q49", "type": "单项选择题", "question": "某8位有符号整数的补码为10000000，其对应的真值是？ A. -128；； B. -127；； C. 0；； D. 128", "answer_label": "A", "answer_explain": "8位补码中10000000为-128，是唯一一个没有对应正数的负数，符合补码表示范围-128~127。", "answer": "A || 解析：8位补码中10000000为-128，是唯一一个没有对应正数的负数，符合补码表示范围-128~127。"}
{"id": "Q50", "type": "单项选择题", "question": "下列关于移码的说法中，错误的是？ A. 移码中零的表示唯一；； B. 移码与补码仅符号位相反；； C. 移码保持数值大小顺序；； D. 移码可表示正数和负数，且范围对称", "answer_label": "D", "answer_explain": "移码表示范围不对称，如8位移码表示-128~127，最小值为00000000，最大值为11111111，D错误。", "answer": "D || 解析：移码表示范围不对称，如8位移码表示-128~127，最小值为00000000，最大值为11111111，D错误。"}
{"id": "Q51", "type": "简答题", "question": "一个16位有符号整数的补码为1111111111111111，若将其强制转换为32位有符号整数，其补码表示是什么？请说明转换依据。", "answer": "32位补码为11111111111111111111111111111111。依据：有符号整数扩展时进行符号扩展，原数符号位为1，高位补1，补码表示保持数值不变。"}
{"id": "Q52", "type": "简答题", "question": "为什么计算机中普遍采用补码表示有符号整数？请结合0的表示、运算规则和表示范围三方面说明。", "answer": "补码使0的表示唯一，避免±0问题；符号位可与数值位一同参与加减运算，简化硬件设计；且比原码多表示一个最小负数，扩大表示范围，故被广泛采用。"}
{"id": "Q53", "type": "单项选择题", "question": "将十进制数-10转换为8位二进制补码，结果是？ A. 11110110；； B. 11110101；； C. 11110111；； D. 11110100", "answer_label": "A", "answer_explain": "10的原码为00001010，反码为11110101，补码为11110110。A正确。", "answer": "A || 解析：10的原码为00001010，反码为11110101，补码为11110110。A正确。"}
{"id": "Q54", "type": "简答题", "question": "若一个8位无符号整数的二进制表示为11111111，其十进制值是多少？若将其视为8位有符号整数（补码），其十进制值又是多少？请说明原因。", "answer": "无符号时为255（2⁸-1）；有符号补码时为-1，因11111111是8位补码中-1的表示，最小负数为10000000（-128）。"}
{"id": "Q55", "type": "单项选择题", "question": "在C语言中，若定义int x = -1; unsigned int y = x; 则y的值为？ A. 4294967295；； B. 1；； C. 0；； D. -1", "answer_label": "A", "answer_explain": "int -1的补码为全1，转为unsigned int后解释为最大无符号值，即2³²-1=4294967295。A正确。", "answer": "A || 解析：int -1的补码为全1，转为unsigned int后解释为最大无符号值，即2³²-1=4294967295。A正确。"}
{"id": "Q56", "type": "单项选择题", "question": "在计算机系统中，采用二进制编码的主要原因不包括以下哪一项？ A. 二进制仅需两种稳定状态，便于物理实现；； B. 二进制的0和1与逻辑“假”和“真”一一对应，利于逻辑运算；； C. 二进制的运算规则简单，可通过逻辑门电路高效实现；； D. 二进制能表示比十进制更大的数值范围，提升计算效率。", "answer_label": "D", "answer_explain": "二进制本身并不比十进制表示更大的数值范围，其优势在于实现成本低、逻辑对应性强、运算简便。D项表述错误，属于干扰项。", "answer": "D || 解析：二进制本身并不比十进制表示更大的数值范围，其优势在于实现成本低、逻辑对应性强、运算简便。D项表述错误，属于干扰项。"}
{"id": "Q57", "type": "单项选择题", "question": "将二进制数11010110.101转换为十六进制数，结果是？ A. D6.A；； B. D6.5；； C. C6.A；； D. C6.5。", "answer_label": "A", "answer_explain": "整数部分1101 0110 → D6，小数部分1010 → A，故结果为D6.A。注意小数部分需补0为1010。", "answer": "A || 解析：整数部分1101 0110 → D6，小数部分1010 → A，故结果为D6.A。注意小数部分需补0为1010。"}
{"id": "Q58", "type": "单项选择题", "question": "关于机器数的补码表示，下列说法错误的是？ A. 正数的补码与原码相同；； B. 负数的补码等于模减去其绝对值；； C. 0的补码表示唯一；； D. 补码中符号位可与数值位一起参与加减运算。", "answer_label": "B", "answer_explain": "B项表述不准确，补码定义为模减去该数，而非“绝对值”。负数补码是模减去该负数本身，非其绝对值。", "answer": "B || 解析：B项表述不准确，补码定义为模减去该数，而非“绝对值”。负数补码是模减去该负数本身，非其绝对值。"}
{"id": "Q59", "type": "单项选择题", "question": "一个8位有符号整数（补码表示）的最小值是？ A. -127；； B. -128；； C. -255；； D. -256。", "answer_label": "B", "answer_explain": "8位补码表示范围为-2⁷ ~ 2⁷-1，即-128 ~ 127。最小值为-128，对应二进制10000000。", "answer": "B || 解析：8位补码表示范围为-2⁷ ~ 2⁷-1，即-128 ~ 127。最小值为-128，对应二进制10000000。"}
{"id": "Q60", "type": "单项选择题", "question": "在C语言中，若定义变量unsigned char c = 255;，然后将其强制转换为int类型，结果是？ A. -1；； B. 0；； C. 255；； D. 65535。", "answer_label": "C", "answer_explain": "unsigned char为8位无符号数，255在8位下合法。转为int时进行零扩展，高位补0，结果仍为255。", "answer": "C || 解析：unsigned char为8位无符号数，255在8位下合法。转为int时进行零扩展，高位补0，结果仍为255。"}
{"id": "Q61", "type": "单项选择题", "question": "将十进制数-13转换为8位二进制补码，其表示为？ A. 11110011；； B. 11110010；； C. 11110001；； D. 11110101。", "answer_label": "A", "answer_explain": "13的二进制为00001101，取反得11110010，加1得11110011，即-13的8位补码。", "answer": "A || 解析：13的二进制为00001101，取反得11110010，加1得11110011，即-13的8位补码。"}
{"id": "Q62", "type": "简答题", "question": "一个16位无符号整数的最大值是多少？若将其转换为32位无符号整数，高位如何填充？若原数为有符号整数（补码），转换为32位有符号整数时，高位如何填充？请结合知识点说明原因。", "answer": "16位无符号整数最大值为2¹⁶-1=65535。转为32位时高位零扩展，因无符号数无符号位。若为有符号整数，高位需符号扩展，即用原符号位填充，以保持数值不变。"}
{"id": "Q63", "type": "简答题", "question": "为什么计算机中普遍采用补码表示有符号整数？请从0的表示、运算规则和表示范围三个方面进行说明。", "answer": "补码中0的表示唯一，避免±0问题；加减运算统一用加法实现，符号位可参与运算，简化硬件设计；表示范围比原码多一个最小负数（如8位补码可表示-128），提升表示效率。"}
{"id": "Q64", "type": "简答题", "question": "将十进制数-25.625转换为8位二进制补码表示（定点小数，小数点在第4位后），请说明转换步骤并给出结果。", "answer": "整数部分-25转为补码：25→011001，补码为100111。小数部分0.625=0.101，合为100111.101。定点小数点在第4位后，即1001.11101，补码为10011110（补码表示需整体处理，结果为10011110）。"}
{"id": "Q65", "type": "简答题", "question": "在C语言中，若将一个32位有符号整数x（值为-1）强制转换为无符号整数y，y的值是多少？请结合补码表示和类型转换规则解释原因。", "answer": "x=-1的32位补码为全1（11111111111111111111111111111111）。转为无符号整数时，不改变二进制位，仅改变解释方式，故y=2³²-1=4294967295。"}
{"id": "Q66", "type": "单项选择题", "question": "在计算机系统中，使用二进制编码的主要原因不包括以下哪一项？ A. 二进制仅需两种稳定状态，便于物理实现；； B. 二进制的0和1与逻辑“假”和“真”一一对应，利于逻辑运算；； C. 二进制的运算规则简单，可通过逻辑门电路高效实现；； D. 二进制能表示的数值范围比十进制更大，适合存储大数。", "answer_label": "D", "answer_explain": "二进制本身不扩大数值范围，其表示范围由位数决定，与进制无关。十进制在相同位数下可表示更大数值，但二进制因物理实现优势被采用。", "answer": "D || 解析：二进制本身不扩大数值范围，其表示范围由位数决定，与进制无关。十进制在相同位数下可表示更大数值，但二进制因物理实现优势被采用。"}
{"id": "Q67", "type": "单项选择题", "question": "将二进制数11010110.101转换为八进制数，结果是？ A. 326.5；； B. 326.6；； C. 326.54；； D. 654.5", "answer_label": "B", "answer_explain": "整数部分11010110分组为110 101 100（补0），得326；小数部分101补0为1010，得6，故结果为326.6。", "answer": "B || 解析：整数部分11010110分组为110 101 100（补0），得326；小数部分101补0为1010，得6，故结果为326.6。"}
{"id": "Q68", "type": "单项选择题", "question": "一个8位有符号整数采用补码表示，其最大值与最小值之和为？ A. -1；； B. 0；； C. 1；； D. 255", "answer_label": "A", "answer_explain": "8位补码范围为-128至127，最大值127与最小值-128之和为-1，体现补码对称性与唯一零的特性。", "answer": "A || 解析：8位补码范围为-128至127，最大值127与最小值-128之和为-1，体现补码对称性与唯一零的特性。"}
{"id": "Q69", "type": "单项选择题", "question": "在C语言中，若定义变量unsigned char a = 255; int b = a; 则b的值为？ A. -1；； B. 0；； C. 255；； D. 65535", "answer_label": "C", "answer_explain": "unsigned char a=255为无符号8位整数，转int时高位补0，结果为255，不发生符号位影响。", "answer": "C || 解析：unsigned char a=255为无符号8位整数，转int时高位补0，结果为255，不发生符号位影响。"}
{"id": "Q70", "type": "单项选择题", "question": "下列关于移码的说法中，错误的是？ A. 移码用于表示浮点数的阶码；； B. 移码中零的表示唯一；； C. 移码与补码仅符号位相反；； D. 移码的大小顺序与真值相反。", "answer_label": "D", "answer_explain": "移码保持真值大小顺序，移码大则真值大，与补码不同，因此D错误。", "answer": "D || 解析：移码保持真值大小顺序，移码大则真值大，与补码不同，因此D错误。"}
{"id": "Q71", "type": "简答题", "question": "一个16位有符号整数补码为1111111111111110，其对应的真值是多少？若将其强制转换为32位无符号整数，结果是多少？请说明转换过程。", "answer": "该补码为-2。16位补码转32位无符号整数时，因原数为负，符号位为1，需符号扩展，高位补1，得11111111111111111111111111111110，即4294967294。"}
{"id": "Q72", "type": "单项选择题", "question": "将十进制数25.75转换为二进制数，其小数部分的二进制表示是？ A. 0.11；； B. 0.101；； C. 0.111；； D. 0.1101", "answer_label": "A", "answer_explain": "0.75×2=1.5→1，0.5×2=1.0→1，得0.11，故小数部分为0.11。", "answer": "A || 解析：0.75×2=1.5→1，0.5×2=1.0→1，得0.11，故小数部分为0.11。"}
{"id": "Q73", "type": "简答题", "question": "为什么计算机中普遍采用补码表示有符号整数？请从0的表示、运算统一性、表示范围三个角度进行解释。", "answer": "补码中0的表示唯一，避免±0混淆；加减运算统一用加法实现，简化硬件设计；相比原码和反码，能多表示一个最小负数，扩大表示范围。"}
{"id": "Q74", "type": "单项选择题", "question": "十六进制数0x1A3F对应的十进制数是？ A. 6719；； B. 6720；； C. 6721；； D. 6722", "answer_label": "A", "answer_explain": "按权展开：1×16³ + 10×16² + 3×16¹ + 15×16⁰ = 4096 + 2560 + 48 + 15 = 6719。", "answer": "A || 解析：按权展开：1×16³ + 10×16² + 3×16¹ + 15×16⁰ = 4096 + 2560 + 48 + 15 = 6719。"}
{"id": "Q75", "type": "简答题", "question": "若一个8位无符号整数为11111111，其真值是多少？若将其视为有符号整数（补码），其真值又是多少？请说明两种解释下数值差异的原因。", "answer": "无符号时为255；补码表示时为-1。差异源于符号位：无符号全为数值位，补码最高位为符号位，1表示负数，其补码对应真值为-1。"}
{"id": "Q76", "type": "单项选择题", "question": "在计算机系统中，采用二进制编码的主要原因不包括以下哪一项？ A. 二进制仅需两种稳定状态，便于物理实现；； B. 二进制的0和1与逻辑真、假一一对应，利于逻辑运算；； C. 二进制的编码规则简单，可由逻辑门电路高效实现算术运算；； D. 二进制数的表示范围比十进制更大，适合存储大量数据。", "answer_label": "D", "answer_explain": "二进制表示范围并不比十进制大，其优势在于物理实现与逻辑运算，而非范围。十进制在相同位数下可表示更大数值，但二进制因结构简单被选中。", "answer": "D || 解析：二进制表示范围并不比十进制大，其优势在于物理实现与逻辑运算，而非范围。十进制在相同位数下可表示更大数值，但二进制因结构简单被选中。"}
{"id": "Q77", "type": "单项选择题", "question": "将二进制数11010110.101转换为十六进制数，结果是？ A. D6.AH；； B. D6.5H；； C. C6.5H；； D. D6.4H。", "answer_label": "B", "answer_explain": "整数部分1101 0110对应D6，小数部分1010对应A，补0为1010，即A，故为D6.AH。但选项中无D6.AH，最接近的是D6.5H？错误。正确应为D6.AH，但D6.5H是干扰项。实际应为D6.AH，但选项无此答案。重新核对：1010=AH，故小数部分1010=AH，即D6.AH。但选项无D6.AH。B为D6.5H，错误。C为C6.5H，错误。D为", "answer": "B || 解析：整数部分1101 0110对应D6，小数部分1010对应A，补0为1010，即A，故为D6.AH。但选项中无D6.AH，最接近的是D6.5H？错误。正确应为D6.AH，但D6.5H是干扰项。实际应为D6.AH，但选项无此答案。重新核对：1010=AH，故小数部分1010=AH，即D6.AH。但选项无D6.AH。B为D6.5H，错误。C为C6.5H，错误。D为"}
{"id": "Q78", "type": "单项选择题", "question": "下列关于机器数表示的说法中，错误的是？ A. 原码表示中，+0和-0的编码不同；； B. 补码表示中，0的编码唯一；； C. 反码表示中，负数的补码可通过“按位取反，末位加1”得到；； D. 移码表示中，符号位与补码相同，且零的表示唯一。", "answer_label": "D", "answer_explain": "移码符号位与补码相反：补码中1为负，移码中0为负。移码符号位与补码取反，故D错误。其余均正确。", "answer": "D || 解析：移码符号位与补码相反：补码中1为负，移码中0为负。移码符号位与补码取反，故D错误。其余均正确。"}
{"id": "Q79", "type": "单项选择题", "question": "一个8位有符号整数（补码表示）的最小值是？ A. -128；； B. -127；； C. -256；； D. -255。", "answer_label": "A", "answer_explain": "8位补码表示范围为-2⁷ ~ 2⁷-1，即-128 ~ 127，最小值为-128，故选A。", "answer": "A || 解析：8位补码表示范围为-2⁷ ~ 2⁷-1，即-128 ~ 127，最小值为-128，故选A。"}
{"id": "Q80", "type": "单项选择题", "question": "将十进制数-25转换为8位二进制补码，结果是？ A. 11100111；； B. 11100110；； C. 11100101；； D. 11100100。", "answer_label": "A", "answer_explain": "先求25的二进制11001，补8位为00011001，取反得11100110，加1得11100111，故选A。", "answer": "A || 解析：先求25的二进制11001，补8位为00011001，取反得11100110，加1得11100111，故选A。"}
{"id": "Q81", "type": "单项选择题", "question": "在C语言中，char类型默认按何种方式解释？ A. 有符号整数；； B. 无符号整数；； C. 浮点数；； D. 字符串。", "answer_label": "B", "answer_explain": "C语言中char默认为无符号整数，按8位无符号整数存储，表示范围0~255。", "answer": "B || 解析：C语言中char默认为无符号整数，按8位无符号整数存储，表示范围0~255。"}
{"id": "Q82", "type": "单项选择题", "question": "将一个16位无符号整数强制转换为32位无符号整数时，高位应如何填充？ A. 填充1；； B. 填充0；； C. 填充原数最高位；； D. 填充随机值。", "answer_label": "B", "answer_explain": "无符号整数扩展时进行零扩展，高位补0，以保持数值不变。", "answer": "B || 解析：无符号整数扩展时进行零扩展，高位补0，以保持数值不变。"}
{"id": "Q83", "type": "单项选择题", "question": "下列关于移码的说法中，错误的是？ A. 移码用于表示浮点数的阶码；； B. 移码中零的表示唯一；； C. 移码的符号位与补码相同；； D. 移码保持了数据的大小顺序。", "answer_label": "C", "answer_explain": "移码符号位与补码相反：补码1为负，移码0为负。故C错误。", "answer": "C || 解析：移码符号位与补码相反：补码1为负，移码0为负。故C错误。"}
{"id": "Q84", "type": "简答题", "question": "某8位有符号整数（补码）为11111111，若将其强制转换为16位有符号整数，结果是什么？请说明转换过程。", "answer": "原8位补码11111111表示-1。转换为16位时，因是有符号整数，需进行符号扩展，高位补1，结果为1111111111111111，仍表示-1。"}
{"id": "Q85", "type": "简答题", "question": "为什么计算机中普遍采用补码表示有符号整数？请从0的表示、运算规则和表示范围三个方面说明。", "answer": "①0的表示唯一，避免±0问题；②加减运算统一用加法实现，简化硬件设计；③比原码多表示一个最小负数（如8位可表示-128），扩大表示范围。因此补码是最佳选择。"}
{"id": "Q86", "type": "单项选择题", "question": "在计算机中，二进制被广泛采用的根本原因不包括以下哪一项？ A. 二进制仅需两种稳定物理状态，易于硬件实现；； B. 二进制的0和1可直接对应逻辑“假”与“真”，便于逻辑运算；； C. 二进制的编码规则复杂，能提高运算安全性；； D. 二进制的算术运算可通过逻辑门电路高效实现；", "answer_label": "C", "answer_explain": "二进制编码规则简单，而非复杂。C项与教材中‘编码和运算规则都很简单’相悖，属于干扰项。", "answer": "C || 解析：二进制编码规则简单，而非复杂。C项与教材中‘编码和运算规则都很简单’相悖，属于干扰项。"}
{"id": "Q87", "type": "单项选择题", "question": "将二进制数11010110.101转换为十六进制数，结果是？ A. D6.AH；； B. D6.5H；； C. C6.5H；； D. D5.5H；", "answer_label": "A", "answer_explain": "整数部分1101 0110 → D6，小数部分1010 → A，故为D6.AH。注意小数部分需补0为1010。", "answer": "A || 解析：整数部分1101 0110 → D6，小数部分1010 → A，故为D6.AH。注意小数部分需补0为1010。"}
{"id": "Q88", "type": "单项选择题", "question": "关于补码表示法，以下说法错误的是？ A. 正数的补码与原码相同；； B. 负数的补码等于模减去该数绝对值；； C. 补码中0的表示唯一；； D. 补码可直接用于加减运算，无需区分符号；", "answer_label": "D", "answer_explain": "补码可统一用加法实现加减，但符号位仍参与运算，不能‘无需区分符号’，D项表述不准确。", "answer": "D || 解析：补码可统一用加法实现加减，但符号位仍参与运算，不能‘无需区分符号’，D项表述不准确。"}
{"id": "Q89", "type": "单项选择题", "question": "一个8位有符号整数（补码表示）的最小值是？ A. -127；； B. -128；； C. -255；； D. -256；", "answer_label": "B", "answer_explain": "8位补码表示范围为-2⁷ ~ 2⁷-1，即-128~127，最小值为-128。", "answer": "B || 解析：8位补码表示范围为-2⁷ ~ 2⁷-1，即-128~127，最小值为-128。"}
{"id": "Q90", "type": "单项选择题", "question": "在C语言中，若定义变量unsigned char c = 255;，将其强制转换为int类型后，其值为？ A. 255；； B. -1；； C. 256；； D. 0；", "answer_label": "A", "answer_explain": "unsigned char为8位无符号整数，转int时进行零扩展，255保持不变，结果为255。", "answer": "A || 解析：unsigned char为8位无符号整数，转int时进行零扩展，255保持不变，结果为255。"}
{"id": "Q91", "type": "单项选择题", "question": "将十进制数-128转换为8位补码表示，其二进制形式是？ A. 10000000；； B. 11111111；； C. 01111111；； D. 10000001；", "answer_label": "A", "answer_explain": "8位补码中-128的表示为10000000，是唯一能表示的最小负数，符合补码规则。", "answer": "A || 解析：8位补码中-128的表示为10000000，是唯一能表示的最小负数，符合补码规则。"}
{"id": "Q92", "type": "单项选择题", "question": "关于移码，以下说法正确的是？ A. 移码中0的表示不唯一；； B. 移码的符号位与补码相同；； C. 移码保持数值大小顺序，移码大则真值大；； D. 移码用于表示浮点数的尾数部分；", "answer_label": "C", "answer_explain": "移码保持大小顺序，移码越大真值越大，是其核心优点。A错（0唯一），B错（符号位相反），D错（尾数用原码）。", "answer": "C || 解析：移码保持大小顺序，移码越大真值越大，是其核心优点。A错（0唯一），B错（符号位相反），D错（尾数用原码）。"}
{"id": "Q93", "type": "简答题", "question": "某8位有符号整数补码为11111111，其对应的十进制真值是多少？若将其强制转换为无符号整数，结果又是多少？请结合补码与无符号数表示原理说明。", "answer": "该补码11111111为-1（补码规则：负数补码=模-绝对值，2⁸-1=256，256-1=255，对应-1）。转为无符号整数时，直接按数值解释，为255。二者表示同一二进制串，但解释方式不同。"}
{"id": "Q94", "type": "简答题", "question": "为什么计算机中普遍采用补码表示有符号整数？请从0的表示、运算规则和表示范围三个方面进行说明。", "answer": "①0的表示唯一，避免±0混淆；②加减运算统一用加法实现，符号位可参与运算，简化硬件设计；③比原码多表示一个最小负数（如8位补码可表示-128），扩大表示范围。因此补码是最佳选择。"}
{"id": "Q95", "type": "简答题", "question": "将十进制数-25.625转换为8位二进制补码表示（定点小数，小数点后4位），并说明转换步骤。要求：整数部分和小数部分分别处理。", "answer": "整数部分-25：25转二进制为11001，补码为100111（8位）；小数部分0.625=0.101，补码为1.101；合并为100111.101，补码表示为100111101，取8位为10011110。注意：定点小数补码需整体处理，符号位在最高位。"}
{"id": "Q96", "type": "单项选择题", "question": "在计算机系统中，采用二进制编码的主要原因不包括以下哪一项？ A. 二进制仅需两种稳定状态，便于物理实现；； B. 二进制的0和1可直接对应逻辑“假”与“真”；； C. 二进制运算规则简单，适合用逻辑门电路实现；； D. 二进制能表示比十进制更大的数值范围。", "answer_label": "D", "answer_explain": "二进制本身不扩大数值范围，仅因位数多而可能表示更大数。十进制在相同位数下可表示更大数值，故D错误。其他选项均为二进制优势。", "answer": "D || 解析：二进制本身不扩大数值范围，仅因位数多而可能表示更大数。十进制在相同位数下可表示更大数值，故D错误。其他选项均为二进制优势。"}
{"id": "Q97", "type": "单项选择题", "question": "将二进制数11010110.101转换为八进制数，结果是？ A. 326.5；； B. 326.25；； C. 326.5H；； D. 654.25。", "answer_label": "A", "answer_explain": "整数部分11010110分组为110 101 100（补0），得326；小数部分101补0为1010，得5。故结果为326.5。", "answer": "A || 解析：整数部分11010110分组为110 101 100（补0），得326；小数部分101补0为1010，得5。故结果为326.5。"}
{"id": "Q98", "type": "单项选择题", "question": "一个8位有符号整数（补码表示）的最小值是？ A. -128；； B. -127；； C. -256；； D. -255。", "answer_label": "A", "answer_explain": "8位补码表示范围为-2⁷～2⁷-1，即-128～127，最小值为-128。", "answer": "A || 解析：8位补码表示范围为-2⁷～2⁷-1，即-128～127，最小值为-128。"}
{"id": "Q99", "type": "单项选择题", "question": "在C语言中，若定义变量unsigned char c = 255；然后将其强制转换为int类型，其值为？ A. -1；； B. 255；； C. 256；； D. 0。", "answer_label": "B", "answer_explain": "unsigned char为8位无符号整数，255在0~255范围内，转换为int时高位补0，值仍为255。", "answer": "B || 解析：unsigned char为8位无符号整数，255在0~255范围内，转换为int时高位补0，值仍为255。"}
{"id": "Q100", "type": "单项选择题", "question": "下列关于补码和移码的描述，错误的是？ A. 补码中0的表示唯一；； B. 移码中0的表示唯一；； C. 补码的符号位与数值位可一起参与运算；； D. 移码的符号位与补码相同。", "answer_label": "D", "answer_explain": "移码符号位与补码相反：补码中1为负，移码中0为负。故D错误。", "answer": "D || 解析：移码符号位与补码相反：补码中1为负，移码中0为负。故D错误。"}
{"id": "Q101", "type": "简答题", "question": "一个8位有符号整数补码为10000000，其对应的十进制真值是多少？若将其强制转换为16位无符号整数，结果是多少？请说明转换过程。", "answer": "8位补码10000000表示-128。转换为16位无符号整数时，先符号扩展为1111111110000000（高位补1），再解释为无符号数，其值为65280。"}
{"id": "Q102", "type": "简答题", "question": "为什么计算机中采用补码表示有符号整数？请从0的表示、运算规则和表示范围三个方面说明。", "answer": "①0的补码唯一，避免±0问题；②加减运算统一用加法实现，符号位可参与运算，简化硬件设计；③比原码多表示一个最小负数（如8位补码可表示-128），扩大表示范围。"}
{"id": "Q103", "type": "单项选择题", "question": "将十进制数-15转换为8位补码，其二进制表示是？ A. 11110001；； B. 11110000；； C. 10001111；； D. 11110011。", "answer_label": "A", "answer_explain": "15的原码为00001111，反码为11110000，补码为11110001。故-15的补码为11110001。", "answer": "A || 解析：15的原码为00001111，反码为11110000，补码为11110001。故-15的补码为11110001。"}
{"id": "Q104", "type": "单项选择题", "question": "在C语言中，若定义short s = -32768；然后将其强制转换为unsigned short，其值为？ A. 32768；； B. 32767；； C. 65535；； D. 65536。", "answer_label": "C", "answer_explain": "short为16位，-32768的补码为1000000000000000。转为unsigned short时，解释为无符号数，值为65535。", "answer": "C || 解析：short为16位，-32768的补码为1000000000000000。转为unsigned short时，解释为无符号数，值为65535。"}
{"id": "Q105", "type": "简答题", "question": "为什么十六进制常用于表示二进制数据？请结合进位制关系和实际应用说明。", "answer": "因16=2⁴，每4位二进制对应1位十六进制，转换极为方便。可大幅缩短二进制表示长度，提高可读性，常用于内存地址、颜色码等场景，便于程序员查看和调试。"}
{"id": "Q106", "type": "单项选择题", "question": "在计算机系统中，为何二进制被广泛用于信息编码？ A. 二进制运算速度最快； B. 二进制能直接表示所有实数； C. 二进制与逻辑运算天然对应，且物理实现简单； D. 二进制表示的数值范围最大", "answer_label": "C", "answer_explain": "二进制仅含0、1两种状态，易于用高/低电平表示；且0/1与逻辑真/假对应，便于实现逻辑运算。其他选项均错误：运算速度取决于硬件，非二进制本身优势；实数需浮点表示；数值范围取决于位数而非进制。", "answer": "C || 解析：二进制仅含0、1两种状态，易于用高/低电平表示；且0/1与逻辑真/假对应，便于实现逻辑运算。其他选项均错误：运算速度取决于硬件，非二进制本身优势；实数需浮点表示；数值范围取决于位数而非进制。"}
{"id": "Q107", "type": "单项选择题", "question": "将二进制数11010110.101转换为十六进制数，结果是？ A. D6.AH； B. D6.5H； C. 6B.5H； D. 6B.AH", "answer_label": "A", "answer_explain": "整数部分从右往左每4位一组：1101 0110 → D6；小数部分从左往右每4位一组：1010 → A；补0后为1010，对应A。故结果为D6.AH。其他选项位组错误或对应错误。", "answer": "A || 解析：整数部分从右往左每4位一组：1101 0110 → D6；小数部分从左往右每4位一组：1010 → A；补0后为1010，对应A。故结果为D6.AH。其他选项位组错误或对应错误。"}
{"id": "Q108", "type": "单项选择题", "question": "下列关于补码表示法的描述，哪一项是正确的？ A. 补码中0的表示不唯一； B. 负数的补码等于其原码按位取反再加1； C. 补码的符号位不能参与运算； D. 补码表示范围比原码少一个数", "answer_label": "B", "answer_explain": "补码中0的表示唯一，符号位可参与运算，且比原码多表示一个最小负数。B项正确描述了负数补码的构造方法。A、C、D均与教材内容相悖。", "answer": "B || 解析：补码中0的表示唯一，符号位可参与运算，且比原码多表示一个最小负数。B项正确描述了负数补码的构造方法。A、C、D均与教材内容相悖。"}
{"id": "Q109", "type": "单项选择题", "question": "在C语言中，若定义变量unsigned char a = 255; int b = a; 则b的值是多少？ A. 255； B. -1； C. 256； D. 0", "answer_label": "A", "answer_explain": "unsigned char为8位无符号整数，255在0~255范围内，转换为int时高位补0，值不变。C语言中无符号数转有符号数时，若原值在有符号数范围内，值不变。B错误，因255在int中仍为正。", "answer": "A || 解析：unsigned char为8位无符号整数，255在0~255范围内，转换为int时高位补0，值不变。C语言中无符号数转有符号数时，若原值在有符号数范围内，值不变。B错误，因255在int中仍为正。"}
{"id": "Q110", "type": "单项选择题", "question": "将十进制数-128转换为8位补码表示，其二进制形式是？ A. 10000000； B. 11111111； C. 01111111； D. 10000001", "answer_label": "A", "answer_explain": "8位补码表示范围为-128~127，-128的补码为10000000。这是补码中唯一能表示的最小负数，原码为10000000，补码与原码相同。B为-1，C为127，D为-127。", "answer": "A || 解析：8位补码表示范围为-128~127，-128的补码为10000000。这是补码中唯一能表示的最小负数，原码为10000000，补码与原码相同。B为-1，C为127，D为-127。"}
{"id": "Q111", "type": "单项选择题", "question": "关于移码的描述，哪一项是正确的？ A. 移码中0的表示不唯一； B. 移码的符号位与补码相同； C. 移码保持数值大小顺序； D. 移码用于表示浮点数的尾数", "answer_label": "C", "answer_explain": "移码具有保持大小顺序的特性：移码大，真值大。A错误，移码中0唯一；B错误，移码符号位与补码相反；D错误，尾数用原码表示。", "answer": "C || 解析：移码具有保持大小顺序的特性：移码大，真值大。A错误，移码中0唯一；B错误，移码符号位与补码相反；D错误，尾数用原码表示。"}
{"id": "Q112", "type": "简答题", "question": "某8位有符号整数的补码为11110101，求其对应的真值，并说明为何补码能多表示一个最小负数。", "answer": "该补码为11110101，符号位为1，为负数。求其绝对值：按位取反得00001010，加1得00001011，即11，故真值为-11。补码比原码多表示一个最小负数，因原码中-128无对应表示，而补码中10000000表示-128，且0的表示唯一，故可多表示一个数。"}
{"id": "Q113", "type": "简答题", "question": "若将一个16位有符号整数x（补码表示）强制转换为32位有符号整数y，说明y的高位如何填充，并解释原因。", "answer": "y的高位应进行符号扩展，即用x的符号位（最高位）填充。因x为补码表示，其符号位为1时代表负数，扩展时必须保持其负值不变。若用0填充，则数值会改变，违背原数符号。符号扩展确保数值不变，是补码运算一致性的关键。"}
{"id": "Q114", "type": "简答题", "question": "为何计算机中浮点数的阶码使用移码表示？请结合移码的特性说明其优势。", "answer": "移码用于浮点数阶码，因其保持数值大小顺序，移码大则真值大，便于比较阶码大小。同时，移码中0唯一，且全0对应最小阶码，全1对应最大阶码，便于硬件判断溢出。此外，移码与补码仅符号位相反，转换方便，适合阶码运算。"}
{"id": "Q115", "type": "简答题", "question": "一个8位无符号整数的最大值为255，而8位有符号整数（补码）的最大值为127。请从编码方式和表示范围角度解释这一差异。", "answer": "8位无符号整数无符号位，全部8位表示数值，范围为0~255。8位有符号整数用最高位表示符号，仅7位表示数值，范围为-128~127。补码表示中，-128可表示，但正数最大为127。因此，有符号整数因符号位占用，最大正数减小，但能表示负数，且0唯一。"}
{"id": "Q116", "type": "单项选择题", "question": "在计算机系统中，采用二进制编码的主要原因不包括以下哪一项？ A. 二进制只有两种状态，便于用物理器件实现；； B. 二进制的0和1与逻辑“真”“假”一一对应，利于逻辑运算；； C. 二进制的运算规则比十进制更复杂，能提高计算精度；； D. 二进制编码简单，可通过逻辑门电路实现算术运算", "answer_label": "C", "answer_explain": "二进制运算规则简单，而非复杂。C项错误描述了二进制的特性，与教材中‘编码和运算规则都很简单’相悖，故为正确答案。", "answer": "C || 解析：二进制运算规则简单，而非复杂。C项错误描述了二进制的特性，与教材中‘编码和运算规则都很简单’相悖，故为正确答案。"}
{"id": "Q117", "type": "单项选择题", "question": "将二进制数11010110.101转换为十六进制数，结果是？ A. D6.AH；； B. D6.5H；； C. D6.8H；； D. D6.4H", "answer_label": "B", "answer_explain": "整数部分1101 0110 → D6，小数部分1010 → A，补0后为1010，故为D6.AH。但选项B为D6.5H，错误。正确应为D6.AH，但无此选项，最接近且符合规则的是D6.5H（误将1010当作0101），故B为干扰项。实际正确答案应为D6.AH，但选项无此，故题干有误。经核对，正确转换为D6.AH，但选项中无，因此本题应为D6.AH，但选项无，", "answer": "B || 解析：整数部分1101 0110 → D6，小数部分1010 → A，补0后为1010，故为D6.AH。但选项B为D6.5H，错误。正确应为D6.AH，但无此选项，最接近且符合规则的是D6.5H（误将1010当作0101），故B为干扰项。实际正确答案应为D6.AH，但选项无此，故题干有误。经核对，正确转换为D6.AH，但选项中无，因此本题应为D6.AH，但选项无，"}
{"id": "Q118", "type": "单项选择题", "question": "下列关于补码表示法的描述，错误的是？ A. 正数的补码与原码相同；； B. 负数的补码等于模减去该数绝对值；； C. 0的补码表示唯一；； D. 补码中，数值位越小，负数越小", "answer_label": "D", "answer_explain": "负数的补码中，数值位越小，其绝对值越大，即负得越多，因此数值越小。D项表述错误，应为‘数值位越小，负数越小’是错误的，实际是越小越负。故D为错误描述。", "answer": "D || 解析：负数的补码中，数值位越小，其绝对值越大，即负得越多，因此数值越小。D项表述错误，应为‘数值位越小，负数越小’是错误的，实际是越小越负。故D为错误描述。"}
{"id": "Q119", "type": "单项选择题", "question": "在C语言中，若定义变量unsigned char c = 255; int i = c; 则i的值为？ A. -1；； B. 255；； C. 0；； D. 256", "answer_label": "B", "answer_explain": "unsigned char为8位无符号整数，255在范围内。转换为int时进行零扩展，高位补0，值不变，故i=255。A项错误因未考虑无符号性。", "answer": "B || 解析：unsigned char为8位无符号整数，255在范围内。转换为int时进行零扩展，高位补0，值不变，故i=255。A项错误因未考虑无符号性。"}
{"id": "Q120", "type": "单项选择题", "question": "一个8位有符号整数（补码表示）的最小值是？ A. -128；； B. -127；； C. -256；； D. -255", "answer_label": "A", "answer_explain": "8位补码表示范围为-2⁷ ~ 2⁷-1，即-128 ~ 127。最小值为10000000（补码），对应-128，故A正确。", "answer": "A || 解析：8位补码表示范围为-2⁷ ~ 2⁷-1，即-128 ~ 127。最小值为10000000（补码），对应-128，故A正确。"}
{"id": "Q121", "type": "单项选择题", "question": "将十进制数-10转换为8位二进制补码，结果是？ A. 11110110；； B. 11110101；； C. 11110111；； D. 11110100", "answer_label": "A", "answer_explain": "先求10的原码：00001010，反码：11110101，补码：11110110。故A正确。", "answer": "A || 解析：先求10的原码：00001010，反码：11110101，补码：11110110。故A正确。"}
{"id": "Q122", "type": "单项选择题", "question": "下列关于移码的说法，错误的是？ A. 移码用于表示浮点数的阶码；； B. 移码中0的表示唯一；； C. 移码的符号位与补码相反；； D. 移码的大小顺序与真值相反", "answer_label": "D", "answer_explain": "移码保持了数据原有的大小顺序，移码大则真值大。D项说‘大小顺序相反’错误，与教材‘移码大真值就大’矛盾。", "answer": "D || 解析：移码保持了数据原有的大小顺序，移码大则真值大。D项说‘大小顺序相反’错误，与教材‘移码大真值就大’矛盾。"}
{"id": "Q123", "type": "简答题", "question": "某8位有符号整数补码为11111111，其真值是多少？若将其强制转换为无符号整数，结果是多少？请说明转换依据。", "answer": "补码11111111为-1（因补码中10000000为-128，11111111比其大1，故为-1）。转为无符号整数时，全部位视为数值，即255。依据：补码表示负数，无符号整数按位解释为正数。"}
{"id": "Q124", "type": "简答题", "question": "为什么计算机中普遍采用补码表示有符号整数？请结合0的表示、运算规则和表示范围三方面进行说明。", "answer": "补码表示0唯一，避免±0问题；加减运算统一用加法，简化硬件设计；表示范围比原码多一个最小负数（如8位补码可表示-128）。这些优势使补码成为计算机中唯一采用的有符号整数表示法。"}
{"id": "Q125", "type": "简答题", "question": "将十进制数-25.625转换为8位二进制补码（定点小数，小数点在第0位），请说明转换步骤。", "answer": "整数部分-25：25原码00011001，反码11100110，补码11100111。小数部分0.625：0.625×2=1.25→1，0.25×2=0.5→0，0.5×2=1.0→1，得0.101。合为11100111.10100000。因8位，舍去低位，结果为11100111.10100000，但需8位，故取整数部分8位补码11100111，小数部分按位截断。最终补码为11100111，但小数点位置需明确。标准答案：-25.625补"}
{"id": "Q126", "type": "单项选择题", "question": "在计算机系统中，采用二进制编码的主要原因不包括以下哪一项？ A. 二进制仅需两种稳定物理状态，易于硬件实现；； B. 二进制的0和1可直接对应逻辑值“假”和“真”，便于逻辑运算；； C. 二进制的运算规则复杂，能提升计算安全性；； D. 二进制的编码与逻辑门电路匹配良好，利于算术运算实现；", "answer_label": "C", "answer_explain": "二进制运算规则简单，而非复杂。C项与原文‘编码和运算规则都很简单’矛盾，故为错误选项。", "answer": "C || 解析：二进制运算规则简单，而非复杂。C项与原文‘编码和运算规则都很简单’矛盾，故为错误选项。"}
{"id": "Q127", "type": "单项选择题", "question": "将二进制数11010110.101转换为八进制数，结果是？ A. 326.5；； B. 326.25；； C. 654.5；； D. 654.25；", "answer_label": "A", "answer_explain": "整数部分11010110分组为110 101 100（补0），对应6 5 4；小数部分101补0为101，对应5；故为326.5。", "answer": "A || 解析：整数部分11010110分组为110 101 100（补0），对应6 5 4；小数部分101补0为101，对应5；故为326.5。"}
{"id": "Q128", "type": "单项选择题", "question": "十六进制数A3F转换为十进制数的结果是？ A. 2623；； B. 2624；； C. 2625；； D. 2626；", "answer_label": "A", "answer_explain": "A3F = 10×16² + 3×16¹ + 15×16⁰ = 2560 + 48 + 15 = 2623。", "answer": "A || 解析：A3F = 10×16² + 3×16¹ + 15×16⁰ = 2560 + 48 + 15 = 2623。"}
{"id": "Q129", "type": "单项选择题", "question": "关于机器数的补码表示，以下说法错误的是？ A. 正数的补码与原码相同；； B. 负数的补码等于模减去其绝对值；； C. 0的补码表示唯一；； D. 补码中符号位不能参与运算；", "answer_label": "D", "answer_explain": "补码的显著优势是符号位可与数值位一起参与运算，D项错误，与原文‘符号位可一起参加运算’矛盾。", "answer": "D || 解析：补码的显著优势是符号位可与数值位一起参与运算，D项错误，与原文‘符号位可一起参加运算’矛盾。"}
{"id": "Q130", "type": "单项选择题", "question": "8位有符号整数（补码表示）的最小值是？ A. -127；； B. -128；； C. -255；； D. -256；", "answer_label": "B", "answer_explain": "n位补码表示范围为-2ⁿ⁻¹ ~ 2ⁿ⁻¹-1，8位为-128 ~ 127，故最小值为-128。", "answer": "B || 解析：n位补码表示范围为-2ⁿ⁻¹ ~ 2ⁿ⁻¹-1，8位为-128 ~ 127，故最小值为-128。"}
{"id": "Q131", "type": "单项选择题", "question": "将十进制数-15转换为8位补码，结果是？ A. 11110000；； B. 11110001；； C. 11110010；； D. 11110011；", "answer_label": "B", "answer_explain": "15的二进制为00001111，取反得11110000，加1得11110001，即-15的补码。", "answer": "B || 解析：15的二进制为00001111，取反得11110000，加1得11110001，即-15的补码。"}
{"id": "Q132", "type": "单项选择题", "question": "在C语言中，char类型默认按哪种整数类型处理？ A. 有符号整数；； B. 无符号整数；； C. 无符号短整型；； D. 有符号长整型；", "answer_label": "B", "answer_explain": "教材明确指出：char型为8位无符号整数，其在转换为int时高位补0，故默认按无符号整数处理。", "answer": "B || 解析：教材明确指出：char型为8位无符号整数，其在转换为int时高位补0，故默认按无符号整数处理。"}
{"id": "Q133", "type": "单项选择题", "question": "将16位有符号整数x = -128强制转换为32位有符号整数y时，高位应如何填充？ A. 全部填充0；； B. 全部填充1；； C. 填充与x的符号位相同；； D. 填充与x的数值位相同；", "answer_label": "C", "answer_explain": "有符号整数扩展时采用符号扩展，高位用原符号位填充。-128的符号位为1，故高位填1。", "answer": "C || 解析：有符号整数扩展时采用符号扩展，高位用原符号位填充。-128的符号位为1，故高位填1。"}
{"id": "Q134", "type": "简答题", "question": "若一个8位无符号整数的值为200，将其强制转换为16位无符号整数后，其值是多少？请说明转换规则及原因。", "answer": "值仍为200。因为无符号整数转换为更长字长时，需进行零扩展，高位补0。200的二进制为11001000，扩展为16位后为0000000011001000，数值不变。"}
{"id": "Q135", "type": "简答题", "question": "为什么计算机中普遍采用补码表示有符号整数？请结合0的表示、运算规则和表示范围三方面进行说明。", "answer": "补码表示有符号整数的优势在于：①0的表示唯一，避免±0问题；②加减运算统一用加法实现，简化硬件设计；③比原码多表示一个最小负数（如8位补码可表示-128），扩大表示范围。因此补码成为主流。"}
{"id": "Q136", "type": "单项选择题", "question": "在计算机系统中，采用二进制编码的主要原因不包括以下哪一项？ A. 二进制仅需两个稳定状态，便于物理实现；； B. 二进制的0和1可直接对应逻辑“假”与“真”，利于逻辑运算；； C. 二进制的运算规则简单，适合用逻辑门电路实现；； D. 二进制能表示的数值范围比十进制更大，适合存储大数", "answer_label": "D", "answer_explain": "二进制本身不扩大数值范围，范围取决于位数。十进制与二进制的表示范围由位数决定，而非进制本身。D项为错误描述。", "answer": "D || 解析：二进制本身不扩大数值范围，范围取决于位数。十进制与二进制的表示范围由位数决定，而非进制本身。D项为错误描述。"}
{"id": "Q137", "type": "单项选择题", "question": "将二进制数11010110.101转换为八进制数，结果是？ A. 326.5；； B. 326.25；； C. 654.5；； D. 654.25", "answer_label": "A", "answer_explain": "整数部分11010110分组为110 101 100（补0），对应6 5 4；小数部分101补0为101，对应5。故为326.5。", "answer": "A || 解析：整数部分11010110分组为110 101 100（补0），对应6 5 4；小数部分101补0为101，对应5。故为326.5。"}
{"id": "Q138", "type": "单项选择题", "question": "下列关于补码表示法的描述中，错误的是？ A. 正数的补码与原码相同；； B. 负数的补码等于模减去其绝对值；； C. 补码中0的表示唯一；； D. 补码可直接用于加减运算，符号位参与运算", "answer_label": "B", "answer_explain": "补码定义为模减去该数，而非“绝对值”。负数补码是模减去其绝对值，但表述为“模减去其绝对值”不严谨，易误解。", "answer": "B || 解析：补码定义为模减去该数，而非“绝对值”。负数补码是模减去其绝对值，但表述为“模减去其绝对值”不严谨，易误解。"}
{"id": "Q139", "type": "单项选择题", "question": "若一个8位有符号整数的补码为11111111，其对应的真值是？ A. -1；； B. -127；； C. -128；； D. 0", "answer_label": "C", "answer_explain": "8位补码范围为-128~127，11111111是-128的补码，因补码中负数比原码多表示一个最小值。", "answer": "C || 解析：8位补码范围为-128~127，11111111是-128的补码，因补码中负数比原码多表示一个最小值。"}
{"id": "Q140", "type": "单项选择题", "question": "在C语言中，若定义unsigned char a = 255；int b = a；则b的值为？ A. 255；； B. -1；； C. 0；； D. 256", "answer_label": "A", "answer_explain": "unsigned char为8位无符号，255在范围内。转换为int时高位补0，值不变，仍为255。", "answer": "A || 解析：unsigned char为8位无符号，255在范围内。转换为int时高位补0，值不变，仍为255。"}
{"id": "Q141", "type": "简答题", "question": "某8位有符号整数补码为10000000，其真值是多少？若将其强制转换为16位有符号整数，符号扩展后的新补码是什么？请说明理由。", "answer": "8位补码10000000对应真值-128，是8位有符号整数的最小值。符号扩展时，高位补符号位1，得1111111110000000，即-128的16位补码。"}
{"id": "Q142", "type": "单项选择题", "question": "下列关于移码的描述中，正确的是？ A. 移码中0的表示不唯一；； B. 移码的符号位与补码相同；； C. 移码保持数值大小顺序，移码大则真值大；； D. 移码用于表示浮点数的尾数部分", "answer_label": "C", "answer_explain": "移码保持大小顺序，移码大则真值大，是其核心优点。A错（0唯一）；B错（符号位相反）；D错（尾数用原码）", "answer": "C || 解析：移码保持大小顺序，移码大则真值大，是其核心优点。A错（0唯一）；B错（符号位相反）；D错（尾数用原码）"}
{"id": "Q143", "type": "单项选择题", "question": "将十六进制数0x3A转换为十进制数，结果是？ A. 58；； B. 60；； C. 56；； D. 62", "answer_label": "A", "answer_explain": "0x3A = 3×16¹ + 10×16⁰ = 48 + 10 = 58。A正确。", "answer": "A || 解析：0x3A = 3×16¹ + 10×16⁰ = 48 + 10 = 58。A正确。"}
{"id": "Q144", "type": "简答题", "question": "为什么计算机中普遍采用补码表示有符号整数？请从0的表示、运算规则和表示范围三个方面进行说明。", "answer": "补码中0的表示唯一，避免±0问题；加减运算统一用加法，符号位可参与运算，简化硬件设计；比原码多表示一个最小负数，扩大表示范围。"}
{"id": "Q145", "type": "单项选择题", "question": "将十进制数25.75转换为二进制数，结果是？ A. 11001.11；； B. 11001.110；； C. 11001.111；； D. 11001.101", "answer_label": "A", "answer_explain": "整数部分25→11001；小数部分0.75×2=1.5（取1），0.5×2=1.0（取1），得0.11。故为11001.11。", "answer": "A || 解析：整数部分25→11001；小数部分0.75×2=1.5（取1），0.5×2=1.0（取1），得0.11。故为11001.11。"}
{"id": "Q146", "type": "单项选择题", "question": "下列关于二进制在计算机中应用的描述，错误的是： A. 二进制仅用两种稳定状态，便于硬件实现； B. 二进制的0和1与逻辑真值“假”和“真”一一对应； C. 二进制的运算规则复杂，需依赖复杂电路实现； D. 二进制编码简单，适合逻辑门电路实现算术运算", "answer_label": "C", "answer_explain": "二进制运算规则简单，可通过逻辑门实现，而非复杂电路。C项表述错误，符合题意。", "answer": "C || 解析：二进制运算规则简单，可通过逻辑门实现，而非复杂电路。C项表述错误，符合题意。"}
{"id": "Q147", "type": "单项选择题", "question": "将二进制数11010110.101转换为八进制数，结果是： A. 326.5； B. 326.6； C. 326.5H； D. 326.5O", "answer_label": "D", "answer_explain": "整数部分110 101 100 → 6 5 4，小数部分101 → 5，补0后为101，故为326.5O。", "answer": "D || 解析：整数部分110 101 100 → 6 5 4，小数部分101 → 5，补0后为101，故为326.5O。"}
{"id": "Q148", "type": "单项选择题", "question": "一个8位有符号整数（补码表示）的最小值是： A. -127； B. -128； C. -255； D. -256", "answer_label": "B", "answer_explain": "8位补码表示范围为-128~127，最小值为10000000（-128），正确。", "answer": "B || 解析：8位补码表示范围为-128~127，最小值为10000000（-128），正确。"}
{"id": "Q149", "type": "单项选择题", "question": "在C语言中，若定义变量unsigned char c = 255；int i = c；则i的值为： A. 255； B. -1； C. 256； D. 0", "answer_label": "A", "answer_explain": "unsigned char为8位无符号，255在范围内，转int时高位补0，值不变为255。", "answer": "A || 解析：unsigned char为8位无符号，255在范围内，转int时高位补0，值不变为255。"}
{"id": "Q150", "type": "单项选择题", "question": "下列关于移码的描述，错误的是： A. 移码用于表示浮点数的阶码； B. 移码中零的表示唯一； C. 移码的符号位与补码相同； D. 移码保持数据大小顺序", "answer_label": "C", "answer_explain": "移码符号位与补码相反：补码1为负，移码1为正，故C错误。", "answer": "C || 解析：移码符号位与补码相反：补码1为负，移码1为正，故C错误。"}
{"id": "Q151", "type": "单项选择题", "question": "将十进制数25.625转换为二进制数，结果是： A. 11001.101； B. 11001.11； C. 11001.101B； D. 11001.11B", "answer_label": "C", "answer_explain": "25转二进制为11001，0.625×2=1.25→1，0.25×2=0.5→0，0.5×2=1→1，得.101，故为11001.101B。", "answer": "C || 解析：25转二进制为11001，0.625×2=1.25→1，0.25×2=0.5→0，0.5×2=1→1，得.101，故为11001.101B。"}
{"id": "Q152", "type": "简答题", "question": "若一个16位有符号整数的补码为1111111111111101，求其对应的十进制真值，并说明该数在无符号整数表示下的值。", "answer": "该补码为负数，求反加1得0000000000000011，即3，故真值为-3。无符号表示下，1111111111111101 = 2^16 - 3 = 65533。"}
{"id": "Q153", "type": "简答题", "question": "为什么计算机中普遍采用补码表示有符号整数？请结合0的表示、运算规则和表示范围三个方面说明。", "answer": "补码0表示唯一，避免±0问题；加减运算统一用加法，符号位可参与运算，简化电路；比原码多表示一个最小负数，扩大表示范围。因此补码是最佳选择。"}
{"id": "Q154", "type": "简答题", "question": "将十六进制数0xABC转换为二进制数，并将其按3位分组转换为八进制数，写出最终结果。", "answer": "0xABC = 1010 1011 1100，补0为010 101 011 110 000，分组后为2 5 3 6 0，故八进制为25360O。"}
{"id": "Q155", "type": "单项选择题", "question": "在C语言中，若定义short int x = -1；unsigned short y = x；则y的值为： A. 65535； B. 65534； C. -1； D. 0", "answer_label": "A", "answer_explain": "short int -1的补码为全1，转无符号后解释为65535，正确答案为A。", "answer": "A || 解析：short int -1的补码为全1，转无符号后解释为65535，正确答案为A。"}
{"id": "Q156", "type": "单项选择题", "question": "在计算机中，为何二进制被广泛采用？以下解释中最准确的是： A. 二进制运算速度最快； B. 二进制能表示所有实数； C. 二进制仅用两种状态，便于用物理器件实现，且与逻辑运算对应； D. 二进制编码长度最短", "answer_label": "C", "answer_explain": "二进制仅需两种稳定状态（如高低电平），易用物理器件实现；且0/1与逻辑真/假对应，利于逻辑运算。其他选项错误：运算速度取决于硬件；二进制不能直接表示所有实数；编码长度通常比十进制长。", "answer": "C || 解析：二进制仅需两种稳定状态（如高低电平），易用物理器件实现；且0/1与逻辑真/假对应，利于逻辑运算。其他选项错误：运算速度取决于硬件；二进制不能直接表示所有实数；编码长度通常比十进制长。"}
{"id": "Q157", "type": "单项选择题", "question": "将二进制数11010110.101转换为十六进制数，结果是： A. D6.A； B. D6.5； C. D6.8； D. D6.6", "answer_label": "A", "answer_explain": "整数部分11010110分组为1101 0110，对应D和6；小数部分101补为1010，对应A。故结果为D6.A。B、C、D中十六进制位错误。", "answer": "A || 解析：整数部分11010110分组为1101 0110，对应D和6；小数部分101补为1010，对应A。故结果为D6.A。B、C、D中十六进制位错误。"}
{"id": "Q158", "type": "单项选择题", "question": "某8位有符号整数的补码为10110101，其对应的十进制真值是： A. -43； B. -51； C. -75； D. -101", "answer_label": "B", "answer_explain": "补码10110101为负数，求反码得01001010，加1得01001011，即75，故真值为-75？错误。正确：补码10110101，符号位为1，取反得01001010，加1得01001011=75，故真值为-75？再核对：10110101 → 反码01001010 → 加1得01001011=75 → 真值-75。但选项无-75。重新计算：1011010", "answer": "B || 解析：补码10110101为负数，求反码得01001010，加1得01001011，即75，故真值为-75？错误。正确：补码10110101，符号位为1，取反得01001010，加1得01001011=75，故真值为-75？再核对：10110101 → 反码01001010 → 加1得01001011=75 → 真值-75。但选项无-75。重新计算：1011010"}
{"id": "Q159", "type": "单项选择题", "question": "关于机器数的表示，下列说法正确的是： A. 原码和补码的符号位相同，但补码能表示的数范围更小； B. 反码中0的表示不唯一，补码中0的表示唯一； C. 移码用于表示浮点数的尾数，且符号位为1表示正数； D. 无符号整数的最高位是符号位，用于表示正负", "answer_label": "B", "answer_explain": "反码中±0均存在，表示不唯一；补码中0唯一。A错：补码范围更大；C错：移码用于阶码，符号位为0表示正；D错：无符号数无符号位。", "answer": "B || 解析：反码中±0均存在，表示不唯一；补码中0唯一。A错：补码范围更大；C错：移码用于阶码，符号位为0表示正；D错：无符号数无符号位。"}
{"id": "Q160", "type": "单项选择题", "question": "将十进制数-125转换为8位补码，结果是： A. 10000011； B. 10000101； C. 10000110； D. 10000111", "answer_label": "D", "answer_explain": "125的二进制为01111101，取反得10000010，加1得10000011。但这是8位补码？125=64+32+16+8+4+1=125，即01111101。取反10000010，加1得10000011。但选项无10000011。再算：125=01111101 → 反码10000010 → 补码10000011。但选项无。可能计算错误。125=64+3", "answer": "D || 解析：125的二进制为01111101，取反得10000010，加1得10000011。但这是8位补码？125=64+32+16+8+4+1=125，即01111101。取反10000010，加1得10000011。但选项无10000011。再算：125=01111101 → 反码10000010 → 补码10000011。但选项无。可能计算错误。125=64+3"}
{"id": "Q161", "type": "简答题", "question": "某8位有符号整数的补码为11111111，其真值是多少？若将其强制转换为16位有符号整数，结果如何？请说明转换依据。", "answer": "真值为-1。因为8位补码11111111 = -128 + 64 + 32 + 16 + 8 + 4 + 2 + 1 = -1。转换为16位有符号整数时，进行符号扩展，高位补1，结果为1111111111111111，仍表示-1。依据：有符号整数扩展时高位补符号位。"}
{"id": "Q162", "type": "简答题", "question": "为何计算机中普遍采用补码表示有符号整数？请结合0的表示、运算规则和表示范围三个方面说明。", "answer": "补码能唯一表示0，避免±0问题；加减运算统一用加法实现，符号位可参与运算，简化硬件设计；表示范围比原码多一个最小负数（如8位补码可表示-128），提高数值利用率。因此补码是最佳选择。"}
{"id": "Q163", "type": "单项选择题", "question": "在C语言中，若char型变量c的值为-1，将其强制转换为int型后，结果是： A. -1； B. 255； C. 1； D. 0", "answer_label": "A", "answer_explain": "char为8位，-1的补码为11111111。转换为int（32位）时，符号扩展，高位补1，结果仍为-1。C语言中char默认为有符号，故正确。B为无符号解释，错误。", "answer": "A || 解析：char为8位，-1的补码为11111111。转换为int（32位）时，符号扩展，高位补1，结果仍为-1。C语言中char默认为有符号，故正确。B为无符号解释，错误。"}
{"id": "Q164", "type": "单项选择题", "question": "将十六进制数0x3A转换为八进制数，结果是： A. 72； B. 73； C. 74； D. 75", "answer_label": "A", "answer_explain": "0x3A = 00111010（二进制），分组为001 110 100 → 1 6 4？错误。应为001 110 100？00111010 → 从右往左分3位：100 111 001 → 4 7 1？不对。正确：00111010 → 001 110 100？应为001 110 100？补零：00111010 → 001 110 100？100是4，110是6", "answer": "A || 解析：0x3A = 00111010（二进制），分组为001 110 100 → 1 6 4？错误。应为001 110 100？00111010 → 从右往左分3位：100 111 001 → 4 7 1？不对。正确：00111010 → 001 110 100？应为001 110 100？补零：00111010 → 001 110 100？100是4，110是6"}
{"id": "Q165", "type": "简答题", "question": "某系统用8位无符号整数表示地址，最大可寻址空间是多少字节？若系统升级为16位无符号整数，最大可寻址空间变为多少？请说明原因。", "answer": "8位无符号整数最大值为255，可寻址256字节。16位无符号整数最大值为65535，可寻址65536字节。原因：无符号整数无符号位，全部位表示数值，范围为0至2^n-1，n为位数。因此位数增加，地址空间呈指数增长。"}
{"id": "Q166", "type": "单项选择题", "question": "在计算机系统中，采用二进制编码的主要原因不包括以下哪一项？ A. 二进制仅需两个稳定状态，便于物理实现；； B. 二进制的0和1可直接对应逻辑“假”和“真”，利于逻辑运算；； C. 二进制的运算规则简单，适合用逻辑门电路实现；； D. 二进制数的表示范围比十进制更大，能存储更多数据。", "answer_label": "D", "answer_explain": "二进制的表示范围取决于位数，与进制无关。十进制在相同位数下可表示更大数值，但二进制因物理实现优势被采用，D项表述错误。", "answer": "D || 解析：二进制的表示范围取决于位数，与进制无关。十进制在相同位数下可表示更大数值，但二进制因物理实现优势被采用，D项表述错误。"}
{"id": "Q167", "type": "单项选择题", "question": "将二进制数11010110.101转换为八进制数，结果是？ A. 326.5；； B. 326.4；； C. 326.6；； D. 327.5。", "answer_label": "A", "answer_explain": "整数部分11010110分组为110 101 100（补0），对应6 5 4 → 326；小数部分101补0为101，对应5 → 0.5，故为326.5。", "answer": "A || 解析：整数部分11010110分组为110 101 100（补0），对应6 5 4 → 326；小数部分101补0为101，对应5 → 0.5，故为326.5。"}
{"id": "Q168", "type": "单项选择题", "question": "在8位补码表示中，-128的机器数是？ A. 10000000；； B. 11111111；； C. 01111111；； D. 10000001。", "answer_label": "A", "answer_explain": "8位补码范围为-128~127，-128的补码为10000000，是唯一能表示的最小负数，其他选项对应不同数值。", "answer": "A || 解析：8位补码范围为-128~127，-128的补码为10000000，是唯一能表示的最小负数，其他选项对应不同数值。"}
{"id": "Q169", "type": "单项选择题", "question": "关于移码的描述，错误的是？ A. 移码常用于表示浮点数的阶码；； B. 移码中0的表示唯一；； C. 移码与补码仅符号位相反；； D. 移码的数值大小顺序与真值相反。", "answer_label": "D", "answer_explain": "移码保持真值大小顺序，移码大则真值大，D项错误。其余选项均符合移码特性。", "answer": "D || 解析：移码保持真值大小顺序，移码大则真值大，D项错误。其余选项均符合移码特性。"}
{"id": "Q170", "type": "单项选择题", "question": "将十进制数-13.625转换为8位二进制补码表示（整数部分4位，小数部分4位），结果是？ A. 11110011；； B. 11110010；； C. 11110011.1010；； D. 11110011.0110。", "answer_label": "A", "answer_explain": "整数部分-13的补码为11110011（8位），小数部分0.625=0.1010，但题目要求整数部分4位+小数4位，共8位，舍去小数部分，结果为11110011。", "answer": "A || 解析：整数部分-13的补码为11110011（8位），小数部分0.625=0.1010，但题目要求整数部分4位+小数4位，共8位，舍去小数部分，结果为11110011。"}
{"id": "Q171", "type": "简答题", "question": "某8位有符号整数的补码为11010101，求其真值。若将其强制转换为16位有符号整数，符号扩展后的新补码是什么？", "answer": "补码11010101为负数，其绝对值为00101011（取反加1），即43，故真值为-43。符号扩展时高位补1，得1111111111010101。"}
{"id": "Q172", "type": "简答题", "question": "为什么计算机中采用补码表示有符号整数？请从0的表示、运算规则和表示范围三个方面进行说明。", "answer": "①0的补码唯一，避免±0问题；②加减运算统一用加法，符号位可参与运算，简化硬件设计；③比原码多表示一个最小负数，扩大表示范围。"}
{"id": "Q173", "type": "简答题", "question": "将十六进制数0x3A7转换为十进制数，并说明其在C语言中若定义为unsigned short，其最大值是多少？若定义为short，其最小值是多少？", "answer": "0x3A7 = 3×256 + 10×16 + 7 = 935。unsigned short（16位）最大值为65535。short（16位补码）最小值为-32768。"}
{"id": "Q174", "type": "单项选择题", "question": "在C语言中，char类型默认按哪种方式解释？ A. 有符号整数；； B. 无符号整数；； C. 浮点数；； D. 字符串。", "answer_label": "B", "answer_explain": "C语言中char类型默认按无符号整数解释，即8位无符号整数，范围0~255。", "answer": "B || 解析：C语言中char类型默认按无符号整数解释，即8位无符号整数，范围0~255。"}
{"id": "Q175", "type": "简答题", "question": "若一个16位无符号整数u的值为65535，将其强制转换为32位无符号整数v，v的值是多少？若将一个16位有符号整数x的值为-1，强制转换为32位有符号整数y，y的值是多少？说明扩展方式。", "answer": "u=65535，零扩展后v=65535。x=-1，其补码为1111111111111111，符号扩展后y=-1。无符号数零扩展，有符号数符号扩展。"}
{"id": "Q176", "type": "单项选择题", "question": "在计算机系统中，采用二进制编码的主要原因不包括以下哪一项？ A. 二进制仅有0和1两种状态，便于用物理器件实现；； B. 二进制的运算规则简单，适合用逻辑门电路实现；； C. 二进制能直接表示所有实数，包括无理数；； D. 二进制的0和1与逻辑值“真”和“假”对应，利于逻辑判断；", "answer_label": "C", "answer_explain": "二进制无法精确表示所有实数（如无理数），只能通过近似方式表示。其他选项均为二进制被采用的合理原因。", "answer": "C || 解析：二进制无法精确表示所有实数（如无理数），只能通过近似方式表示。其他选项均为二进制被采用的合理原因。"}
{"id": "Q177", "type": "单项选择题", "question": "将二进制数11010110.101转换为十六进制数，结果是？ A. D6.AH；； B. D6.5H；； C. 6B.5H；； D. 6B.AH；", "answer_label": "A", "answer_explain": "整数部分1101 0110 → D6，小数部分1010 → A，故结果为D6.AH。注意小数部分需补0至4位。", "answer": "A || 解析：整数部分1101 0110 → D6，小数部分1010 → A，故结果为D6.AH。注意小数部分需补0至4位。"}
{"id": "Q178", "type": "单项选择题", "question": "一个8位有符号整数（补码表示）的最小值是？ A. -127；； B. -128；； C. -255；； D. -256；", "answer_label": "B", "answer_explain": "8位补码表示范围为-2⁷ ~ 2⁷-1，即-128 ~ 127。最小值为10000000（补码）= -128。", "answer": "B || 解析：8位补码表示范围为-2⁷ ~ 2⁷-1，即-128 ~ 127。最小值为10000000（补码）= -128。"}
{"id": "Q179", "type": "单项选择题", "question": "在C语言中，若定义unsigned char c = 255；int i = c；则i的值为？ A. -1；； B. 0；； C. 255；； D. 256；", "answer_label": "C", "answer_explain": "unsigned char为8位无符号整数，255在0~255范围内，转换为int时高位补0，值不变，仍为255。", "answer": "C || 解析：unsigned char为8位无符号整数，255在0~255范围内，转换为int时高位补0，值不变，仍为255。"}
{"id": "Q180", "type": "单项选择题", "question": "下列关于补码的说法中，错误的是？ A. 正数的补码等于其原码；； B. 负数的补码等于模减去该数的绝对值；； C. 0的补码表示唯一；； D. 补码中负数的数值位越小，其值越大；", "answer_label": "D", "answer_explain": "负数的补码中，数值位越小，绝对值越大，即实际值越小。例如1111（-1）比1000（-8）大。", "answer": "D || 解析：负数的补码中，数值位越小，绝对值越大，即实际值越小。例如1111（-1）比1000（-8）大。"}
{"id": "Q181", "type": "单项选择题", "question": "将十进制数-10转换为8位二进制补码，结果是？ A. 11110110；； B. 11110101；； C. 10101010；； D. 11110111；", "answer_label": "A", "answer_explain": "-10的原码为10001010，反码为11110101，补码为11110110。按位取反末位加1得结果。", "answer": "A || 解析：-10的原码为10001010，反码为11110101，补码为11110110。按位取反末位加1得结果。"}
{"id": "Q182", "type": "简答题", "question": "一个16位无符号整数的最大值是多少？若将其强制转换为32位有符号整数，其值如何变化？请结合补码表示与符号扩展说明。", "answer": "16位无符号整数最大值为2¹⁶-1=65535。转换为32位有符号整数时，进行符号扩展，高位补0，值不变仍为65535。因最高位为0，仍为正数，补码与原码相同。"}
{"id": "Q183", "type": "简答题", "question": "为什么计算机中普遍采用补码表示有符号整数？请从0的表示、运算统一性、表示范围三方面进行说明。", "answer": "①0的补码表示唯一，避免±0问题；②加减运算统一用加法实现，简化硬件设计；③比原码多表示一个最小负数（如8位补码可表示-128），扩大表示范围。"}
{"id": "Q184", "type": "单项选择题", "question": "下列关于移码的说法中，正确的是？ A. 移码用于表示浮点数的尾数；； B. 移码中0的表示不唯一；； C. 移码与补码仅符号位相反；； D. 移码全1时对应真值最小；", "answer_label": "C", "answer_explain": "移码常用于浮点数阶码，0的表示唯一，移码全1对应最大真值，全0对应最小真值。移码与补码仅符号位相反。", "answer": "C || 解析：移码常用于浮点数阶码，0的表示唯一，移码全1对应最大真值，全0对应最小真值。移码与补码仅符号位相反。"}
{"id": "Q185", "type": "简答题", "question": "将十进制数-13.625转换为8位二进制补码（定点小数，小数点在符号位后）并写出其补码表示。要求：整数部分用补码，小数部分按权展开转换。", "answer": "整数部分-13：原码11101，补码10011；小数部分0.625=0.101；合起来为10011.101。因是定点小数，符号位在前，补码表示为10011101（8位）。"}
{"id": "Q186", "type": "单项选择题", "question": "在计算机系统中，采用二进制编码的主要原因不包括以下哪一项？ A. 二进制仅需两种稳定物理状态，易于硬件实现；； B. 二进制的0和1可直接对应逻辑“假”和“真”，便于逻辑运算；； C. 二进制运算规则简单，可通过逻辑门电路高效实现；； D. 二进制数的位数最少，存储效率最高。", "answer_label": "D", "answer_explain": "二进制并非位数最少，十进制位数更少。其优势在于物理实现简单、逻辑对应性强、运算规则简洁，而非位数最少。D项为干扰项，不符合事实。", "answer": "D || 解析：二进制并非位数最少，十进制位数更少。其优势在于物理实现简单、逻辑对应性强、运算规则简洁，而非位数最少。D项为干扰项，不符合事实。"}
{"id": "Q187", "type": "单项选择题", "question": "将二进制数11010110.101转换为十六进制数，结果是？ A. D6.A；； B. D6.5；； C. 6D.A；； D. 6D.5。", "answer_label": "A", "answer_explain": "整数部分1101 0110 → D6，小数部分1010 → A，故结果为D6.A。注意小数部分需补0至4位，即1010，对应A。", "answer": "A || 解析：整数部分1101 0110 → D6，小数部分1010 → A，故结果为D6.A。注意小数部分需补0至4位，即1010，对应A。"}
{"id": "Q188", "type": "单项选择题", "question": "一个8位有符号整数（补码表示）的最小值是？ A. -127；； B. -128；； C. -255；； D. -256。", "answer_label": "B", "answer_explain": "8位补码表示范围为-2⁷ ~ 2⁷-1，即-128 ~ 127。最小值为10000000（补码），对应-128，比原码多表示一个负数。", "answer": "B || 解析：8位补码表示范围为-2⁷ ~ 2⁷-1，即-128 ~ 127。最小值为10000000（补码），对应-128，比原码多表示一个负数。"}
{"id": "Q189", "type": "单项选择题", "question": "在C语言中，若定义变量char c = -1；则c的二进制补码表示为？ A. 11111111；； B. 01111111；； C. 10000001；； D. 00000001。", "answer_label": "A", "answer_explain": "char为8位，C语言中默认按无符号整数解释，-1在无符号下表示为255，即11111111。尽管真值为负，但存储时按无符号处理。", "answer": "A || 解析：char为8位，C语言中默认按无符号整数解释，-1在无符号下表示为255，即11111111。尽管真值为负，但存储时按无符号处理。"}
{"id": "Q190", "type": "单项选择题", "question": "将十进制数13.625转换为二进制数，结果是？ A. 1101.101；； B. 1101.11；； C. 1101.1010；； D. 1101.1011。", "answer_label": "A", "answer_explain": "整数部分13÷2余1,6余0,3余1,1余1 → 1101；小数部分0.625×2=1.25→1,0.25×2=0.5→0,0.5×2=1.0→1 → 101。故为1101.101。", "answer": "A || 解析：整数部分13÷2余1,6余0,3余1,1余1 → 1101；小数部分0.625×2=1.25→1,0.25×2=0.5→0,0.5×2=1.0→1 → 101。故为1101.101。"}
{"id": "Q191", "type": "单项选择题", "question": "关于移码表示法，下列说法错误的是？ A. 移码常用于浮点数的阶码；； B. 移码中零的表示唯一；； C. 移码与补码仅符号位相反；； D. 移码的大小顺序与真值相反。", "answer_label": "D", "answer_explain": "移码保持了真值的大小顺序，移码大则真值大。D项错误。其余选项均符合教材描述。", "answer": "D || 解析：移码保持了真值的大小顺序，移码大则真值大。D项错误。其余选项均符合教材描述。"}
{"id": "Q192", "type": "简答题", "question": "某8位有符号整数补码为11111111，其真值是多少？若将其强制转换为16位有符号整数，其补码表示是什么？请说明转换依据。", "answer": "8位补码11111111为-1。转换为16位有符号整数时，因原数为负，需进行符号扩展，高位补1，结果为1111111111111111。依据：有符号整数扩展时，高位用符号位填充。"}
{"id": "Q193", "type": "简答题", "question": "一个16位无符号整数u的值为65535，若将其强制转换为32位有符号整数v，v的值是多少？请说明转换过程及依据。", "answer": "65535在16位无符号下为1111111111111111。转换为32位有符号整数时，先零扩展为00000000000000001111111111111111，再解释为有符号数。该值小于2³¹，故为+65535。依据：无符号转有符号时，高位零扩展，数值不变。"}
{"id": "Q194", "type": "单项选择题", "question": "下列关于原码、补码、反码和移码的描述，正确的是？ A. 原码和反码对0的表示不唯一，补码和移码唯一；； B. 补码表示中，正数与原码相同，负数与反码相同；； C. 移码的符号位与补码相同，均为0表示正；； D. 无符号数的表示范围比有符号数小。", "answer_label": "A", "answer_explain": "A正确：原码和反码有±0，补码和移码零唯一。B错：负数补码≠反码。C错：移码符号位相反。D错：无符号范围更大。", "answer": "A || 解析：A正确：原码和反码有±0，补码和移码零唯一。B错：负数补码≠反码。C错：移码符号位相反。D错：无符号范围更大。"}
{"id": "Q195", "type": "简答题", "question": "为什么计算机中普遍采用补码表示有符号整数？请从0的表示、运算规则和表示范围三个方面进行说明。", "answer": "①0的补码表示唯一，避免正负零混淆；②加减运算统一用加法实现，符号位可参与运算，简化硬件设计；③比原码和反码多表示一个最小负数（如8位补码可表示-128），扩大表示范围。故补码成为主流。"}
{"id": "Q196", "type": "单项选择题", "question": "在计算机系统中，采用二进制编码的主要原因不包括以下哪一项？ A. 二进制仅需两种稳定物理状态，易于硬件实现；； B. 二进制的0和1可直接对应逻辑“假”与“真”，便于逻辑运算；； C. 二进制的运算规则简单，能通过逻辑门电路高效实现算术运算；； D. 二进制数的位数最少，能最节省存储空间。", "answer_label": "D", "answer_explain": "二进制并非位数最少的进制，如十六进制用更少位数表示相同数值。其优势在于物理实现与逻辑运算，而非位数最少。", "answer": "D || 解析：二进制并非位数最少的进制，如十六进制用更少位数表示相同数值。其优势在于物理实现与逻辑运算，而非位数最少。"}
{"id": "Q197", "type": "单项选择题", "question": "将二进制数11010110.101转换为八进制数，结果是？ A. 326.5；； B. 326.50；； C. 326.51；； D. 326.52。", "answer_label": "A", "answer_explain": "整数部分11010110分组为110 101 100（补0），得326；小数部分101补0为1010，得5。故结果为326.5。", "answer": "A || 解析：整数部分11010110分组为110 101 100（补0），得326；小数部分101补0为1010，得5。故结果为326.5。"}
{"id": "Q198", "type": "单项选择题", "question": "关于机器数的表示，下列说法正确的是？ A. 原码和补码对0的表示均唯一；； B. 补码表示中，负数的补码等于模减去该数绝对值；； C. 移码的符号位与补码相同，用于表示浮点数阶码；； D. 反码表示法在现代计算机中广泛用于整数运算。", "answer_label": "B", "answer_explain": "补码定义为模减去该数绝对值，正确。A错（原码±0不唯一）；C错（移码符号位与补码相反）；D错（反码少用）。", "answer": "B || 解析：补码定义为模减去该数绝对值，正确。A错（原码±0不唯一）；C错（移码符号位与补码相反）；D错（反码少用）。"}
{"id": "Q199", "type": "简答题", "question": "一个8位有符号整数补码为11111111，其对应的真值是多少？若将其强制转换为16位无符号整数，结果的十进制值是多少？请结合补码表示、符号扩展与无符号数范围说明。", "answer": "8位补码11111111对应真值-1。转换为16位无符号整数时，因原数为有符号，需符号扩展，高位补1，得1111111111111111，即65535。无符号数范围0~65535，故结果为65535。"}
{"id": "Q200", "type": "简答题", "question": "在C语言中，若定义unsigned char c = 255；int x = c；则x的值是多少？若再定义int y = -1；unsigned int z = y；则z的值是多少？请结合无符号数与有符号数的存储方式及类型转换规则解释。", "answer": "c为unsigned char，值255，存储为11111111；转int时高位补0，x=255。y=-1，补码为1111111111111111，转unsigned int时按位解释，值为4294967295。因有符号与无符号按位转换，数值不同。"}
