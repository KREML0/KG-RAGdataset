{
    "id": "2.1.5-01",
    "type": "单项选择题",
    "question": "若十进制数为137.5,则其八进制数为( )。 A. 89.8 B. 211.4 C. 211.5 D. 1011111.101",
    "answer_label": "B",
    "answer_explain": "十进制数转换成八进制数,整数部分采用除基取余法:将整数除以8,所得余数即为转换后的八进制数个位上的数码,再将商除以8,余数为八进制数十位上的数码,如此反复进行,直到商是0为止。小数部分采用乘基取整法:将小数乘以8,所得积的整数部分即为八进制数十分位上的数码,再将此积的小数部分乘以8,得到百分位上的数码,如此反复直到积是1.0为止。经转换得到的八进制数为211.4。",
    "answer": "B || 解析：十进制数转换成八进制数,整数部分采用除基取余法:将整数除以8,所得余数即为转换后的八进制数个位上的数码,再将商除以8,余数为八进制数十位上的数码,如此反复进行,直到商是0为止。小数部分采用乘基取整法:将小数乘以8,所得积的整数部分即为八进制数十分位上的数码,再将此积的小数部分乘以8,得到百分位上的数码,如此反复直到积是1.0为止。经转换得到的八进制数为211.4。"
  },
  {
    "id": "2.1.5-02",
    "type": "单项选择题",
    "question": "一个16位无符号二进制数的表示范围是()。 A. 0~65536 B. 0~65535 C. -32768~32767 D. -32768~32768",
    "answer_label": "B",
    "answer_explain": "一个16位无符号二进制数的表示范围是0~2^16-1,即0~65535。",
    "answer": "B || 解析：一个16位无符号二进制数的表示范围是0~2^16-1,即0~65535。"
  },
  {
    "id": "2.1.5-03",
    "type": "单项选择题",
    "question": "下列说法有误的是()。 A. 任何二进制整数都可以用十进制表示 B. 任何二进制小数都可以用十进制表示 C. 任何十进制整数都可以用二进制表示 D. 任何十进制小数都可以用二进制表示",
    "answer_label": "D",
    "answer_explain": "选项A、B、C明显正确,二进制整数和十进制整数可以相互转换,仅仅是每位的位权不同而已。而二进制数的小数位只能表示1/2,1/4,1/8,…,1/2^n,因此无法表示所有的十进制小数,选项D错误。",
    "answer": "D || 解析：选项A、B、C明显正确,二进制整数和十进制整数可以相互转换,仅仅是每位的位权不同而已。而二进制数的小数位只能表示1/2,1/4,1/8,…,1/2^n,因此无法表示所有的十进制小数,选项D错误。"
  },
  {
    "id": "2.1.5-04",
    "type": "单项选择题",
    "question": "对真值0表示形式唯一的机器数是()。 A. 原码 B. 补码和移码 C. 反码 D. 以上都不对",
    "answer_label": "B",
    "answer_explain": "假设位数为5位(含1位符号位),[+0]原=00000,[-0]原=10000。[+0]反=00000,[-0]反=11111。[+0]补=[-0]补=00000,[+0]移=[-0]移=10000。可知,0的补码和移码的表示是唯一的。",
    "answer": "B || 解析：假设位数为5位(含1位符号位),[+0]原=00000,[-0]原=10000。[+0]反=00000,[-0]反=11111。[+0]补=[-0]补=00000,[+0]移=[-0]移=10000。可知,0的补码和移码的表示是唯一的。"
  },
  {
    "id": "2.1.5-05",
    "type": "单项选择题",
    "question": "若 $[X]_{补}=1.1101010$,则 $[X]_{原}=()$。 A. 1.0010101 B. 1.0010110 C. 0.0010110 D. 0.1101010",
    "answer_label": "B",
    "answer_explain": "若X为负数,则其补码转换成原码的规则是“符号位不变,数值位取反,末位加1”,即数值位 1101010 取反得 0010101,末位加1得 0010110。所以 $[X]_{原}=1.0010110$。",
    "answer": "B || 解析：若X为负数,则其补码转换成原码的规则是“符号位不变,数值位取反,末位加1”,即数值位 1101010 取反得 0010101,末位加1得 0010110。所以 $[X]_{原}=1.0010110$。"
  },
  {
    "id": "2.1.5-06",
    "type": "单项选择题",
    "question": "若X为负数,则由[X]补求[-X]补是将()。 A. [X]补各值保持不变 B. [X]补符号位变反,其他各位不变 C. [X]补除符号位外,各位变反,末位加1 D. [X]补连同符号位一起变反,末位加1",
    "answer_label": "D",
    "answer_explain": "不论X是正数还是负数,由[X]补求[-X]补的方法是连同符号位一起,每位取反,末位加1。",
    "answer": "D || 解析：不论X是正数还是负数,由[X]补求[-X]补的方法是连同符号位一起,每位取反,末位加1。"
  },
  {
    "id": "2.1.5-07",
    "type": "单项选择题",
    "question": "8位原码能表示的不同数据有()个。 A. 15 B. 16 C. 255 D. 256",
    "answer_label": "C",
    "answer_explain": "8个二进制位有 $2^8=256$ 种不同表示。原码中0有两种表示,因此原码能表示的不同数据为 $2^8-1=255$ 个。0在反码中也有两种表示,因此若题目改为反码,答案也为选项C。0在补码与移码中只有一种表示,因此题目若改为补码或移码,答案为选项D。",
    "answer": "C || 解析：8个二进制位有 $2^8=256$ 种不同表示。原码中0有两种表示,因此原码能表示的不同数据为 $2^8-1=255$ 个。0在反码中也有两种表示,因此若题目改为反码,答案也为选项C。0在补码与移码中只有一种表示,因此题目若改为补码或移码,答案为选项D。"
  },
  {
    "id": "2.1.5-08",
    "type": "单项选择题",
    "question": "一个n+1位整数x原码的数值范围是( )。 A. $-2^n+1 < x < 2^n-1$ B. $-2^n+1 \\le x < 2^n-1$ C. $-2^n+1 < x \\le 2^n-1$ D. $-2^n+1 \\le x \\le 2^n-1$",
    "answer_label": "D",
    "answer_explain": "n+1位整数原码的表示范围为 $-(2^n-1) \\le x \\le 2^n-1$, 即 $-2^n+1 \\le x \\le 2^n-1$。",
    "answer": "D || 解析：n+1位整数原码的表示范围为 $-(2^n-1) \\le x \\le 2^n-1$, 即 $-2^n+1 \\le x \\le 2^n-1$。"
  },
  {
    "id": "2.1.5-09",
    "type": "单项选择题",
    "question": "n位定点整数(有符号)表示的最大值是()。 A. $2^n$ B. $2^n-1$ C. $2^{n-1}$ D. $2^{n-1}-1$",
    "answer_label": "D",
    "answer_explain": "n位二进制有符号定点整数,数值位只有 n-1 位,最高位为符号位,所以最大值为 $2^{n-1}-1$。",
    "answer": "D || 解析：n位二进制有符号定点整数,数值位只有 n-1 位,最高位为符号位,所以最大值为 $2^{n-1}-1$。"
  },
  {
    "id": "2.1.5-10",
    "type": "单项选择题",
    "question": "对于相同位数(设为N位,不考虑符号位)的二进制补码小数和十进制小数,二进制小数能表示的数的个数/十进制小数所能表示数的个数为( )。 A. $(0.2)^N$ B. $(0.2)^{N-1}$ C. $(0.02)^N$ D. $(0.02)^{N-1}$",
    "answer_label": "A",
    "answer_explain": "N位二进制小数共有 $2^N$ 种状态,每种状态都能表示一个不同的小数,而N位十进制小数能表示的数的个数为 $10^N$,二者的商为 $2^N / 10^N = (2/10)^N = (0.2)^N$。这也是为何在计算机的运算中会出现误差情况的原因,它表明仅有 $(0.2)^N$ 概率的十进制数可以精确地用二进制数表示。",
    "answer": "A || 解析：N位二进制小数共有 $2^N$ 种状态,每种状态都能表示一个不同的小数,而N位十进制小数能表示的数的个数为 $10^N$,二者的商为 $2^N / 10^N = (2/10)^N = (0.2)^N$。这也是为何在计算机的运算中会出现误差情况的原因,它表明仅有 $(0.2)^N$ 概率的十进制数可以精确地用二进制数表示。"
  },
  {
    "id": "2.1.5-11",
    "type": "单项选择题",
    "question": "若定点整数为64位,含1位符号位,则采用补码表示的绝对值最大的负数为( )。 A. $-2^{64}$ B. $-(2^{64}-1)$ C. $-2^{63}$ D. $-(2^{63}-1)$",
    "answer_label": "C",
    "answer_explain": "对于长度为 n+1 (含1位符号位)定点整数x,用补码表示时,x的最小值(绝对值最大的负数)为 $-2^n$,其中 $n=63$。",
    "answer": "C || 解析：对于长度为 n+1 (含1位符号位)定点整数x,用补码表示时,x的最小值(绝对值最大的负数)为 $-2^n$,其中 $n=63$。"
  },
  {
    "id": "2.1.5-12",
    "type": "单项选择题",
    "question": "下列关于补码和移码关系的叙述中,( )是不正确的。 A. 相同位数的补码和移码表示具有相同的数据表示范围 B. 0的补码和移码表示相同 C. 同一个数的补码和移码表示,其数值部分相同,而符号相反 D. 一般用移码表示浮点数的阶码,而补码表示定点整数",
    "answer_label": "B",
    "answer_explain": "以机器字长5位为例, $[0]_{补}=00000$, $[0]_{移}=2^4+0=10000$, $[0]_{补}\\ne[0]_{移}$,表示不相同,但在补码或移码中的表示形式是唯一的。",
    "answer": "B || 解析：以机器字长5位为例, $[0]_{补}=00000$, $[0]_{移}=2^4+0=10000$, $[0]_{补}\\ne[0]_{移}$,表示不相同,但在补码或移码中的表示形式是唯一的。"
  },
  {
    "id": "2.1.5-13",
    "type": "单项选择题",
    "question": "若 $[x]_{补}=1.x_1x_2x_3x_4x_5x_6$,其中x_i取0或1,若要x>-32,应当满足()。 A. $x_1$为0,其他各位任意 B. $x_1$为1,其他各位任意 C. $x_1$为1,$x_2$~$x_6$中至少有一位为1 D. $x_1$为0,$x_2$~$x_6$中至少有一位为1",
    "answer_label": "C",
    "answer_explain": "对于此类题型,先写出特定值的机器码表示,然后根据机器数判断大小的规则来推导数值位的特点(若条件允许,也可以取特殊值来推断)。-32的补码(假设整数，字长7位含符号位)为 $1000000$。这里是小数，假设字长7位，表示范围是 $[-1, 1)$。-32超出范围。 假设题目指整数，字长7位。$-32$的补码是 $1000000$。根据负数补码判断大小的规则:数值位部分越小,其绝对值越大,即负得越多。若要 $x>-32$，则 $x$ 的补码 $1.x_1x_2x_3x_4x_5x_6$ 对应的数值位 $x_1x_2x_3x_4x_5x_6$ 必须大于 $000000$。这意味着 $x_1x_2x_3x_4x_5x_6$ 不能全为0。由于符号位是1, x是负数。-32的7位补码是1000000。要 x > -32，补码要大于1000000。因此 $1.x_1...x_6 > 1.000000$。对于负数补码比较，数值部分越大，真值越大（越接近0）。所以 $x_1...x_6$ 要大于 $000000$。即 $x_1...x_6$ 不全为0。但是选项是关于$x_1$到$x_6$的。 换种思路，-32的补码是1000000 (7位)。若要x > -32, 则x的范围是 [-31, -1]。补码表示是 [1000001, 1111111]。数值位 $x_1...x_6$ 的范围是 [000001, 111111]。因此 $x_1...x_6$ 中至少有一位是1。如果$x_1=1$，则 $1.1xxxxxx$ 范围是 $[-16, -1]$，满足条件。如果 $x_1=0$，则 $1.0xxxxx$ 范围是 $[-32, -17]$。要大于-32，则 $x_2...x_6$ 中至少要有一位是1。综合起来，$x_1...x_6$ 至少有一位为1。选项C $x_1=1$ 时，$1.1xxxxxx$ 肯定大于 $1.000000$ (-32)，满足条件。选项D $x_1=0$ 时，$1.0xxxxxx$。若 $x_2...x_6$ 至少一位为1，则大于 $1.000000$ (-32)，也满足。 C选项更严格。再审题，题目用的是小数点，可能是小数。假设是7位补码小数，范围[-1, 1)。 $1.x_1...x_6$ 表示负数。-32这个值没有意义。 假设题目意指7位整数补码。$-32$的补码是 $1000000$。要 $x > -32$, x的补码要大于 $1000000$。即 $1.x_1x_2x_3x_4x_5x_6 > 1.000000$。比较补码大小，符号位相同，比较数值位。$x_1x_2x_3x_4x_5x_6 > 000000$。即数值位不能全0。选项C：$x_1=1$，则 $1.1xxxxx > 1.000000$ 成立。选项D：$x_1=0$，则 $1.0xxxxx$。若 $x_2..x_6$ 至少一位为1，则 $1.0xxxxx > 1.000000$ 成立。选项C ($x_1=1$) 是充分条件，但不是必要条件。选项D ($x_1=0$ 且后面不全0) 也是充分条件。 C和D合起来是 $x_1...x_6$ 不全为0。 C选项似乎更接近答案的逻辑。 【特殊值法】对于选项A,取1.000000,真值为-32,错误。对于选项B,取1.100000,真值为-16,符合 $x>-32$。对于选项C, $x_1$为1,$x_2$~$x_6$中至少有一位为1, 例如取1.100001,真值为-15,符合。若取1.100000，真值为-16，也符合。选项C包含B。对于选项D, $x_1$为0,$x_2$~$x_6$中至少有一位为1, 例如取1.000001,真值为-31,符合。 根据答案解析的思路：-32的补码为1.000000 (书中答案解析用了小数形式但值是整数)。要x > -32，补码值要大于1.000000。若 $x_1=1$, 则 $1.1xxxxx$ 表示的数在 $[-16, -1]$ 之间，大于-32。若 $x_1=0$, 则 $1.0xxxxx$ 表示的数在 $[-32, -17]$ 之间。要大于-32，则 $x_2...x_6$ 不能全为0，即至少有一位为1。所以条件是 $x_1=1$ 或者 ($x_1=0$ 且 $x_2...x_6$ 不全为0)。选项C是其中一种情况。选项D是另一种情况。但答案只选了C。可能是题目理解有偏差，或者选项本身设置问题。但按照解析，它推导出的条件是 $x_1$ 必须为1, 而 $x_2..x_6$ 中至少有一位为1。这与标准补码比较规则不符。 重新看答案解析的推导："-32的补码为1,100000 (7位整数补码)。...若要x>-32, 数值位 $x_1x_2x_3x_4x_5x_6$ 需大于100000 (这里可能有误，应为大于000000), 即 $x_1$ 必须为1, 而 $x_2..x_6$ 中至少有一位为1。" 这个推导过程有问题。大于100000 这个结论是错的。应该是大于000000。大于000000的条件是 $x_1..x_6$ 不全为0。 如果按解析的结论 $x_1=1$ 且 $x_2..x_6$ 至少有一位为1，那么选项C成立。",
    "answer": "C || 解析：对于此类题型,先写出特定值的机器码表示,然后根据机器数判断大小的规则来推导数值位的特点(若条件允许,也可以取特殊值来推断)。-32的补码(7位整数)为1000000。根据负数补码判断大小的规则:数值位部分越小,其绝对值越大,即负得越多。因此,若要x>-32, x的补码要大于1000000。 即 $1.x_1x_2x_3x_4x_5x_6 > 1.000000$。比较数值部分，$x_1x_2x_3x_4x_5x_6$ 必须大于 $000000$。即 $x_1x_2x_3x_4x_5x_6$ 不全为0。选项C ($x_1=1$ 且 $x_2..x_6$ 至少有一位为1) 是这种情况的一部分，且满足条件。【特殊值法】对于选项A,取1.000000,真值为-32,错误。对于选项B,取1.100000,真值为-16,符合。对于选项C, $x_1$为1,$x_2$~$x_6$中至少有一位为1, 例如取1.100001,真值为-15,符合。对于选项D, $x_1$为0,$x_2$~$x_6$中至少有一位为1, 例如取1.000001,真值为-31,符合。按照答案解析，选C。"
  },
  {
    "id": "2.1.5-14",
    "type": "单项选择题",
    "question": "设x为整数,[x]补=1.X1X2X3X4X5,若要x<-16, X1~X5应满足的条件是()。 A. X1~X5至少有一个为1 B. X1必须为0,X2~X5至少有一个为1 C. X1必须为0,X2~X5任意 D. X1必须为1,X2~X5任意",
    "answer_label": "C",
    "answer_explain": "解题思路与上题类似(也可采用特殊值解法,请读者自行思考)。-16的补码(6位整数)为110000。要 $x < -16$, 则 $x$ 的补码 $1.X1X2X3X4X5$ 必须小于 $1.10000$。比较负数补码大小，数值位越小，真值越小（绝对值越大）。所以 $X1X2X3X4X5$ 必须小于 $10000$。即 $X1$ 必须为0。",
    "answer": "C || 解析：解题思路与上题类似(也可采用特殊值解法,请读者自行思考)。-16的补码(6位整数)为110000。根据负数补码判断大小的规则:数值位部分越小,其绝对值越大,即负得越多。因此,若要 $x < -16$, x的补码 $1.X1X2X3X4X5$ 需小于 $1.10000$。比较数值位 $X1X2X3X4X5$ 需小于 $10000$。这意味着 $X1$ 必为0, 而 $X2\\sim X5$ 任意。"
  },
  {
    "id": "2.1.5-15",
    "type": "单项选择题",
    "question": "设x为真值,x*为其绝对值,满足 $[-x^*]_{补}=[x]_{补}$,当且仅当()。 A. x任意 B. x为正数 C. x为负数 D. 以上说法都不对",
    "answer_label": "D",
    "answer_explain": "当x为0时，$-x^*=0$, $[0]_补 = [0]_补$ 成立。当x为正数时， $x^*=x$, $[-x^*]_补 = [-x]_补$，而 $[x]_补$ 是正数的补码。一个负数的补码不可能等于一个正数的补码（除非是0）。当x为负数时，$x^*=-x$, $[-x^*]_补 = [-(-x)]_补 = [x]_补$，这个等式恒成立。但是题目要求“当且仅当”，0和负数都满足，所以B、C都不对。应选D。",
    "answer": "D || 解析：当x为0时, $[-0^*]_补 = [0]_补 = [0]_补$ 成立。当x为正数时, $x^*=x > 0$, $[-x^*]_补 = [-x]_补$ 是负数补码, $[x]_补$ 是正数补码, 两者不等。当x为负数时, $x^*=-x > 0$, $[-x^*]_补 = [-(-x)]_补 = [x]_补$ 恒成立。因此，满足条件的x为0或负数。选项B、C都不全面，选项A错误，应选D。"
  },
  {
    "id": "2.1.5-16",
    "type": "单项选择题",
    "question": "假定一个十进制数为-66,按补码形式存放在一个8位寄存器中,该寄存器的内容用十六进制表示为( )。 A. C2H B. BEH C. BDH D. 42H",
    "answer_label": "B",
    "answer_explain": "$+66$ 的8位二进制原码为 $01000010$。求 $-66$ 的补码：将 $+66$ 的原码按位取反得 $10111101$, 末位加1得 $10111110$。转换成十六进制为 BEH。",
    "answer": "B || 解析：$+66 = (01000010)_2$。则 $[-66]_{补}$ 为将 $01000010$ 按位取反加1, 即 $10111101 + 1 = 10111110 = BEH$。"
  },
  {
    "id": "2.1.5-17",
    "type": "单项选择题",
    "question": "设机器数采用补码表示(含1位符号位),若寄存器内容为9BH,则对应的十进制数为( )。 A. -27 B. -97 C. -101 D. 155",
    "answer_label": "C",
    "answer_explain": "$9BH=(10011011)_2$。最高位的1表示负数。求其原码：符号位不变，数值位 $0011011$ 按位取反得 $1100100$, 末位加1得 $1100101$。原码为 $11100101$。对应的十进制真值为 $-(64+32+4+1)=-101$。",
    "answer": "C || 解析：$9BH=(10011011)_2$。最高位的1表示负数。求其原码：符号位不变，数值位 $0011011$ 取反加1。即 $1100100 + 1 = 1100101$。所以原码是 $11100101$。真值为 $-(64+32+4+1)=-101$。"
  },
  {
    "id": "2.1.5-18",
    "type": "单项选择题",
    "question": "若寄存器内容为10000000,若它等于0,则为( )。 A. 原码 B. 补码 C. 反码 D. 移码",
    "answer_label": "A",
    "answer_explain": "值等于-0说明只可能是原码或反码(因为补码和移码表示0时是唯一的,没有+0和-0之分)。$[-0]_{原}=10000000$, $[-0]_{反}=11111111$。",
    "answer": "A || 解析：值等于-0说明只可能是原码或反码(因为补码和移码表示0时是唯一的,没有+0和-0之分)。$[-0]_{原}=10000000$, $[-0]_{反}=11111111$。"
  },
  {
    "id": "2.1.5-19",
    "type": "单项选择题",
    "question": "若寄存器内容为11111111,若它等于+127,则为( )。 A. 反码 B. 补码 C. 原码 D. 移码",
    "answer_label": "D",
    "answer_explain": "这里寄存器长度为8。$[+127]_{原}=[+127]_{反}=[+127]_{补}=01111111$。移码的定义为 $[x]_{移} = 2^n + x$ (对于n+1位字长)。8位字长n=7。$[+127]_{移}=2^7+127 = 128+127 = 255 = (11111111)_2$。",
    "answer": "D || 解析：这里寄存器长度为8。$[+127]_{原}=[+127]_{反}=[+127]_{补}=01111111$。又知同一数值的移码和补码除最高位相反外,其他各位相同,则 $[+127]_{移}=11111111$ (即将补码符号位取反)。或按定义 $[+127]_{移} = 2^7 + 127 = 128 + 127 = 255 = (11111111)_2$。"
  },
  {
    "id": "2.1.5-20",
    "type": "单项选择题",
    "question": "若寄存器内容为11111111,若它等于-1,则为( )。 A. 原码 B. 补码 C. 反码 D. 移码",
    "answer_label": "B",
    "answer_explain": "这里寄存器长度为8。$[-1]_{原}=10000001$。$[-1]_{反}=11111110$。$[-1]_{补}=11111111$。$[-1]_{移}=2^7+(-1)=128-1=127=01111111$。",
    "answer": "B || 解析：这里寄存器长度为8。$[-1]_{原}=10000001$。$[-1]_{补}=11111111$。$[-1]_{反}=11111110$。$[-1]_{移}=2^7+(-1)=127=01111111$。"
  },
  {
    "id": "2.1.5-21",
    "type": "单项选择题",
    "question": "若寄存器内容为00000000,若它等于-128,则为()。 A. 原码 B. 补码 C. 反码 D. 移码",
    "answer_label": "D",
    "answer_explain": "这里寄存器长度为8。$[-128]$ 无法用原码和反码表示。$[-128]_{补}=10000000$。$[-128]_{移}=2^7+(-128)=128-128=0=(00000000)_2$。",
    "answer": "D || 解析：这里寄存器长度为8。$[-128]_{补}=10000000$。$[-128]_{移}=2^7+(-128)=0=(00000000)_2$。"
  },
  {
    "id": "2.1.5-22",
    "type": "单项选择题",
    "question": "若二进制定点小数真值是-0.1101,机器表示为1.0010,则为( )。 A. 原码 B. 补码 C. 反码 D. 移码",
    "answer_label": "C",
    "answer_explain": "真值-0.1101。原码为1.1101。补码为1.0011 (数值位取反加1)。反码为1.0010 (数值位取反)。移码通常用于表示阶码,不用来表示定点小数。",
    "answer": "C || 解析：真值-0.1101。对应的原码表示为1.1101。补码表示为1.0011。反码表示为1.0010。移码通常用于表示阶码,不用来表示定点小数。"
  },
  {
    "id": "2.1.5-23",
    "type": "单项选择题",
    "question": "下列为8位移码机器数 $[x]_{移}$,求 $[-x]_{移}$ 时,( )将会发生溢出。 A. 11111111 B. 00000000 C. 10000000 D. 01111111",
    "answer_label": "B",
    "answer_explain": "8位移码表示范围为 $[-128, 127]$。A: 11111111 对应真值 127, -x = -127, $[-127]_{移}=1$。 B: 00000000 对应真值 -128, -x = 128, 超出表示范围,溢出。 C: 10000000 对应真值 0, -x = 0, $[0]_{移}=10000000$。 D: 01111111 对应真值 -1, -x = 1, $[1]_{移}=10000001$。因此选项B发生溢出。",
    "answer": "B || 解析：8位移码表示范围为 $[-128, 127]$。选项A对应真值 $255-128=127$, $-x=-127$, $[-127]_{移} = 2^7-127 = 1 = 00000001$。选项B对应真值 $0-128=-128$, $-x=128$, 超出范围，发生溢出。选项C对应真值 $128-128=0$, $-x=0$, $[0]_{移}=10000000$。选项D对应真值 $127-128=-1$, $-x=1$, $[1]_{移}=128+1=129=10000001$。因此选项B发生溢出。"
  },
  {
    "id": "2.1.5-24",
    "type": "单项选择题",
    "question": "一个8位的二进制整数由2个“0”和6个“1”组成,采用补码或者移码表示,则下列说法中正确的是()。 A. 若采用移码表示,偏置值为127,则此整数最小为-64 B. 若采用移码表示,偏置值为128,则此整数最大为123 C. 若采用补码表示,则此整数最小为-96 D. 若采用补码表示,则此整数最大为252",
    "answer_label": "A",
    "answer_explain": "补码表示：最大值，符号位为0，剩下1个0和6个1，为 $01111110 = 126$。最小值，符号位为1，剩下1个0和6个1。为使值最小（绝对值最大），数值位应尽可能小，即 $10011111 = -97$。\n移码表示（偏置值128）：最大值，移码最大，把0放在低位 $11111100$, 真值 $= (11111100)_2 - 128 = 252 - 128 = 124$。最小值，移码最小，把0放在高位 $00111111$, 真值 $= (00111111)_2 - 128 = 63 - 128 = -65$。\n移码表示（偏置值127）：最大值，移码最大 $11111100$, 真值 $= 252 - 127 = 125$。最小值，移码最小 $00111111$, 真值 $= 63 - 127 = -64$。 选项A正确。",
    "answer": "A || 解析：当采用补码表示时,要使得数值最大,就要让符号位为0,且把“1”放在高位,得到的补码为01111110B=126;要使得数值最小,就要让符号位为1,且把“1”放在低位(数值位最小),得到的补码为10011111B = -97。当采用移码表示时(偏置值为128),要使数值最大,就要把“1”放在高位,得到的移码为11111100B, 真值 $11111100B - 10000000B = 01111100B = 124$;要使得数值最小,则应把“1”放在低位,得到的移码为00111111B, 真值 $00111111B - 10000000B = - (10000000B - 00111111B) = -1000001B = -65$。当采用移码表示时(偏置值为127),要使得数值最大,得到的移码为11111100B, 真值 $11111100B - 01111111B = 10000001B = 129?$ (计算错误) 真值 $= 252 - 127 = 125$。要使得数值最小,则应把“1”放在低位,得到的移码为00111111B, 真值 $00111111B - 01111111B = -(01111111B - 00111111B) = -01000000B = -64$。选项A正确。"
  },
  {
    "id": "2.1.5-25",
    "type": "单项选择题",
    "question": "计算机内部的定点数大多用补码表示,以下是一些关于补码特点的叙述:\nI. 零的表示是唯一的\nII. 符号位可以和数值部分一起参加运算\nIII. 和其真值的对应关系简单、直观\nIV. 减法可用加法来实现\n在以上叙述中,( )是补码表示的特点。\nA. I和II B. I和III C. I、II和III D. I、II和IV",
    "answer_label": "D",
    "answer_explain": "[+0]补和[-0]补是相同的,所以选项I正确。在进行补码定点数的加减运算时,符号作为数的一部分参加运算,选项II正确。$[A]_{补}-[B]_{补}=[A]_{补}+[-B]_{补}$,即将减法采用加法实现,选项IV正确。实际上,补码和其真值的对应关系远不如原码和其真值的对应关系简单直观,选项III错误。",
    "answer": "D || 解析：[+0]补和[-0]补是相同的,所以选项I正确。在进行补码定点数的加减运算时,符号作为数的一部分参加运算,选项II正确。$[A]_{补}-[B]_{补}=[A]_{补}+[-B]_{补}$,即将减法采用加法实现,选项IV正确。实际上,补码和其真值的对应关系远不如原码和其真值的对应关系简单直观,选项III错误。"
  },
  {
    "id": "2.1.5-26",
    "type": "单项选择题",
    "question": "在计算机中,通常用来表示主存地址的是()。 A. 移码 B. 补码 C. 原码 D. 无符号数",
    "answer_label": "D",
    "answer_explain": "主存地址都是正数,因此不需要符号位,因此直接采用无符号数表示。",
    "answer": "D || 解析：主存地址都是正数,因此不需要符号位,因此直接采用无符号数表示。"
  },
  {
    "id": "2.1.5-27",
    "type": "单项选择题",
    "question": "16位补码整数0x8FA0扩展为32位应该是()。 A. 0x0000 8FA0 B. 0xFFFF 8FA0 C. 0xFFFF FFAO D. 0x8000 8FA0",
    "answer_label": "B",
    "answer_explain": "16位扩展为32位,进行符号扩展。该数0x8FA0最高位为1,是负数,需用1来填充高16位。因此结果为0xFFFF 8FA0。",
    "answer": "B || 解析：16位扩展为32位,符号位不变,高位是符号位的扩展。该数0x8FA0最高位为1，是一个负数,需用1来填充高16位。A是一个正数,C的数值位发生变化,D用0来填充高位,均不正确。"
  },
  {
    "id": "2.1.5-28",
    "type": "单项选择题",
    "question": "【2012统考真题】假定编译器规定 int型和short型长度分别为32位和16位,执行下列C语言语句:\nunsigned short x=65530;\nunsigned int y=x;\n得到y的机器数为( )。\nA. 0000 7FFAH B. 0000 FFFAH C. FFFF 7FFAH D. FFFF FFFAH",
    "answer_label": "B",
    "answer_explain": "将一个16位 unsigned short 型数转换成32位 unsigned int型数时,因为都是无符号数,新表示形式的高位用0填充。$x=65530$ 的16位二进制表示为 $1111 1111 1111 1010$ (即 $65535-5 = FFFFH - 5H = FFFAH$)。扩展为32位无符号整数y时，高16位补0，得到 $0000 0000 0000 0000 1111 1111 1111 1010$。其十六进制表示为 0000 FFFAH。",
    "answer": "B || 解析：将一个16位 unsigned short 型数转换成32位 unsigned int型数时,因为都是无符号数,新表示形式的高位用0填充。16位无符号整数 $x=65530$, 其十六进制表示为FFFAH $(65535-5)$。扩展为32位无符号整数y时高位补0, 所以y的十六进制表示为0000 FFFAH。\n排除法:先直接排除C、D,然后分析余下选项的特征。A、B的值相差很大。可以算出A的值 $7FFAH = 32762$，B的值 $FFFAH = 65530$。"
  },
  {
    "id": "2.1.5-29",
    "type": "单项选择题",
    "question": "【2015统考真题】由3个“1”和5个“0”组成的8位二进制补码,能表示的最小整数是()。 A. -126 B. -125 C. -32 D. -3",
    "answer_label": "B",
    "answer_explain": "要表示最小整数（负数绝对值最大），符号位必须为1。剩下2个“1”和5个“0”组成数值位。负数补码，数值位越小，绝对值越大，数越小。因此，数值位应为 $0000011$。组成的补码为 $10000011$。求其原码：符号位不变，数值位 $0000011$ 取反加1得 $1111100 + 1 = 1111101$。原码为 $11111101$。真值为 $-(64+32+16+8+4+1) = -125$。",
    "answer": "B || 解析：负数的补码，数值位部分越小,其绝对值越大,即负得越多。采用补码整数表示时,要得到最小值，符号位为1。剩下的2个“1”和5个“0”组成数值位。为使值最小，数值位应尽可能小，即 $0000011$。补码形式为10000011。转换为真值：求原码，数值位取反加1得 $1111100+1=1111101$。原码为 $11111101 = -(64+32+16+8+4+1) = -125$。"
  },
  {
    "id": "2.1.5-30",
    "type": "单项选择题",
    "question": "【2016统考真题】有如下C语言程序段:\nshort si = -32767;\nunsigned short usi = si;\n执行上述两条语句后,usi的值为( )。\nA. -32767 B. 32767 C. 32768 D. 32769",
    "answer_label": "D",
    "answer_explain": "short型为16位有符号整数。$si=-32767$ 的补码表示：$+32767 = (0111 1111 1111 1111)_2$。$-32767$ 的补码为符号位不变，数值位取反加1？不对。求+32767的补码，然后按位取反加1。$+32767$ 的补码是 $0111 1111 1111 1111$。按位取反是 $1000 0000 0000 0000$。末位加1是 $1000 0000 0000 0001$。这是 $si$ 的机器码。当将 $si$ 赋给 unsigned short 型变量 $usi$ 时，位模式不变，但解释方式变为无符号数。$usi$ 的机器码也是 $1000 0000 0000 0001$。解释为无符号数，其值为 $2^{15} + 1 = 32768 + 1 = 32769$。",
    "answer": "D || 解析：因C语言中的数据在内存中为补码表示形式,si对应的补码为 $1000 0000 0000 0001B$。由signed 型转换为等长的 unsigned 型数据时,位模式不变，符号位成为数据的一部分,即负数转换为无符号数(正数)时,其数值将发生变化。usi对应的机器码与si的相同,但表示无符号数,为 $2^{15}+1=32769$。"
  },
  {
    "id": "2.1.5-31",
    "type": "单项选择题",
    "question": "【2018统考真题】冯·诺依曼结构计算机中的数据采用二进制编码表示,其主要原因是()。\nI. 二进制的运算规则简单\nII. 制造两个稳态的物理器件较容易\nIII. 便于用逻辑门电路实现算术运算\nA. 仅 I、II B. 仅 I、III C. 仅 II、III D. I、II和III",
    "answer_label": "D",
    "answer_explain": "对于选项I,二进制只有0和1两种数值,运算规则较简单,都通过ALU转换成加法运算。对于选项II,二进制数只需要高电平和低电平两个状态就可表示,这样的物理器件很容易制造。对于选项III,二进制数与逻辑量相吻合。二进制的0和1正好与逻辑量的“真”和“假”相对应,因此用二进制数表示二值逻辑显得十分自然,采用逻辑门电路很容易实现运算。",
    "answer": "D || 解析：对于选项I,二进制只有0和1两种数值,运算规则较简单,都通过ALU转换成加法运算。对于选项II,二进制数只需要高电平和低电平两个状态就可表示,这样的物理器件很容易制造。对于选项III,二进制数与逻辑量相吻合。二进制的0和1正好与逻辑量的“真”和“假”相对应,因此用二进制数表示二值逻辑显得十分自然,采用逻辑门电路很容易实现运算。"
  },
  {
    "id": "2.1.5-32",
    "type": "单项选择题",
    "question": "【2019统考真题】考虑以下C语言代码:\nunsigned short usi = 65535;\nshort si = usi;\n执行上述程序段后,si的值是()。\nA. -1 B. -32767 C. -32768 D. -65535",
    "answer_label": "A",
    "answer_explain": "unsigned short 型为无符号短整型,长度为2字节(16位)。$usi = 65535$ 的二进制表示是16个1: $1111 1111 1111 1111$。当将 $usi$ 赋值给 short 型变量 $si$ 时，位模式不变，但解释方式变为有符号数（补码）。$si$ 的机器码也是 $1111 1111 1111 1111$。解释为16位补码，其真值为-1。",
    "answer": "A || 解析：unsigned short 型为无符号短整型,长度为2字节,因此 $usi=65535$ 转换为二进制代码即 16个1: $1111 1111 1111 1111$。short型为短整型,长度为2字节,在采用补码的机器上,short si的二进制代码为16个1: $1111 1111 1111 1111$,因此si的值为-1。"
  },
  {
    "id": "2.1.5-33",
    "type": "单项选择题",
    "question": "【2021统考真题】已知有符号整数用补码表示,变量x, y, z 的机器数分别为FFFDH, FFDFH, 7FFCH,下列结论中,正确的是( )\nA. 若x, y和z为无符号整数,则z < x < y\nB. 若x, y和z 为无符号整数,则x < y < z\nC. 若x, y和z 为有符号整数,则x < y < z\nD. 若x, y和z 为有符号整数,则y < x < z",
    "answer_label": "D",
    "answer_explain": "假设是16位整数。 无符号整数比较：x=FFFDH > y=FFDFH > z=7FFCH。所以A、B错误。\n有符号整数比较（补码）：z=7FFCH 是正数。x=FFFDH 和 y=FFDFH 是负数。负数补码比较：数值位越小，绝对值越大，数越小。x 的数值位是 FFDH 取反加1的原码绝对值是 0003H，真值是-3。y 的数值位是 FDFH 取反加1的原码绝对值是 0021H，真值是-33。所以 y < x。 因此 y < x < z。选项D正确。",
    "answer": "D || 解析：假设是16位整数。若x, y和z均为无符号整数,则 $x=FFFDH > y=FFDFH > z=7FFCH$,选项A和B错误。若x, y和z均为有符号整数,补码的最高位是符号位,0表示正数,1表示负数,因此z为正数,而x和y为负数。对于x和y的比较, 数值位取反加1求绝对值：x的绝对值是3，y的绝对值是33。所以真值 $x=-3$, $y=-33$。因此 $y < x$。 综合得 $y < x < z$。选项D正确。"
  },
  {
    "id": "2.1.5-34",
    "type": "单项选择题",
    "question": "【2022统考真题】32位补码所能表示的整数范围是( )。 A. $-2^{32} \\sim 2^{31}-1$ B. $-2^{31} \\sim 2^{31}-1$ C. $-2^{32} \\sim 2^{32}-1$ D. $-2^{31} \\sim 2^{32}-1$",
    "answer_label": "B",
    "answer_explain": "n位补码整数的最小值是 $100...0$ (真值为$-2^{n-1}$);最大值是 $011...1$ (真值为$2^{n-1}-1$)。n位补码整数所能表示的范围是 $-2^{n-1} \\sim 2^{n-1}-1$。对于32位补码整数，n=32，范围是 $-2^{31} \\sim 2^{31}-1$。",
    "answer": "B || 解析：n位补码整数的最小值是 $100...0 (-2^{n-1})$;最大值是 $011...1 (2^{n-1}-1)$。n位补码整数所能表示的范围是 $-2^{n-1} \\sim 2^{n-1}-1$。32位补码整数所能表示的范围是 $-2^{31} \\sim 2^{31}-1$。"
  },
  {
    "id": "2.3.5-01",
    "type": "单项选择题",
    "question": "在C语言的不同类型的数据混合运算中,要先转换成同一类型后进行运算。设一表达式中包含有int型、long型、char型和double型的变量与数据,则表达式最后的运算结果是(),这4种类型数据的转换规律是()。 A. long, int -> char -> double -> long B. long, char -> int -> long -> double C. double, char -> int -> long -> double D. double, char -> int -> double -> long",
    "answer_label": "C",
    "answer_explain": "不同类型的数据混合运算时,遵循的原则是“类型提升”,即较低类型转换为较高类型,最终结果为精度最高的 double 型。4种类型数据的转换规律为 char -> int -> long -> double。",
    "answer": "C || 解析：不同类型的数据混合运算时,遵循的原则是“类型提升”,即较低类型转换为较高类型,最终结果为 double 型。4种类型数据的转换规律为 char -> int -> long -> double。"
  },
  {
    "id": "2.3.5-02",
    "type": "单项选择题",
    "question": "长度相同但格式不同的两种浮点数,假设前者阶码长、尾数短,后者阶码短、尾数长,其他规定均相同,则它们可表示的数的范围和精度为( )。 A. 两者可表示的数的范围和精度相同 B. 前者可表示的数的范围大但精度低 C. 后者可表示的数的范围大且精度高 D. 前者可表示的数的范围大且精度高",
    "answer_label": "B",
    "answer_explain": "在浮点数总位数不变的情况下,阶码位数越多,表示的数的范围越大;尾数位数越多,表示的数的精度越高。因此前者范围大但精度低。",
    "answer": "B || 解析：在浮点数总位数不变的情况下,阶码位数越多,尾数位数越少,即表示的数的范围越大,精度越差(数变稀疏)。"
  },
  {
    "id": "2.3.5-03",
    "type": "单项选择题",
    "question": "长度相同、格式相同的两种浮点数,假设前者基数大,后者基数小,其他规定均相同,则它们可表示的数的范围和精度为( )。 A. 两者可表示的数的范围和精度相同 B. 前者可表示的数的范围大但精度低 C. 后者可表示的数的范围大且精度高 D. 前者可表示的数的范围大且精度高",
    "answer_label": "B",
    "answer_explain": "基数是浮点数的进制,决定了阶码变化的权重。基数越大,阶码每变化一位,尾数小数点需要移动的位数越多,表示的数的绝对值就越大,范围就越大。但是,在浮点数的总位数不变的情况下,能表示的不同状态个数是一定的。若范围增大,则意味着浮点数的离散程度增大,相邻两个浮点数之间的间隔就越大,精度就越低。例如,假设符号为S、尾数为M、阶码为E,则基数为2时的浮点数表示形式为 $(-1)^S \\times M \\times 2^E$,基数为4时的浮点数表示形式为 $(-1)^S \\times M \\times 4^E$,显然基数为4时的表示范围大,但数据的离散程度也增大,精度降低。",
    "answer": "B || 解析：基数是浮点数的进制,决定了阶码变化的权重。基数越大,阶码每变化一位,尾数小数点需要移动的位数越多,表示的数的绝对值就越大,范围就越大。但是,在浮点数的总位数不变的情况下,能表示的不同状态个数是一定的。若范围增大,则意味着浮点数的离散程度增大,相邻两个浮点数之间的间隔就越大,精度就越低。例如,假设符号为S、尾数为M、阶码为E,则基数为2时的浮点数表示形式为 $(-1)^S \\times M \\times 2^E$,基数为4时的浮点数表示形式为 $(-1)^S \\times M \\times 4^E$,显然基数为4时的表示范围大,但数据的离散程度也增大,精度降低。"
  },
  {
    "id": "2.3.5-04",
    "type": "单项选择题",
    "question": "下列说法中正确的是()。 A. 采用变形补码进行加减法运算可以避免溢出 B. 只有定点数运算才可能溢出,浮点数运算不会产生溢出 C. 定点数和浮点数运算都可能产生溢出 D. 两个正数相加时一定产生溢出",
    "answer_label": "C",
    "answer_explain": "变形补码,即用两个二进制位来表示数字的符号位,其余与补码相同,所以并不能避免溢出,只是便于检测溢出,选项A错误。定点数和浮点数运算都可能产生溢出,但是溢出判断有区别,因此选项B错误、选项C正确。在定点运算中,当运算结果超出数的表示范围时,就发生溢出:在浮点运算中,运算结果超出尾数表示范围却不一定溢出,只有规格化后阶码超出所能表示的范围时,才发生溢出。两个正数相加，结果不一定超出表示范围，选项D错误。",
    "answer": "C || 解析：变形补码,即用两个二进制位来表示数字的符号位,其余与补码相同,所以并不能避免溢出,选项A错误。定点数和浮点数运算都可能产生溢出,但是溢出判断有区别,因此选项B错误、选项C正确。在定点运算中,当运算结果超出数的表示范围时,就发生溢出:在浮点运算中,运算结果超出尾数表示范围却不一定溢出,只有规格化后阶码超出所能表示的范围时,才发生溢出,选项D错误。"
  },
  {
    "id": "2.3.5-05",
    "type": "单项选择题",
    "question": "在规格化浮点运算中,若某浮点数为$2^5 \\times 1.10101$,其中尾数为补码表示,则该数()。 A. 不需规格化 B. 需右移规格化 C. 需将尾数左移一位规格化 D. 需将尾数左移两位规格化",
    "answer_label": "C",
    "answer_explain": "考查浮点数的规格化。当尾数为补码表示时，规格化形式要求符号位和最高数值位不同。正数规格化形式为 0.1xxxx，负数规格化形式为 1.0xxxx。题中尾数 $1.10101$ 为负数补码，其符号位与最高数值位相同（都是1），不符合规格化要求。需要左规。将尾数左移一位，变成 $1.01010$ (低位补0)，此时符号位1和最高数值位0不同，符合规格化要求。左移一位，阶码减1，变为 $2^4 \\times 1.01010$。",
    "answer": "C || 解析：考查浮点数的规格化。当尾数为补码表示, 规格化要求符号位和最高数值位不同，正数为0.1xxxx形式，负数为1.0xxxx形式。题中尾数 $1.10101$ 是负数补码，符号位与最高数值位相同，非规格化。需左移一位，尾数变为 $1.01010$，阶码减1。所以需将尾数左移一位规格化。"
  },
  {
    "id": "2.3.5-06",
    "type": "单项选择题",
    "question": "某浮点机,采用规格化浮点数表示,阶码用移码表示(最高位代表符号位),尾数用原码表示。下列()的表示不是规格化浮点数。 A. 11111111, 1.1000...00 B. 00111111, 1.0111...01 C. 10000001, 0.1111...01 D. 01111111, 0.1000...10",
    "answer_label": "B",
    "answer_explain": "尾数用原码表示，规格化要求：正数形式为 $0.1xxxx$，负数形式为 $1.1xxxx$。选项B的尾数 $1.0111...01$ 是负数，但最高数值位是0，不符合规格化要求。",
    "answer": "B || 解析：原码表示时,正数的规格化形式为0.1x...,负数的规格化形式为1.1x...,因此选项B错误。"
  },
  {
    "id": "2.3.5-07",
    "type": "单项选择题",
    "question": "下列关于对阶操作说法正确的是( )。 A. 在浮点加减运算的对阶操作中,若阶码减小,则尾数左移 B. 在浮点加减运算的对阶操作中,若阶码增大,则尾数右移;若阶码减小,则尾数左移 C. 在浮点加减运算的对阶操作中,若阶码增大,则尾数右移 D. 以上都不对",
    "answer_label": "C",
    "answer_explain": "对阶操作是将较小的阶码调整到与较大的阶码一致，即小阶向大阶看齐。此时，阶码小的数的尾数需要右移，每右移一位，阶码加1，直到两个数的阶码相等。不存在阶码减小的情况，因此选项A、B错误。选项C描述了尾数右移伴随阶码增大的过程，正确。",
    "answer": "C || 解析：对阶操作,是将较小的阶码调整到与较大的阶码一致,因此小阶码的尾数需要右移，阶码增大。不存在阶码减小、尾数左移的情况,因此选项A、B错误。"
  },
  {
    "id": "2.3.5-08",
    "type": "单项选择题",
    "question": "浮点数的IEEE754标准对尾数编码采用的是()。 A. 原码 B. 反码 C. 补码 D. 移码",
    "answer_label": "A",
    "answer_explain": "IEEE 754 标准中尾数采用原码表示,阶码部分用移码表示。",
    "answer": "A || 解析：IEEE 754 标准中尾数采用原码表示,阶码部分用移码表示。"
  },
  {
    "id": "2.3.5-09",
    "type": "单项选择题",
    "question": "在IEEE 754标准规定的64位浮点数格式中,符号位为1位,阶码为11位,尾数为52位,则它所能表示的最小规格化负数为( )。 A. $-(2-2^{-52}) \\times 2^{-1023}$ B. $-(2-2^{-52}) \\times 2^{+1023}$ C. $-1 \\times 2^{-1024}$ D. $-(1-2^{-52}) \\times 2^{+2047}$",
    "answer_label": "B",
    "answer_explain": "64位双精度格式，阶码11位，尾数52位，偏置值1023。规格化数的阶码范围是1到2046。最小规格化负数，即绝对值最大的规格化负数。符号位为1。阶码取最大值2046，真值为 $2046-1023 = 1023$。尾数取最大值（52个1），真值为 $1.11...1$ (小数点后52个1)，值为 $1 + (1-2^{-52}) = 2 - 2^{-52}$。所以最小（绝对值最大）规格化负数为 $-(2-2^{-52}) \\times 2^{1023}$。",
    "answer": "B || 解析：长浮点数,其阶码11位,尾数52位,采取隐藏位策略,其规格化真值为 $(-1)^S \\times 1.f \\times 2^{e-1023}$, 阶码e范围 [1, 2046]。最小规格化负数即绝对值最大的规格化负数。符号位S=1。阶码e取最大值2046，指数真值为 $2046-1023=1023$。尾数f取最大值（全1），隐藏位为1，尾数真值为 $1 + (1-2^{-52}) = 2-2^{-52}$。所以最小规格化负数为 $-(2-2^{-52}) \\times 2^{+1023}$。"
  },
  {
    "id": "2.3.5-10",
    "type": "单项选择题",
    "question": "按照 IEEE 754标准规定的32位单精度浮点数41A4C000H对应的十进制数是()。 A. 4.59375 B. -20.59375 C. -4.59375 D. 20.59375",
    "answer_label": "D",
    "answer_explain": "41A4C000H 写成二进制为 $0 10000011 01001001100000000000000$。符号位 S=0 (正数)。阶码 e = $(10000011)_2 = 128+2+1 = 131$。指数真值为 $E = e - 127 = 131 - 127 = 4$。尾数 f = $01001001100...0$。尾数真值 M = $1.f = 1.010010011$。数值为 $M \\times 2^E = (1.010010011)_2 \\times 2^4 = (10100.10011)_2 = 16+4 + 1/2 + 1/16 + 1/32 = 20 + 0.5 + 0.0625 + 0.03125 = 20.59375$。",
    "answer": "D || 解析：在IEEE 754 单精度浮点数中,最高位为符号位;其后是8位阶码,以2为底,用移码表示,阶码的偏置值为127;其后23位是尾数数值位。对于规格化的二进制浮点数,数值的最高位总是“1”,为了能使尾数多表示一位有效值,将这个“1”隐藏,因此尾数数值实际上是24位。隐藏的“1”是一位整数。在浮点格式中表示出来的23位尾数是纯小数,用原码表示。41A4C000H 写成二进制为 $0 10000011 01001001100000000000000$。第一位为符号位0,表示是正数。之后的8位 $10000011$ 表示阶码, 真值为 $(10000011)_2 - 127 = 131 - 127 = 4$。剩下的是隐藏了最高1的尾数的小数部分 $f = 01001001100...0$。所以尾数真值为 $1.f = (1.010010011)_2$。数值为 $(1.010010011)_2 \\times 2^4 = (10100.10011)_2 = 16+4+0.5+0.0625+0.03125 = 20.59375$。"
  },
  {
    "id": "2.3.5-11",
    "type": "单项选择题",
    "question": "在浮点数编码表示中,( )在机器数中不出现,是隐含的。 A. 阶码 B. 符号 C. 尾数 D. 基数",
    "answer_label": "D",
    "answer_explain": "浮点数表示为 $N=(-1)^S \\times M \\times R^E$。符号S、阶码E、尾数M都显式存储在机器数中。基数R通常约定为某个固定值（如2或16），不显式存储，是隐含的。",
    "answer": "D || 解析：浮点数表示中基数的值是约定好的,因此将其隐含。"
  },
  {
    "id": "2.3.5-12",
    "type": "单项选择题",
    "question": "若某单精度浮点数、某原码、某补码、某移码的32位机器数均为0xF0000000,则这些数从大到小的顺序是()。 A. 浮原补移 B. 浮移补原 C. 移原补浮 D. 移补原浮",
    "answer_label": "D",
    "answer_explain": "机器数 $0xF0000000 = (11110000...0)_2$。\n移码：最高位为1表示正数。真值为 $(11110000...0)_2 - 2^{31} = (2^{32}-2^{28}) - 2^{31} = 2^{31} - 2^{28}$ (正大数)。\n补码：最高位为1表示负数。原码为 $10010000...0$，真值为 $-2^{28}$ (负数)。\n原码：最高位为1表示负数。真值为 $-(1110000...0)_2 = -(2^{30}+2^{29}+2^{28})$ (负绝对值更大)。\n浮点数(IEEE 754单精度)：符号位S=1 (负数)。阶码e = $(11100000)_2 = 224$。指数 $E=e-127 = 224-127 = 97$。尾数f=0。真值为 $-1.0 \\times 2^{97}$ (负绝对值巨大)。\n比较大小：移码(正大数) > 补码($-2^{28}$) > 原码($-(2^{30}+..) $) > 浮点数($-2^{97}$)。顺序：移补原浮。",
    "answer": "D || 解析：这个机器数的最高位为1。对于原码、补码、单精度浮点数而言为负数,对于移码而言为正数,所以移码最大。补码真值为 $-2^{28}$。原码真值为 $-(2^{30}+2^{29}+2^{28})$。单精度浮点数 $S=1$, $e=(11100000)_2=224$, $f=0$。$E=e-127=97$。真值为 $-1.0 \\times 2^{97}$。比较大小：移码 > 补码 > 原码 > 浮点数。顺序：移补原浮。"
  },
  {
    "id": "2.3.5-13",
    "type": "单项选择题",
    "question": "采用规格化的浮点数最主要是为了()。 A. 增加数据的表示范围 B. 方便浮点运算 C. 防止运算时数据溢出 D. 增加数据的表示精度",
    "answer_label": "D",
    "answer_explain": "规格化是为了保证尾数中包含尽可能多的有效数字位，从而提高数据的表示精度。表示范围主要由阶码决定，运算方便性和溢出与规格化关系不大。",
    "answer": "D || 解析：与非规格化浮点数相比,采用规格化浮点数的目的主要是为了增加数据的表示精度。"
  },
  {
    "id": "2.3.5-14",
    "type": "单项选择题",
    "question": "下列说法中,正确的是()。\nI. 在计算机中,表示的数有时会发生溢出,根本原因是计算机的字长有限\nII. 一个正数的补码和这个数的原码表示一样,而正数的反码是原码各位取反\nIII. 设有两个正的规格化浮点数 $N_1=2^{m} \\times M_1$ 和 $N_2=2^{n} \\times M_2$,若m>n,则有 $N_1 > N_2$\nA. I B. III C. I, II, III D. I, III",
    "answer_label": "D",
    "answer_explain": "I 正确，溢出的根本原因是表示范围有限，而范围有限是因为字长有限。II 错误，正数的原码、反码、补码都相同。III 正确，对于正的规格化浮点数，尾数M的范围通常是固定的（如 $[1/R, 1)$ 或 $[1, R)$ for IEEE 754）。如果阶码 $m > n$，即使 $M_1$ 略小于 $M_2$，只要阶码差异足够大，$N_1$ 就会大于 $N_2$。更严格地说，对于基数为R的规格化正数， $1/R \\le M < 1$。若 $m > n$, 则 $m \\ge n+1$。 $N_1 = 2^m M_1 \\ge 2^m (1/R)$。 $N_2 = 2^n M_2 < 2^n \\times 1$。 如果 $2^m (1/R) > 2^n$, 即 $2^{m-n} > R$。对于基数R=2， $m-n \\ge 1$， $2^{m-n} \\ge 2$，所以 $N_1 > N_2$ 总是成立。因此I和III正确。",
    "answer": "D || 解析：选项I正确；正数的原码、反码和补码都相同,选项II错误；因为是规格化正浮点数,所以 $M_1, M_2$ 均为 $[1/R, 1)$ 范围内的正数 (R为基数)。若 $m>n$, 则 $m \\ge n+1$。$N_1 = R^m M_1 \\ge R^m (1/R) = R^{m-1}$。$N_2 = R^n M_2 < R^n \\times 1 = R^n$。因为 $m-1 \\ge n$, 所以 $R^{m-1} \\ge R^n$。因此 $N_1 > N_2$。选项 III 正确。"
  },
  {
    "id": "2.3.5-15",
    "type": "单项选择题",
    "question": "在浮点运算中,下溢指的是()。 A. 运算结果的绝对值小于机器所能表示的最小绝对值 B. 运算的结果小于机器所能表示的最小负数 C. 运算的结果小于机器所能表示的最小正数 D. 运算结果的最低有效位产生的错误",
    "answer_label": "A",
    "answer_explain": "运算结果在0至最小规格化正数之间时称为正下溢,在0至绝对值最小规格化负数之间时称为负下溢,统称下溢。即运算结果的绝对值小于机器能表示的最小规格化数的绝对值。",
    "answer": "A || 解析：运算结果在0至规格化最小正数之间时称为正下溢,运算结果在0至规格化最大负数(绝对值最小的负数)之间时称为负下溢,正下溢和负下溢统称下溢。"
  },
  {
    "id": "2.3.5-16",
    "type": "单项选择题",
    "question": "判断浮点数运算是否溢出,取决于( )。 A. 尾数是否上溢 B. 尾数是否下溢 C. 阶码是否上溢 D. 阶码是否下溢",
    "answer_label": "C",
    "answer_explain": "浮点数运算结果是否溢出主要看结果规格化后阶码是否超出所能表示的范围。阶码超出最大值称为上溢，表示结果绝对值太大无法表示。阶码小于最小值称为下溢，结果按0处理或用非规格化数表示。尾数溢出可以通过规格化操作（右规）调整。",
    "answer": "C || 解析：判断浮点数运算是否溢出,取决于阶码是否上溢。阶码下溢可以通过非规格化数来表示。尾数上溢或下溢,可以通过左移或右移进行调整。"
  },
  {
    "id": "2.3.5-17",
    "type": "单项选择题",
    "question": "假定采用IEEE 754标准中的单精度浮点数格式表示一个数为45100000H,则该数的值是()。 A. $(+1.125)_{10} \\times 2^{10}$ B. $(+1.125)_{10} \\times 2^{11}$ C. $(+0.125)_{10} \\times 2^{11}$ D. $(+0.125)_{10} \\times 2^{10}$",
    "answer_label": "B",
    "answer_explain": "45100000H 写成二进制为 $0 10001010 00100000000000000000000$。符号位 S=0 (正数)。阶码 e = $(10001010)_2 = 128+8+2 = 138$。指数 $E = e - 127 = 138 - 127 = 11$。尾数 f = $00100...0$。尾数真值 M = $1.f = (1.001)_2 = 1 + 1/8 = 1.125$。数值为 $M \\times 2^E = 1.125 \\times 2^{11}$。",
    "answer": "B || 解析：写成二进制表示为 $0 10001010 00100000000000000000000$。第一位为符号位,0表示正数。随后8位(float型) $10001010$ 是用移码表示的阶码, 减去偏置值127后得指数真值 $(10001010)_2 - 127 = 138 - 127 = 11$。尾数部分隐藏了整数部分的“1”, 小数部分 $f = 0010...0$。因此尾数真值 $M = (1.001)_2 = (1+1/8)_{10} = (1.125)_{10}$。因此该数值为 $(+1.125)_{10} \\times 2^{11}$。"
  },
  {
    "id": "2.3.5-18",
    "type": "单项选择题",
    "question": "已知 float 型采用IEEE754单精度浮点格式,若x, y为float型变量,且x=-126, y=15.75,则执行语句z=x+y时,在浮点运算单元中进行对阶操作后的结果是()。 A. x不变, y为 0 10000101 0.001111110...0 B. x不变, y为 0 10000110 0.001111110...0 C. y不变, x为 1 10000101 0.001111110...0 D. y不变, x为 1 10000110 0.001111110...0",
    "answer_label": "A",
    "answer_explain": "$x=-126 = -(1111110)_2 = -1.111110 \\times 2^6$。符号S=1。指数 $E=6$。阶码 $e = E+127 = 6+127 = 133 = (10000101)_2$。尾数小数部分 f = $1111100...0$。\n$y=15.75 = (1111.11)_2 = 1.11111 \\times 2^3$。符号S=0。指数 $E=3$。阶码 $e = E+127 = 3+127 = 130 = (10000010)_2$。尾数小数部分 f = $1111100...0$。\n对阶：小阶向大阶看齐。y的阶码小。y的阶码需要加3变为133。y的尾数需要右移3位。原尾数真值为 $1.11111$。右移3位变为 $0.00111111$。所以对阶后，x不变，y的符号=0, 阶码=10000101, 尾数（不含隐藏位）=0.00111111。选项A正确。注意选项中的尾数表示可能指移位后的值，而非存储格式。",
    "answer": "A || 解析：规格化 IEEE 754浮点数尾数部分的数值范围为[1, 2)。 $x=-126 = -(1111110)_2 = -1.111110 \\times 2^6$。$y=15.75 = (1111.11)_2 = 1.11111 \\times 2^3$。所以浮点数x、y的指数真值分别为6和3。对阶操作是小阶向大阶看齐, 即y的指数变为6, 阶码移码表示为 $6+127 = 133 = (10000101)_2$。y的尾数（真值）右移3位, 变为 $0.00111111$。"
  },
  {
    "id": "2.3.5-19",
    "type": "单项选择题",
    "question": "在IEEE 754标准浮点格式中,非规格化浮点数表示为( )。 A. 阶码为0,尾数为任意非0的二进制数 B. 阶码为255,尾数全为0 C. 阶码为255,尾数为任意非0的二进制数 D. 阶码为0,尾数全为0",
    "answer_label": "A",
    "answer_explain": "在IEEE 754 标准格式中,阶码全为0,尾数不全为0表示非规格化数。阶码全0尾数全0表示0。阶码全1尾数全0表示无穷大。阶码全1尾数非0表示NaN。",
    "answer": "A || 解析：在IEEE 754 标准格式中,阶码全为0,尾数不全为0表示非规格化数,非规格化数可用于处理阶码下溢,使得出现比最小规格化数还小的数时程序也能继续进行下去。"
  },
  {
    "id": "2.3.5-20",
    "type": "单项选择题",
    "question": "在规格化的浮点数中,将阶码部分的n位移码表示改为n位补码表示,其他不变,则浮点数的表示范围( )。 A. 增大 B. 减小 C. 不变 D. 都不对",
    "answer_label": "C",
    "answer_explain": "n位移码和n位补码能够表示的整数个数和范围是相同的（都是 $2^n$ 个数，范围都是 $[-2^{n-1}, 2^{n-1}-1]$）。因此，改变阶码的编码方式（从移码到补码）不会改变阶码能表示的真值范围，从而浮点数的表示范围也不变。",
    "answer": "C || 解析：在位数相同的条件下,移码和补码的表示范围是相同的,所以阶码的表示范围不变,因此浮点数的表示范围不变,只是改变了浮点数的表示形式。"
  },
  {
    "id": "2.3.5-21",
    "type": "单项选择题",
    "question": "设浮点数共12位。其中阶码含1位阶符共4位,以2为底,补码表示;尾数含1位符号共8位,补码表示,规格化。则该浮点数所能表示的最大正数是()。 A. $2^7$ B. $2^8$ C. $2^8-1$ D. $2^7-1$",
    "answer_label": "D",
    "answer_explain": "最大正数：尾数取最大正规格化数，阶码取最大正数。\n阶码4位补码，范围 $[-2^3, 2^3-1] = [-8, 7]$。最大阶码为7 (0111)。\n尾数8位补码，正规格化形式为 $0.1xxxxxxx$。最大值为 $0.1111111 = 1 - 2^{-7}$。\n最大正数为 $(1-2^{-7}) \\times 2^7 = 2^7 - 1$。",
    "answer": "D || 解析：为使浮点数取正数最大,可使尾数取正数最大,阶码取正数最大。尾数为8位补码(含符号位),正规格化数形式为0.1xxxxxxx，正值最大为0.1111111, 即 $1-2^{-7}$。阶码为4位补码(含符号位),正值最大为0111,即7。则最大正数为 $(1-2^{-7}) \\times 2^7 = 2^7-1$。"
  },
  {
    "id": "2.3.5-22",
    "type": "单项选择题",
    "question": "计算机在进行浮点数的加减运算之前先进行对阶操作,若x的阶码大于y的阶码,则应将()。 A. x的阶码缩小至与y的阶码相同,且使x的尾数部分进行算术左移 B. x的阶码缩小至与y的阶码相同,且使x的尾数部分进行算术右移 C. y的阶码扩大至与x的阶码相同,且使y的尾数部分进行算术左移 D. y的阶码扩大至与x的阶码相同,且使y的尾数部分进行算术右移",
    "answer_label": "D",
    "answer_explain": "对阶的规则是小阶向大阶看齐。即阶码小的数的阶码扩大（加1），同时尾数算术右移（除以2），直到两数的阶码相等为止。题中x的阶码大于y的阶码，所以y的阶码需要扩大，尾数需要右移。",
    "answer": "D || 解析：浮点数加减运算时,首先要进行对阶,根据对阶的规则,阶码和尾数将进行相应的操作。对阶的规则是小阶码向大阶码看齐,即阶码小的数的尾数算术右移,每右移一位,阶码加1,直到两数的阶码相等为止。"
  },
  {
    "id": "2.3.5-23",
    "type": "单项选择题",
    "question": "若浮点数的尾数用补码表示,则下列()中的尾数是规格化数形式。 A. 1.11000 B. 0.01110 C. 0.01010 D. 1.00010",
    "answer_label": "D",
    "answer_explain": "尾数用补码表示时，规格化形式要求符号位和最高数值位必须不同。A: 符号位1, 最高数值位1 (相同)。 B: 符号位0, 最高数值位0 (相同)。 C: 符号位0, 最高数值位0 (相同)。 D: 符号位1, 最高数值位0 (不同)。因此D是规格化数。",
    "answer": "D || 解析：补码的规格化表示是小数点后一位(最高数值位)与符号位不同。"
  },
  {
    "id": "2.3.5-24",
    "type": "单项选择题",
    "question": "设浮点数的基数为4,尾数用原码表示,则以下()是规格化的数。 A. 1.001101 B. 0.001101 C. 1.011011 D. 0.000010",
    "answer_label": "C",
    "answer_explain": "基数为R，尾数用原码表示时，规格化要求 $1/R \\le |M| < 1$。基数为4时，要求 $1/4 \\le |M| < 1$。尾数是原码小数。\nA: $|M|=0.001101 < 1/4$ (非规格化)。\nB: $|M|=0.001101 < 1/4$ (非规格化)。\nC: $|M|=0.011011$。 $(0.01)_4 = 1/16 < 1/4$? 不对。基数为4，用2位二进制表示一位4进制数。规格化要求最高“4进制位”非0。即尾数小数点后两位不全为0。\nA: 1.00 11 01 (最高两位00)。 B: 0.00 11 01 (最高两位00)。 C: 1.01 10 11 (最高两位01，非0)。 D: 0.00 00 10 (最高两位00)。所以C是规格化数。",
    "answer": "C || 解析：原码表示的规格化要求：对于基数R，尾数M的绝对值满足 $1/R \\le |M| < 1$。当基数为4时，R=4，要求 $1/4 \\le |M| < 1$。这意味着尾数小数点后的最高两位二进制位不能全为0。选项A: 1.001101, $|M|=0.001101$, 最高两位00。选项B: 0.001101, $|M|=0.001101$, 最高两位00。选项C: 1.011011, $|M|=0.011011$, 最高两位01。选项D: 0.000010, $|M|=0.000010$, 最高两位00。只有C满足条件。"
  },
  {
    "id": "2.3.5-25",
    "type": "单项选择题",
    "question": "下列关于舍入的说法,正确的是()。\nI. 不仅仅只有浮点数需要舍入,定点数在运算时也可能要舍入\nII. 在浮点数舍入中,只有左规格化时可能要舍入\nIII. 在浮点数舍入中,只有右规格化时可能要舍入\nIV. 在浮点数舍入中,左、右规格化均可能要舍入\nV. 舍入不一定产生误差\nA. I, III, V B. I, II, V C. V D. I, IV",
    "answer_label": "A",
    "answer_explain": "I 正确，定点数乘法结果可能位数翻倍，除法可能有小数，若要存回原字长寄存器，需要舍入。II 错误，左规是尾数左移，不会丢失位，不需要舍入。III 正确，右规是尾数右移，最低位移出丢失，需要按规则舍入。IV 错误。V 正确，例如“向偶数舍入”时，如果恰好在中间且舍入结果与原值相等（如1.5舍入到2，但如果某数本身就是2.0），或者截断法舍去的是0，则不产生误差。但是通常舍入会产生误差。 答案解析选C，只认为V正确。但I和III也应正确。再看教材原文 [cite: 2328-2331][cite_start]，舍入发生在对阶和尾数右规时。左规不涉及舍入。所以III正确，II、IV错误。定点数舍入是存在的。V是否正确存疑，通常舍入是为了在有限精度下近似表示，必然有误差，除非舍弃的是0。 按照书中答案解析选C，仅V正确。但教材内容支持III。I定点数舍入也存在。 V 舍入不一定产生误差，例如 1.100 舍入到 1.10 没有误差。 再查证，答案解析选择 C，只认为 V 正确。这似乎与常识和其他点不符。 按照PDF提供的答案解析 [cite: 2541]，选 C，认为只有 V 正确。解释是：舍入是浮点数的概念，定点数没有舍入的概念。浮点数舍入的情况有两种:对阶、右规格化。舍入不一定产生误差,如向下舍入11.00到11.0时是没有误差的。 该解析否定了 I 和 III/IV，肯定了 V。因此选择 C。",
    "answer": "C || 解析：舍入是浮点数的概念,定点数没有舍入的概念(I错误)。浮点数舍入的情况有两种:对阶、右规格化(II错误, III错误, IV错误)。舍入不一定产生误差,如向下舍入11.00到11.0时是没有误差的(V正确)。"
  },
  {
    "id": "2.3.5-26",
    "type": "单项选择题",
    "question": "计算机中的信息按边界对齐方式存储的含义是()。 A. 信息的字节长度必须是整数 B. 信息单元的字节长度必须是整数 C. 信息单元的存储地址必须是整数 D. 信息单元的存储地址是其字节长度的整数倍",
    "answer_label": "D",
    "answer_explain": "信息在存储器中按边界对齐方式存储的含义是信息单元的存储地址是其字节长度(大小)的整数倍。例如，4字节的int型数据，其起始地址必须是4的倍数。",
    "answer": "D || 解析：信息在存储器中按边界对齐方式存储的含义是信息单元的存储地址是其字节长度的整数倍。这样可以保证对一个字长数据的读/写只需要一次存储器访问,提高了访存效率,但有时会导致存储空间的浪费。因此,这是一种以空间换时间的办法。"
  },
  {
    "id": "2.3.5-27",
    "type": "单项选择题",
    "question": "假设已定义三个int型变量x、y和z,sizeof(int)=4, double型采用IEEE 754双精度浮点数格式,变量dx, dy和dz的声明和初始化如下:\ndouble dx = (double)x;\ndouble dy = (double)y;\ndouble dz = (double)z;\n则下列关系表达式中永远为真的是()。\nI. $dx+dy==(double)(x+y)$\nII. $dx \\times dx >= 0$\nIII. $dx/dx == dy/dy$\nIV. $(dx+dy)+dz == dx+(dy+dz)$\nA. I和II B. II和III C. III和IV D. II和IV",
    "answer_label": "D",
    "answer_explain": "I 非永真, $x+y$ 可能发生int溢出，而 $dx+dy$ 不会溢出（或溢出方式不同），转换后再比较可能不等。II 永真, double型平方永远非负（包括+0, +inf, NaN>=0不一定为真，但正常数值平方非负）。III 非永真, 若dx或dy为0或NaN，则结果可能不等（NaN!=NaN, 1/0=inf, 0/0=NaN）。IV 永真, 因为int到double的转换是精确的，且double精度足够高，对于由int转换来的数进行加法满足结合律（不考虑极端溢出或NaN情况）。 答案解析选D，认为II和IV永真。",
    "answer": "D || 解析：选项I非永真,因为x+y可能溢出,而dx+dy不会溢出。选项II永真,double型平方结果非负。选项III非永真,dx和dy中只要有一个为0、另一个不为0就不相等, 或者为NaN时也不等。选项IV永真,因为dx、dy和dz是由32位int型转换得到的,double型可以精确地表示int型,且对阶时尾数移动位数不会超过52位,因此尾数不会舍入,于是不会发生大数吃小数的情况，加法结合律成立。"
  },
  {
    "id": "2.3.5-28",
    "type": "单项选择题",
    "question": "在按字节编址的计算机中,采用小端方式存储数据,某静态二维数组b的声明如下:\nstatic short $b[2][4] = {{2, 9, -1, 5}, {3, 1, -6, 2}};\n若b的首地址为0x8049820,采用按行优先存储,地址0x804982c中的内容是()。\nA. FAH B. FFH C. 00H D. 05H",
    "answer_label": "A",
    "answer_explain": "short型占2字节。按行优先存储。b[0][0]地址0x8049820, b[0][1]地址0x8049822, b[0][2]地址0x8049824, b[0][3]地址0x8049826。b[1][0]地址0x8049828, b[1][1]地址0x804982a, b[1][2]地址0x804982c。该地址存放的是 b[1][2] = -6。-6的16位补码表示：+6 = 0000 0000 0000 0110。取反加1得 1111 1111 1111 1010 = FFFA H。采用小端方式存储，低地址0x804982c存放低字节 FAH，高地址0x804982d存放高字节 FFH。所以地址0x804982c中的内容是FAH。",
    "answer": "A || 解析：二维数组b的元素是short型,占2字节,采用按行优先存储。b[0][0]的地址为0x8049820, b[0][1]的地址为0x8049822, ..., b[1][0]的地址为0x8049828, b[1][1]的地址为0x804982a, b[1][2]的地址为0x804982c。b[1][2]的值为-6。-6的16位补码表示为FFFAH。采用小端方式存储,低字节FAH存放在低地址0x804982c,高字节FFH存放在高地址0x804982d。因此地址0x804982c中的内容是FAH。"
  },
  {
    "id": "2.3.5-29",
    "type": "单项选择题",
    "question": "在按字节编址的计算机中,数据在存储器中以小端方式存放。假定 int型变量i的地址为08000000H, i的机器数为01234567H,地址08000000H单元的内容是()。\nA. 01H B. 23H C. 45H D. 67H",
    "answer_label": "D",
    "answer_explain": "小端方式是将最低有效字节存储在内存的最低地址。机器数 01234567H 中，最低有效字节是 67H。因此地址 08000000H 存放的是 67H。",
    "answer": "D || 解析：小端方式是将最低有效字节存储在最小地址。在数01234567H中,最低有效字节为67H。因此地址08000000H单元的内容是67H。"
  },
  {
    "id": "2.3.5-30",
    "type": "单项选择题",
    "question": "在按字节编址的32位计算机中,按边界对齐方式为以下结构型变量x分配存储空间:\nstruct cont_info {\n  char id;\n  unsigned int post;\n  char phone;\n} x;\n若x的首地址为0x8049820,则成员变量phone的起始地址为( )。\nA. 0x8049828 B. 0x8049826 C. 0x8049825 D. 0x8049822",
    "answer_label": "A",
    "answer_explain": "按边界对齐：char占1字节，对齐值为1；unsigned int占4字节，对齐值为4。\nid存放在地址 0x8049820 (地址%1=0)。\npost需要4字节对齐，起始地址必须是4的倍数。紧接着id的地址是0x8049821，不是4的倍数。需要填充3个字节。post存放在地址 0x8049824 到 0x8049827 (地址%4=0)。\nphone是char型，占1字节，对齐值为1。紧接着post的地址是0x8049828，是1的倍数。phone存放在地址 0x8049828。\n结构体总长度需要是最大对齐值（4）的倍数。当前占用 $1(id) + 3(padding) + 4(post) + 1(phone) = 9$ 字节。需要填充3字节到12字节。phone的起始地址是0x8049828。",
    "answer": "A || 解析：结构体按边界对齐存放的要求:数据成员的起始地址是其数据类型大小的整数倍,char型占1字节,对齐值为1;unsigned int型占4字节,对齐值为4。据此分析,id 的起始地址为 0x8049820。post 的起始地址必须是4的倍数，所以是 0x8049824 (0x8049821, 0x8049822, 0x8049823为填充字节)。post占用4字节到0x8049827。phone 的起始地址为 0x8049828 (地址%1=0)。结构体x的存放方式如下所示:\n地址|820|821|822|823|824|825|826|827|828|829|82A|82B\n---|---|---|---|---|---|---|---|---|---|---|---|---\n内容|id|pad|pad|pad|post|post|post|post|phone|pad|pad|pad"
  },
  {
    "id": "2.3.5-31",
    "type": "单项选择题",
    "question": "在按字节编址,采用大端方式的16位计算机中,执行完下列C语言程序片段后,m的低字节地址的内容为( )。\nunsigned int m=n;\nint n = 0xA1B6;\nm = m >> 1;",
    "answer_label": "A",
    "answer_explain": "假设int和unsigned int都是16位。n = 0xA1B6。m = n = 0xA1B6。m是unsigned int，右移是逻辑右移。m >> 1 = 0xA1B6 >> 1 = (1010 0001 1011 0110)_2 >> 1 = (0101 0000 1101 1011)_2 = 0x50DB。采用大端方式存储，高字节存放在低地址，低字节存放在高地址。m=0x50DB，高字节是50H，低字节是DBH。低字节地址（即变量m的起始地址）存放高字节50H。",
    "answer": "A || 解析：int 型强制转换为 unsigned int型后,位模式不变。m = n = 0xA1B6。m是unsigned int型, m >> 1 是逻辑右移, 结果为 0x50DB $( (1010000110110110)_2 >> 1 = (0101000011011011)_2 )$。因为采用大端方式, 内存的低地址存放高位字节, 高地址存放低位字节。所以m的存储：低地址存50H，高地址存DBH。因此低字节地址的内容为50H。"
  },
  {
    "id": "2.3.5-32",
    "type": "单项选择题",
    "question": "假定变量i、f的数据类型分别是int、float。已知 $i=12345$, $f=1.2345\\times10^3$, 则在一个32位机器中执行下列表达式时,结果为“假”的是()。 A. $i == (int)(double)i$ B. $f == (float)(double)f$ C. $i == (int)(float)i$ D. $f == (float)(int)f$",
    "answer_label": "D",
    "answer_explain": "A: int -> double -> int。double可以精确表示int，转回int不变。为真。\nB: float -> double -> float。double精度高于float，转回float不变（假设原始f可以精确表示）。为真。\nC: int -> float -> int。$i=12345 < 2^{14}$。二进制约为14位。float尾数有23+1=24位精度。int转换为float是精确的。再转回int不变。为真。\nD: float -> int -> float。$f=1.2345\\times10^3 = 1234.5$。转换为int时，小数部分0.5丢失，变为1234。再转换为float，变为1234.0。与原来的1234.5不相等。为假。",
    "answer": "D || 解析：对于选项A和B, int型的有效位数不超过31位, float型的有效位数(24位)比 double型的(53位)小得多, 因此int和float都能精确转换为double型, 再转回原类型值不变。对于选项C, $i=12345 < 2^{14}$, 二进制位数少于24位, 因此int转换为float是精确的, 再转回int不变。对于选项D, $f=1234.5$, 转换为int型后, 小数点后面的0.5丢失, 变为1234, 再转换为float型为1234.0, 因此与原来的f不相等。"
  },
  {
    "id": "2.3.5-33",
    "type": "单项选择题",
    "question": "有以下C语言代码段:\nint m = 13;\nfloat a = 12.6, x;\nx = m / 2 + a / 2;\nprintf(\"%f\\n\", x);\n执行上述代码后,输出的x值为( )。\nA. 12.000000 B. 12.300000 C. 12.800000 D. 12",
    "answer_label": "B",
    "answer_explain": "m是int型，m/2是整数除法，$13/2 = 6$。a是float型，a/2是浮点数除法，$12.6 / 2 = 6.3$。表达式 $x = m/2 + a/2 = 6 + 6.3$。整数6会自动提升为float型6.0。$x = 6.0 + 6.3 = 12.3$。printf以%f格式输出，默认保留6位小数，结果为12.300000。",
    "answer": "B || 解析：整数与整数运算,结果为整数,所以m/2的结果为6。实数(float)与整数(2)运算,结果为实数,所以a/2的结果为6.3。整数(m/2的结果6)与实数(a/2的结果6.3)相加,整数提升为实数, 所以 $x=6.0+6.3=12.3$。C语言的输出格式%f默认保留小数点后6位,输出为12.300000。"
  },
  {
    "id": "2.3.5-34",
    "type": "单项选择题",
    "question": "【2009统考真题】浮点数加、减运算过程一般包括对阶、尾数运算、规格化、舍入和判断溢出等步骤。设浮点数的阶码和尾数均采用补码表示,且位数分别为5和7(均含2位符号位)。若有两个数 $X=2^7 \\times 29/32$ 和 $Y=2^5 \\times 5/8$,则用浮点加法计算X+Y的最终结果是()。 A. 00111 1100010 B. 00111 0100010 C. 01000 0010001 D. 发生溢出",
    "answer_label": "D",
    "answer_explain": "阶码5位补码（双符号位），范围 $[-2^3, 2^3-1] = [-8, 7]$。\n尾数7位补码（双符号位），范围 $[-2^5, 2^5-1]$? 不对，尾数通常是小数。假设是规格化小数。正数 $00.1xxxx$，负数 $11.0xxxx$。\n$X=2^7 \\times 29/32$。阶码=7 (00111)。尾数 $29/32 = (0.11101)_2$。规格化补码 $00.11101$。\nX表示为 (00111; 00.11101)\n$Y=2^5 \\times 5/8$。阶码=5 (00101)。尾数 $5/8 = (0.101)_2$。规格化补码 $00.10100$。\nY表示为 (00101; 00.10100)\n对阶：X阶码大。Y的阶码加2，尾数右移2位。$Y = 2^7 \\times (0.00101)_2$。尾数 $00.00101$。\n尾数相加：$00.11101 + 00.00101 = 01.00010$。\n规格化：结果 $01.00010$ 表示正溢出。需要右规。尾数右移1位 $00.10001$，阶码加1。阶码变为 $7+1=8$。\n判断溢出：阶码8超出了范围[-8, 7]。发生溢出。",
    "answer": "D || 解析：X的浮点数格式为 阶码 00111 (真值7); 尾数 $29/32=(0.11101)_2$, 补码 $00.11101$。\nY的浮点数格式为 阶码 00101 (真值5); 尾数 $5/8=(0.101)_2$, 补码 $00.10100$。\n然后根据浮点数的加法步骤进行运算。\n①对阶。X、Y阶码相减, 即 $00111 - 00101 = 00111 + 11011 = 00010$ (补码加法, 结果是+2),可知X的阶码比Y的阶码大2。根据小阶码向大阶码看齐的原则,将Y的阶码加2,尾数右移2位,Y变为 阶码 00111; 尾数 $00.00101$。\n②尾数相加。即 $00.11101 + 00.00101 = 01.00010$。尾数相加结果符号位为01,表示结果正溢出,需要右规。\n③规格化。将尾数右移1位,阶码加1。尾数变为 $00.10001$, 阶码变为 $00111+1=01000$ (真值8)。\n④判断溢出。阶码真值为8,超出了阶码表示范围[-8, 7]。发生溢出。"
  },
  {
    "id": "2.3.5-35",
    "type": "单项选择题",
    "question": "【2010统考真题】假定变量i、f和d的数据类型分别为int、float 和 double(...),已知 $i=785$, $f=1.5678E3$, $d=1.5E100$,若在32位机器中执行下列关系表达式,则结果为“真”的是()。\nI. $i == (int)(float)i$\nII. $f == (float)(int)f$\nIII. $f == (float)(double)f$\nIV. $(d+f)-d == f$\nA. 仅 I 和 II B. 仅 I 和 III C. 仅 II 和 III D. 仅 III 和 IV",
    "answer_label": "B",
    "answer_explain": "I: $i=785 < 2^{10}$。二进制位数少于24。int -> float 精确。float -> int 精确。为真。\nII: $f=1.5678E3 = 1567.8$。 $(int)f = 1567$。$(float)(int)f = 1567.0$。与原f不等。为假。\nIII: float -> double -> float。double精度更高，转换精确，转回不变。为真。\nIV: $d=1.5E100$ 是非常大的数。f相对很小。$d+f$ 对阶时，f的尾数会右移很多位导致精度丢失变成0（大数吃小数）。$(d+f)$ 结果近似等于d。$(d+f)-d$ 近似等于0，不等于f。为假。 因此I和III为真。",
    "answer": "B || 解析：题中三种数据类型强制类型转换的顺序为 int -> float -> double。若将 float 型转换为 int 型,小数位部分会被舍去。int 型是32位整数,而 float 型有效位只有24位,因此一个超过24位有效位的int 型整数在转换为 float 型时可能有损失精度。\n本题中 $i=785 = (110001001)_2$, 小于 $2^{10}$，有效位少于24位, 因此转换为 float 型不会发生精度损失, 选项I正确。\n对于选项II, $f=1567.8$。将 float 型的f转换为 int 型, 小数点后的数位丢失, $(int)f=1567$, 再转回float为1567.0，结果非真。\ndouble 型的精度(53位)和范围都比 float 型(24位)的大, float 型转换为 double 型不会有损失, 再转回float也不变, 选项III正确。\n对于选项IV, $d=1.5E100$ 远大于 $f=1.5678E3$。浮点运算 $d+f$ 时需要对阶, f的尾数需要右移约 $(100-3) \\times \\log_2 10 \\approx 97 \\times 3.32 \\approx 322$ 位，远超float精度，f有效位全部丢失， $(d+f)$ 的结果等于d。 $(d+f)-d = d-d = 0$，不等于f，结果非真。"
  },
  {
    "id": "2.3.5-36",
    "type": "单项选择题",
    "question": "【2011统考真题】float型数据通常用IEEE754单精度格式表示。若编译器将float型变量x分配在一个32位浮点寄存器FR1中,且 $x=-8.25$,则FR1的内容是( )。\nA. C104 0000H B. C242 0000H C. C184 0000H D. C1C2 0000H",
    "answer_label": "A",
    "answer_explain": "同例2.5。$x=-8.25 = -(1000.01)_2 = -1.00001 \\times 2^3$。\n符号S=1。指数 $E=3$。阶码 $e = E+127 = 3+127 = 130 = (10000010)_2$。\n尾数小数部分 f = $0000100...0$。\n组合：$1 10000010 00001000000000000000000$ = C104 0000H。",
    "answer": "A || 解析：本题的目的在于考查IEEE754单精度浮点数的表示。首先先将x转换成二进制为 $-1000.01 = -1.00001 \\times 2^3$。然后计算阶码E,根据IEEE754单精度浮点数格式,指数真值 $E=3$。阶码 $e = E+127 = 3+127=130$, 转换成二进制为 $10000010$。最后,根据IEEE754标准,尾数最高位的“1”是被隐藏的,小数部分 $f = 0000100...0$。\nIEEE 754 单精度浮点数格式:符号(1位)+阶码(8位)+尾数(23位)。\n因此FR1的内容为 $1 10000010 00001000000000000000000$ = C104 0000H。"
  },
  {
    "id": "2.3.5-37",
    "type": "单项选择题",
    "question": "【2012统考真题】float型(IEEE754单精度浮点数格式)能表示的最大正整数是()。 A. $2^{126}-2^{103}$ B. $2^{127}-2^{104}$ C. $2^{127}-2^{103}$ D. $2^{128}-2^{104}$",
    "answer_label": "D",
    "answer_explain": "最大规格化正浮点数：符号S=0。阶码e取最大规格化值 $254$。指数 $E=254-127=127$。尾数f取最大值（全1）。尾数真值 $M = 1.11...1$ (小数点后23个1) $= 1 + (1-2^{-23}) = 2 - 2^{-23}$。最大值为 $M \\times 2^E = (2-2^{-23}) \\times 2^{127} = 2^{128} - 2^{104}$。",
    "answer": "D || 解析：IEEE 754 单精度浮点数是尾数用采取隐藏位策略的原码表示,且阶码用移码(偏置值为127)表示的浮点数。规格化短浮点数的真值为 $(-1)^S \\times 1.f \\times 2^{e-127}$,其中S为符号位,阶码e的取值为1~254(8位表示),尾数f为23位,共32位。因此,float类型能表示的最大正数是 $e=254$, $f$ 全1时：$(1 + (1-2^{-23})) \\times 2^{254-127} = (2-2^{-23}) \\times 2^{127} = 2^{128} - 2^{104}$。"
  },
  {
    "id": "2.3.5-38",
    "type": "单项选择题",
    "question": "【2012统考真题】某计算机存储器按字节编址,采用小端方式存放数据。假定编译器规定int型和short型长度分别为32位和16位,并且数据按边界对齐存储。某C语言程序段如下:\nstruct {\n  int a;\n  char b;\n  short c;\n} record;\nrecord.a = 273;\n若 record 变量的首地址为0xC008,地址0xC008中的内容及record.c的地址分别为( )。\nA. 0x00, 0xC00D B. 0x00, 0xC00E C. 0x11, 0xC00D D. 0x11, 0xC00E",
    "answer_label": "D",
    "answer_explain": "边界对齐：int a (4B) 对齐4，char b (1B) 对齐1，short c (2B) 对齐2。\n首地址 0xC008。\na 存放在 0xC008 - 0xC00B (地址%4=0)。$record.a = 273 = 256 + 17 = (0000 0000 0000 0000 0001 0001 0001)_2 = 0x00000111$。小端存储，低字节11H存放在低地址0xC008。所以0xC008内容为0x11。\nb 存放在 0xC00C (地址%1=0)。\nc 需要2字节对齐，起始地址需为偶数。紧接着b的地址是0xC00D，不是偶数。需要填充1字节。c存放在 0xC00E - 0xC00F (地址%2=0)。所以record.c的地址为0xC00E。\n结构体总长度需为最大对齐值(4)的倍数。当前占用 $4(a) + 1(b) + 1(padding) + 2(c) = 8$ 字节。8是4的倍数。总长度8B。\n所以 0xC008内容为0x11，record.c地址为0xC00E。",
    "answer": "D || 解析：结构体 record 大小：int a占4B，char b占1B，short c占2B。按边界对齐存储：a起始地址需是4的倍数，b起始地址需是1的倍数，c起始地址需是2的倍数。结构体总大小需是最大对齐值(4)的倍数。\n首地址 0xC008 (是4的倍数)。a 存放在 0xC008 - 0xC00B。\n$record.a = 273 = (0x00000111)_{16}$。采用小端方式存放数据, 低字节 11H 存放在低地址 0xC008, 01H 存放在 0xC009, 00H 存放在 0xC00A, 00H 存放在 0xC00B。\n地址 0xC008 中的内容为 0x11。\nb 存放在 0xC00C (是1的倍数)。\nc 需存放在2的倍数地址。紧邻b的地址是0xC00D, 不是偶数。需要填充1字节在0xC00D。c 存放在 0xC00E - 0xC00F。\nrecord.c 的地址为 0xC00E。\n结构体总大小 $4+1+1(padding)+2=8$ 字节，是4的倍数。"
  },
  {
    "id": "2.3.5-39",
    "type": "单项选择题",
    "question": "【2013统考真题】某数采用IEEE754单精度浮点数格式表示为C6400000H,则该数的值是()。 A. $-1.5 \\times 2^{13}$ B. $-1.5 \\times 2^{12}$ C. $-0.5 \\times 2^{13}$ D. $-0.5 \\times 2^{12}$",
    "answer_label": "A",
    "answer_explain": "同 例2.6 和 2.3.5-10 类似题。C6400000H = $1 10001100 10000000000000000000000$。\n符号S=1 (负数)。阶码 e = $(10001100)_2 = 128+8+4 = 140$。指数 $E = e - 127 = 140 - 127 = 13$。\n尾数小数部分 f = $100...0$。尾数真值 M = $1.f = (1.1)_2 = 1 + 1/2 = 1.5$。\n数值为 $(-1)^S \\times M \\times 2^E = -1.5 \\times 2^{13}$。",
    "answer": "A || 解析：IEEE 754 单精度浮点数格式为C6400000H, 二进制格式为 $1 10001100 10000000000000000000000$。\n符号为1表示负数。\n阶码 e = $(10001100)_2 = 140$。指数真值 $E = e - 127 = 140 - 127 = 13$。\n尾数小数部分 $f = 100...0$。尾数真值 $M = 1.f = (1.1)_2 = 1.5$。\n因此, 浮点数的值为 $-1.5 \\times 2^{13}$。"
  },
  {
    "id": "2.3.5-40",
    "type": "单项选择题",
    "question": "【2014统考真题】float型数据常用IEEE754单精度浮点格式表示。假设两个float型变量x和y分别存放在32位寄存器f1和f2中,若(f1)=CC900000H, (f2)=B0C00000H,则x和y之间的关系为( )。\nA. x<y且符号相同 B. x<y且符号不同 C. x>y且符号相同 D. x>y且符号不同",
    "answer_label": "A",
    "answer_explain": "(f1) = CC900000H = $1 10011001 10010...0$。 符号S=1 (负)。阶码e=$(10011001)_2 = 153$。指数 $E=153-127=26$。尾数 $M=1.1001$。\nx = $-1.1001 \\times 2^{26}$。\n(f2) = B0C00000H = $1 01100001 10000...0$。 符号S=1 (负)。阶码e=$(01100001)_2 = 97$。指数 $E=97-127=-30$。尾数 $M=1.1$。\ny = $-1.1 \\times 2^{-30}$。\n两者符号相同（都为负）。比较绝对值：$|x| = 1.1001 \\times 2^{26}$ 远大于 $|y| = 1.1 \\times 2^{-30}$。因为是负数，所以 x < y。",
    "answer": "A || 解析：(f1)=CC900000H 对应的二进制是 $(1100 1100 1001 ...)_2$。\n(f2)=B0C00000H 对应的二进制是 $(1011 0000 1100 ...)_2$。\n根据IEEE 754 浮点数标准,可知 (f1) 的符号为1,阶码为 $(10011001)_2=153$, 指数 $E1=153-127=26$。 (f2) 的符号为1,阶码为 $(01100001)_2=97$, 指数 $E2=97-127=-30$。\n可知两数均为负数,符号相同,B、D排除。\n因为 $E1 > E2$, 所以 $|x| > |y|$。而符号为负,真值大小相反,即 $x < y$。"
  },
  {
    "id": "2.3.5-41",
    "type": "单项选择题",
    "question": "【2015统考真题】下列有关浮点数加减运算的叙述中,正确的是()。\nI. 对阶操作不会引起阶码上溢或下溢\nII. 右规和尾数舍入都可能引起阶码上溢\nIII. 左规时可能引起阶码下溢\nIV. 尾数溢出时结果不一定溢出\nA. 仅 II、III B. 仅 I, II, IV C. 仅 I, III, IV D. I, II, III, IV",
    "answer_label": "D",
    "answer_explain": "I: 对阶是小阶向大阶看齐，阶码不变或增大（等于较大阶码），不会下溢。也不会上溢，因为结果阶码等于原来两个阶码中较大的那个，原来不大就不会溢出。正确。\nII: 右规时尾数右移，阶码加1，可能导致阶码上溢。舍入（如0舍1入）也可能导致尾数加1产生进位，需要再次右规，阶码再加1，也可能上溢。正确。\nIII: 左规时尾数左移，阶码减1，可能导致阶码下溢。正确。\nIV: 尾数计算溢出（如两个正尾数相加结果大于等于2，或负尾数相加结果小于-2）可以通过右规操作纠正，最终是否溢出取决于右规后阶码是否上溢。所以尾数溢出不代表最终结果溢出。正确。\n全部正确。",
    "answer": "D || 解析：对阶是较小的阶码向较大的阶码对齐,所以对阶后的阶码是两个阶码中较大的那个,不可能发生阶码溢出,选项I正确。右规和尾数舍入过程,都可能使尾数加1导致需要右规，阶码加1而可能上溢,选项II正确。左规时阶码减1，可能导致阶码下溢,同理选项III也正确。尾数计算结果溢出时可以通过右规操作调整，结果不一定溢出,选项IV正确。"
  },
  {
    "id": "2.3.5-42",
    "type": "单项选择题",
    "question": "【2016统考真题】某计算机字长为32位,按字节编址,采用小端方式存放数据。假定有一个double型变量,其机器数表示为1122334455667788H,存放在以00008040H开始的连续存储单元中,则存储单元00008046H中存放的是()。\nA. 22H B. 33H C. 77H D. 66H",
    "answer_label": "A",
    "answer_explain": "double型变量占8字节。机器数1122334455667788H。小端存储，低字节存放在低地址。存放顺序（地址从低到高）：88H, 77H, 66H, 55H, 44H, 33H, 22H, 11H。\n地址：8040H, 8041H, 8042H, 8043H, 8044H, 8045H, 8046H, 8047H。\n所以地址00008046H中存放的是22H。",
    "answer": "A || 解析：大端方式:一个字中的高位字节存放在内存中这个字区域的低地址处。小端方式:一个字中的低位字节存放在内存中这个字区域的低地址处。double型变量占8字节。机器数为 1122334455667788H。按小端方式存放：\n地址 | 内容\n---|---\n8040H | 88H\n8041H | 77H\n8042H | 66H\n8043H | 55H\n8044H | 44H\n8045H | 33H\n8046H | 22H\n8047H | 11H\n从而存储单元00008046H中存放的是22H。"
  },
  {
    "id": "2.3.5-43",
    "type": "单项选择题",
    "question": "【2018统考真题】IEEE754单精度浮点格式表示的数中,最小的规格化正数是()。 A. $1.0 \\times 2^{-126}$ B. $1.0 \\times 2^{-127}$ C. $1.0 \\times 2^{-128}$ D. $1.0 \\times 2^{-149}$",
    "answer_label": "A",
    "answer_explain": "最小规格化正数：符号S=0。阶码e取最小值1 (0不是规格化)。指数 $E=e-127 = 1-127 = -126$。尾数f取最小值0。尾数真值 $M=1.f = 1.0$。最小规格化正数为 $1.0 \\times 2^{-126}$。",
    "answer": "A || 解析：IEEE 754 单精度浮点数的符号位、阶码位、尾数位(省去隐藏位1)所占的位数分别是1、8、23。最小规格化正数: 符号位取0。阶码e的取值范围是1~254,取最小值1,得指数真值 $E = e - 127 = 1-127=-126$。尾数f取最小值全0。最终推出最小规格化正数为 $1.0 \\times 2^{-126}$。"
  },
  {
    "id": "2.3.5-44",
    "type": "单项选择题",
    "question": "【2018统考真题】某32位计算机按字节编址,采用小端方式。若语句“int i=0;”对应指令的机器代码为“C745 FC 00000000”,则语句“int i=-64;”对应指令的机器代码是()。\nA. C7 45 FC C0 FF FF FF B. C7 45 FC 0C FF FF FF C. C7 45 FC FF FF FF C0 D. C7 45 FC FF FF FF 0C",
    "answer_label": "A",
    "answer_explain": "指令“C745 FC”部分表示将后续的32位立即数存入地址[ebp-4]（通常是局部变量i的位置）。“00000000”是立即数0的小端存储形式。需要找到-64的32位补码的小端存储形式。-64的32位补码：+64 = 0x00000040。取反加1得 0xFFFFFFBF + 1 = 0xFFFFFFC0。小端存储，低字节C0存放在低地址，然后是FF, FF, FF。所以立即数部分是 C0 FF FF FF。完整指令代码为 C7 45 FC C0 FF FF FF。",
    "answer": "A || 解析：按字节编址,采用小端方式,低位的数据存储在低地址位、高位的数据存储在高地址位,并且按照一字节的顺序存储。由题意,存储0的机器代码后4字节是00000000 (小端)。我们需要把-64的32位补码按小端方式存储。 $-64$ 表示成32位的十六进制补码是FFFFFFC0H。根据小端方式的特点,低位字节C0存储在低地址,然后是FF, FF, FF。所以机器代码应为 C7 45 FC C0 FF FF FF。"
  },
  {
    "id": "2.3.5-45",
    "type": "单项选择题",
    "question": "【2020统考真题】在按字节编址、采用小端方式的32位计算机中,按边界对齐方式为以下C语言结构型变量分配存储空间:\nstruct record {\n  short x1;\n  int   x2;\n} a;\n若a的首地址为2020FE00H, a的成员变量x2的机器数为12340000H,则其中34H所在存储单元的地址是()。\nA. 2020FE03H B. 2020FE04H C. 2020FE05H D. 2020FE06H",
    "answer_label": "D",
    "answer_explain": "边界对齐：short x1 (2B) 对齐2，int x2 (4B) 对齐4。\n首地址 2020FE00H (是4的倍数，也是2的倍数)。\nx1 存放在 2020FE00H - 2020FE01H (地址%2=0)。\nx2 需要4字节对齐。紧接着x1的地址是2020FE02H，不是4的倍数。需要填充2字节。x2存放在 2020FE04H - 2020FE07H (地址%4=0)。\nx2的机器数为12340000H。小端存储，低字节00H存放在低地址2020FE04H，下一个字节00H在2020FE05H，接着34H在2020FE06H，最高字节12H在2020FE07H。\n所以34H所在地址是 2020FE06H。",
    "answer": "D || 解析：在32位计算机中,按字节编址,根据小端方式和按边界对齐的定义,变量a的存放方式:\nshort x1占2字节，对齐值为2。int x2占4字节，对齐值为4。\na的首地址 2020FE00H (是4的倍数)。\nx1 存放在 2020FE00H - 2020FE01H。\nx2 需存放在4的倍数地址。紧邻x1的地址是2020FE02H，不是4的倍数。需填充2字节在2020FE02H, 2020FE03H。\nx2 存放在 2020FE04H - 2020FE07H。\nx2 的机器数为 12340000H。采用小端存储，字节存放顺序为 00H, 00H, 34H, 12H。\n地址 | 内容\n---|---\nFE04H | 00H\nFE05H | 00H\nFE06H | 34H\nFE07H | 12H\n于是,34H所在存储单元的地址为2020FE06H。"
  },
  {
    "id": "2.3.5-46",
    "type": "单项选择题",
    "question": "【2020统考真题】已知有符号整数用补码表示,float型数据用IEEE 754标准表示,假定变量x的类型只可能是int或float,当x的机器数为C8000000H时,x的值可能是()。 A. $-7 \\times 2^{27}$ B. $-2^{16}$ C. $2^{17}$ D. $2.5 \\times 2^{17}$",
    "answer_label": "A",
    "answer_explain": "机器数 C8000000H = $(1100 1000 0000 ... 0)_2$。\n1) 若为 int 型 (32位补码): 最高位为1，是负数。求原码：数值位取反加1。 $100 1000 ... 0$ 取反是 $011 0111 ... 1$，加1是 $011 1000 ... 0$。原码是 $1011 1000 ... 0$。真值为 $-(2^{30} + 2^{29} + 2^{28}) = -(7 \\times 2^{28})$? 不对，求补码的真值可以直接按权展开，符号位权为 $-2^{31}$。值为 $-2^{31} + 2^{30} + 2^{27} = -2^{30} + 2^{27}$? 还是不对。 重新计算真值：补码 $11001000...0$。真值 = $-(各位取反加1)$ = $-(00110111...1 + 1) = -(00111000...0) = -(2^{29}+2^{28}+2^{27}) = -(4+2+1) \\times 2^{27} = -7 \\times 2^{27}$。\n2) 若为 float 型 (IEEE 754): $1 10010000 000...0$。符号S=1 (负)。阶码 e = $(10010000)_2 = 128+16=144$。指数 $E=e-127=144-127=17$。尾数小数部分f=0。尾数真值M=1.0。值为 $-1.0 \\times 2^{17} = -2^{17}$。\n比较选项：A: $-7 \\times 2^{27}$ (可能，如果是int)。 B: $-2^{16}$ (不是)。 C: $2^{17}$ (正数，不是)。 D: $2.5 \\times 2^{17}$ (正数，不是)。 因此选A。",
    "answer": "A || 解析：机器数 C8000000H = $1100 1000 0000 0000 0000 0000 0000 0000$。\n将其转换为对应的float型或int型。\n1) 若为float型(IEEE 754单精度),则 $S=1$, $e=(10010000)_2=144$, $f=0$。指数 $E=e-127=144-127=17$。尾数 $M=1.0$。x的值为 $-1.0 \\times 2^{17} = -2^{17}$。\n2) 若为int型(32位补码), 最高位1表示负数。求真值：按权展开，符号位权 $-2^{31}$。值为 $-2^{31} + 2^{30} + 2^{27} = -2^{30}(2-1) + 2^{27} = -2^{30} + 2^{27}$? 另一种方法：各位取反加1求绝对值。取反 $0011 0111 ... 1$, 加1 $0011 1000 ... 0 = 2^{29}+2^{28}+2^{27} = (4+2+1)\\times 2^{27} = 7 \\times 2^{27}$。所以真值为 $-7 \\times 2^{27}$。\n比较选项，选A。"
  },
  {
    "id": "2.3.5-47",
    "type": "单项选择题",
    "question": "【2021统考真题】下列数值中,不能用 IEEE 754浮点格式精确表示的是( )。 A. 1.2 B. 1.25 C. 2.0 D. 2.5",
    "answer_label": "A",
    "answer_explain": "IEEE 754 浮点格式基于二进制。能精确表示的数，其小数部分必须能表示为有限个 $2^{-k}$ 之和。\nA: 1.2。小数部分0.2。转二进制：$0.2\\times2=0.4$(0), $0.4\\times2=0.8$(0), $0.8\\times2=1.6$(1), $0.6\\times2=1.2$(1), $0.2\\times2=0.4$(0)... 循环 0011。无法精确表示。\nB: 1.25 = $1 + 1/4 = (1.01)_2$。可以精确表示。\nC: 2.0 = $(10.0)_2 = 1.0 \\times 2^1$。可以精确表示。\nD: 2.5 = $2 + 1/2 = (10.1)_2 = 1.01 \\times 2^1$。可以精确表示。",
    "answer": "A || 解析：使用排除法。选项B: $1.25 = 1 + 0.25 = 1 + 1/4 = (1.01)_2$。选项C: $2.0 = (10.0)_2$。选项D: $2.5 = 2 + 0.5 = (10.1)_2$。因此,选项B、C和D均可以用IEEE754浮点格式精确表示。选项A的十进制小数1.2转换成二进制的结果是无限循环小数 $1.00110011..._2$,无法用精度有限的IEEE754格式精确表示。"
  },
  {
    "id": "2.3.5-48",
    "type": "单项选择题",
    "question": "【2022统考真题】-0.4375的IEEE754单精度浮点数表示为( )。 A. BEE0 0000H B. BF60 0000H C. BF70 0000H D. COE0 0000H",
    "answer_label": "A",
    "answer_explain": "-0.4375。小数部分 $0.4375 = 0.25 + 0.125 + 0.0625 = 1/4 + 1/8 + 1/16 = (0.0111)_2$。\n$-0.4375 = -(0.0111)_2 = -1.11 \\times 2^{-2}$。\n符号S=1。指数 $E=-2$。阶码 $e = E+127 = -2+127=125 = (01111101)_2$。\n尾数小数部分 f = $1100...0$。\n组合：$1 01111101 11000000000000000000000$ = BEE0 0000H。",
    "answer": "A || 解析：IEEE 754 单精度浮点数格式中依次为符号1位、阶码8位(偏置值127)、尾数23位(隐藏1位)。\n$-0.4375 = -(0.5 - 0.0625)?$ 不对。 $0.4375 = 7/16 = (0.0111)_2$。\n$-0.4375 = -(0.0111)_2 = -1.11 \\times 2^{-2}$。规格化形式。\n根据单精度浮点数格式: 符号S=1。指数 $E=-2$。阶码 $e = E+127 = -2+127=125$, 8位二进制为 $01111101$。尾数隐藏小数点前的1, 剩下的 $f = 1100...0$ (23位)。\n该浮点数的二进制格式为 $1 01111101 11000000000000000000000$。\n对应的十六进制格式为 BEE0 0000H。"
  },
  {
    "id": "2.3.5-49",
    "type": "单项选择题",
    "question": "【2023统考真题】若short型变量x=-8190,则x的机器数是( )。 A. E002H B. E001H C. 9FFFH D. 9FFEH",
    "answer_label": "A",
    "answer_explain": "short型为16位有符号整数，补码表示。x是负数。先求+8190的二进制。$8190 = 8192 - 2 = 2^{13} - 2^1 = (0010 0000 0000 0000)_2 - (0000 0000 0000 0010)_2 = (0001 1111 1111 1110)_2$。这是+8190的原码和补码。求-8190的补码：按位取反加1。取反 $1110 0000 0000 0001$。加1得 $1110 0000 0000 0010$ = E002H。",
    "answer": "A || 解析：short 型变量是补码表示的16位有符号整数。x是负数,可先求出+8190的机器数。 $8190 = 8192-2 = 2^{13}-2^1$。 $+8190$ 的16位二进制表示为 $0001 1111 1111 1110$。求 $-8190$ 的补码：将 $+8190$ 的二进制按位取反,末位加1。取反得 $1110 0000 0000 0001$。末位加1得 $1110 0000 0000 0010$ = E002H。"
  },
  {
    "id": "2.3.5-50",
    "type": "单项选择题",
    "question": "【2023统考真题】已知float 型变量用 IEEE 754单精度浮点数格式表示。若float 型变量x的机器数为80200000H,则x的值是()。 A. $-2^{-128}$ B. $-1.01 \\times 2^{-127}$ C. $-1.01 \\times 2^{-126}$ D. 非数(NaN)",
    "answer_label": "A",
    "answer_explain": "机器数 80200000H = $1 00000000 0100...0$。\n符号S=1 (负)。阶码e = 0。尾数小数部分 $f = 0100...0$ (非0)。\n根据IEEE 754规则，阶码为0且尾数非0表示非规格化数。\n非规格化数的指数真值固定为 $1-127 = -126$。尾数真值 $M = 0.f = (0.01)_2 = 1/4$。\n值为 $(-1)^S \\times M \\times 2^{-126} = -1 \\times (1/4) \\times 2^{-126} = -2^{-2} \\times 2^{-126} = -2^{-128}$。",
    "answer": "A || 解析：把x的机器数按二进制展开, 80200000H = $1 00000000 01000000000000000000000$。\n符号S=1为负。阶码e全为0。尾数f = $0100...0$ 不全为0。\n由表2.4可知,这是非规格化数。对于32位非规格化负数,其真值为 $-2^{-126} \\times (0.f)$。这里 $f=(0100...)_2$, 所以 $(0.f)_2 = (0.01)_2 = 1/4 = 2^{-2}$。因此 x的值是 $-2^{-126} \\times 2^{-2} = -2^{-128}$。\n值的类型 | 符号 | 阶码 | 尾数 | 值 (单精度)\n---|---|---|---|---\n非规格化正数 | 0 | 0 | $f\\ne0$ | $2^{-126}(0.f)$\n非规格化负数 | 1 | 0 | $f\\ne0$ | $-2^{-126}(0.f)$"
  },
  {
    "id": "2.3.5-51",
    "type": "单项选择题",
    "question": "【2024统考真题】某科学实验中,需要使用大量的整型参数,为了在保证表数精度的基础上提高运算速度,需要选择合理的数据表示方法。若整型参数 $\\alpha, \\beta$ 的取值范围分别为 $-2^{20} \\sim 2^{20}$, $-2^{40} \\sim 2^{40}$,则在下列选项中, $\\alpha, \\beta$ 最适合采用的数据表示方法分别是()。 A. 32位整数、32位整数 B. 单精度浮点数、单精度浮点数 C. 32位整数、双精度浮点数 D. 单精度浮点数、双精度浮点数",
    "answer_label": "C",
    "answer_explain": "参数是整型参数，优先考虑用整型表示以保证精度和运算速度。\n$\\alpha$ 的范围是 $[-2^{20}, 2^{20}]$。32位整数（int）的范围是 $[-2^{31}, 2^{31}-1]$，完全覆盖 $\\alpha$ 的范围。单精度浮点数（float）尾数精度24位，可以精确表示 $[-2^{24}, 2^{24}]$ 之间的整数，也能覆盖 $\\alpha$ 的范围，但整数运算速度通常比浮点运算快且无精度损失。所以 $\\alpha$ 适合用32位整数。\n$\\beta$ 的范围是 $[-2^{40}, 2^{40}]$。32位整数无法表示。64位整数（long long）范围是 $[-2^{63}, 2^{63}-1]$，可以表示。单精度浮点数（float）最大正数约为 $2^{128}$，范围足够，但尾数精度只有24位，无法精确表示所有 $2^{40}$ 以内的整数。双精度浮点数（double）尾数精度53位，可以精确表示 $[-2^{53}, 2^{53}]$ 之间的整数，覆盖 $\\beta$ 的范围。在没有64位整数选项的情况下，双精度浮点数是表示 $\\beta$ 的合适选择。\n因此 $\\alpha$ 用32位整数， $\\beta$ 用双精度浮点数。",
    "answer": "C || 解析：表示整数时,相同位数的浮点型的精度不如整型,因此在能满足 $\\alpha, \\beta$ 的取值范围的前提下,应优先选择整型;否则,才选择浮点型。32位补码整数的表示范围是 $[-2^{31}, 2^{31}-1]$, 满足 $\\alpha$ 的取值范围 $[-2^{20}, 2^{20}]$, 因此 $\\alpha$ 应采用32位整数。 $\\beta$ 的范围 $[-2^{40}, 2^{40}]$ 超出了32位整数和单精度浮点数可以精确表示的整数范围（float精度24位）。双精度浮点数的尾数精度为53位，可以精确表示 $[-2^{53}, 2^{53}]$ 之间的所有整数，满足 $\\beta$ 的精度要求和范围要求。因此 $\\beta$ 应采用双精度浮点数。"
  }