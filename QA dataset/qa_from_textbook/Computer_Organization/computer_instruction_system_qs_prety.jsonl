{"id": "1", "type": "单项选择题", "question": "01.下列关于指令集体系结构和指令系统的说法中,错误的是()。 A.指令集体系结构位于计算机软/硬件的交界面上 B. 指令集体系结构是指低级语言程序员所看到的概念结构和功能特性 C. 任何程序运行前都要先转换为机器语言程序 D. 指令系统和机器语言是无关的", "answer_label": "D", "answer_explain": "指令集体系结构(ISA)完整定义了软件和硬件之间的接口,是机器语言或汇编语言程序员 所应熟悉的。指令系统是计算机硬件的语言系统,这显然和机器语言有关。", "answer": "D || 解析：指令集体系结构(ISA)完整定义了软件和硬件之间的接口,是机器语言或汇编语言程序员 所应熟悉的。指令系统是计算机硬件的语言系统,这显然和机器语言有关。"}
{"id": "2", "type": "单项选择题", "question": "02.下列有关指令集体系结构(ISA)的叙述中,错误的是()。 A. ISA规定了执行每条指令时所包含的控制信号 B. ISA规定了指令获取操作数的方式,即寻址方式 C. ISA规定了所有指令的集合,包括指令格式和操作类型 D. ISA规定了程序可访问的寄存器个数、存储空间大小、编址方式和大端/小端方式", "answer_label": "A", "answer_explain": "指令集体系结构(ISA)是软件和硬件之间接口的一个完整定义,包含了基本数据类型、指 令集、寄存器、寻址模式、存储体系、中断和异常处理及外部I/O。ISA规定了执行每条指令时所 需要的操作码、操作数、寻址方式等信息,以及指令的功能和效果。控制信号是由控制单元根据 ISA 生成的,它属于微架构层面的实现细节,而不是ISA层面的抽象定义。", "answer": "A || 解析：指令集体系结构(ISA)是软件和硬件之间接口的一个完整定义,包含了基本数据类型、指 令集、寄存器、寻址模式、存储体系、中断和异常处理及外部I/O。ISA规定了执行每条指令时所 需要的操作码、操作数、寻址方式等信息,以及指令的功能和效果。控制信号是由控制单元根据 ISA 生成的,它属于微架构层面的实现细节,而不是ISA层面的抽象定义。"}
{"id": "3", "type": "单项选择题", "question": "03.在CPU执行指令的过程中,指令的地址由()给出。 A. 程序计数器(PC) B. 指令的地址码字段 C. 操作系统 D. 程序员", "answer_label": "A", "answer_explain": "PC存放当前欲执行指令的地址,而指令的地址码字段则保存操作数地址。", "answer": "A || 解析：PC存放当前欲执行指令的地址,而指令的地址码字段则保存操作数地址。"}
{"id": "4", "type": "单项选择题", "question": "04.运算型指令的寻址与转移型指令的寻址的不同点在于( ) A.前者取操作数,后者决定程序转移地址 B. 后者取操作数,前者决定程序转移地址 C.前者是短指令,后者是长指令 D.前者是长指令,后者是短指令", "answer_label": "A", "answer_explain": "运算型指令寻址的是操作数,而转移型指令寻址的是下次欲执行的指令的地址。", "answer": "A || 解析：运算型指令寻址的是操作数,而转移型指令寻址的是下次欲执行的指令的地址。"}
{"id": "5", "type": "单项选择题", "question": "05.程序控制类指令的功能是()。 A.进行算术运算和逻辑运算 B.进行主存与CPU之间的数据传送 C.进行CPU和1/0设备之间的数据传送 D. 改变程序执行的顺序", "answer_label": "D", "answer_explain": "程序控制类指令用于改变程序执行的顺序,并使程序具有测试、分析、判断和循环执行的能力。", "answer": "D || 解析：程序控制类指令用于改变程序执行的顺序,并使程序具有测试、分析、判断和循环执行的能力。"}
{"id": "6", "type": "单项选择题", "question": "06. 下列指令中不属于程序控制指令的是( )。 A.无条件转移指令 B.条件转移指令 C. 中断隐指令 D. 循环指令", "answer_label": "C", "answer_explain": "程序控制类指令主要包括无条件转移、有条件转移、子程序调用和返回指令、循环指令等。中断隐指令是由硬件实现的,并不是指令系统中存在的指令,更不可能属于程序控制类指令。", "answer": "C || 解析：程序控制类指令主要包括无条件转移、有条件转移、子程序调用和返回指令、循环指令等。中断隐指令是由硬件实现的,并不是指令系统中存在的指令,更不可能属于程序控制类指令。"}
{"id": "7", "type": "单项选择题", "question": "07.下列指令中应用程序不准使用的指令是( ) A. 循环指令 B. 转换指令 C. 特权指令 D. 条件转移指令", "answer_label": "C", "answer_explain": "特权指令是指仅用于操作系统或其他系统软件的指令。为确保系统与数据安全起见,这类指 令不提供给用户使用。", "answer": "C || 解析：特权指令是指仅用于操作系统或其他系统软件的指令。为确保系统与数据安全起见,这类指 令不提供给用户使用。"}
{"id": "8", "type": "单项选择题", "question": "08.堆栈计算机中,有些堆栈零地址的运算类指令在指令格式中不给出操作数的地址,参加 的两个操作数来自()。 A. 累加器和寄存器 B. 累加器和暂存器 C.堆栈的栈顶和次栈顶单元 D. 堆栈的栈顶单元和暂存器", "answer_label": "C", "answer_explain": "零地址的运算类指令也称堆栈运算指令,参与的两个操作数来自栈顶和次栈顶单元。", "answer": "C || 解析：零地址的运算类指令也称堆栈运算指令,参与的两个操作数来自栈顶和次栈顶单元。"}
{"id": "9", "type": "单项选择题", "question": "09. 以下叙述错误的是()。 A.为了便于取指令,指令的长度通常为存储字长的整数倍 B.单地址指令是固定长度的指令 C.单字长指令可加快取指令的速度 D. 单地址指令可能有一个操作数,也可能有两个操作数", "answer_label": "B", "answer_explain": "指令的地址个数与指令的长度是否固定没有必然联系,即使是单地址指令,也可能由于单地 址的寻址方式不同而导致指令长度不同。", "answer": "B || 解析：指令的地址个数与指令的长度是否固定没有必然联系,即使是单地址指令,也可能由于单地 址的寻址方式不同而导致指令长度不同。"}
{"id": "10", "type": "单项选择题", "question": "10.能够完成两个数的算术运算的单地址指令,地址码指明一个操作数,另一个操作数来自 ()方式。 A. 立即寻址 B. 隐含寻址 C. 间接寻址 D. 基址寻址", "answer_label": "B", "answer_explain": "单地址指令中只有一个地址码,在完成两个操作数的算术运算时,一个操作数由地址码指出, 另一个操作数通常存放在累加寄存器(ACC)中,属于隐含寻址。", "answer": "B || 解析：单地址指令中只有一个地址码,在完成两个操作数的算术运算时,一个操作数由地址码指出, 另一个操作数通常存放在累加寄存器(ACC)中,属于隐含寻址。"}
{"id": "11", "type": "单项选择题", "question": "11.设机器字长为32位,一个容量为16MB的存储器,CPU按半字寻址,其寻址单元数是 (). Α. 224 B. 223 C. 222 D. 221", "answer_label": "B", "answer_explain": "$16M=2^{24}$,字长为32位,现在按半字(16位)寻址,相当于有8M $(=2^{23})$ 个存储单元, 每个存储单元中存放16位。", "answer": "B || 解析：$16M=2^{24}$,字长为32位,现在按半字(16位)寻址,相当于有8M $(=2^{23})$ 个存储单元, 每个存储单元中存放16位。"}
{"id": "12", "type": "单项选择题", "question": "12.某指令系统有200条指令,对操作码采用固定长度二进制编码,最少需要用()位。 A. 4 B. 8 C. 16 D. 32", "answer_label": "B", "answer_explain": "因 $128=2^{7}<200<2^{8}=256$,因此采用定长操作码时,至少需要8位。", "answer": "B || 解析：因 $128=2^{7}<200<2^{8}=256$,因此采用定长操作码时,至少需要8位。"}
{"id": "13", "type": "单项选择题", "question": "13.在指令格式中,采用扩展操作码设计方案的目的是()。 A. 减少指令字长度 B.增加指令字长度 C.保持指令字长度不变而增加指令的数量 D. 保持指令字长度不变而增加寻址空间", "answer_label": "C", "answer_explain": "扩展操作码并未改变指令的长度,而是使操作码长度随地址码的减少而增加。", "answer": "C || 解析：扩展操作码并未改变指令的长度,而是使操作码长度随地址码的减少而增加。"}
{"id": "14", "type": "单项选择题", "question": "14.一个计算机系统采用32位单字长指令,地址码为12位,若定义了250条二地址指令, 则还可以有( )条单地址指令。 A. 212 B. 213 C. 214 D. 3x213", "answer_label": "D", "answer_explain": "地址码为12位,二地址指令的操作码长度为32-12-12-8位,已定义了250条二地址指 令, $2^{8}-250=6$,即可以设计出单地址指令 $6\\times2^{12}=3\\times2^{13}$ 条。", "answer": "D || 解析：地址码为12位,二地址指令的操作码长度为32-12-12-8位,已定义了250条二地址指 令, $2^{8}-250=6$,即可以设计出单地址指令 $6\\times2^{12}=3\\times2^{13}$ 条。"}
{"id": "15", "type": "单项选择题", "question": "15.【2017统考真题】某计算机按字节编址,指令字长固定且只有两种指令格式,其中三 地址指令29条、二地址指令107条,每个地址字段为6位,则指令字长至少应该是 () A. 24位 B. 26位 C. 28位 D. 32位", "answer_label": "A", "answer_explain": "三地址指令有29条,所以其操作码至少为5位。以5位进行计算,它剩余32-29 3种操作 码给二地址。而二地址额外多了6位给操作码,因此其数量最大达3×64=192。所以指令字长最少 为23位,因为计算机按字节编址,需要是8的倍数,所以指令字长至少应该是24位。", "answer": "A || 解析：三地址指令有29条,所以其操作码至少为5位。以5位进行计算,它剩余32-29 3种操作 码给二地址。而二地址额外多了6位给操作码,因此其数量最大达3×64=192。所以指令字长最少 为23位,因为计算机按字节编址,需要是8的倍数,所以指令字长至少应该是24位。"}
{"id": "16", "type": "单项选择题", "question": "16.【2022统考真题】下列选项中,属于指令集体系结构(ISA)规定的内容是( )。 Ⅰ. 指令字格式和指令类型 II. CPU的时钟周期 III. 通用寄存器个数和位数 IV.加法器的进位方式 A. 仅1 II B. 仅1、III C.仅II IV D. 仅I、III、IV", "answer_label": "B", "answer_explain": "指令集体系结构处于软/硬件的交界面上。指令字和指令格式、通用寄存器个数和位数都与机 器指令有关,由ISA规定。两个CPU可以有不同的时钟周期,但指令集可以相同:加法器的进 位方式涉及电路设计,这两项都属于计算机的硬件部分,不由ISA规定。", "answer": "B || 解析：指令集体系结构处于软/硬件的交界面上。指令字和指令格式、通用寄存器个数和位数都与机 器指令有关,由ISA规定。两个CPU可以有不同的时钟周期,但指令集可以相同:加法器的进 位方式涉及电路设计,这两项都属于计算机的硬件部分,不由ISA规定。"}
{"id": "17", "type": "单项选择题", "question": "17.【2022统考真题】设计某指令系统时,假设采用16位定长指令字格式,操作码使用扩 展编码方式,地址码为6位,包含零地址、一地址和二地址3种格式的指令。若二地址 指令有12条,一地址指令有254条,则零地址指令的条数最多为( )。 A. 0 B. 2 C. 64 D. 128", "answer_label": "D", "answer_explain": "地址码为6位,一条二地址指令会占用2°条一地址指令的空间,一条一地址指令会占用2° 条零地址指令的空间。若全都是零地址指令,则最多有2条,减去一地址指令和二地址指令所 占用的零地址指令空间,即20-254×26-12×2×2=(21-254-12×2 )×2=2×2=128。 【另解】二地址指令有12条,则剩余16-12=4种操作码给一地址指令,一地址指令有254 条,剩余4×64-254=2种操作码给0地址指令,所以0地址一共有2×2=128条。", "answer": "D || 解析：地址码为6位,一条二地址指令会占用2°条一地址指令的空间,一条一地址指令会占用2° 条零地址指令的空间。若全都是零地址指令,则最多有2条,减去一地址指令和二地址指令所 占用的零地址指令空间,即20-254×26-12×2×2=(21-254-12×2 )×2=2×2=128。\n【另解】二地址指令有12条,则剩余16-12=4种操作码给一地址指令,一地址指令有254 条,剩余4×64-254=2种操作码给0地址指令,所以0地址一共有2×2=128条。"}
{"id": "18", "type": "单项选择题", "question": "01.指令系统中采用不同寻址方式的目的是()。 A. 提供扩展操作码的可能并降低指令译码难度 B.可缩短指令字长,扩大寻址空间,提高编程的灵活性 C. 实现程序控制 D. 三者都正确", "answer_label": "B", "answer_explain": "采用不同寻址方式的目的是为了缩短指令字长,扩大寻址空间,提高编程的灵活性,但这也 提高了指令译码的复杂度。程序控制是靠转移指令而非寻址方式实现的。", "answer": "B || 解析：采用不同寻址方式的目的是为了缩短指令字长,扩大寻址空间,提高编程的灵活性,但这也 提高了指令译码的复杂度。程序控制是靠转移指令而非寻址方式实现的。"}
{"id": "19", "type": "单项选择题", "question": "02.采用直接转移的无条件转移指令的功能是将指令中的地址码送入( )。 A. 程序计数器(PC) B. 累加器(ACC) C. 指令寄存器(IR) D. 地址寄存器(MAR)", "answer_label": "A", "answer_explain": "转移指令有条件/无条件、直接/间接、相对/绝对三种属性。条件转移是指需要先判断条件是 否成立,才决定是否转移;无条件转移是指不用判断条件就可以转移,典型的是函数调用和返回。 直接转移是指转移目标地址直接放在指令中,执行时直接将地址码送入PC:间接转移是指转移 目标地址存放在寄存器或内存单元中。相对转移是指转移目标地址为当前PC值加上偏移量,偏 移量一般在指令中;绝对转移是指转移目标地址直接由指令或寄存器给出。", "answer": "A || 解析：转移指令有条件/无条件、直接/间接、相对/绝对三种属性。条件转移是指需要先判断条件是 否成立,才决定是否转移;无条件转移是指不用判断条件就可以转移,典型的是函数调用和返回。\n直接转移是指转移目标地址直接放在指令中,执行时直接将地址码送入PC:间接转移是指转移 目标地址存放在寄存器或内存单元中。相对转移是指转移目标地址为当前PC值加上偏移量,偏 移量一般在指令中;绝对转移是指转移目标地址直接由指令或寄存器给出。"}
{"id": "20", "type": "单项选择题", "question": "03.为了缩短指令中某个地址段的位数,有效的方法是采取( )。 A. 立即寻址 B. 变址寻址 C. 间接寻址 D. 寄存器寻址", "answer_label": "D", "answer_explain": "CPU中寄存器的数量都不会太多,用很短的编码就可以指定寄存器,寄存器寻址需要的地址 段位数为「log(通用寄存器个数),因此能有效地缩短地址段的位数。立即寻址,操作数直接保存 在指令中,若地址段位数太小,则操作数表示的范围会很小;变址寻址,EA=变址寄存器IX的 内容+ 形式地址A,A与主存寻址空间有关;间接寻址中存放的仍然是主存地址。", "answer": "D || 解析：CPU中寄存器的数量都不会太多,用很短的编码就可以指定寄存器,寄存器寻址需要的地址 段位数为「log(通用寄存器个数),因此能有效地缩短地址段的位数。立即寻址,操作数直接保存 在指令中,若地址段位数太小,则操作数表示的范围会很小;变址寻址,EA=变址寄存器IX的 内容+ 形式地址A,A与主存寻址空间有关;间接寻址中存放的仍然是主存地址。"}
{"id": "21", "type": "单项选择题", "question": "04.简化地址结构的基本方法是尽量采用( ) A. 寄存器寻址 B. 隐含寻址 C. 直接寻址 D. 间接寻址", "answer_label": "B", "answer_explain": "隐含寻址不明显给出操作数地址,而在指令中隐含操作数的地址,因此可以简化地址结构。", "answer": "B || 解析：隐含寻址不明显给出操作数地址,而在指令中隐含操作数的地址,因此可以简化地址结构。"}
{"id": "22", "type": "单项选择题", "question": "05.在指令寻址的各种方式中,获取操作数最快的方式是( )。 A. 直接寻址 B.立即寻址 C.寄存器寻址 D. 间接寻址", "answer_label": "B", "answer_explain": "立即寻址最快,指令直接给出操作数;寄存器寻址次之,只需访问一次寄存器;直接寻址再 次之,访问一次内存;间接寻址最慢,要访问内存两次或以上。", "answer": "B || 解析：立即寻址最快,指令直接给出操作数;寄存器寻址次之,只需访问一次寄存器;直接寻址再 次之,访问一次内存;间接寻址最慢,要访问内存两次或以上。"}
{"id": "23", "type": "单项选择题", "question": "06.假定指令中地址码所给出的是操作数的有效地址,则该指令采用()。 A. 直接寻址 B.立即寻址 C. 寄存器寻址 D. 间接寻址", "answer_label": "A", "answer_explain": "指令字中的形式地址为操作数的有效地址,这种方式为直接寻址。", "answer": "A || 解析：指令字中的形式地址为操作数的有效地址,这种方式为直接寻址。"}
{"id": "24", "type": "单项选择题", "question": "07.设指令中的地址码为A,变址寄存器为X,程序计数器为PC,则变址间址寻址方式的 操作数的有效地址EA是()。 A. $((PC)+A)$ B. ((X)+A) C. $(X)+(A)$ D. (X) + A", "answer_label": "B", "answer_explain": "变址寻址的有效地址是(X)+A,再进行间址,即把(X)+A中取出的内容作为真实地址EA, 即EA=((X)+A)。 寄存器中的内容和指令地址码相加得到的是操作数的地址码。", "answer": "B || 解析：变址寻址的有效地址是(X)+A,再进行间址,即把(X)+A中取出的内容作为真实地址EA, 即EA=((X)+A)。\n寄存器中的内容和指令地址码相加得到的是操作数的地址码。"}
{"id": "25", "type": "单项选择题", "question": "08.( )便于处理数组问题。 A. 间接寻址 B. 变址寻址 C.相对寻址 D. 基址寻址", "answer_label": "B", "answer_explain": "变址寻址便于处理数组问题。基址寻址与变址寻址的区别见下表。", "answer": "B || 解析：变址寻址便于处理数组问题。基址寻址与变址寻址的区别见下表。\n||基址寻址|变址寻址|\n|---|---|---|\n|有效地址|EA (BR)+A|EA = (IX) + A|\n|访存次数|1|1|\n|寄存器内容|由操作系统或管理程序确定|由用户设定|\n|程序执行过程中值可变否|不可变|可变|\n|特点|有利于多道程序设计和编制浮动程序|有利于处理数组问题和编制循环程序|\n"}
{"id": "26", "type": "单项选择题", "question": "09.堆栈寻址方式中,设A为累加器,SP为堆栈指示器, $M_{sp}$ 为SP指示的栈顶单元。若进 栈操作的动作是(A)→Msp (SP)-1 SP,则出栈操作的动作应为( )。 A. $(M_{sp})\\rightarrow A,(SP)+1\\rightarrow SP$ B. (SP)+1-SP. (MSP) →A C. $(SP)-1\\rightarrow SP,(M_{SP})\\rightarrow A$ D. $(M_{SP})\\rightarrow A,(SP)-1\\rightarrow SP$", "answer_label": "B", "answer_explain": "进、出堆栈时对栈顶指针的操作顺序是不同的,进栈时是先压入数据(A)→Msp,后修改指针 (SP)-1→SP,说明栈指针是指向栈顶的空单元的,所以出栈时要先修改指针(SP)+1→SP,然后 才能弹出数据(MSP)→A。", "answer": "B || 解析：进、出堆栈时对栈顶指针的操作顺序是不同的,进栈时是先压入数据(A)→Msp,后修改指针 (SP)-1→SP,说明栈指针是指向栈顶的空单元的,所以出栈时要先修改指针(SP)+1→SP,然后 才能弹出数据(MSP)→A。"}
{"id": "27", "type": "单项选择题", "question": "10.相对寻址方式中,指令所提供的相对地址实质上是一种()。 A. 立即数 B. 内存地址 C.以本条指令在内存中首地址为基准位置的偏移量 D.以下条指令在内存中首地址为基准位置的偏移量", "answer_label": "D", "answer_explain": "相对寻址中,有效地址EA=(PC)+A(A为形式地址),执行本条指令时,PC已完成加1操 作,PC中保存的是下一条指令的地址,因此以下一条指令的地址为基准位置的偏移量。", "answer": "D || 解析：相对寻址中,有效地址EA=(PC)+A(A为形式地址),执行本条指令时,PC已完成加1操 作,PC中保存的是下一条指令的地址,因此以下一条指令的地址为基准位置的偏移量。"}
{"id": "28", "type": "单项选择题", "question": "11.下列关于堆栈寻址的描述中,错误的是()。 A. 可以用内存来实现堆栈 B. 堆栈寻址要求计算机中设有堆栈 C. 可以用硬盘来实现堆栈,称为硬堆栈 D. 可以用寄存器组来实现堆栈", "answer_label": "C", "answer_explain": "堆栈是主存(或寄存器)中一块特定的、按后进先出原则管理的存储区,寄存器堆栈称为硬 堆栈,主存中划分出来的区域作为堆栈是最合算且最常用的方法,这种堆栈称为软堆栈。", "answer": "C || 解析：堆栈是主存(或寄存器)中一块特定的、按后进先出原则管理的存储区,寄存器堆栈称为硬 堆栈,主存中划分出来的区域作为堆栈是最合算且最常用的方法,这种堆栈称为软堆栈。"}
{"id": "29", "type": "单项选择题", "question": "12.指令寻址方式有顺序和跳跃两种,采用跳跃寻址方式可以实现( )。 A. 程序浮动 B.程序的无条件浮动和条件浮动 C.程序的无条件转移和条件转移 D. 程序的调用", "answer_label": "C", "answer_explain": "跳跃寻址通过转移类指令(如相对寻址)来实现,可用来实现程序的条件或无条件转移。", "answer": "C || 解析：跳跃寻址通过转移类指令(如相对寻址)来实现,可用来实现程序的条件或无条件转移。"}
{"id": "30", "type": "单项选择题", "question": "13.寄存器R1、R2均为16位,指令MOV R1 [R2]的功能是把内存数据传送至寄存器R1, 寻址方式为寄存器间接寻址。R2的值为1234H,内存单元1234H存放数据56H,内存 单元1235H存放数据78H,采用小端方式存储。则执行指令后RI的值为( )。 A. 5678H B. 7856H C. 8765H D. 6587H", "answer_label": "B", "answer_explain": "寄存器R2中的值是1234H,内存单元1234H中的值是56H,1235H中的值是78H,因为采 用小端方式,所以实际存储的数据为7856H,取出后存放到R1,因此R1的值为7856H。", "answer": "B || 解析：寄存器R2中的值是1234H,内存单元1234H中的值是56H,1235H中的值是78H,因为采 用小端方式,所以实际存储的数据为7856H,取出后存放到R1,因此R1的值为7856H。"}
{"id": "31", "type": "单项选择题", "question": "14. 某计算机的字长为16位,主存按字编址。转移指令由两个字节组成,采用相对寻址, 第一个字节为操作码字段,第二个字节为相对偏移量字段。若某转移指令所在的主存地 址为4000H,相对偏移量字段的内容为06H,则该转移指令执行后的PC值为( )。 A. 4002H B. 4004H C. 4007H D. 4008H", "answer_label": "C", "answer_explain": "主存按字编址,指令字长为1个字(2字节),因此取出该指令后,PC自动加1,相对偏移 量为06H,所以该转移指令执行后的PC值为4000H+06H+1H = 4007H.", "answer": "C || 解析：主存按字编址,指令字长为1个字(2字节),因此取出该指令后,PC自动加1,相对偏移 量为06H,所以该转移指令执行后的PC值为4000H+06H+1H = 4007H."}
{"id": "32", "type": "单项选择题", "question": "15.某计算机的指令字长为16位,由低到高第0~7位是形式地址D,第8~9位为寻址特 征位X,第10~15位为操作码。当X=00时为直接寻址;当X=01时使用X1进行变 址寻址;当X=10时使用X2进行变址寻址;当X=11时为相对寻址。设(PC)=1234H, (X1)=0005H, (X2)=1188H,则指令2222H的有效地址是( )。 A. 1256H B. 0027H C. 2222H D. 11AAH", "answer_label": "D", "answer_explain": "将指令2222H展开成二进制为0010001000100010B,因此寻址特征位X=10,即使用X2 进行变址寻址,其有效地址为1188H+22H= 11AAH.", "answer": "D || 解析：将指令2222H展开成二进制为0010001000100010B,因此寻址特征位X=10,即使用X2 进行变址寻址,其有效地址为1188H+22H= 11AAH."}
{"id": "33", "type": "单项选择题", "question": "16.某机器指令字长为16位,主存按字节编址,取指令时,每取一字节,PC自动加1。当 前指令地址为2000H,指令内容为相对寻址的无条件转移指令,指令中的形式地址为 40H。则取指令后及指令执行后PC的内容为( )。 A. 2000H, 2042H B. 2002H, 2040H С. 2002H, 2042H D. 2000H, 2040H", "answer_label": "C", "answer_explain": "指令字长为16位,2字节,因此取指令后PC的内容为(PC)+2=2002H;无条件转移指令将 下一条指令的地址送至PC,形式地址为40H,指令执行后PC=2002H+0040H = 2042H ", "answer": "C || 解析：指令字长为16位,2字节,因此取指令后PC的内容为(PC)+2=2002H;无条件转移指令将 下一条指令的地址送至PC,形式地址为40H,指令执行后PC=2002H+0040H = 2042H "}
{"id": "34", "type": "单项选择题", "question": "17.某计算机的主存容量为4M×16位,且存储字长等于指令字长,若该机能完成97种操作, 操作码位数固定,且有直接、间接、基址、变址,相对、立即六种寻址方式,则相对寻 址的偏移量范围为( )。 Α. (-32, +31) B. (-64, +63) C. (-128, +127) D. (-256, +255)", "answer_label": "A", "answer_explain": "操作码位数固定,且能完成97种操作,则操作码位数是「log297]=7位:具有六种寻址方式, 则寻址特征位数是「log26]=3位;指令字长为16位,因此地址码位数是16-3-7=6位,6位补 码的表示范围为-32~+31,即为相对寻址的偏移量范围。", "answer": "A || 解析：操作码位数固定,且能完成97种操作,则操作码位数是「log297]=7位:具有六种寻址方式, 则寻址特征位数是「log26]=3位;指令字长为16位,因此地址码位数是16-3-7=6位,6位补 码的表示范围为-32~+31,即为相对寻址的偏移量范围。"}
{"id": "35", "type": "单项选择题", "question": "18.对按字寻址的机器,程序计数器和指令寄存器的位数各取决于( )。 A.机器字长,存储器的字数 B. 存储器的字数,指令字长 C.指令字长,机器字长 D. 地址总线宽度,存储器的字数", "answer_label": "B", "answer_explain": "机器按字寻址,程序计数器(PC)给出下一条指令字的访存地址(指令在内存中的地址), 因此取决于存储器的字数;指令寄存器(IR)用于接收取得的指令,因此取决于指令字长。", "answer": "B || 解析：机器按字寻址,程序计数器(PC)给出下一条指令字的访存地址(指令在内存中的地址), 因此取决于存储器的字数;指令寄存器(IR)用于接收取得的指令,因此取决于指令字长。"}
{"id": "36", "type": "单项选择题", "question": "19.假设寄存器R中的数值为200,主存地址为200和300的地址单元中存放的内容分别是 300和400,则()方式下访问到的操作数为200。 A. 直接寻址200 B.寄存器间接寻址(R) C.存储器间接寻址(200) D. 寄存器寻址R", "answer_label": "D", "answer_explain": "直接寻址200访问的操作数是300,选项A错误。寄存器间接寻址(R)的访问结果与1一样, 选项B错误。存储器间接寻址(200)表示主存地址200中的内容为有效地址,有效地址为300,访 问的操作数是400,选项C错误。寄存器寻址R表示寄存器R的内容为操作数,只有选项D正确。", "answer": "D || 解析：直接寻址200访问的操作数是300,选项A错误。寄存器间接寻址(R)的访问结果与1一样, 选项B错误。存储器间接寻址(200)表示主存地址200中的内容为有效地址,有效地址为300,访 问的操作数是400,选项C错误。寄存器寻址R表示寄存器R的内容为操作数,只有选项D正确。"}
{"id": "37", "type": "单项选择题", "question": "20.假设某条指令的第一个操作数采用寄存器间接寻址方式,指令中给出的寄存器编号为8, 8号寄存器的内容为1200H,地址为1200H的单元中的内容为12FCH,地址为12FCH 的单元中的内容为38D8H,而地址为38D8H的单元中的內容为88F9H,则该操作数的 有效地址为( ) A. 1200H B. 12FCH C. 38D8H D. 88F9H", "answer_label": "A", "answer_explain": "寄存器间接寻址中操作数的有效地址EA=(R), 8号寄存器内容为1200H,因此EA = 1200H。", "answer": "A || 解析：寄存器间接寻址中操作数的有效地址EA=(R), 8号寄存器内容为1200H,因此EA = 1200H。"}
{"id": "38", "type": "单项选择题", "question": "21.设相对寻址的转移指令占3B,第一字节为操作码,第二、三字节为相对位移量(补码 表示),而且数据在存储器中采用以低字节为字地址的存放方式。每当CPU从存储器取 出一字节时,即自动完成(PC)+1→PC。若PC的当前值为240(十进制),要求转移到 290(十进制),则转移指令的第二,三字节的机器代码是();若PC的当前值为240 (十进制),要求转移到200(十进制),则转移指令的第二、三字节的机器代码是( )。 A. 2FH FFH B. D5H 00H C. D5H、FFH D. 2FH 00H", "answer_label": "D、C", "answer_explain": "首先需要讲解一下补码扩充的问题。补码的扩充只需使用符号位补足即可,也就是说正数补 码的扩充只要补0,负数补码的扩充只需补1(这是由补码的性质决定的)。理解了该性质,这道 题就变成了十进制转换为十六进制的简单问题。 1)PC的当前值为240,该指令取出后PC的值为243,要求转移到290,即相对位移量为 290-24347,转换成补码为2FH。因为数据在存储器中采用以低字节地址为字地址的 存放方式,所以该转移指令的第二字节为2FH,而由于47是正数,只需在高位补0,所 以第三字节为00H。 2)PC的当前值为240,该指令取出后PC的值为243,要求转移到2 的值为243,要求转移到200,即相对位移量为 200-243-43,转换成补码为D5H。数据在存储器中采用以低字节地址为字地址的存放 方式,因此该转移指令的第二字节为D5H,因为-43是负数,所以只需在高位补1,所以 第三字节为FFH.", "answer": "D、C || 解析：首先需要讲解一下补码扩充的问题。补码的扩充只需使用符号位补足即可,也就是说正数补 码的扩充只要补0,负数补码的扩充只需补1(这是由补码的性质决定的)。理解了该性质,这道 题就变成了十进制转换为十六进制的简单问题。\n1)PC的当前值为240,该指令取出后PC的值为243,要求转移到290,即相对位移量为 290-24347,转换成补码为2FH。因为数据在存储器中采用以低字节地址为字地址的 存放方式,所以该转移指令的第二字节为2FH,而由于47是正数,只需在高位补0,所 以第三字节为00H。\n2)PC的当前值为240,该指令取出后PC的值为243,要求转移到2 的值为243,要求转移到200,即相对位移量为 200-243-43,转换成补码为D5H。数据在存储器中采用以低字节地址为字地址的存放 方式,因此该转移指令的第二字节为D5H,因为-43是负数,所以只需在高位补1,所以 第三字节为FFH."}
{"id": "39", "type": "单项选择题", "question": "22.某计算机按字节编址,采用大端方式,某指令的一个操作数的机器数为ABCD00FFH, 该操作数采用基址寻址方式,指令中形式地址(用补码表示)为FFOOH,当前基址寄存 器的内容为C0000000H,则该操作数的LSB(即FFH)存放的地址是( ) A. C000 FFOOH B. C000 FF03H C. BFFF FFOOH D. BFFF FF03H", "answer_label": "D", "answer_explain": "基址寻址的操作数的有效地址为基址寄存器内容加上形式地址,即C0000000H + FF00H = C000 0000H+ FFFF FF00H =BFFF FF00H。因为是大端方式,所以LSB的存放地址为BFFFFF03H。", "answer": "D || 解析：基址寻址的操作数的有效地址为基址寄存器内容加上形式地址,即C0000000H + FF00H = C000 0000H+ FFFF FF00H =BFFF FF00H。因为是大端方式,所以LSB的存放地址为BFFFFF03H。"}
{"id": "40", "type": "单项选择题", "question": "23.下列关于指令的功能及分类的叙述中,正确的是()。 A. 算术与逻辑运算指令,通常完成算术运算或逻辑运算,都需要两个数据 B.移位操作指令,通常用于把指定的两个操作数左移或右移一位 C.转移指令、子程序调用与返回指令,用于解决数据调用次序的需求 D.特权指令,通常仅用于实现系统软件,这类指令一般不提供给用户", "answer_label": "D", "answer_explain": "算术与逻辑运算指令用于完成对一个(如自增、取反等)或两个数据的算术运算或逻辑运算, 选项A错误。移位操作用于把一个操作数左移或右移一位或多位,选项B错误。转移指令、子程 序调用与返回指令用于解决变动程序中指令执行次序的需求,而不是数据调用次序的需求,选项 C错误。", "answer": "D || 解析：算术与逻辑运算指令用于完成对一个(如自增、取反等)或两个数据的算术运算或逻辑运算, 选项A错误。移位操作用于把一个操作数左移或右移一位或多位,选项B错误。转移指令、子程 序调用与返回指令用于解决变动程序中指令执行次序的需求,而不是数据调用次序的需求,选项 C错误。"}
{"id": "41", "type": "单项选择题", "question": "24.某计算机字长为16位,标志寄存器中存在ZF、SF、OF和CF标志位,采用双字节字长 指令字。假定 bgt(大于零转移)指令的第一个字节指明操作码和寻址方式,第二个字 节为立即数 Imm8,用补码表示。指令功能是:若跳转条件成立,则 $PC=PC+2+Imm8\\times2$; 否则, $PC=PC+2$。则下列叙述中错误的是()。 A.该计算机按字节编址 B. 若 bgt 指令是无符号整数的比较,则跳转条件可以是 $ZF+CF=0$ C. 若 bgt 指令是有符号整数的比较,则跳转条件可以是SF OF = 0 D.转移目标地址的范围是相对于bgt指令的前127条指令到后128条指令之间", "answer_label": "C", "answer_explain": "PC的增量是2,每条指令占2字节,可知编址单位为字节。若bgt 指令是无符号整数的比较, 则大于零时,ZF一定为0,且CF也一定为0。若bgt 指令是有符号整数的比较,则跳转条件成立 时,要么未发生溢出, $SF=OF=0$,要么发生溢出SF=OF=1,但前提是ZF一定为0,所以正确 的跳转条件是 $(ZF+(SF\\oplus OF)=0$ 。Imm8的范围为-128~127,因此转移目地址的范围是PC+2+ (-128×2)~PC+2+127×2,即相对于bgt指令的前127条指令到后128条指令之间。", "answer": "C || 解析：PC的增量是2,每条指令占2字节,可知编址单位为字节。若bgt 指令是无符号整数的比较, 则大于零时,ZF一定为0,且CF也一定为0。若bgt 指令是有符号整数的比较,则跳转条件成立 时,要么未发生溢出, $SF=OF=0$,要么发生溢出SF=OF=1,但前提是ZF一定为0,所以正确 的跳转条件是 $(ZF+(SF\\oplus OF)=0$ 。Imm8的范围为-128~127,因此转移目地址的范围是PC+2+ (-128×2)~PC+2+127×2,即相对于bgt指令的前127条指令到后128条指令之间。"}
{"id": "42", "type": "单项选择题", "question": "25.【2009统考真题】某机器字长为16位,主存按字节编址,转移指令采用相对寻址,由2 字节组成,第一字节为操作码字段,第二字节为相对位移量字段。假定取指令时,每取 一字节PC自动加1。若某转移指令所在主存地址为2000H,相对位移量字段的内容为 06H,则该转移指令成功转移后的目标地址是()。 A. 2006H B. 2007H C. 2008H D. 2009H", "answer_label": "C", "answer_explain": "相对寻址 $EA=(PC)+A$,首先计算取指令后的PC值。转移指令由2字节组成,每取一字节 PC加1,取指令后的PC值为2002H,因此 $EA=(PC)+A=2002H+06H=2008H$。本题易误选选 项A或B,选项A未考虑PC值的自动更新,选项B虽然考虑了PC值的自动更新,但未注意到 该转移指令是一条2字节指令,PC值应是“+2”而不是“+1”。", "answer": "C || 解析：相对寻址 $EA=(PC)+A$,首先计算取指令后的PC值。转移指令由2字节组成,每取一字节 PC加1,取指令后的PC值为2002H,因此 $EA=(PC)+A=2002H+06H=2008H$。本题易误选选 项A或B,选项A未考虑PC值的自动更新,选项B虽然考虑了PC值的自动更新,但未注意到 该转移指令是一条2字节指令,PC值应是“+2”而不是“+1”。"}
{"id": "43", "type": "单项选择题", "question": "26.【2011统考真题】偏移寻址通过将某个寄存器的内容与一个形式地址相加来生成有效地 址。下列寻址方式中,不属于偏移寻址方式的是( )。 A. 间接寻址 B. 基址寻址 C. 相对寻址 D. 变址寻址", "answer_label": "A", "answer_explain": "间接寻址不需要寄存器,EA=(A)。基址寻址EA=A+基址寄存器BR的内容;相对寻址 EA=A+程序计数器PC的内容;变址寻址EA=A+变址寄存器IX的内容。后三者都是将某个 寄存器的内容与一个形式地址相加而形成有效地址,所以统称偏移寻址。", "answer": "A || 解析：间接寻址不需要寄存器,EA=(A)。基址寻址EA=A+基址寄存器BR的内容;相对寻址 EA=A+程序计数器PC的内容;变址寻址EA=A+变址寄存器IX的内容。后三者都是将某个 寄存器的内容与一个形式地址相加而形成有效地址,所以统称偏移寻址。"}
{"id": "44", "type": "单项选择题", "question": "27.【2011统考真题】某机器有一个标志寄存器,其中有进位/借位标志CF、零标志 ZF、符 号标志 SF 和溢出标志OF,条件转移指令bgt(无符号整数比较大于时转移)的转移条 件是()。 A. CF+OF = 1 B. SF+ZF=1 C. CF+ZF=1 D. CF+SF=1", "answer_label": "C", "answer_explain": "假设两个无符号整数A和B, bgt指令会将A和B进行比较,也就是将A和B相减。若A>B, 则A-B肯定无进位/借位,也不为0(为0时表示两数相等),因此CF和ZF均为0,选C。其余 选项中用到了符号标志SF和溢出标志OF,SF表示结果的符号,OF是有符号整数的溢出标志位, 对于无符号数运算,SF和OF没有意义,显然应当排除。", "answer": "C || 解析：假设两个无符号整数A和B, bgt指令会将A和B进行比较,也就是将A和B相减。若A>B, 则A-B肯定无进位/借位,也不为0(为0时表示两数相等),因此CF和ZF均为0,选C。其余 选项中用到了符号标志SF和溢出标志OF,SF表示结果的符号,OF是有符号整数的溢出标志位, 对于无符号数运算,SF和OF没有意义,显然应当排除。"}
{"id": "45", "type": "单项选择题", "question": "28.【2013统考真题】假设变址寄存器R的内容为1000H,指令中的形式地址为2000H;地 址1000H中的内容为2000H,地址2000H中的内容为3000H,地址3000H中的内容为 4000H,则变址寻址方式下访问到的操作数是()。 A. 1000H B. 2000H C. 3000H D. 4000H", "answer_label": "D", "answer_explain": "根据变址寻址的方法,变址寄存器的内容(1000H)与形式地址的内容(2000H)相加,得到 操作数的实际地址(3000H),根据实际地址访问内存,获取操作数4000H。", "answer": "D || 解析：根据变址寻址的方法,变址寄存器的内容(1000H)与形式地址的内容(2000H)相加,得到 操作数的实际地址(3000H),根据实际地址访问内存,获取操作数4000H。"}
{"id": "46", "type": "单项选择题", "question": "29.【2014统考真题】某计算机有16个通用寄存器,采用32位定长指令字,操作码字段(含 寻址方式位)为8位,STORE指令的源操作数和目的操作数分别采用寄存器直接寻址 和基址寻址方式。若基址寄存器可使用任意一个通用寄存器,且偏移量用补码表示,则 STORE 指令中偏移量的取值范围是( )。 Α. -32768~+32767 B. -32767~+32768 C. -65536~+65535 D. -65535~+65536", "answer_label": "A", "answer_explain": "采用32位定长指令字,其中操作码为8位,两个地址码共占用32-824位,而STORE 指令的源操作数和目的操作数分别采用寄存器直接寻址和基址寻址,机器中共有16个通用寄存器, 因此寻址一个寄存器需要 $log_{2}16=4$ 位,源操作数中的寄存器直接寻址用掉4位,而且的操作数采用 基址寻址也要指定一个寄存器,同样用掉4位,则留给偏移量的位数为24-4-4-16位,而偏移量 用补码表示,因此16位补码的表示范围为-32768~+32767。", "answer": "A || 解析：采用32位定长指令字,其中操作码为8位,两个地址码共占用32-824位,而STORE 指令的源操作数和目的操作数分别采用寄存器直接寻址和基址寻址,机器中共有16个通用寄存器, 因此寻址一个寄存器需要 $log_{2}16=4$ 位,源操作数中的寄存器直接寻址用掉4位,而且的操作数采用 基址寻址也要指定一个寄存器,同样用掉4位,则留给偏移量的位数为24-4-4-16位,而偏移量 用补码表示,因此16位补码的表示范围为-32768~+32767。"}
{"id": "47", "type": "单项选择题", "question": "30.【2016统考真题】某指令格式如下所示。 OP M D 其中M为寻址方式,1为变址寄存器编号,D为形式地址。若采用先变址后间址的寻址 方式,则操作数的有效地址是( )。 A. I+D B. (I) + D C. $((I)+D)$ D. ((I)) + D", "answer_label": "C", "answer_explain": "变址寻址中,有效地址(EA)等于指令字中的形式地址与变址寄存器的内容之和,即 $EA=(I)+D$。间接寻址是相对于直接寻址而言的,指令的地址字段给出的形式地址不是操作数的 真正地址,而是操作数地址的地址,即 $EA=(D)$。从而该操作数的有效地址是 $((I)+D)$。", "answer": "C || 解析：变址寻址中,有效地址(EA)等于指令字中的形式地址与变址寄存器的内容之和,即 $EA=(I)+D$。间接寻址是相对于直接寻址而言的,指令的地址字段给出的形式地址不是操作数的 真正地址,而是操作数地址的地址,即 $EA=(D)$。从而该操作数的有效地址是 $((I)+D)$。"}
{"id": "48", "type": "单项选择题", "question": "31.【2017统考真题】下列寻址方式中,最适合按下标顺序访问一维数组元素的是( )。 A. 相对寻址 B. 寄存器寻址 C. 直接寻址 D. 变址寻址", "answer_label": "D", "answer_explain": "在变址操作时,将计算机指令中的地址与变址寄存器中的地址相加,得到有效地址,指令 提供数组首地址,由变址寄存器来定位数据中的各元素。所以它最适合按下标顺序访问一维数 组元素,选择选项D。相对寻址以PC为基地址,以指令中的地址为偏移量确定有效地址。寄 存器寻址则在指令中指出需要使用的寄存器。直接寻址在指令的地址字段直接指出操作数的有 效地址。", "answer": "D || 解析：在变址操作时,将计算机指令中的地址与变址寄存器中的地址相加,得到有效地址,指令 提供数组首地址,由变址寄存器来定位数据中的各元素。所以它最适合按下标顺序访问一维数 组元素,选择选项D。相对寻址以PC为基地址,以指令中的地址为偏移量确定有效地址。寄 存器寻址则在指令中指出需要使用的寄存器。直接寻址在指令的地址字段直接指出操作数的有 效地址。"}
{"id": "49", "type": "单项选择题", "question": "32.【2018统考真题】按字节编址的计算机中,某double型数组A的首地址为2000H,使用变 址寻址和循环结构访问数组A,保存数组下标的变址寄存器的初值为0,每次循环取一个数 组元素,其偏移地址为变址值乘以 sizeof (double),取完后变址寄存器的内容自动加1。若 某次循环所取元素的地址为2100H,则进入该次循环时变址寄存器的內容是()。 A. 25 B. 32 C. 64 D. 100", "answer_label": "B", "answer_explain": "根据变址寻址的公式 $EA=(IX)+A$,有(IX)=2100H 2000H100H 256, sizeof(double) = 8 (双精度浮点数用8位字节表示),因此数组的下标为 $256/8=32$。", "answer": "B || 解析：根据变址寻址的公式 $EA=(IX)+A$,有(IX)=2100H 2000H100H 256, sizeof(double) = 8 (双精度浮点数用8位字节表示),因此数组的下标为 $256/8=32$。"}
{"id": "50", "type": "单项选择题", "question": "33.【2019统考真题】某计算机采用大端方式,按字节编址。某指令中操作数的机器数为1234 FF00H,该操作数采用基址寻址方式,形式地址(用补码表示)为FF12H,基址寄存器的 内容为F0000000H,则该操作数的LSB(最低有效字节)所在的地址是( )。 A. F000 FF12H B. F000 FF15H C. EFFF FF12H D. EFFF FF15H", "answer_label": "D", "answer_explain": "注意,内存地址是无符号数。 操作数采用基址寻址方式, $EA=(BR)+A$,基址寄存器BR的内容为F0000000H,形式地址 用补码表示为FF12H即11111111 0001 0010B,因此有效地址为F0000000H+(-00EEH) = EFFF FF12H。计算机采用大端方式编址,所以低位字节存放在字的高地址处,机器数一共占4字节, 该操作数的LSB所在的地址是EFFF FF12H+3 EFFF FF15H.", "answer": "D || 解析：注意,内存地址是无符号数。\n操作数采用基址寻址方式, $EA=(BR)+A$,基址寄存器BR的内容为F0000000H,形式地址 用补码表示为FF12H即11111111 0001 0010B,因此有效地址为F0000000H+(-00EEH) = EFFF FF12H。计算机采用大端方式编址,所以低位字节存放在字的高地址处,机器数一共占4字节, 该操作数的LSB所在的地址是EFFF FF12H+3 EFFF FF15H."}
{"id": "51", "type": "单项选择题", "question": "34.【2020统考真题】某计算机采用16位定长指令字格式,操作码位数和寻址方式位数固 定,指令系统有48条指令,支持直接、间接、立即、相对4种寻址方式。在单地址指 令中,直接寻址方式的可寻址范围是( )。 A. 0-255 B. 0-1023 C.128 127 D. -512-511", "answer_label": "A", "answer_explain": "48条指令需要6位操作码字段 $(2^{3}<48<2^{6})$,4种寻址方式需要2位寻址特征位 $(4=2^{2})$, 还剩16-6-2=8位作为地址码,所以直接寻址范围为0~255。注意,主存地址不能为负。", "answer": "A || 解析：48条指令需要6位操作码字段 $(2^{3}<48<2^{6})$,4种寻址方式需要2位寻址特征位 $(4=2^{2})$, 还剩16-6-2=8位作为地址码,所以直接寻址范围为0~255。注意,主存地址不能为负。"}
{"id": "52", "type": "单项选择题", "question": "35.【2023 统考真题】某运算类指令中有一个地址码为通用寄存器编号,对应通用寄存器 中存放的是操作数或操作数的地址,CPU区分两者的依据是()。 A.操作数的寻址方式 B.操作数的编码方式 C.通用寄存器的编号 D. 通用寄存器的內容", "answer_label": "A", "answer_explain": "指令字由操作码、寻址特征和地址码三个字段组成,寻址特征字段用来指明指令属于哪种寻 址方式。若寻址方式是寄存器直接寻址,则地址码所指的通用寄存器中存放的是操作数,若寻址 方式是寄存器间接寻址,则对应通用寄存器中存放的是操作数的地址。", "answer": "A || 解析：指令字由操作码、寻址特征和地址码三个字段组成,寻址特征字段用来指明指令属于哪种寻 址方式。若寻址方式是寄存器直接寻址,则地址码所指的通用寄存器中存放的是操作数,若寻址 方式是寄存器间接寻址,则对应通用寄存器中存放的是操作数的地址。"}
{"id": "53", "type": "单项选择题", "question": "01. 假设 $R[ax]=FFE8H$, $R[bx]=7FE6H$,执行指令“add ax, bx”后,寄存器的内容和各标 志的变化为( )。 A. $R[ax]=7FCEH$, $OF=1$, $SF=0$, $CF=0$, $ZF=0$ B. $R[bx]=7FCEH$ $OF=1$, $SF=0$, $CF=0$, $ZF=0$ C. $R[ax]=7FCEH$, $OF=0$, $SF=0$, $CF=1$, $ZF=0$ D. $R[bx]=7FCEH$, $OF=0.$ $SF=0$, $CF=1$, $ZF=0$", "answer_label": "C", "answer_explain": "该指令是 Intel格式,add指令的目的寄存器为ax。add指令的补码加法过程为1111 1111 1110 1000+0111 1111 11100110 (1)0111 1111 1100 1110(7FCEH),两个操作数的符号不同,必然不会溢 出, $OF=0$;结果的符号位为0, $SF=0$;有进位,CF=CSub=10=1;非0, $ZF=0$。", "answer": "C || 解析：该指令是 Intel格式,add指令的目的寄存器为ax。add指令的补码加法过程为1111 1111 1110 1000+0111 1111 11100110 (1)0111 1111 1100 1110(7FCEH),两个操作数的符号不同,必然不会溢 出, $OF=0$;结果的符号位为0, $SF=0$;有进位,CF=CSub=10=1;非0, $ZF=0$。\n注意\n无论是无符号数还是有符号数,都以二进制代码形式无差别地存放在计算机内。即便两个有符号数 相加,也会导致CF的变动,只是CF值对有符号数运算是没有意义的,同理,两个无符号数相加,也会 导致OF和SF的变动,只是OF值和SF值仅对有符号数运算有意义。"}
{"id": "54", "type": "单项选择题", "question": "02. 假设 $R[ax]=7FE6H$, $R[bx]=FF$ FFE8H,执行指令“sub bx,ax”后,寄存器的内存和各标 志的变化为( ), A. $R[ax]=8002H$, $OF=0$, $SF=1$, $CF=1$, $ZF=0$ B. $R[bx]=8002H$, $OF=0$, $SF=1$, $CF=0$, $ZF=0$ C. $R[ax]=8002H$ $OF=1$, $SF=1$, $CF=0$, $ZF=0$ D. $R[bx]=8002H$ $OF=1$, $SF=1$, $CF=0$, $ZF=0$", "answer_label": "B", "answer_explain": "该指令是 Intel格式,sub指令的目的寄存器为bx。sub减法运算用补码加法实现,被减数+ 减数逐位取反+1=11111111 1110 1000 1000 0000 0001 1001+1 (1)1000 0000 0000 0010 (8002H),两个操作数的符号位都是1,结果的符号位也是1,无溢出, $OF=0$;结果为负数, $SF=1$; 进位输出 $C_{out}=1$,低位进位 Sub 1, $CF=C_{out}$ Sub 11 $1=0$;非0, $ZF=0$.", "answer": "B || 解析：该指令是 Intel格式,sub指令的目的寄存器为bx。sub减法运算用补码加法实现,被减数+ 减数逐位取反+1=11111111 1110 1000 1000 0000 0001 1001+1 (1)1000 0000 0000 0010 (8002H),两个操作数的符号位都是1,结果的符号位也是1,无溢出, $OF=0$;结果为负数, $SF=1$;\n进位输出 $C_{out}=1$,低位进位 Sub 1, $CF=C_{out}$ Sub 11 $1=0$;非0, $ZF=0$."}
{"id": "55", "type": "单项选择题", "question": "03.某计算机的数据采用小端方式存储,减法指令“sub ax, $imm^{\\prime\\prime}$ 的功能 $\\forall(ax)-imm\\rightarrow ax$, imm 表示立即数,该指令对应的十六进机器码为2 (从左到右以字节为单位由低 地址到高地址),其中XXXX对应imm的机器码,若 $imm=-3$ $(ax)=7$ 则该指令对应 的机器码和执行后OF标志位的值分别为( )。 A. 2DFFFDH, 0 B. 2DFFFDH, 1 C. 2DFDFFH, 0 D. 2DFDFFH, 1", "answer_label": "C", "answer_explain": "imm的值为-3,转换成二进制为1111111111111101B,即FFFDH,因为该计算机采用小端存 储,先存储低位字节,所以该指令对应的机器码为2DFDFFH,OF是有符号数运算的溢出标志位, 7-(-3)显然没有溢出,因此OF标志位为0。", "answer": "C || 解析：imm的值为-3,转换成二进制为1111111111111101B,即FFFDH,因为该计算机采用小端存 储,先存储低位字节,所以该指令对应的机器码为2DFDFFH,OF是有符号数运算的溢出标志位, 7-(-3)显然没有溢出,因此OF标志位为0。"}
{"id": "56", "type": "单项选择题", "question": "04. 某C语言程序中对数组变量b的声明为“intb[10][5];”,有一条for 语句如下: for $(i=0;i<10;i++)$ for(j=0;j<5;j++) $sum+=b[i][j];$ 假设执行到“sum+=b[i][j];”时,sum的值在eax中,b[i][0]所在的地址在edx中,j在 esi中,则 $sum+=b[i][j];$”所对应的指令(Intel格式)可以是()。 A. add dword ptr eax, [edx+esi*4] B. add dword ptr eax, [esi+edx*4] C. add dword ptr eax, [edx+esi*2] D. add dword ptr eax, [esi+edx*2]", "answer_label": "A", "answer_explain": "b[i][0]所在的地址在edx中,在esi中,一个数组元素占4字节,所以b[i][j]的地址为R[edx]+ R[esi]*4,指令格式为Intel格式,第一个为目的操作数,第二个为源操作数,于是选项A正确。", "answer": "A || 解析：b[i][0]所在的地址在edx中,在esi中,一个数组元素占4字节,所以b[i][j]的地址为R[edx]+ R[esi]*4,指令格式为Intel格式,第一个为目的操作数,第二个为源操作数,于是选项A正确。"}
{"id": "57", "type": "单项选择题", "question": "05. 假设 R[eax] = 080480B4H, $R[ebx]=00000011H$ M[080480F8H]=000000B0H,执行指 令“imul eax, [eax+ebx*4],-16”后,寄存器或存储单元的内容变为( )。 A. R[eax] 00000B00H B. M[080480F8H]=00000B00H C. R[eax] =FFFFF500H D. M[080480F8H]=FFFFF500H", "answer_label": "C", "answer_explain": "指令的一个源操作数在内存单元中,地址为R[eax]+R[ebx]*4 = 080480B4H+00000011H*4 = 080480F8H。指令的功能是R[eax]-M[080480F8H]*(-16)=(-000000B0H)<<4 = FFFFFF50H<<4 = FFFFF500H。目的操作数保存在eax中,所以主存单元080480F8H中的内容不会改变。", "answer": "C || 解析：指令的一个源操作数在内存单元中,地址为R[eax]+R[ebx]*4 = 080480B4H+00000011H*4 = 080480F8H。指令的功能是R[eax]-M[080480F8H]*(-16)=(-000000B0H)<<4 = FFFFFF50H<<4 = FFFFF500H。目的操作数保存在eax中,所以主存单元080480F8H中的内容不会改变。"}
{"id": "58", "type": "单项选择题", "question": "06.程序P中有两个变量和」,被分别分配在寄存器eax和edx中,P中语句“if(i<j) {...}\" 对应的指令序列如下(左边为指令地址,中间为机器代码,右边为汇编指令),其中jle 指令的偏移量为Od: 804846a 39 c2 cmp dword ptr edx, eax 804846c 7e Od jle xxxxxxxx 若执行到804846aH处的cmp指令时, $i=105$, $j=100$,则jle指令执行后将转到( ) 处的指令执行。 Α. 8048461H B. 804846cH C. 8048479H D. 804847bH", "answer_label": "D", "answer_explain": "$i=105$, $j=100$,即edx的内容为100,eax的内容为105,cmp指令就是对这两个数做减法, 显然 $100<105$,满足jle指令小于或等于的条件,jle指令长度为2字节,所以jle指令执行后将 转移到当前 PC值+偏移量=804846cH+2+OdH=804847bH处执行。", "answer": "D || 解析：$i=105$, $j=100$,即edx的内容为100,eax的内容为105,cmp指令就是对这两个数做减法, 显然 $100<105$,满足jle指令小于或等于的条件,jle指令长度为2字节,所以jle指令执行后将 转移到当前 PC值+偏移量=804846cH+2+OdH=804847bH处执行。"}
{"id": "59", "type": "单项选择题", "question": "07.假定全局数组a的声明为double a[8],a的首地址为80498c0H,变量被分配在寄存器 ecx中,现要将a i 取到eax相应宽度的寄存器中,则所用的汇编指令是( )。 A. mov eax, [ecx*4+80498c0H] B. mov eax, ecx*4+80498c0H C. mov eax, [ecx*8+80498c0H] D. mov eax, ecx*8+80498c0H", "answer_label": "C", "answer_explain": "每个double 型的数组元素占8字节,数组a的首地址为80498c0H,i存储在ecx中,所以a门 在主存中的地址可表示为[ecx*8+80498c0H],因此汇编指令可以是mov eax, [ecx*8+80498c0H]。", "answer": "C || 解析：每个double 型的数组元素占8字节,数组a的首地址为80498c0H,i存储在ecx中,所以a门 在主存中的地址可表示为[ecx*8+80498c0H],因此汇编指令可以是mov eax, [ecx*8+80498c0H]。"}
{"id": "60", "type": "单项选择题", "question": "08. 子程序调用指令的完整功能是()。 A.改变堆栈指针SP的值 B.改变程序计数器 PC 的值 C.改变程序计数器PC的值和堆栈指针SP的值 D.改变地址寄存器的值", "answer_label": "C", "answer_explain": "子程序调用指令需要将程序断点保存至堆栈,这个过程会改变SP的值,同时也会改变PC 的值以跳转到子程序执行。", "answer": "C || 解析：子程序调用指令需要将程序断点保存至堆栈,这个过程会改变SP的值,同时也会改变PC 的值以跳转到子程序执行。"}
{"id": "61", "type": "单项选择题", "question": "09.下列关于选择结构语句“if(comp_A) then statement_B else statement_C”对应的机器级 代码表示的叙述中,错误的是()。 A.一定包含一条无条件转移指令 B.一定包含一条条件转移指令(分支指令) C. 计算comp_A的代码段一定在条件转移指令之前 D. 对应 statement_B的代码一定在对应 statement_C的代码之前", "answer_label": "D", "answer_explain": "在if语句的机器级代码中,comp_A 后面紧接着有一个条件跳移指令,条件成立则转跳到 statement B. statement B中有一个无条件跳移指令,会转跳到 if-else的下一条语句,选项A、B和C 正确。statement B不一定在 statement C之前,这取决于条件转移指令的类型和方向,选项D错误。", "answer": "D || 解析：在if语句的机器级代码中,comp_A 后面紧接着有一个条件跳移指令,条件成立则转跳到 statement B. statement B中有一个无条件跳移指令,会转跳到 if-else的下一条语句,选项A、B和C 正确。statement B不一定在 statement C之前,这取决于条件转移指令的类型和方向,选项D错误。"}
{"id": "62", "type": "单项选择题", "question": "10.下列关于循环结构语句的机器级代码表示的叙述中,错误的是()。 A.一定至少包含一条条件转移指令 B.不一定包含无条件转移指令 C.循环结束条件可以用一条比较指令CMP来实现 D. 循环体内执行的指令不包含条件转移指令", "answer_label": "D", "answer_explain": "循环结构循环体内最后会有一条条件转移指令,判断是否跳出循环,可以用比较指令(CMP) 来实现,选项A和C正确,选项D错误。循环结构不一定包含无条件转移指令,选项B正确。", "answer": "D || 解析：循环结构循环体内最后会有一条条件转移指令,判断是否跳出循环,可以用比较指令(CMP) 来实现,选项A和C正确,选项D错误。循环结构不一定包含无条件转移指令,选项B正确。"}
{"id": "63", "type": "单项选择题", "question": "11.下列有关调用指令(转子指令)的叙述中,错误的是()。 A.与高级语言源程序中的过程调用相对应,一次过程调用对应一条调用指令 B. 指令执行时必须保留返回地址,调用指令随后一条指令的地址是返回地址 C.嵌套调用时返回地址通常保存在栈中,非嵌套调用时可保存在特定寄存器中 D. 指令执行时将无条件转移到目标地址处,转移目标地址无须在指令中明显给出", "answer_label": "D", "answer_explain": "为了能保证从被调用过程返回到调用过程继续执行,必须确定并保存返回地址,这个地址是 调用指令随后的指令的地址,返回地址只能由调用指令来计算并保存,因为执行调用指令后就跳 转到了被调用过程,因此无法获取返回地址。为了保证嵌套调用时能够返回到调用过程,必须将 返回地址压栈,若不压栈而保存在特定寄存器中,则后面执行的调用指令会将前面调用指令保存 的返回地址覆盖掉。调用指令执行时将无条件转移到目标地址处,这个目标地址就是被调用过程 第一条指令的地址,它一定在调用指令中明显给出,因此选项D错误。", "answer": "D || 解析：为了能保证从被调用过程返回到调用过程继续执行,必须确定并保存返回地址,这个地址是 调用指令随后的指令的地址,返回地址只能由调用指令来计算并保存,因为执行调用指令后就跳 转到了被调用过程,因此无法获取返回地址。为了保证嵌套调用时能够返回到调用过程,必须将 返回地址压栈,若不压栈而保存在特定寄存器中,则后面执行的调用指令会将前面调用指令保存 的返回地址覆盖掉。调用指令执行时将无条件转移到目标地址处,这个目标地址就是被调用过程 第一条指令的地址,它一定在调用指令中明显给出,因此选项D错误。"}
{"id": "64", "type": "单项选择题", "question": "12.假设P为调用过程,为被调用过程,程序在32位x86处理器上执行,以下是C语言 程序中过程调用所涉及的操作: ①过程保存P的现场,并为非静态局部变量分配空间 ② 过程P将实参存放到Q能访问到的地方 ③ 过程P将返回地址存放到特定处,并转跳到Q执行 ④过程Q取出返回地址,并转跳回到过程P执行 ⑤过程恢复P的现场,并释放局部变量所占空间 ⑥ 执行过程的函数体 过程调用的正确执行步骤是()。 A. 2-3-4-1-66 B. 231465 C. 231-6-5-4 D. 23160-4", "answer_label": "C", "answer_explain": "过程调用的具体过程已在4.3.4节中介绍。", "answer": "C || 解析：过程调用的具体过程已在4.3.4节中介绍。"}
{"id": "65", "type": "单项选择题", "question": "01.下列关于RISC的叙述中,正确的是()。 A. RISC 机一定采用流水技术 B.采用流水技术的机器一定是RISC机 C. RISC机的兼容性优于CISC机 D. CPU配备很少的通用寄存器", "answer_label": "A", "answer_explain": "RISC 必然采用流水线技术,这也是由其指令的特点决定的。而CISC则无此强制要求,但为 了提高指令执行速度,CISC也往往采用流水线技术,因此流水线技术并非RISC的专利。CISC 机可以兼容很多不同的高级语言和软件,而RISC机的指令系统简单精简,只包含一些基本的指 令,这些指令需要通过组合来实现复杂的功能,从而增加了编译器的设计难度和程序员的编程难 度,因此CISC机的兼容性更好。CPU配备很多通用寄存器是RISC机的主要特点。", "answer": "A || 解析：RISC 必然采用流水线技术,这也是由其指令的特点决定的。而CISC则无此强制要求,但为 了提高指令执行速度,CISC也往往采用流水线技术,因此流水线技术并非RISC的专利。CISC 机可以兼容很多不同的高级语言和软件,而RISC机的指令系统简单精简,只包含一些基本的指 令,这些指令需要通过组合来实现复杂的功能,从而增加了编译器的设计难度和程序员的编程难 度,因此CISC机的兼容性更好。CPU配备很多通用寄存器是RISC机的主要特点。"}
{"id": "66", "type": "单项选择题", "question": "02.下列描述中,不符合RISC指令系统特点的是( )。 A.指令长度固定,指令种类少 B.寻址方式种类尽量减少,指令功能尽可能强 C.增加寄存器的数目,以尽量减少访存次数 D. 选取使用频率最高的一些简单指令,以及很有用但不复杂的指令", "answer_label": "B", "answer_explain": "A、C和D都是RISC的特点。对于B,寻址方式种类尽量减少是RISC的特点,而增强指令 的功能则是 CISC的特点。RISC指令功能简单,复杂指令的功能由简单指令的组合来实现。", "answer": "B || 解析：A、C和D都是RISC的特点。对于B,寻址方式种类尽量减少是RISC的特点,而增强指令 的功能则是 CISC的特点。RISC指令功能简单,复杂指令的功能由简单指令的组合来实现。"}
{"id": "67", "type": "单项选择题", "question": "03. 以下有关RISC的描述中,正确的是()。 A.为了实现兼容,新设计的RISC是从原来CISC系统的指令系统中挑选一部分实现的 B. 采用RISC技术后,计算机的体系结构又恢复到了早期的情况 C. RISC 的主要目标是减少指令数,因此允许以增加每条指令的功能的方法来减少指令 系统所包含的指令数 D.以上说法都不对", "answer_label": "D", "answer_explain": "RISC 选择一些常用的寄存器型指令,并不是为了兼容CISC,RISC也不可能兼容CISC,A 错误。RISC只是CPU的结构发生变化,基本不影响整个计算机的结构,并且即使是采用RISC 技术的CPU,其架构也不可能像早期一样简单,B错误。RISC的指令功能简单,通过简单指令 的组合来实现复杂指令的功能,C错误,但RISC的主要目标是减少指令数是正确的。", "answer": "D || 解析：RISC 选择一些常用的寄存器型指令,并不是为了兼容CISC,RISC也不可能兼容CISC,A 错误。RISC只是CPU的结构发生变化,基本不影响整个计算机的结构,并且即使是采用RISC 技术的CPU,其架构也不可能像早期一样简单,B错误。RISC的指令功能简单,通过简单指令 的组合来实现复杂指令的功能,C错误,但RISC的主要目标是减少指令数是正确的。"}
{"id": "68", "type": "单项选择题", "question": "04.下列关于RISC和CISC的说法中,不正确的是()。 A. RISC 指令格式种类少,寻址方式少,指令长度固定,更容易用硬布线电路实现 B. CISC指令功能强大,寻址方式多,便于汇编程序员编程 C. CISC指令格式种类多,所以更有利于编译优化 D. RISC多数指令能够在一个时钟周期内完成,特别适合流水线工作", "answer_label": "C", "answer_explain": "CISC 指令格式种类多,增大了编译优化的复杂性,因此不利于编译优化。", "answer": "C || 解析：CISC 指令格式种类多,增大了编译优化的复杂性,因此不利于编译优化。"}
{"id": "69", "type": "单项选择题", "question": "05.【2009统考真题】下列关于RISC的说法中,错误的是()。 A. RISC 普遍采用微程序控制器 B. RISC 大多数指令在一个时钟周期内完成 C. RISC的内部通用寄存器数量相对CISC多 D. RISC 的指令数、寻址方式和指令格式种类相对CISC少", "answer_label": "A", "answer_explain": "相对于CISC,RISC的特点是:指令条数少;指令长度固定,指令格式和寻址种类少;只有 取数/存数指令访问存储器,其余指令的操作均在寄存器之间进行;CPU中通用寄存器多;大部 分指令在一个时钟周期内完成;以硬布线逻辑为主,不用或少用微程序控制。B、C和D都是RISC 的特点。RISC的速度快,因此普遍采用硬布线控制器,A错误。", "answer": "A || 解析：相对于CISC,RISC的特点是:指令条数少;指令长度固定,指令格式和寻址种类少;只有 取数/存数指令访问存储器,其余指令的操作均在寄存器之间进行;CPU中通用寄存器多;大部 分指令在一个时钟周期内完成;以硬布线逻辑为主,不用或少用微程序控制。B、C和D都是RISC 的特点。RISC的速度快,因此普遍采用硬布线控制器,A错误。"}
