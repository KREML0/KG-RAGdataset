{"id": "326", "type": "单项选择题", "question": "2. 下列关于存储管理目标的说法中，错误的是( ) A. 为进程分配内存空间 B. 回收被进程释放的内存空间 C. 提高内存的利用率 D. 提高内存的物理存取速度", "answer_label": "D", "answer_explain": "内存的物理存取速度是由硬件决定的，而不是由操作系统管理的。操作系统可以通过虚拟内 存、缓存等技术提高数据的逻辑存取速度，但不能改变内存的物理特性。", "answer": "D || 解析：内存的物理存取速度是由硬件决定的，而不是由操作系统管理的。操作系统可以通过虚拟内 存、缓存等技术提高数据的逻辑存取速度，但不能改变内存的物理特性。"}
{"id": "327", "type": "单项选择题", "question": "3. 下列关于内存保护的描述中，不正确的是( ) A. 一个进程不能未被授权就访问另外一个进程的内存空间 B. 内存保护可以仅通过操作系统(软件)来满足，不需要处理器(硬件)的支持 C. 内存保护的方法有界地址保护和上下限地址保护 D. 一个进程不能直接跳转到另一个进程的指令地址中", "answer_label": "B", "answer_explain": "内存保护需要硬件和软件的配合，不能仅靠操作系统来实现。通常需要在 CPU  中设置上下 限寄存器、重定位寄存器、界地址寄存器等寄存器，以记录进程在内存中的合法范围。", "answer": "B || 解析：内存保护需要硬件和软件的配合，不能仅靠操作系统来实现。通常需要在 CPU  中设置上下 限寄存器、重定位寄存器、界地址寄存器等寄存器，以记录进程在内存中的合法范围。"}
{"id": "328", "type": "单项选择题", "question": "4.内存保护需要由( )完成，以保证进程空间不被非法访问。 A. 操作系统 B.硬件机构 C. 操作系统和硬件机构合作 D. 操作系统或者硬件机构独立完成", "answer_label": "C", "answer_explain": "内存保护是内存管理的一部分，是操作系统的任务，但是出于安全性和效率考虑，必须由硬 件实现，所以需要操作系统和硬件机构的合作来完成。", "answer": "C || 解析：内存保护是内存管理的一部分，是操作系统的任务，但是出于安全性和效率考虑，必须由硬 件实现，所以需要操作系统和硬件机构的合作来完成。"}
{"id": "329", "type": "单项选择题", "question": "5. 下列各种存储管理方式中，需要硬件地址变换机构的是() I. 单一连续分配 II. 固定分区分配 III. 页式存储管理 IV. 动态分区分配 V. 页式虚拟存储管理 A.I 、III 、V B.II 、III 、IV C.III 、IV 、V D.II 、III 、IV 、V", "answer_label": "C", "answer_explain": "硬件地址变换机构一般用于动态重定位的情况。而单一连续分配和固定分区分配采用的是静 态重定位，不需要硬件地址变换机构，而由装入程序或操作系统来完成地址转换。因此，只有页 式存储管理、动态分区分配和页式虚拟存储管理需要硬件地址变换机构。", "answer": "C || 解析：硬件地址变换机构一般用于动态重定位的情况。而单一连续分配和固定分区分配采用的是静 态重定位，不需要硬件地址变换机构，而由装入程序或操作系统来完成地址转换。因此，只有页 式存储管理、动态分区分配和页式虚拟存储管理需要硬件地址变换机构。"}
{"id": "330", "type": "单项选择题", "question": "6. 在固定分区分配中，每个分区的大小是( ) A. 随作业长度变化 B. 可以不同但预先固定 C. 相同 D. 可以不同但根据作业长度固定", "answer_label": "B", "answer_explain": "在固定分区分配中，每个分区的大小是在系统启动时就确定了的，不会随着作业的长度而变 化。分区的大小可以不同，也可以相同，但是一旦确定，就不会改变。", "answer": "B || 解析：在固定分区分配中，每个分区的大小是在系统启动时就确定了的，不会随着作业的长度而变 化。分区的大小可以不同，也可以相同，但是一旦确定，就不会改变。"}
{"id": "331", "type": "单项选择题", "question": "7. 在动态分区分配方案中，某一进程完成后，系统回收其主存空间并与相邻空闲区合并，为此需修改空闲 区表，造成空闲区数减1的情况是( ) A. 无上邻空闲区也无下邻空闲区 B. 有上邻空闲区但无下邻空闲区 C. 有下邻空闲区但无上邻空闲区 D. 有上邻空闲区也有下邻空闲区", "answer_label": "D", "answer_explain": "将上邻空闲区、下邻空闲区和回收区合并为一个空闲区，因此空闲区数反而减少了一个。而 仅有上邻空闲区或下邻空闲区时，空闲区数并不减少。", "answer": "D || 解析：将上邻空闲区、下邻空闲区和回收区合并为一个空闲区，因此空闲区数反而减少了一个。而 仅有上邻空闲区或下邻空闲区时，空闲区数并不减少。"}
{"id": "332", "type": "单项选择题", "question": "8. 设 内 存 的 分 配 情 况 如 下 图 所 示 。 若 要 申 请 一 块 4 0KB 的内存空间，采用最佳适应算法，则所得到的分区 首址为( ) A.100K B.190K C.330K D.410K", "answer_label": "C", "answer_explain": "最佳适配算法是指，每次为作业分配内存空间时，总是找到能满足空间大小需要的最小空闲 分区给作业，可以产生最小的内存空闲分区。从图中可以看出应选择大小为60KB 的空闲分区，其首地址为330K。", "answer": "C || 解析：最佳适配算法是指，每次为作业分配内存空间时，总是找到能满足空间大小需要的最小空闲 分区给作业，可以产生最小的内存空闲分区。从图中可以看出应选择大小为60KB 的空闲分区，其首地址为330K。"}
{"id": "333", "type": "单项选择题", "question": "9. 某分段存储管理系统中，段表内容如下表所示，逻辑地址的格式为(段号，段内偏移),则逻辑地址(2,154) 对应的物理地址是( ) A.120K+2 B.480K+154 C.30K+154 D.480K+2", "answer_label": "B", "answer_explain": "段号为2,其对应的首地址为480K,段长度为20K, 大于154,所以逻辑地址(2,154)对应的 物理地址为480K+154。", "answer": "B || 解析：段号为2,其对应的首地址为480K,段长度为20K, 大于154,所以逻辑地址(2,154)对应的 物理地址为480K+154。"}
{"id": "334", "type": "单项选择题", "question": "10. 动态重定位是在作业的( )中进行的。 A. 编译过程 B. 装入过程 C. 链接过程 D. 执行过程", "answer_label": "D", "answer_explain": "静态装入是指在编程阶段就把物理地址计算好。可重定位是指在装入时把逻辑地址转换成物 理地址，但装入后不能改变。动态重定位是指在执行时再决定装入的地址并装入，装入后有可能 换出，所以同一个模块在内存中的物理地址是可能改变的，在作业运行过程中，当执行到一条访 存指令时，再把逻辑地址转换为主存的物理地址，实际上是通过地址变换机构实现的。", "answer": "D || 解析：静态装入是指在编程阶段就把物理地址计算好。可重定位是指在装入时把逻辑地址转换成物 理地址，但装入后不能改变。动态重定位是指在执行时再决定装入的地址并装入，装入后有可能 换出，所以同一个模块在内存中的物理地址是可能改变的，在作业运行过程中，当执行到一条访 存指令时，再把逻辑地址转换为主存的物理地址，实际上是通过地址变换机构实现的。"}
{"id": "335", "type": "单项选择题", "question": "11. 下列关于程序装入的动态重定位方式的描述中，错误的是() A. 系统将程序装入内存后，程序在内存中的位置可能发生移动 B. 系统为每个进程分配一个重定位寄存器 C. 被访问单元的物理地址=逻辑地址+重定位寄存器的值 D. 逻辑地址到物理地址的映射过程在进程执行时发生", "answer_label": "B", "answer_explain": "动态重定位允许程序在内存中移动，系统中只有一个重定位寄存器，每次切换进程时，都要 保存和恢复该寄存器的值，不会为每个进程分配一个重定位寄存器，选项B 错误。", "answer": "B || 解析：动态重定位允许程序在内存中移动，系统中只有一个重定位寄存器，每次切换进程时，都要 保存和恢复该寄存器的值，不会为每个进程分配一个重定位寄存器，选项B 错误。"}
{"id": "336", "type": "单项选择题", "question": "12. 动态重定位的过程依赖于( ) I. 可重定位装入程序 II. 重定位寄存器 III. 地址变换机构 IV. 目标程序 A.I 和 I B.II 和 II C.I 、I 和 III D.I 、II 、III 和 IV", "answer_label": "C", "answer_explain": "可重定位装入程序在重定位的过程中执行，重定位寄存器(也称基址寄存器)用于存放进程 的基地址，地址变换机构用于将指令中的逻辑地址与重定位寄存器中的基地址相加得到物理地 址。目标程序是装入内存后执行的，动态重定位不依赖于目标程序。", "answer": "C || 解析：可重定位装入程序在重定位的过程中执行，重定位寄存器(也称基址寄存器)用于存放进程 的基地址，地址变换机构用于将指令中的逻辑地址与重定位寄存器中的基地址相加得到物理地 址。目标程序是装入内存后执行的，动态重定位不依赖于目标程序。"}
{"id": "337", "type": "单项选择题", "question": "13. 为保证一个程序在主存中被改变存放位置后仍能正确执行，应采用( ) A. 静态重定位 B. 动态重定位 C. 动态分配 D. 静态分配", "answer_label": "B", "answer_explain": "动态重定位可以在程序加载或运行时，根据程序的实际存放位置，对程序中的地址进行修改， 使其与物理地址相符。静态重定位只能在程序加载时进行一次地址修改，若程序在运行过程中改  变了存放位置，则会出错。动态分配和静态分配是指内存的分配方式，与重定位无关。", "answer": "B || 解析：动态重定位可以在程序加载或运行时，根据程序的实际存放位置，对程序中的地址进行修改， 使其与物理地址相符。静态重定位只能在程序加载时进行一次地址修改，若程序在运行过程中改  变了存放位置，则会出错。动态分配和静态分配是指内存的分配方式，与重定位无关。"}
{"id": "338", "type": "单项选择题", "question": "14. 下面的存储管理方案中，( )方式可以采用静态重定位。 A. 固定分区 B. 可变分区 C. 页式 D. 段式", "answer_label": "A", "answer_explain": "静态重定位只能对程序中的地址进行一次修改，而不能动态调整。在固定分区方式中，作业 装入内存后位置不会改变，且作业在内存中占用连续的存储空间，因此可以采用静态重定位。其 余三种方案均可能在运行过程中改变程序在内存中的位置，不能采用静态重定位。", "answer": "A || 解析：静态重定位只能对程序中的地址进行一次修改，而不能动态调整。在固定分区方式中，作业 装入内存后位置不会改变，且作业在内存中占用连续的存储空间，因此可以采用静态重定位。其 余三种方案均可能在运行过程中改变程序在内存中的位置，不能采用静态重定位。"}
{"id": "339", "type": "单项选择题", "question": "15. 对重定位存储管理方式，应( ) A. 在整个系统中设置一个重定位寄存器 B. 为每道程序设置一个重定位寄存器 C. 为每道程序设置两个重定位寄存器 D. 为每道程序和数据都设置一个重定位寄存器", "answer_label": "A", "answer_explain": "为使地址转换不影响到指令的执行速度，必须有硬件地址变换结构的支持，即需在系统中增 设一个重定位寄存器，用它来存放程序(数据)在内存中的始址。在执行程序或访问数据时，真 正访问的内存地址由相对地址与重定位寄存器中的地址相加而成，这时将始址存入重定位寄存 器，之后的地址访问即可通过硬件变换实现。因为系统处理器在同一时刻只能执行一条指令或访 问数据，所以为每道程序(数据)设置一个寄存器没有必要(同时也不现实，因为寄存器是很昂 贵的硬件，而且程序的道数是无法预估的),而只需在切换程序执行时重置寄存器内容。", "answer": "A || 解析：为使地址转换不影响到指令的执行速度，必须有硬件地址变换结构的支持，即需在系统中增 设一个重定位寄存器，用它来存放程序(数据)在内存中的始址。在执行程序或访问数据时，真 正访问的内存地址由相对地址与重定位寄存器中的地址相加而成，这时将始址存入重定位寄存 器，之后的地址访问即可通过硬件变换实现。因为系统处理器在同一时刻只能执行一条指令或访 问数据，所以为每道程序(数据)设置一个寄存器没有必要(同时也不现实，因为寄存器是很昂 贵的硬件，而且程序的道数是无法预估的),而只需在切换程序执行时重置寄存器内容。"}
{"id": "340", "type": "单项选择题", "question": "16. 在可变分区管理中，采用拼接技术的目的是() A. 合并空闲区 B. 合并分配区 C. 增加主存容量 D. 便于地址转换", "answer_label": "A", "answer_explain": "在可变分区管理中，回收空闲区时采用拼接技术对空闲区进行合并。", "answer": "A || 解析：在可变分区管理中，回收空闲区时采用拼接技术对空闲区进行合并。"}
{"id": "341", "type": "单项选择题", "question": "17. 某页式存储管理系统中，按字节编址，页表内容如下表所示。若页的大小为4KB, 则地址转换机构将逻 辑地址4097转换成的物理地址为()(地址均用十进制表示) A.8192 B.4097 C.2049 D.1025", "answer_label": "B", "answer_explain": "逻辑地址4097对应的页号为4097/4096=1,页内偏移量为4097%4096=1。由页表可知，页 号1对应的页框号也是1,页大小为4KB, 因此转换成的物理地址为1×4K+1=4097。", "answer": "B || 解析：逻辑地址4097对应的页号为4097/4096=1,页内偏移量为4097%4096=1。由页表可知，页 号1对应的页框号也是1,页大小为4KB, 因此转换成的物理地址为1×4K+1=4097。"}
{"id": "342", "type": "单项选择题", "question": "18. 不会产生内部碎片的存储管理是( ) A. 分页式存储管理 B. 分段式存储管理 C. 固定分区式存储管理 D. 段页式存储管理", "answer_label": "B", "answer_explain": "分页式存储管理有内部碎片，分段式存储管理有外部碎片，固定分区存储管理方式有内部碎 片，段页式存储管理方式有内部碎片。", "answer": "B || 解析：分页式存储管理有内部碎片，分段式存储管理有外部碎片，固定分区存储管理方式有内部碎 片，段页式存储管理方式有内部碎片。"}
{"id": "343", "type": "单项选择题", "question": "19. 多进程在主存中彼此互不干扰的环境下运行，操作系统是通过()来实现的。 A. 内存分配 B. 内存保护 C. 内存扩充 D. 地址映射", "answer_label": "B", "answer_explain": "多进程的执行通过内存保护实现互不干扰，如页式管理中有页地址越界保护，段式管理中有\n段地址越界保护。", "answer": "B || 解析：多进程的执行通过内存保护实现互不干扰，如页式管理中有页地址越界保护，段式管理中有\n段地址越界保护。"}
{"id": "344", "type": "单项选择题", "question": "20. 在动态分区分配存储管理中，随着时间的推移，会产生越来越多的小碎片，可通过紧凑技术解决，即操作 系统不时地对进程进行移动和整理，则适合采用( )装入技术。 A. 绝对装入 B. 静态重定位 C. 动态重定位 D. 静态重定位和动态重定位", "answer_label": "C", "answer_explain": "绝对装入在编译时直接将程序的逻辑地址转换成物理地址；静态重定位虽然允许将装入模块 装入内存的任何位置，但不允许进程在内存中移动；动态重定位在程序执行时才产生真正的物理 地址，它允许进程在内存中移动，但需要一个重定位寄存器的支持。", "answer": "C || 解析：绝对装入在编译时直接将程序的逻辑地址转换成物理地址；静态重定位虽然允许将装入模块 装入内存的任何位置，但不允许进程在内存中移动；动态重定位在程序执行时才产生真正的物理 地址，它允许进程在内存中移动，但需要一个重定位寄存器的支持。"}
{"id": "345", "type": "单项选择题", "question": "21. 在动态分区分配存储管理中，不需要对空闲区链进行排序的分配算法是( ) A. 首次适应法 B. 最佳适应法 C. 最差适应法 D. 都不需要", "answer_label": "A", "answer_explain": "首次适应法从空闲区链的链首开始顺序查找，找到一个大小满足要求的空闲分区，根据作业 的大小，从该分区中划出一块内存空间分配给请求者，余下的空闲分区仍然留在空闲链中。这种 算法不需要对空闲区链进行排序，只需按地址递增的顺序链接即可。", "answer": "A || 解析：首次适应法从空闲区链的链首开始顺序查找，找到一个大小满足要求的空闲分区，根据作业 的大小，从该分区中划出一块内存空间分配给请求者，余下的空闲分区仍然留在空闲链中。这种 算法不需要对空闲区链进行排序，只需按地址递增的顺序链接即可。"}
{"id": "346", "type": "单项选择题", "question": "22. 分区管理中采用最佳适应分配算法时，把空闲区按( )次序登记在空闲区表中。 A. 长度递增 B. 长度递减 C. 地址递增 D. 地址递减", "answer_label": "A", "answer_explain": "最佳适应算法要求从剩余的空闲分区中选出最小且满足存储要求的分区，空闲区应按长度递 增登记在空闲区表中。", "answer": "A || 解析：最佳适应算法要求从剩余的空闲分区中选出最小且满足存储要求的分区，空闲区应按长度递 增登记在空闲区表中。"}
{"id": "347", "type": "单项选择题", "question": "23. 首次适应算法的空闲分区() A. 按大小递减顺序连在一起 B. 按大小递增顺序连在一起 C. 按地址由小到大排列 D. 按地址由大到小排列", "answer_label": "C", "answer_explain": "首次适应算法的空闲分区按地址递增的次序排列。", "answer": "C || 解析：首次适应算法的空闲分区按地址递增的次序排列。"}
{"id": "348", "type": "单项选择题", "question": "24. 为了提高搜索空闲分区的速度，在大、中型系统中往往采用基于索引搜索的动态分区分配算法，以下不 属于基于索引搜索的动态分区分配算法的是( ) A. 快速适应算法 B. 伙伴系统 C. 哈希算法 D. 最佳适应算法", "answer_label": "D", "answer_explain": "基于顺序搜索的分配算法有首次适应算法、循环首次适应算法、最佳适应算法和最坏适应算 法；基于索引搜索的分配算法有快速适应算法、伙伴系统和哈希算法。", "answer": "D || 解析：基于顺序搜索的分配算法有首次适应算法、循环首次适应算法、最佳适应算法和最坏适应算 法；基于索引搜索的分配算法有快速适应算法、伙伴系统和哈希算法。"}
{"id": "349", "type": "单项选择题", "question": "25. 内存存储管理由连续分配方式发展为页式管理方式的主要动力是( ) A. 提高内存利用率 B. 提高系统吞叶量 C. 满足用户的需要 D. 更好的满足多道程序的需要", "answer_label": "A", "answer_explain": "连续分配会产生内部碎片和外部碎片，导致内存空间的浪费。而页式管理将进程和内存都划 分为固定大小的页，然后将进程的页离散地装入内存页框，从而提高内存的利用率。", "answer": "A || 解析：连续分配会产生内部碎片和外部碎片，导致内存空间的浪费。而页式管理将进程和内存都划 分为固定大小的页，然后将进程的页离散地装入内存页框，从而提高内存的利用率。"}
{"id": "350", "type": "单项选择题", "question": "26. 页式存储管理中的页表是由( )建立的。 A. 编译程序 B. 用户程序 C. 链接程序 D. 操作系统", "answer_label": "D", "answer_explain": "页表是由操作系统在程序装入内存时建立的，根据进程的逻辑地址空间和物理地址空间的对 应关系，为每个页设置一个页表项，记录其对应的物理页框号、有效位等信息。", "answer": "D || 解析：页表是由操作系统在程序装入内存时建立的，根据进程的逻辑地址空间和物理地址空间的对 应关系，为每个页设置一个页表项，记录其对应的物理页框号、有效位等信息。"}
{"id": "351", "type": "单项选择题", "question": "27. 在段式存储管理中，共享段表是用来实现( )的。 A. 多个进程共享同一段代码或数据 B. 多个进程共享同一段物理内存空间 C. 多个进程共享同一段逻辑地址空间 D. 多个进程共享同一段号", "answer_label": "A", "answer_explain": "在段式存储管理中，若有些段可被多个进程共享，则可用一个单独的共享段表来描述这些段， 而不需要在每个进程的段表中都保存一份。共享段表的作用是实现多个进程共享同一段代码或数 据，这样既能节省内存空间，又能便于实现对共享段的更新和维护。多个进程共享同一段物理内 存空间并不需要用到共享段表，只需在各自的段表中指向相同的物理地址即可。多个进程共享同 一段逻辑地址空间是不可能的，因为每个进程的逻辑地址空间都是相互独立的。在段式存储管理 中，并不要求各个进程中相同功能的段必须有相同的段号。", "answer": "A || 解析：在段式存储管理中，若有些段可被多个进程共享，则可用一个单独的共享段表来描述这些段， 而不需要在每个进程的段表中都保存一份。共享段表的作用是实现多个进程共享同一段代码或数 据，这样既能节省内存空间，又能便于实现对共享段的更新和维护。多个进程共享同一段物理内 存空间并不需要用到共享段表，只需在各自的段表中指向相同的物理地址即可。多个进程共享同 一段逻辑地址空间是不可能的，因为每个进程的逻辑地址空间都是相互独立的。在段式存储管理 中，并不要求各个进程中相同功能的段必须有相同的段号。"}
{"id": "352", "type": "单项选择题", "question": "28. 在段式存储管理中，若一个进程有n 个段，则该进程需要( )个段表。 A.n B.n+1 C.1 D.2", "answer_label": "C", "answer_explain": "不管进程有多少个段，系统都为每个进程建立一张段表，每个段表项对应进程中的一段。", "answer": "C || 解析：不管进程有多少个段，系统都为每个进程建立一张段表，每个段表项对应进程中的一段。"}
{"id": "353", "type": "单项选择题", "question": "29. 采用分页或分段管理后，提供给用户的物理地址空间( ) A. 分页支持更大的物理地址空间 B. 分段支持更大的物理地址空间 C.不能确定 D. 一样大 ", "answer_label": "C", "answer_explain": "页表和段表同样存储在内存中，系统提供给用户的物理地址空间为总空间大小减去页表或段 表的长度。因为页表和段表的长度不能确定，所以提供给用户的物理地址空间大小也不能确定。", "answer": "C || 解析：页表和段表同样存储在内存中，系统提供给用户的物理地址空间为总空间大小减去页表或段 表的长度。因为页表和段表的长度不能确定，所以提供给用户的物理地址空间大小也不能确定。"}
{"id": "353", "type": "单项选择题", "question": "30. 分页系统中的页面是为( ) A. 用户所感知的 B. 操作系统所感知的 C. 编译系统所感知的 D. 连接装配程序所感知的 ", "answer_label": "B", "answer_explain": "分页管理是在硬件和操作系统层面实现的，对用户、编译系统、装配程序等上层是不可见的。", "answer": "B || 解析：分页管理是在硬件和操作系统层面实现的，对用户、编译系统、装配程序等上层是不可见的。"}
{"id": "354", "type": "单项选择题", "question": "31. 在页式存储管理中，页表的始地址存放在( )中。 A. 物理内存 B. 页表 C. 快表(TLB) D. 页表寄存器", "answer_label": "D", "answer_explain": "页表的功能由一组专门的存储器实现，其始址放在页表基址寄存器 (PTBR)   中。这样才能 满足在地址变换时能够较快地完成逻辑地址和物理地址之间的转换。", "answer": "D || 解析：页表的功能由一组专门的存储器实现，其始址放在页表基址寄存器 (PTBR)   中。这样才能 满足在地址变换时能够较快地完成逻辑地址和物理地址之间的转换。"}
{"id": "355", "type": "单项选择题", "question": "32. 在页式存储管理中，当CPU 形成一个有效地址时，查找页表的工作是由()实现的。 A. 操作系统 B. 页表查询程序 C. 硬件 D. 存储管理进程", "answer_label": "C", "answer_explain": "在页式存储管理中，CPU 将虚拟地址分解为页号和页内偏移量，然后通过硬件中的页表寄存 器和内存管理单元 (MMU),   将页号转换为物理地址，再拼接上页内偏移量，得到最终的内存物 理地址。这一过程是由硬件自动完成的，不需要操作系统或其他软件的干预。", "answer": "C || 解析：在页式存储管理中，CPU 将虚拟地址分解为页号和页内偏移量，然后通过硬件中的页表寄存 器和内存管理单元 (MMU),   将页号转换为物理地址，再拼接上页内偏移量，得到最终的内存物 理地址。这一过程是由硬件自动完成的，不需要操作系统或其他软件的干预。"}
{"id": "356", "type": "单项选择题", "question": "33. 采用段式存储管理时，一个程序如何分段是在( )时决定的。 A. 分配主存 B. 用户编程 C. 装作业 D. 程序执行", "answer_label": "B", "answer_explain": "分段是指在用户编程时，将程序按照逻辑划分为几个逻辑段。", "answer": "B || 解析：分段是指在用户编程时，将程序按照逻辑划分为几个逻辑段。"}
{"id": "357", "type": "单项选择题", "question": "34. 下面的()方法有利于程序的动态链接。 A. 分段存储管理 B. 分页存储管理 C. 可变式分区管理 D. 固定式分区管理", "answer_label": "A", "answer_explain": "程序的动态链接与程序的逻辑结构相关，分段存储管理将程序按照逻辑段进行划分，因此有 利于其动态链接。其他的内存管理方式与程序的逻辑结构无关。", "answer": "A || 解析：程序的动态链接与程序的逻辑结构相关，分段存储管理将程序按照逻辑段进行划分，因此有 利于其动态链接。其他的内存管理方式与程序的逻辑结构无关。"}
{"id": "358", "type": "单项选择题", "question": "35. 当前编程人员编写好的程序经过编译转换成目标文件后，各条指令的地址编号起始一般定为(),称为 ( ) 地 址 。 A.1 B.0 C.IP D.CS A. 绝对 B. 名义 C. 逻辑 D. 实", "answer_label": "B", "answer_explain": "、C\n编译后一个目标程序所限定的地址范围称为该作业的逻辑地址空间。换句话说，地址空间仅 指程序用来访问信息所用的一系列地址单元的集合。这些单元的编号称为逻辑地址。通常，编译 地址都是相对始址“0”的，因此逻辑地址也称相对地址。", "answer": "B || 解析：、C\n编译后一个目标程序所限定的地址范围称为该作业的逻辑地址空间。换句话说，地址空间仅 指程序用来访问信息所用的一系列地址单元的集合。这些单元的编号称为逻辑地址。通常，编译 地址都是相对始址“0”的，因此逻辑地址也称相对地址。"}
{"id": "359", "type": "单项选择题", "question": "36. 可重入程序是通过( )方法来改善系统性能的。 A. 改变时间片长度 B. 改变用户数 C. 提高对换速度 D. 减少对换数量", "answer_label": "D", "answer_explain": "可重入程序主要是通过共享来使用同一块存储空间的，或通过动态链接的方式将所需的 程序段映射到相关进程中去，其最大的优点是减少了对程序段的调入/调出，因此减少了对换 数 量 。", "answer": "D || 解析：可重入程序主要是通过共享来使用同一块存储空间的，或通过动态链接的方式将所需的 程序段映射到相关进程中去，其最大的优点是减少了对程序段的调入/调出，因此减少了对换 数 量 。"}
{"id": "360", "type": "单项选择题", "question": "37. 操作系统实现( )存储管理的代价最小。 A. 分区 B. 分页 C. 分段 D. 段页式", "answer_label": "A", "answer_explain": "实现分页、分段和段页式存储管理需要特定的数据结构支持，如页表、段表等。为了提高性 能，还需要硬件提供快存和地址加法器等，代价高。分区存储管理是满足多道程序设计的最简单 的存储管理方案，特别适合嵌入式等微型设备。", "answer": "A || 解析：实现分页、分段和段页式存储管理需要特定的数据结构支持，如页表、段表等。为了提高性 能，还需要硬件提供快存和地址加法器等，代价高。分区存储管理是满足多道程序设计的最简单 的存储管理方案，特别适合嵌入式等微型设备。"}
{"id": "361", "type": "单项选择题", "question": "38. 动态分区又称可变式分区，它是系统运行过程中( )动态建立的。 A. 在作业装入时 B. 在作业创建时 C. 在作业完成时 D. 在作业未装入时", "answer_label": "A", "answer_explain": "动态分区时，在系统启动后，除操作系统占据一部分内存外，其余所有内存空间是一个大空 闲区，称为自由空间。若作业申请内存，则从空闲区中划出一个与作业需求量相适应的分区分配 给该作业，将作业创建为进程，在作业运行完毕后，再收回释放的分区。", "answer": "A || 解析：动态分区时，在系统启动后，除操作系统占据一部分内存外，其余所有内存空间是一个大空 闲区，称为自由空间。若作业申请内存，则从空闲区中划出一个与作业需求量相适应的分区分配 给该作业，将作业创建为进程，在作业运行完毕后，再收回释放的分区。"}
{"id": "362", "type": "单项选择题", "question": "39. 在页式存储管理中选择页面的大小，需要考虑下列()因素。 I. 页面大的好处是页表比较少 I. 页面小的好处走可以减少由内碎片引起的内存浪费 Ⅲ.影响磁盘访问时间的主要因素通常不是页面大小，所以使用时优先考虑较大的页面 A.I 和III B.II和III C.I和II D.I、II和III", "answer_label": "C", "answer_explain": "页面大，用于管理页面的页表项就少，但是页内碎片会比较大；页面小，用于管理页面的页 表项就多，但是页内碎片小。通过适当的计算可以获得较佳的页面大小和较小的系统开销。", "answer": "C || 解析：页面大，用于管理页面的页表项就少，但是页内碎片会比较大；页面小，用于管理页面的页 表项就多，但是页内碎片小。通过适当的计算可以获得较佳的页面大小和较小的系统开销。"}
{"id": "363", "type": "单项选择题", "question": "40.某个操作系统对内存的管理采用页式存储管理方法，所划分的页面大小() A. 要根据内存大小确定 B.必须相同 C. 要根据CPU 的地址结构确定 D. 要依据外存和内存的大小确定", "answer_label": "B", "answer_explain": "页式管理中很重要的一个问题是页面大小如何确定。确定页面大小有很多因素，如进程的平 均大小、页表占用的长度等。而一旦确定，所有的页面就是等长的(一般取2的整数幂倍),以 便易于系统管理。", "answer": "B || 解析：页式管理中很重要的一个问题是页面大小如何确定。确定页面大小有很多因素，如进程的平 均大小、页表占用的长度等。而一旦确定，所有的页面就是等长的(一般取2的整数幂倍),以 便易于系统管理。"}
{"id": "364", "type": "单项选择题", "question": "41. 引入段式存储管理方式，主要是为了更好地满足用户的一系列要求。下面选项中不属于这一系列要求 的是( ) A. 方便操作 B. 方便编程 C. 共享和保护 D. 动态链接和增长", "answer_label": "A", "answer_explain": "引入段式存储管理方式，主要是为了满足用户的下列要求：方便编程、分段共享、分段保护、 动态链接和动态增长。", "answer": "A || 解析：引入段式存储管理方式，主要是为了满足用户的下列要求：方便编程、分段共享、分段保护、 动态链接和动态增长。"}
{"id": "365", "type": "单项选择题", "question": "42.对主存储器的访问，( ) A. 以块(页)或段为单位 B. 以字节或字为单位 C. 随存储器的管理方案不同而异 D. 以用户的逻辑记录为单位", "answer_label": "B", "answer_explain": "这里是指主存的访问，不是主存的分配。对主存的访问是以字节或字为单位的。例如，在页 式管理中，不仅要知道块号，还要知道页内偏移。", "answer": "B || 解析：这里是指主存的访问，不是主存的分配。对主存的访问是以字节或字为单位的。例如，在页 式管理中，不仅要知道块号，还要知道页内偏移。"}
{"id": "366", "type": "单项选择题", "question": "43. 以下存储管理方式中，不适合多道程序设计系统的是( ) A. 单用户连续分配 B. 固定式分区分配 C. 可变式分区分配 D. 分页式存储管理方式", "answer_label": "A", "answer_explain": "单用户连续分配管理方式只适用于单用户、单任务的操作系统，不适用于多道程序设计。", "answer": "A || 解析：单用户连续分配管理方式只适用于单用户、单任务的操作系统，不适用于多道程序设计。"}
{"id": "367", "type": "单项选择题", "question": "44. 在分页存储管理中，主存的分配() A. 以页框为单位进行 B. 以作业的大小进行 C. 以物理段进行 D. 以逻辑记录大小进行", "answer_label": "A", "answer_explain": "在分页存储管理中，逻辑地址分配是按页为单位进行分配的，而主存的分配即物理地址分配 是以内存块为单位分配的。", "answer": "A || 解析：在分页存储管理中，逻辑地址分配是按页为单位进行分配的，而主存的分配即物理地址分配 是以内存块为单位分配的。"}
{"id": "368", "type": "单项选择题", "question": "45. 在段式分配中，CPU 每次从内存中取一次数据需要()次访问内存。 A.1 B.3 C.2 D.4", "answer_label": "C", "answer_explain": "在段式分配中，取一次数据时先从内存查找段表，再拼成物理地址后访问内存，共需要2次 内存访问。", "answer": "C || 解析：在段式分配中，取一次数据时先从内存查找段表，再拼成物理地址后访问内存，共需要2次 内存访问。"}
{"id": "369", "type": "单项选择题", "question": "46. 在段页式分配中，CPU 每次从内存中取一次数据需要( )次访问内存。 A.1 B.3 C.2 D.4", "answer_label": "B", "answer_explain": "在段页式分配中，取一次数据时先从内存查找段表，再访问内存查找相应的页表，最后拼成 物理地址后访问内存，共需要3次内存访问。", "answer": "B || 解析：在段页式分配中，取一次数据时先从内存查找段表，再访问内存查找相应的页表，最后拼成 物理地址后访问内存，共需要3次内存访问。"}
{"id": "370", "type": "单项选择题", "question": "47. 采用段页式存储管理时，内存地址结构是( ) A. 线性的 B. 二维的 C. 三维的 D. 四维的", "answer_label": "B", "answer_explain": "虽然段页式存储管理的内存地址结构分为段号、段内页号和页内地址三部分，但分页是操作 系统的行为，用户不用指出页内偏移量的位数；而分段之间是独立的，且段长不定长，需指出段 号所占的位数。因此，当采用段页式存储管理时，内存地址结构仍然是二维的。而在分页存储管 理中，作业地址空间是一维的，即单一的线性地址空间，程序员只需要一个整数来表示地址。简 言之，确定一个地址需要几个参数，作业地址空间就是几维的。", "answer": "B || 解析：虽然段页式存储管理的内存地址结构分为段号、段内页号和页内地址三部分，但分页是操作 系统的行为，用户不用指出页内偏移量的位数；而分段之间是独立的，且段长不定长，需指出段 号所占的位数。因此，当采用段页式存储管理时，内存地址结构仍然是二维的。而在分页存储管 理中，作业地址空间是一维的，即单一的线性地址空间，程序员只需要一个整数来表示地址。简 言之，确定一个地址需要几个参数，作业地址空间就是几维的。"}
{"id": "371", "type": "单项选择题", "question": "48.在段页式存储管理中，地址映射表是( ) A. 每个进程一张段表，两张页表 B. 每个进程的每个段一张段表，一张页表 C. 每个进程一张段表，每个段一张页表 D. 每个进程一张页表，每个段一张段表", "answer_label": "C", "answer_explain": "段页式系统中，进程首先划分为段，每段再进一步划分为页。", "answer": "C || 解析：段页式系统中，进程首先划分为段，每段再进一步划分为页。"}
{"id": "372", "type": "单项选择题", "question": "49. 操作系统采用分页存储管理方式，要求( ) A. 每个进程拥有一张页表，且进程的页表驻留在内存中 B. 每个进程拥有一张页表，但只有执行进程的页表驻留在内存中 C. 所有进程共享一张页表，以节约有限的内存空间，但页表必须驻留在内存中 D. 所有进程共享一张页表，只有页表中当前使用的页面必须驻留在内存中，以最大限度地节省有限的 内存空间", "answer_label": "A", "answer_explain": "在多个进程并发执行时，所有进程的页表大多数驻留在内存中，在系统中只设置一个页表寄 存器(PTR),   它存放页表在内存中的始址和长度。平时，进程未执行时，页表的始址和页表长度 存放在本进程的PCB 中，当调度到某进程时，才将这两个数据装入页表寄存器中。每个进程都有 一个单独的逻辑地址，有一张属于自己的页表。", "answer": "A || 解析：在多个进程并发执行时，所有进程的页表大多数驻留在内存中，在系统中只设置一个页表寄 存器(PTR),   它存放页表在内存中的始址和长度。平时，进程未执行时，页表的始址和页表长度 存放在本进程的PCB 中，当调度到某进程时，才将这两个数据装入页表寄存器中。每个进程都有 一个单独的逻辑地址，有一张属于自己的页表。"}
{"id": "373", "type": "单项选择题", "question": "50. 在分段存储管理方式中，( ) A. 以段为单位，每段是一个连续存储区 B. 段与段之间必定不连续 C. 段与段之间必定连续 D. 每段是等长的", "answer_label": "A", "answer_explain": "在分段存储管理方式中，以段为单位进行分配，每段是一个连续存储区，每段不一定等长， 段与段之间可连续，也可不连续。", "answer": "A || 解析：在分段存储管理方式中，以段为单位进行分配，每段是一个连续存储区，每段不一定等长， 段与段之间可连续，也可不连续。"}
{"id": "374", "type": "单项选择题", "question": "51. 下列关于段式存储管理的叙述中，错误的是( ) A. 段是逻辑结构上相对独立的程序块，因此段是可变长的 B. 按程序中实际的段来分配主存，所以分配后的存储块是可变长的 C. 每个段表项必须记录对应段在主存的起始位置和段的长度 D. 分段方式对低级语言程序员和编译器来说是透明的", "answer_label": "D", "answer_explain": "分段方式对低级语言程序员和编译器是可见的，因为低级语言程序员可以按照程序的逻辑结 构划分段，并给每个段命名；编译器也需要对各个段生成逻辑地址。", "answer": "D || 解析：分段方式对低级语言程序员和编译器是可见的，因为低级语言程序员可以按照程序的逻辑结 构划分段，并给每个段命名；编译器也需要对各个段生成逻辑地址。"}
{"id": "375", "type": "单项选择题", "question": "52. 段页式存储管理汲取了页式管理和段式管理的长处，其实现原理结合了页式和段式管理的基本思想，即 ( ) A. 用分段方法来分配和管理物理存储空间，用分页方法来管理用户地址空间 B. 用分段方法来分配和管理用户地址空间，用分页方法来管理物理存储空间 C. 用分段方法来分配和管理主存空间，用分页方法来管理辅存空间 D. 用分段方法来分配和管理辅存空间，用分页方法来管理主存空间", "answer_label": "B", "answer_explain": "段页式存储管理兼有页式管理和段式管理的优点，采用分段方法来分配和管理用户地址空 间，采用分页方法来管理物理存储空间。但它的开销要比段式和页式管理的开销大。", "answer": "B || 解析：段页式存储管理兼有页式管理和段式管理的优点，采用分段方法来分配和管理用户地址空 间，采用分页方法来管理物理存储空间。但它的开销要比段式和页式管理的开销大。"}
{"id": "376", "type": "单项选择题", "question": "53. 以下存储管理方式中，会产生内部碎片的是( ) I. 分段虚拟存储管理 II. 分页虚拟存储管理 III. 段页式分区管理 IV.固定式分区管理 A.I、II、III B.III、IV C.仅I D.II、II、IV", "answer_label": "D", "answer_explain": "只要是固定的分配就会产生内部碎片，其余的都会产生外部碎片。若固定和不固定同时存在 \t(例如段页式),则仍视为固定。分段虚拟存储管理：每段的长度都不一样(对应不固定),所以 会产生外部碎片。分页虚拟存储管理：每页的长度都一样(对应固定),所以会产生内部碎片。 段页式分区管理：既有固定，又有不固定，以固定为主，所以会有内部碎片。固定式分区管理： 很明显固定，会产生内部碎片。综上分析，选项Ⅱ、ⅢI、IV 会产生内部碎片。", "answer": "D || 解析：只要是固定的分配就会产生内部碎片，其余的都会产生外部碎片。若固定和不固定同时存在 \t(例如段页式),则仍视为固定。分段虚拟存储管理：每段的长度都不一样(对应不固定),所以 会产生外部碎片。分页虚拟存储管理：每页的长度都一样(对应固定),所以会产生内部碎片。 段页式分区管理：既有固定，又有不固定，以固定为主，所以会有内部碎片。固定式分区管理： 很明显固定，会产生内部碎片。综上分析，选项Ⅱ、ⅢI、IV 会产生内部碎片。"}
{"id": "377", "type": "单项选择题", "question": "54. 下列关于页式存储管理的论述中，正确的是( ) I. 若关闭TLB, 则每取一条指令或一个操作数都至少要访存2次 II. 页式存储管理不会产生内部碎片 III. 页式存储管理中的页面是为用户所感知的 IV. 页式存储方式可以采用静态重定位 A.I 、II 、IV B.I 、IV C. 仅I D. 全都正确", "answer_label": "C", "answer_explain": "选项I 正确：关闭TLB 后，每当访问一条指令或存取一个操作数时都要先访问页表(内存中), 得到物理地址后，再访问一次内存进行相应操作。选项Ⅱ错误：记住，凡是分区固定的都会产生 内部碎片，而无外部碎片。选项Ⅲ错误：页式存储管理对于用户是透明的。选项IV 错误：静态 重定位是在程序运行之前由装配程序完成的，必须分配其要求的全部连续内存空间。而页式存储 管理方案是将程序离散地分成若干页(块),从而可以将程序装入不连续的内存空间，显然静态 重定位不能满足其要求。", "answer": "C || 解析：选项I 正确：关闭TLB 后，每当访问一条指令或存取一个操作数时都要先访问页表(内存中), 得到物理地址后，再访问一次内存进行相应操作。选项Ⅱ错误：记住，凡是分区固定的都会产生 内部碎片，而无外部碎片。选项Ⅲ错误：页式存储管理对于用户是透明的。选项IV 错误：静态 重定位是在程序运行之前由装配程序完成的，必须分配其要求的全部连续内存空间。而页式存储 管理方案是将程序离散地分成若干页(块),从而可以将程序装入不连续的内存空间，显然静态 重定位不能满足其要求。"}
{"id": "378", "type": "单项选择题", "question": "55. 在某分页存储管理的系统中，地址结构长18位，其中11～17位为页号，0～10位为页内偏移量，则主存 的最大容量为( )KB, 主存可分为( )个页。若有一作业依次放入2、3、7号物理块，相对地址1500 处有一条指令 “store r1,2500”,该指令地址所在页的页号为0,则指令的物理地址为( ),指令数据的 存储地址所在页的页框号为( ) A.256 、256 、5596 、3 B.256 、128 、5596 、3 C.256 、128 、5596 、7 D.256 、128 、3548 、7", "answer_label": "B", "answer_explain": "地址结构长18位，所以主存的最大容量为2⁸=256KB; 页内偏移量占11位，所以页面大小 为2¹¹=2048B;  页号占7位，所以主存页数为2⁷=128个。该指令的相对地址为1500,小于一个页面的大小，所以该指令存放在2号物理块中，物理地址为2×2048+1500=5596,指令数据的存 放地址为2500,大于一个页面的大小，所以指令数据存放在3号物理块中。", "answer": "B || 解析：地址结构长18位，所以主存的最大容量为2⁸=256KB; 页内偏移量占11位，所以页面大小 为2¹¹=2048B;  页号占7位，所以主存页数为2⁷=128个。该指令的相对地址为1500,小于一个页面的大小，所以该指令存放在2号物理块中，物理地址为2×2048+1500=5596,指令数据的存 放地址为2500,大于一个页面的大小，所以指令数据存放在3号物理块中。"}
{"id": "379", "type": "单项选择题", "question": "56. 在某页式存储管理的系统中，主存容量为1MB, 被分成256个页框，页框号为0,1,2,…,255。某作业的 地址空间占用4页，其页号为0,1,2,3,被分配到主存的第2,4,1,5号页框中，则作业中的2号页在主存 中的始址是( ) A.1 B.1024 C.2048 D.4096", "answer_label": "D", "answer_explain": "主存容量为1MB,   分为256个页框，页框大小为1MB/256=4KB,      作业中的2号页被分配 到主存的1号页框中，因此其在主存中的始址为1×4096=4096。", "answer": "D || 解析：主存容量为1MB,   分为256个页框，页框大小为1MB/256=4KB,      作业中的2号页被分配 到主存的1号页框中，因此其在主存中的始址为1×4096=4096。"}
{"id": "380", "type": "单项选择题", "question": "57. 下列关于分页和分段的描述中，正确的是( ) A. 分段是信息的逻辑单位，段长由系统决定 B. 引入分段的主要目的是实现离散分配并提高内存利用率 C. 分页是信息的物理单位，页长由用户决定 D .页面在物理内存中只能从页面大小的整数倍地址开始存放", "answer_label": "D", "answer_explain": "分段是指将逻辑地址空间划分为若干不等长的单元，称为段。段长由用户根据信息的性质和 逻辑结构决定，而不由系统决定，引入分段的主要目的是更好地满足用户的需求，实现程序的模 块化和保护。实现离散分配并提高内存利用率是引入分页的主要目的。", "answer": "D || 解析：分段是指将逻辑地址空间划分为若干不等长的单元，称为段。段长由用户根据信息的性质和 逻辑结构决定，而不由系统决定，引入分段的主要目的是更好地满足用户的需求，实现程序的模 块化和保护。实现离散分配并提高内存利用率是引入分页的主要目的。"}
{"id": "381", "type": "单项选择题", "question": "58. 在采用页式存储管理的系统中，逻辑地址空间大小为256TB,页表项大小为8B, 页面大小为4KB,则该 系统中的页表应该采用( )级页表。 A.2 B.3 C.4 D.5", "answer_label": "C", "answer_explain": "逻辑地址空间大小为256TB=2⁴⁸B,     逻辑地址有48位，页面大小为4KB=2¹²B,      页内偏移 量2占12位，剩余36位表示页表索引，页表项大小为8B,   一个页面能存放4KB÷8=2⁹   个页表 项，因此可用9位来表示某一级的页表索引，36÷9=4,所以共需要采用4级页表。", "answer": "C || 解析：逻辑地址空间大小为256TB=2⁴⁸B,     逻辑地址有48位，页面大小为4KB=2¹²B,      页内偏移 量2占12位，剩余36位表示页表索引，页表项大小为8B,   一个页面能存放4KB÷8=2⁹   个页表 项，因此可用9位来表示某一级的页表索引，36÷9=4,所以共需要采用4级页表。"}
{"id": "382", "type": "单项选择题", "question": "59.若对经典的页式存储管理方式的页表做出稍微改造，允许不同页表的页表项指向同一个页帧，则可能的 结果有( ) I. 可以实现对可重入代码的共享 I. 只需修改页表项，就能实现内存“复制”操作 III. 容易发生越界访问 IV. 可以实现进程间通信 A.I 、I 、IV B.II 、III C.I 、II 、III D.仅I", "answer_label": "A", "answer_explain": "让不同页表的页表项指向同一个页帧，可以共享该页帧的代码，若代码是可重入的(如编辑 软件、编译软件等),则这种方法可以节省大量的内存空间。实现内存“复制”操作时，不需要 将页面的内容逐字节复制，而只需将页表中指向该页面的指针复制到目的地址的页表项中。越界 保护是通过界地址寄存器实现的，选项Ⅲ是干扰项。当多个进程需要通信时，可以采用共享内 存的方式，它们是通过让各个进程页表的页表项指向相同的页帧实现的。", "answer": "A || 解析：让不同页表的页表项指向同一个页帧，可以共享该页帧的代码，若代码是可重入的(如编辑 软件、编译软件等),则这种方法可以节省大量的内存空间。实现内存“复制”操作时，不需要 将页面的内容逐字节复制，而只需将页表中指向该页面的指针复制到目的地址的页表项中。越界 保护是通过界地址寄存器实现的，选项Ⅲ是干扰项。当多个进程需要通信时，可以采用共享内 存的方式，它们是通过让各个进程页表的页表项指向相同的页帧实现的。"}
{"id": "383", "type": "单项选择题", "question": "60.【2009统考真题】分区分配内存管理方式的主要保护措施是( ) A. 界地址保护 B. 程序代码保护 C. 数据保护 D. 栈保护", "answer_label": "A", "answer_explain": "每个进程都拥有自己独立的进程空间，若一个进程在运行时所产生的地址在其地址空间之 外，则发生地址越界，因此需要进行界地址保护，即当程序要访问某个内存单元时，由硬件检查 是否允许，若允许则执行，否则产生地址越界中断。", "answer": "A || 解析：每个进程都拥有自己独立的进程空间，若一个进程在运行时所产生的地址在其地址空间之 外，则发生地址越界，因此需要进行界地址保护，即当程序要访问某个内存单元时，由硬件检查 是否允许，若允许则执行，否则产生地址越界中断。"}
{"id": "384", "type": "单项选择题", "question": "61.【2009统考真题】一个分段存储管理系统中，地址长度为32位，其中段号占8位，则最大段长是( ) A.2⁸B B.2¹⁶B C.2²4B D.2³2B", "answer_label": "C", "answer_explain": "分段存储管理的逻辑地址分为段号和位移量两部分，段内位移的最大值就是最大段长。地址 长度为32位，段号占8位，因此位移量占32-8=24位，因此最大段长为2²⁴B。", "answer": "C || 解析：分段存储管理的逻辑地址分为段号和位移量两部分，段内位移的最大值就是最大段长。地址 长度为32位，段号占8位，因此位移量占32-8=24位，因此最大段长为2²⁴B。"}
{"id": "385", "type": "单项选择题", "question": "62.【2010统考真题】某基于动态分区存储管理的计算机，其主存容量为55MB(初始为空),采用最佳适配 (Best Fit)算法，分配和释放的顺序为：分配15MB, 分配30MB, 释放15MB, 分配8MB,分配6MB, 此时 主存中最大空闲分区的大小是( ) A.7MB B.9MB C.10MB D.15MB", "answer_label": "B", "answer_explain": "最佳适配算法是指每次为作业分配内存空间时，总是找到能满足空间大小需要的最小空闲分 区给作业，可以产生最小的内存空闲分区。下图显示了这个过程的主存空间变化。\n6MB\n15MB\n9MB\n30MB\n40MB\n8MB\n10MB\n2MB\n分配\n8MB\n图中，灰色部分为分配出去的空间，白色部分为空闲区。这样，容易发现，此时主存中最大 空闲分区的大小为9MB。", "answer": "B || 解析：最佳适配算法是指每次为作业分配内存空间时，总是找到能满足空间大小需要的最小空闲分 区给作业，可以产生最小的内存空闲分区。下图显示了这个过程的主存空间变化。\n6MB\n15MB\n9MB\n30MB\n40MB\n8MB\n10MB\n2MB\n分配\n8MB\n图中，灰色部分为分配出去的空间，白色部分为空闲区。这样，容易发现，此时主存中最大 空闲分区的大小为9MB。"}
{"id": "386", "type": "单项选择题", "question": "63.【2010统考真题】某计算机采用二级页表的分页存储管理方式，按字节编址，页大小为2¹⁰B,页表项大 小为2B, 逻辑地址结构为 逻辑地址空间大小为2¹⁶页，则表示整个逻辑地址空间的页目录表中包含表项的个数至少是( ) A.64 B.128 C.256 D.512", "answer_label": "B", "answer_explain": "页大小为2¹⁰B, 所以页内偏移量占10位，又因为页表项大小为2B, 一页可以存放2⁹个页表\n208                     2 0 2 6 年 操 作 系 统 考 研 复 习 指 导\n项，所以页号占9位，根据逻辑地址空间共有2⁶页可知，页目录号加页号共占16位，页目录号 占7位，所以页目录表中包含表项的个数至少是2⁷=128。", "answer": "B || 解析：页大小为2¹⁰B, 所以页内偏移量占10位，又因为页表项大小为2B, 一页可以存放2⁹个页表\n208                     2 0 2 6 年 操 作 系 统 考 研 复 习 指 导\n项，所以页号占9位，根据逻辑地址空间共有2⁶页可知，页目录号加页号共占16位，页目录号 占7位，所以页目录表中包含表项的个数至少是2⁷=128。"}
{"id": "387", "type": "单项选择题", "question": "64.【2011统考真题】在虚拟内存管理中，地址变换机构将逻辑地址变换为物理地址，形成该逻辑地址的阶 段是( ) A. 编辑 B. 编译 C. 链接 D.装载", "answer_label": "C", "answer_explain": "编译后的程序需要经过链接才能装载，而链接后形成的目标程序中的地址也就是逻辑地址。 以 C 语言为例：C 程序经过预处理→编译→汇编→链接产生了可执行文件，其中链接的前一步是  产生可重定位的二进制目标文件。C 语言采用源文件独立编译的方法，如程序main.c,filel.c,file2.c,      file1.h,file2.h  在链接的前一步生成了main.o,filel.o,file2.0,    这些目标模块的逻辑地址都从0开始， 但只是相对于该模块的逻辑地址。链接器将这三个文件、libc 和其库文件链接成一个可执行文件， 从而形成整个程序的完整逻辑地址空间。\n例如，filel.o  的逻辑地址为0～1023,main.o 的逻辑地址为0～1023,假设链接时将 file1.o 链接在main.o 之后，则链接之后file1.o 对应的逻辑地址应为1024～2047。", "answer": "C || 解析：编译后的程序需要经过链接才能装载，而链接后形成的目标程序中的地址也就是逻辑地址。 以 C 语言为例：C 程序经过预处理→编译→汇编→链接产生了可执行文件，其中链接的前一步是  产生可重定位的二进制目标文件。C 语言采用源文件独立编译的方法，如程序main.c,filel.c,file2.c,      file1.h,file2.h  在链接的前一步生成了main.o,filel.o,file2.0,    这些目标模块的逻辑地址都从0开始， 但只是相对于该模块的逻辑地址。链接器将这三个文件、libc 和其库文件链接成一个可执行文件， 从而形成整个程序的完整逻辑地址空间。\n例如，filel.o  的逻辑地址为0～1023,main.o 的逻辑地址为0～1023,假设链接时将 file1.o 链接在main.o 之后，则链接之后file1.o 对应的逻辑地址应为1024～2047。"}
{"id": "388", "type": "单项选择题", "question": "65.【2014统考真题】下列选项中，属于多级页表优点的是() A. 加快地址变换速度 B. 减少缺页中断次数 C. 减少页表项所占字节数 D. 减少页表所占的连续内存空间", "answer_label": "D", "answer_explain": "多级页表不仅不会加快地址的变换速度，还会因为增加更多的查表过程，使地址变换速度减慢； 也不会减少缺页中断的次数，相反，若访问过程中多级的页表都不在内存中，则会大大增加缺页的 次数，并不会减少页表项所占的字节数，而多级页表能够减少页表所占的连续内存空间，即当页表 太大时，将页表再分级，把每张页表控制在一页之内，减少页表所占的连续内存空间。", "answer": "D || 解析：多级页表不仅不会加快地址的变换速度，还会因为增加更多的查表过程，使地址变换速度减慢； 也不会减少缺页中断的次数，相反，若访问过程中多级的页表都不在内存中，则会大大增加缺页的 次数，并不会减少页表项所占的字节数，而多级页表能够减少页表所占的连续内存空间，即当页表 太大时，将页表再分级，把每张页表控制在一页之内，减少页表所占的连续内存空间。"}
{"id": "389", "type": "单项选择题", "question": "66.【2016统考真题】某进程的段表内容如下所示。 段号 0 1 2 访问段号为2、段内地址为400的逻辑地址时，进行地址转换的结果是( ) A. 段缺失异常 B.得到内存地址4400 C. 越权异常 D. 越界异常", "answer_label": "D", "answer_explain": "分段系统的逻辑地址A 到物理地址E 之间的地址变换过程如图3.16所示。\n①从逻辑地址A 中取出前几位为段号S,   后几位为段内偏移量 W,  注意段式存储管理的题 目中，逻辑地址一般以二进制数给出，而页式存储管理的题目中，逻辑地址一般以十进 制数给出，读者要注意具体问题具体分析。\n②比较段号S 和段表长度M,  若 S≥M,    则产生越界异常，否则继续执行。\n③在段表中查询段号对应的段表项，段号S 对应的段表项地址=段表始址F+    段号S× 段 表项长度。取出段表项中该段的段长C,   若 W≥C,    则产生越界中断，否则继续执行。\n④取出段表项中该段的基址b,  计算E=b+W,      用得到的物理地址E 去访问内存。\n题目中段号为2的段长为300,小于段内地址400,因此发生越界异常，选项D 正确。", "answer": "D || 解析：分段系统的逻辑地址A 到物理地址E 之间的地址变换过程如图3.16所示。\n①从逻辑地址A 中取出前几位为段号S,   后几位为段内偏移量 W,  注意段式存储管理的题 目中，逻辑地址一般以二进制数给出，而页式存储管理的题目中，逻辑地址一般以十进 制数给出，读者要注意具体问题具体分析。\n②比较段号S 和段表长度M,  若 S≥M,    则产生越界异常，否则继续执行。\n③在段表中查询段号对应的段表项，段号S 对应的段表项地址=段表始址F+    段号S× 段 表项长度。取出段表项中该段的段长C,   若 W≥C,    则产生越界中断，否则继续执行。\n④取出段表项中该段的基址b,  计算E=b+W,      用得到的物理地址E 去访问内存。\n题目中段号为2的段长为300,小于段内地址400,因此发生越界异常，选项D 正确。"}
{"id": "390", "type": "单项选择题", "question": "67.【 2 0 1 7 统 考 真 题 】 某 计 算 机 按 字 节 编 址 ， 其 动 态 分 区 内 存 管 理 采 用 最 佳 适 应 算 法 ， 每 次 分 配 和 回 收 内 存 后都对空闲分区链重新排序。当前空闲分区信息如下表所示。 回 收 始 址 为 6 0K 、 大 小 为 1 4 0KB 的 分 区 后 ， 系 统 中 空 闲 分 区 的 数 量 、 空 闲 分 区 链 第 一 个 分 区 的 始 址 和 大小分别是() A.3 、20K 、380KB B.3 、500K、80KB C.4 、20K、180KB D.4 、500K、80KB", "answer_label": "B", "answer_explain": "回收始址为60K、大小为140KB 的分区时，它与表中第一个分区和第四个分区合并，成为 始址为20K、大小为380KB的分区，剩余3个空闲分区。在回收内存后，算法会对空闲分区链按 分区大小由小到大进行排序，表中的第二个分区排第一。", "answer": "B || 解析：回收始址为60K、大小为140KB 的分区时，它与表中第一个分区和第四个分区合并，成为 始址为20K、大小为380KB的分区，剩余3个空闲分区。在回收内存后，算法会对空闲分区链按 分区大小由小到大进行排序，表中的第二个分区排第一。"}
{"id": "391", "type": "单项选择题", "question": "68.【2019统考真题】在分段存储管理系统中，用共享段表描述所有被共享的段。若进程 P₁ 和 P₂ 共享段 S, 则下列叙述中，错误的是( ) A. 在物理内存中仅保存一份段S 的内容 B. 段 S 在 P₁ 和 P₂ 中应该具有相同的段号 C.P₁ 和 P₂ 共享段S 在共享段表中的段表项 D.P₁ 和 P₂ 都不再使用段S 时才回收段S 所占的内存空间", "answer_label": "B", "answer_explain": "段的共享是通过两个作业的段表中相应表项指向被共享的段的同一个物理副本来实现的，因此 在内存中仅保存一份段S 的内容，选项 A 正确。段S 对进程 P₁ 、P₂ 来说，使用位置可能不同，所 以在不同进程中的逻辑段号可能不同，选项B 错误。段表项存放的是段的物理地址(包括段始址和 段长度),对共享段S 来说物理地址唯一，选项C 正确。为了保证进程可以顺利使用段S,  段 S 必 须确保在没有任何进程使用它(可在段表项中设置共享进程计数)后才能被删除，选项D 正确。", "answer": "B || 解析：段的共享是通过两个作业的段表中相应表项指向被共享的段的同一个物理副本来实现的，因此 在内存中仅保存一份段S 的内容，选项 A 正确。段S 对进程 P₁ 、P₂ 来说，使用位置可能不同，所 以在不同进程中的逻辑段号可能不同，选项B 错误。段表项存放的是段的物理地址(包括段始址和 段长度),对共享段S 来说物理地址唯一，选项C 正确。为了保证进程可以顺利使用段S,  段 S 必 须确保在没有任何进程使用它(可在段表项中设置共享进程计数)后才能被删除，选项D 正确。"}
{"id": "392", "type": "单项选择题", "question": "69.【2019统考真题】某计算机主存按字节编址，采用二级分页存储管理，地址结构如下： 虚拟地址20501225H 对应的页目录号、页号分别是( ) A.081H,101H B.081H,401H C.201H,101H D.201H,401H", "answer_label": "A", "answer_explain": "题中给出的是十六进制地址，首先将它转化为二进制地址，然后用二进制地址去匹配题中对 应的地址结构。转换为二进制地址和地址结构的对应关系如下图所示。前10位、11～20位、21～32位分别对应页目录号、页号和页内偏移。把页目录号、页号单 独拿出，转换为十六进制时缺少的位数在高位补零，000010000001,000100000001分别对应 081H,101H,      选项 A 正确。", "answer": "A || 解析：题中给出的是十六进制地址，首先将它转化为二进制地址，然后用二进制地址去匹配题中对 应的地址结构。转换为二进制地址和地址结构的对应关系如下图所示。前10位、11～20位、21～32位分别对应页目录号、页号和页内偏移。把页目录号、页号单 独拿出，转换为十六进制时缺少的位数在高位补零，000010000001,000100000001分别对应 081H,101H,      选项 A 正确。"}
{"id": "393", "type": "单项选择题", "question": "70.【2019统考真题】在下列动态分区分配算法中，最容易产生内存碎片的是() A. 首次适应算法 B. 最坏适应算法 C. 最佳适应算法 D. 循环首次适应算法", "answer_label": "C", "answer_explain": "最佳适应算法总是匹配与当前大小要求最接近的空闲分区，但是大多数情况下空闲分区的大 小不可能完全和当前要求的大小相等，几乎每次分配内存都会产生很小的难以利用的内存块，所 以最佳适应算法最容易产生最多的内存碎片。", "answer": "C || 解析：最佳适应算法总是匹配与当前大小要求最接近的空闲分区，但是大多数情况下空闲分区的大 小不可能完全和当前要求的大小相等，几乎每次分配内存都会产生很小的难以利用的内存块，所 以最佳适应算法最容易产生最多的内存碎片。"}
{"id": "394", "type": "单项选择题", "question": "71. 【2021统考真题】在采用二级页表的分页系统中，CPU 页表基址寄存器中的内容是( ) A. 当前进程的一级页表的起始虚拟地址 B. 当前进程的一级页表的起始物理地址 C. 当前进程的二级页表的起始虚拟地址 D. 当前进程的二级页表的起始物理地址", "answer_label": "B", "answer_explain": "在多级页表中，页表基址寄存器存放的是顶级页表的起始物理地址，所以存放的是一级页表 的起始物理地址。", "answer": "B || 解析：在多级页表中，页表基址寄存器存放的是顶级页表的起始物理地址，所以存放的是一级页表 的起始物理地址。"}
{"id": "395", "type": "单项选择题", "question": "72. 【2023统考真题】进程 R 和 S 共享数据 data, 若 data 在 R 和 S 中所在页的页号分别为p1 和 p2, 两个页 所对应的页框号分别为f1 和 f2, 则下列叙述中，正确的是( ) 【微信公 A.p1 和 p2 一定相等，f1 和 f2 一定相等 B.p1 和 p2 一定相等，f1 和 f2 不一定相等 C.p1 和p2 不一定相等，f1 和 f2 一定相等 D.p1 和 p2 不一定相等，f1 和 f2 不一定相等", "answer_label": "C", "answer_explain": "进程 R 和 S 共享数据data,   说明它们都映射了同一个共享内存段，于是这个段在物理内存中 的位置(页框号)必然相同，但这两个段在不同进程的地址空间中的位置(页号)可以不同。因 此，pl  和 p2 不一定相等，fl  和f2 一定相等。", "answer": "C || 解析：进程 R 和 S 共享数据data,   说明它们都映射了同一个共享内存段，于是这个段在物理内存中 的位置(页框号)必然相同，但这两个段在不同进程的地址空间中的位置(页号)可以不同。因 此，pl  和 p2 不一定相等，fl  和f2 一定相等。"}
{"id": "396", "type": "单项选择题", "question": "73. 【2024统考真题】下列算法中，每次回收分区时仅合并大小相等的空闲分区的是( ) A. 伙伴算法 B. 最佳适应算法 C. 最坏适应算法 D. 首次适应算法 3.2虚拟内存管理", "answer_label": "A", "answer_explain": "伙伴算法的一次回收过程可能要进行多次合并。例如，当回收大小为2'的空闲分区时，若之 前已存在一个大小为2'的空闲分区(这两个分区称为一对伙伴),则将其与伙伴分区合并成大小 为2+¹的空闲分区；合并后，若还存在一个大小为2+¹的空闲分区，则继续与其伙伴分区合并成 大小为2'+2的空闲分区，以此类推。综上所述，伙伴算法每次回收分区时，仅合并大小相等的空 闲分区，选项A 正确。", "answer": "A || 解析：伙伴算法的一次回收过程可能要进行多次合并。例如，当回收大小为2'的空闲分区时，若之 前已存在一个大小为2'的空闲分区(这两个分区称为一对伙伴),则将其与伙伴分区合并成大小 为2+¹的空闲分区；合并后，若还存在一个大小为2+¹的空闲分区，则继续与其伙伴分区合并成 大小为2'+2的空闲分区，以此类推。综上所述，伙伴算法每次回收分区时，仅合并大小相等的空 闲分区，选项A 正确。"}
{"id": "397", "type": "单项选择题", "question": "1. 请求分页存储管理中，若把页面尺寸增大一倍而且可容纳的最大页数不变，则在程序顺序执行时缺页中 断次数会( ) A. 增加 B. 减少 C. 不变 D. 可能增加也可能减少", "answer_label": "B", "answer_explain": "对于顺序执行程序，缺页中断的次数等于其访问的页帧数。因为页面尺寸增大，存放程序需 要的页帧数就减少，所以缺页中断的次数也会减少。", "answer": "B || 解析：对于顺序执行程序，缺页中断的次数等于其访问的页帧数。因为页面尺寸增大，存放程序需 要的页帧数就减少，所以缺页中断的次数也会减少。"}
{"id": "398", "type": "单项选择题", "question": "2. 进程在执行中发生了缺页中断，经操作系统处理后，应让其执行( )指令。 A. 被中断的前一条 B. 被中断的那一条 C. 被中断的后一条 D. 启动时的第一条", "answer_label": "B", "answer_explain": "缺页中断是访存指令引起的，说明所要访问的页面不在内存中，进行缺页中断处理并调入所 要访问的页后，访存指令显然应该重新执行。", "answer": "B || 解析：缺页中断是访存指令引起的，说明所要访问的页面不在内存中，进行缺页中断处理并调入所 要访问的页后，访存指令显然应该重新执行。"}
{"id": "399", "type": "单项选择题", "question": "3. 虚拟存储技术是( ) A. 补充内存物理空间的技术 B. 补充内存逻辑空间的技术 C. 补充外存空间的技术 D. 扩充输入/输出缓冲区的技术", "answer_label": "B", "answer_explain": "虚拟存储技术并未实际扩充内存、外存，而是采用相关技术相对地扩充主存。", "answer": "B || 解析：虚拟存储技术并未实际扩充内存、外存，而是采用相关技术相对地扩充主存。"}
{"id": "400", "type": "单项选择题", "question": "4. 下列关于虚拟存储器的论述中，正确的是( ) A.作业在运行前，必须全部装入内存，且在运行过程中也一直驻留内存 B. 作业在运行前，不必全部装入内存，且在运行过程中也不必一直驻留内存 C. 作业在运行前，不必全部装入内存，但在运行过程中必须一直驻留内存 D. 作业在运行前，必须全部装入内存，但在运行过程中不必一直驻留内存", "answer_label": "B", "answer_explain": "在非虚拟存储器中，作业必须全部装入内存且在运行过程中也一直驻留内存；在虚拟存储器 中，作业不必全部装入内存且在运行过程中也不用一直驻留内存，这是两者的主要区别之一。", "answer": "B || 解析：在非虚拟存储器中，作业必须全部装入内存且在运行过程中也一直驻留内存；在虚拟存储器 中，作业不必全部装入内存且在运行过程中也不用一直驻留内存，这是两者的主要区别之一。"}
{"id": "401", "type": "单项选择题", "question": "5. 以下不属于虚拟内存特征的是( ) A. 一次性 B. 多次性 C. 对换性 D. 离散性", "answer_label": "A", "answer_explain": "多次性、对换性和离散性是虚拟内存的特征，一次性则是传统存储系统的特征。", "answer": "A || 解析：多次性、对换性和离散性是虚拟内存的特征，一次性则是传统存储系统的特征。"}
{"id": "402", "type": "单项选择题", "question": "6. 为使虚存系统有效地发挥其预期的作用，所运行的程序应具有的特性是( ) A. 该程序不应含有过多的I/O 操作 B. 该程序的大小不应超过实际的内存容量 C. 该程序应具有较好的局部性 D. 该程序的指令相关性不应过多", "answer_label": "C", "answer_explain": "虚拟存储技术基于程序的局部性原理。局部性越好，虚拟存储系统越能更好地发挥作用。", "answer": "C || 解析：虚拟存储技术基于程序的局部性原理。局部性越好，虚拟存储系统越能更好地发挥作用。"}
{"id": "403", "type": "单项选择题", "question": "7. ( )是请求分页存储管理方式和基本分页存储管理方式的区别。 A. 地址重定向 B. 不必将作业全部装入内存 C. 采用快表技术 D. 不必将作业装入连续区域", "answer_label": "B", "answer_explain": "请求分页存储管理方式和基本分页存储管理方式的区别是，前者采用虚拟技术，因此开始运 行时，不必将作业全部一次性装入内存，而后者不是。", "answer": "B || 解析：请求分页存储管理方式和基本分页存储管理方式的区别是，前者采用虚拟技术，因此开始运 行时，不必将作业全部一次性装入内存，而后者不是。"}
{"id": "404", "type": "单项选择题", "question": "8. 通常所说的“存储保护”的基本含义是( ) A. 防止存储器硬件受损 B. 防止程序在内存丢失 C. 防止程序间相互越界访问 D. 防止程序源码被人偷窃", "answer_label": "C", "answer_explain": "通常所说的“存储保护”的基本含义是防止程序间相互越界访问。存储保护可以保证多个程 序在共享主存时不相互覆盖或非法访问，从而保证系统的正常运行和安全性。", "answer": "C || 解析：通常所说的“存储保护”的基本含义是防止程序间相互越界访问。存储保护可以保证多个程 序在共享主存时不相互覆盖或非法访问，从而保证系统的正常运行和安全性。"}
{"id": "405", "type": "单项选择题", "question": "9. 在页式虚拟存储管理中，程序的链接方式必然是( ) A. 静态链接 B. 装入时动态链接 C.运行时动态链接 D. 不确定哪种链接方式", "answer_label": "C", "answer_explain": "在页式虚拟存储管理中，程序的逻辑地址和物理地址是不一致的，而且物理地址是在程序运 行时才确定的，因此，程序的链接也必须在运行时进行，不能在装入时或编译时进行。运行时动 态链接是一种在程序执行过程中，根据需要动态地将目标模块装入内存并进行链接的技术。", "answer": "C || 解析：在页式虚拟存储管理中，程序的逻辑地址和物理地址是不一致的，而且物理地址是在程序运 行时才确定的，因此，程序的链接也必须在运行时进行，不能在装入时或编译时进行。运行时动 态链接是一种在程序执行过程中，根据需要动态地将目标模块装入内存并进行链接的技术。"}
{"id": "406", "type": "单项选择题", "question": "10. 虚拟地址指的是() A. 程序访问内存时使用的地址 B. 访问内存总线上的地址 C. 内存与磁盘交换数据时使用的地址 D. 寄存器的地址", "answer_label": "A", "answer_explain": "程序访问内存时使用的是虚拟地址，操作系统负责将其转换为物理地址。", "answer": "A || 解析：程序访问内存时使用的是虚拟地址，操作系统负责将其转换为物理地址。"}
{"id": "407", "type": "单项选择题", "question": "11. 在采用页式虚拟存储管理和固定分配局部置换策略的系统中，数组采用行优先存储，页框大小为512B。 某个进程中有如下代码段(该代码段已提前读入内存): 系统为该进程分配的数据区只有1个页框，则执行该代码会发生( )次缺页中断。 A.1 B.2 C.128 D.16384", "answer_label": "D", "answer_explain": "数组大小为128×128,int 型数据占4B,  一个页框可以存放一行数据。当访问a[0][0]时，发 生第一次缺页中断，此时调入第一行数据；之后访问a[1][0],   又发生缺页中断。每访问一个元素， 都发生一次缺页中断，共有128×128=16384个元素，因此共发生16384次缺页中断。", "answer": "D || 解析：数组大小为128×128,int 型数据占4B,  一个页框可以存放一行数据。当访问a[0][0]时，发 生第一次缺页中断，此时调入第一行数据；之后访问a[1][0],   又发生缺页中断。每访问一个元素， 都发生一次缺页中断，共有128×128=16384个元素，因此共发生16384次缺页中断。"}
{"id": "408", "type": "单项选择题", "question": "12. 假设某个进程分配有4个页框，每个页框大小为128个字(一个整数占一个字)。进程的代码段正好可 以存放在一页中，而且总是占用0号页框。数据会在其他3个页框中换进或换出。数组X 为按行优先 存储，则执行该进程会发生()次缺页中断。 A.32 B.1024 C.2048 D .其他都不对", "answer_label": "C", "answer_explain": "数组大小为64×64,一个页框可以存放两行数据。当访问X[0][0]时，发生第一次缺页中断， 此时调入前两行数据，之后访问 X[1][0],   不发生缺页中断，因为已被调入内存；当访问 X[2][0]  时，又发生缺页中断；同理，访问X[3][0]时不发生缺页中断。不难发现，每访问两个元素就发生 一次缺页中断，共有64×64=4096个元素，因此共发生2048次缺页中断。", "answer": "C || 解析：数组大小为64×64,一个页框可以存放两行数据。当访问X[0][0]时，发生第一次缺页中断， 此时调入前两行数据，之后访问 X[1][0],   不发生缺页中断，因为已被调入内存；当访问 X[2][0]  时，又发生缺页中断；同理，访问X[3][0]时不发生缺页中断。不难发现，每访问两个元素就发生 一次缺页中断，共有64×64=4096个元素，因此共发生2048次缺页中断。"}
{"id": "409", "type": "单项选择题", "question": "13. 在配置了TLB 的页式虚拟存储管理的系统中，假设TLB 的命中率约为75%,忽略访问TLB 的时间，并 且使用二级页表，则每次存取的平均访存次数是() A.1.25 B.1.5 C.1.75 D.2", "answer_label": "B", "answer_explain": "若TLB 命中，则访问TLB 就能得到物理地址；若TLB 未命中，则需要2次访存，依次访问 一级页表和二级页表，才能得到物理地址，最后用物理地址在内存中存取数据。平均访存次数= TLB 命中率×1+(1-TLB 命中率)×3=0.75×1+(1-0.75)×3=1.5。", "answer": "B || 解析：若TLB 命中，则访问TLB 就能得到物理地址；若TLB 未命中，则需要2次访存，依次访问 一级页表和二级页表，才能得到物理地址，最后用物理地址在内存中存取数据。平均访存次数= TLB 命中率×1+(1-TLB 命中率)×3=0.75×1+(1-0.75)×3=1.5。"}
{"id": "410", "type": "单项选择题", "question": "14.下面关于请求页式系统的页面调度算法中，说法错误的是( ) A. 一个好的页面调度算法应减少和避免抖动现象 B.FIFO 算法实现简单，选择最先进入主存储器的页面调出 C.LRU 算法基于局部性原理，首先调出最近一段时间内最长时间未被访问过的页面 D.CLOCK 算法首先调出一段时间内被访问次数多的页面", "answer_label": "D", "answer_explain": "CLOCK 算法选择将最近未使用的页面置换出去，因此也称NRU 算法。", "answer": "D || 解析：CLOCK 算法选择将最近未使用的页面置换出去，因此也称NRU 算法。"}
{"id": "411", "type": "单项选择题", "question": "15. 考虑页面置换算法，系统有 m 个物理块供调度，初始时全空，页面引用串长度为p, 包含了n 个不同的页 号，无论用什么算法，缺页次数不会少于( ) A.m B.p C.n D.min(m,n)", "answer_label": "C", "answer_explain": "无论采用什么页面置换算法，每种页面第一次访问时不可能在内存中，必然发生缺页，所以 缺页次数大于或等于n。", "answer": "C || 解析：无论采用什么页面置换算法，每种页面第一次访问时不可能在内存中，必然发生缺页，所以 缺页次数大于或等于n。"}
{"id": "412", "type": "单项选择题", "question": "16. 在请求分页存储管理中，若采用 FIFO页面淘汰算法，则当可供分配的页帧数增加时，缺页中断的次数 ( ) A. 减少 B. 增加 C.无影响 D. 可能增加也可能减少", "answer_label": "D", "answer_explain": "请求分页存储管理中，若采用 FIFO  页面淘汰算法，可能产生当驻留集增大时页故障数不 减反增的Belady 异常。然而，还有另外一种情况。例如，页面序列为1,2,3,1,2,3,当页帧数 为2时产生6次缺页中断，当页帧数为3时产生3次缺页中断。所以在请求分页存储管理中， 若采用 FIFO  页面淘汰算法，则当可供分配的页帧数增加时，缺页中断的次数可能增加，也可 能减少。", "answer": "D || 解析：请求分页存储管理中，若采用 FIFO  页面淘汰算法，可能产生当驻留集增大时页故障数不 减反增的Belady 异常。然而，还有另外一种情况。例如，页面序列为1,2,3,1,2,3,当页帧数 为2时产生6次缺页中断，当页帧数为3时产生3次缺页中断。所以在请求分页存储管理中， 若采用 FIFO  页面淘汰算法，则当可供分配的页帧数增加时，缺页中断的次数可能增加，也可 能减少。"}
{"id": "413", "type": "单项选择题", "question": "17. 设主存容量为1MB,外存容量为400MB,计算机系统的地址寄存器有32位，那么虚拟存储器的最大容 量 是 ( ) A.1MB B.401MB C.1MB+2³²MB D.2³2B", "answer_label": "D", "answer_explain": "进程的虚拟地址空间寻址由系统的地址结构决定，这就决定了虚拟存储器的最大容量，而与 主存和外存的容量没有必然联系，因此虚拟地址空间为2³²B。比如，在64位系统环境下，虚拟 存储技术使得进程可用地址空间达2⁶⁴B,  但外存显然是达不到这个大小的。", "answer": "D || 解析：进程的虚拟地址空间寻址由系统的地址结构决定，这就决定了虚拟存储器的最大容量，而与 主存和外存的容量没有必然联系，因此虚拟地址空间为2³²B。比如，在64位系统环境下，虚拟 存储技术使得进程可用地址空间达2⁶⁴B,  但外存显然是达不到这个大小的。"}
{"id": "414", "type": "单项选择题", "question": "18. 一台机器有32位虚拟地址和16位物理地址，若页面大小为512B,采用单级页表，则页表共有( )个页 表 项 。 A.2⁷ B.216 C.2² D.2³2", "answer_label": "C", "answer_explain": "页面大小为512B,  页内偏移量占9位，虚拟地址占32位，页号占23位，因此页表共有2³ 个页表项。页表项数量与物理地址的位数没有必然关系。", "answer": "C || 解析：页面大小为512B,  页内偏移量占9位，虚拟地址占32位，页号占23位，因此页表共有2³ 个页表项。页表项数量与物理地址的位数没有必然关系。"}
{"id": "415", "type": "单项选择题", "question": "19. 在某分页存储管理的系统中，逻辑地址为16位，页面大小为1KB, 第0,1,2,3号页依次存放在3,7,11, 10号页框中，则逻辑地址0A6FH 对应的物理地址为()【 研七七】 A.1E6FH B.2E6FH C.DE6FH D.EE6FH", "answer_label": "B", "answer_explain": "页面大小为1KB,  页内偏移量占10位，页号占6位，将0A6FH 展开为二进制，得到逻辑页 号为2(000010),存放在11号(001011)页框中，拼接上页内偏移量得到物理地址为 2E6FH。", "answer": "B || 解析：页面大小为1KB,  页内偏移量占10位，页号占6位，将0A6FH 展开为二进制，得到逻辑页 号为2(000010),存放在11号(001011)页框中，拼接上页内偏移量得到物理地址为 2E6FH。"}
{"id": "416", "type": "单项选择题", "question": "20. 在决定页面大小时，选择较小的页面是为了减少( ) A. 页表大小 B. 缺页次数 C.I/O 开销 D. 页内碎片", "answer_label": "D", "answer_explain": "页面越小，页表项数量越多，页表所占的空间就更大；页面越小，缺页率越高；页面越小， 换入换出的次数就越多，I/O 操作更频繁。页面越小，页内浪费的空间越少，内存利用率越高。", "answer": "D || 解析：页面越小，页表项数量越多，页表所占的空间就更大；页面越小，缺页率越高；页面越小， 换入换出的次数就越多，I/O 操作更频繁。页面越小，页内浪费的空间越少，内存利用率越高。"}
{"id": "417", "type": "单项选择题", "question": "21. 某虚拟存储器系统采用页式内存管理，使用LRU 页面替换算法，考虑页面访问地址序列1,8,1,7,8,2, 7,2,1,8,3,8,2,1,3,1,7,1,3,7。假定内存容量为4个页面，开始时是空的，则页面失效次数是( ) A.4 B.5 C.6 D.7", "answer_label": "C", "answer_explain": "利用LRU 置换算法时的置换如下图所示。\n分别在访问第1个、第2个、第4个、第6个、第11个、第17个页面时产生中断，共产生 6次中断。", "answer": "C || 解析：利用LRU 置换算法时的置换如下图所示。\n分别在访问第1个、第2个、第4个、第6个、第11个、第17个页面时产生中断，共产生 6次中断。"}
{"id": "418", "type": "单项选择题", "question": "22. 导致LRU 算法实现起来耗费高的原因是() A. 需要硬件的特殊支持 B. 需要特殊的中断处理程序 C. 需要在页表中标明特殊的页类型 D. 需要对所有的页进行排序", "answer_label": "D", "answer_explain": "LRU 算法需要对所有页最近一次被访问的时间进行记录，查找时间最久的进行替换，这涉及   排序，对置换算法而言，开销太大。为此需要在页表项中增加LRU 位，选项A 可视为“耗费高” 这一结果，选项D 才是造成选项A 的原因。", "answer": "D || 解析：LRU 算法需要对所有页最近一次被访问的时间进行记录，查找时间最久的进行替换，这涉及   排序，对置换算法而言，开销太大。为此需要在页表项中增加LRU 位，选项A 可视为“耗费高” 这一结果，选项D 才是造成选项A 的原因。"}
{"id": "419", "type": "单项选择题", "question": "23. 在虚拟存储器系统的页表项中，决定是否会发生页故障的是( ) A. 有效位 B. 修改位 C. 页类型 D. 保护码", "answer_label": "A", "answer_explain": "页表项中的合法位信息显示本页面是否在内存中，即决定了是否会发生页面故障。", "answer": "A || 解析：页表项中的合法位信息显示本页面是否在内存中，即决定了是否会发生页面故障。"}
{"id": "420", "type": "单项选择题", "question": "24. 在页面置换策略中，( )策略可能引起抖动 A.FIFO B.LRU C. 没有一种 D. 所有", "answer_label": "D", "answer_explain": "抖动是进程的页面置换过程中，频繁的页面调度(缺页中断)行为，所有的页面调度策略都 不可能完全避免抖动。", "answer": "D || 解析：抖动是进程的页面置换过程中，频繁的页面调度(缺页中断)行为，所有的页面调度策略都 不可能完全避免抖动。"}
{"id": "421", "type": "单项选择题", "question": "25. 虚拟存储管理系统的基础是程序的()理论。 A. 动态性 B.虚拟性 C. 局部性 D. 全局性", "answer_label": "C", "answer_explain": "基于局部性原理：当程序装入时，不必将其全部读入内存，而只需将当前需要执行的部分页 或段读入内存，就可让程序开始执行。在程序执行过程中，若需执行的指令或访问的数据尚未在 内存(称为缺页或缺段)中，则由处理器通知操作系统将相应的页或段调入内存，然后继续执行 程序。由于程序具有局部性，虚拟存储管理在扩充逻辑地址空间的同时，对程序执行时内存调换 的代价很小。", "answer": "C || 解析：基于局部性原理：当程序装入时，不必将其全部读入内存，而只需将当前需要执行的部分页 或段读入内存，就可让程序开始执行。在程序执行过程中，若需执行的指令或访问的数据尚未在 内存(称为缺页或缺段)中，则由处理器通知操作系统将相应的页或段调入内存，然后继续执行 程序。由于程序具有局部性，虚拟存储管理在扩充逻辑地址空间的同时，对程序执行时内存调换 的代价很小。"}
{"id": "422", "type": "单项选择题", "question": "26. 请求分页存储管理的主要特点是() A. 消除了页内零头 B. 扩充了内存 C. 便于动态链接 D. 便于信息共享", "answer_label": "B", "answer_explain": "请求分页存储管理就是为了解决内存容量不足而使用的方法，它基于局部性原理实现了以时 间换取空间的目的。它的主要特点自然是间接扩充了内存。", "answer": "B || 解析：请求分页存储管理就是为了解决内存容量不足而使用的方法，它基于局部性原理实现了以时 间换取空间的目的。它的主要特点自然是间接扩充了内存。"}
{"id": "423", "type": "单项选择题", "question": "27. 在请求分页存储管理的页表中增加了若干项信息，其中修改位和访问位供( )参考。 A. 分配页面 B. 调入页面 C. 置换算法 D. 程序访问", "answer_label": "C", "answer_explain": "当需要置换页面时，置换算法根据修改位和访问位选择调出内存的页面。", "answer": "C || 解析：当需要置换页面时，置换算法根据修改位和访问位选择调出内存的页面。"}
{"id": "424", "type": "单项选择题", "question": "28. 下列关于驻留集和工作集的表述中，正确的是( ) I. 驻留集是进程已装入内存的页面的集合 II. 工作集是某段时间间隔内，进程运行所需要访问页面的集合 III.工作集是驻留集的子集 A.I B.I 、II C.II 、III D.I 、II 、III", "answer_label": "B", "answer_explain": "驻留集是指分配给进程的物理页面的集合。工作集是指在某段时间内，进程实际要访问的页 面的集合。工作集不一定是驻留集的子集，因为有些工作集中的页面可能还未被调入内存，或已 被换出内存。只有当工作集完全包含在驻留集中时，才能保证进程不发生缺页中断。", "answer": "B || 解析：驻留集是指分配给进程的物理页面的集合。工作集是指在某段时间内，进程实际要访问的页 面的集合。工作集不一定是驻留集的子集，因为有些工作集中的页面可能还未被调入内存，或已 被换出内存。只有当工作集完全包含在驻留集中时，才能保证进程不发生缺页中断。"}
{"id": "425", "type": "单项选择题", "question": "29. 在配置了TLB 的页式虚拟存储管理的系统中，假设访问内存需要1μs,查询 TLB 需要0.2 μs 。已知 TLB 和内存的访问是串行的，请问在 TLB 命中率为85%和50%时，系统的平均访问时间分别是多少?( ) A.1.5μs,1.8μs B.1.35μs,1.7μs C.1.6μs,1.7μs D.1.35μs,1.8,μs", "answer_label": "B", "answer_explain": "平均访存时间=命中率×快表访问时间+不命中率×(快表访问时间+页表访问时间)+内 存访问时间。当TLB 命中率为85%时，平均访存时间=0.85×0.2+0.15×(1+0.2)+1=1.35μs。当 TLB 命中率为50%时，平均访存时间=0.5×0.2+0.5×(1+0.2)+1=1.7 μs。", "answer": "B || 解析：平均访存时间=命中率×快表访问时间+不命中率×(快表访问时间+页表访问时间)+内 存访问时间。当TLB 命中率为85%时，平均访存时间=0.85×0.2+0.15×(1+0.2)+1=1.35μs。当 TLB 命中率为50%时，平均访存时间=0.5×0.2+0.5×(1+0.2)+1=1.7 μs。"}
{"id": "426", "type": "单项选择题", "question": "30. 下列选项中，( )不是页面换进换出效率的影响因素。 A. 页面置换算法 B. 已修改页面写回磁盘的频率 C. 磁盘数据读入内存的频率 D.CPU 与内存交换的速度", "answer_label": "D", "answer_explain": "页面置换算法影响进程运行过程中的缺页率，从而影响页面换进换出的开销。若建立一个已 修改页面的链表，则对每个要被换出的页面(已修改),系统可暂不把它们写回磁盘，而等被换 出页面数量达到一定值时，才集中写回磁盘，从而减少页面换出的开销。当已修改页面链表中暂 未写回磁盘的页面再使用时，就不需从磁盘中调入，而直接从该链表上获取，从而减少页面换进 的开销。CPU 与内存交换的速度，不是页面换进换出效率的影响因素。", "answer": "D || 解析：页面置换算法影响进程运行过程中的缺页率，从而影响页面换进换出的开销。若建立一个已 修改页面的链表，则对每个要被换出的页面(已修改),系统可暂不把它们写回磁盘，而等被换 出页面数量达到一定值时，才集中写回磁盘，从而减少页面换出的开销。当已修改页面链表中暂 未写回磁盘的页面再使用时，就不需从磁盘中调入，而直接从该链表上获取，从而减少页面换进 的开销。CPU 与内存交换的速度，不是页面换进换出效率的影响因素。"}
{"id": "427", "type": "单项选择题", "question": "31. 允许进程在所有页框中选择一个页面替换，而不管该页框是否已分配给其他进程的置换方法是() A. 局部置换 B. 全局置换 C. 进程外置换 D. 进程内置换", "answer_label": "B", "answer_explain": "这种置换方法是全局置换，它不受驻留集大小的限制，可以从任何页框中选择一个页面置换。", "answer": "B || 解析：这种置换方法是全局置换，它不受驻留集大小的限制，可以从任何页框中选择一个页面置换。"}
{"id": "428", "type": "单项选择题", "question": "32. 在页面置换算法中，存在Belady 现象的算法是( ) A. 最佳页面置换算法(OPT) B. 先进先出置换算法(FIFO) C. 最近最久未使用算法(LRU) D. 最近未使用算法(NRU)", "answer_label": "B", "answer_explain": "FIFO 是队列类算法，有Belady 现象；选项C 、D 均为堆栈类算法，理论上可以证明不会出 现Belady现象。", "answer": "B || 解析：FIFO 是队列类算法，有Belady 现象；选项C 、D 均为堆栈类算法，理论上可以证明不会出 现Belady现象。"}
{"id": "429", "type": "单项选择题", "question": "33. 页式虚拟存储管理的主要特点是( ) A. 不要求将作业装入主存的连续区域 B. 不要求将作业同时全部装入主存的连续区域 C. 不要求进行缺页中断处理 D. 不要求进行页面置换", "answer_label": "B", "answer_explain": "页式虚拟存储管理的主要特点是，不要求将作业同时全部装入主存的连续区域，一般只装入 10%～30%。不要求将作业装入主存连续区域是所有离散式存储管理(包括页式存储管理)的特 点；页式虚拟存储管理需要进行缺页中断处理和页面置换。", "answer": "B || 解析：页式虚拟存储管理的主要特点是，不要求将作业同时全部装入主存的连续区域，一般只装入 10%～30%。不要求将作业装入主存连续区域是所有离散式存储管理(包括页式存储管理)的特 点；页式虚拟存储管理需要进行缺页中断处理和页面置换。"}
{"id": "430", "type": "单项选择题", "question": "34. 提供虚拟存储技术的存储管理方法有( ) A. 动态分区存储管理 B. 页式存储管理 C. 请求段式存储管理 D. 存储覆盖技术", "answer_label": "C", "answer_explain": "虚拟存储技术是基于页或段从内存的调入/调出实现的，需要有请求机制的支持。", "answer": "C || 解析：虚拟存储技术是基于页或段从内存的调入/调出实现的，需要有请求机制的支持。"}
{"id": "431", "type": "单项选择题", "question": "35.内存映射可以将一个文件映射到进程的虚拟地址空间的某个区域，实现文件磁盘地址和进程虚拟地址 空间的映射关系，下列说法中正确的是( ) A.内存映射文件是将整个文件内容一次性加载到内存中的一种方式 B. 内存映射文件只适用于读取文件，不支持对文件进行写操作 C.内存映射文件可以通过修改内存中的数据来实现对文件的写操作 D. 由于进程的虚拟地址空间是独立的，内存映射文件不支持多进程映射到同一文件", "answer_label": "C", "answer_explain": "内存映射文件将一个文件映射到进程的虚拟地址空间的某个区域，让进程可以按读/写内 存的方式来读/写文件，选项C 正确。内存映射文件不是一次性加载整个文件，而是按需加载 文件的部分，这样既节省空间，又方便处理大文件。虽然进程的虚拟地址空间是独立的，但 操作系统可以通过页表将对应的虚拟地址空间映射到相同的物理内存，很方便实现多个进程 共享同一文件。", "answer": "C || 解析：内存映射文件将一个文件映射到进程的虚拟地址空间的某个区域，让进程可以按读/写内 存的方式来读/写文件，选项C 正确。内存映射文件不是一次性加载整个文件，而是按需加载 文件的部分，这样既节省空间，又方便处理大文件。虽然进程的虚拟地址空间是独立的，但 操作系统可以通过页表将对应的虚拟地址空间映射到相同的物理内存，很方便实现多个进程 共享同一文件。"}
{"id": "432", "type": "单项选择题", "question": "36. 在虚拟分页存储管理系统中，若进程访问的页面不在主存中，且主存中没有可用的空闲帧时，系统正确 的处理顺序为( ) A. 决定淘汰页 → 页面调出 → 缺页中断 → 页面调入 B. 决定淘汰页 → 页面调入 → 缺页中断 → 页面调出 C. 缺页中断 → 决定淘汰页 → 页面调出 → 页面调入 D. 缺页中断 → 决定淘汰页 → 页面调入 → 页面调出", "answer_label": "C", "answer_explain": "根据缺页中断的处理流程，产生缺页中断后，首先去内存寻找空闲物理块，若内存没有空闲 物理块，则使用页面置换算法决定淘汰页面，然后调出该淘汰页面，最后再调入该进程欲访问的 页面。整个流程可归纳为缺页中断→决定淘汰页→页面调出→页面调入。", "answer": "C || 解析：根据缺页中断的处理流程，产生缺页中断后，首先去内存寻找空闲物理块，若内存没有空闲 物理块，则使用页面置换算法决定淘汰页面，然后调出该淘汰页面，最后再调入该进程欲访问的 页面。整个流程可归纳为缺页中断→决定淘汰页→页面调出→页面调入。"}
{"id": "433", "type": "单项选择题", "question": "37. 已知系统为32位实地址，采用48位虚拟地址，页面大小为4KB, 页表项大小为8B。 假设系统使用纯页 式存储，则要采用()级页表，页内偏移()位。 A.3,12 B.3,14 C.4,12 D.4,14", "answer_label": "C", "answer_explain": "页面大小为4KB,  因此页内偏移为12位。系统采用48位虚拟地址，因此虚页号48-12=36 位。采用多级页表时，最高级页表项不能超出一页大小；每页能容纳的页表项数为4KB/8B=512=  2⁹,36/9=4,因此应采用4级页表，最高级页表项正好占据一页空间，所以本题选择选项C。", "answer": "C || 解析：页面大小为4KB,  因此页内偏移为12位。系统采用48位虚拟地址，因此虚页号48-12=36 位。采用多级页表时，最高级页表项不能超出一页大小；每页能容纳的页表项数为4KB/8B=512=  2⁹,36/9=4,因此应采用4级页表，最高级页表项正好占据一页空间，所以本题选择选项C。"}
{"id": "434", "type": "单项选择题", "question": "38. 下列说法中，正确的是( ) I. 先进先出(FIFO) 页面置换算法会产生 Belady 现象 Ⅱ.最近最少使用(LRU) 页面置换算法会产生Belady 现象 Ⅲ.在进程运行时，若其工作集页面都在虚拟存储器内，则能够使该进程有效地运行，否则会出现频繁的 页面调入/调出现象 IV. 在进程运行时，若其工作集页面都在主存储器内，则能够使该进程有效地运行，否则会出现频繁的页 面调入/调出现象 A.I 、III B.I 、IV C.II 、III D.II 、IV", "answer_label": "B", "answer_explain": "FIFO算法可能产生Belady现象，例如页面走向为1,2,3,4,1,2,5,1,2,3,4,5时，当分配3帧时 产生9次缺页中断，分配4帧时产生10次缺页中断，选项I 正确。最近最少使用法不会产生Belady 现象，选项Ⅱ错误。若页面在内存中，则不会产生缺页中断，即不会出现页面的调入/调出，而不是 虚拟存储器(包括作为虚拟内存那部分硬盘),所以选项ⅢI 错误、选项IV 正确。", "answer": "B || 解析：FIFO算法可能产生Belady现象，例如页面走向为1,2,3,4,1,2,5,1,2,3,4,5时，当分配3帧时 产生9次缺页中断，分配4帧时产生10次缺页中断，选项I 正确。最近最少使用法不会产生Belady 现象，选项Ⅱ错误。若页面在内存中，则不会产生缺页中断，即不会出现页面的调入/调出，而不是 虚拟存储器(包括作为虚拟内存那部分硬盘),所以选项ⅢI 错误、选项IV 正确。"}
{"id": "435", "type": "单项选择题", "question": "39. 测得某个采用按需调页策略的计算机系统的部分状态数据为： CPU 利用率为20%,用于交换空间的磁 盘利用率为97.7%,其他设备的利用率为5%。由此判断系统出现异常，这种情况下( )能提高系统性 能。 A. 安装一个更快的硬盘 B. 通过扩大硬盘容量增加交换空间 C.增加运行进程数 D. 加内存条来增加物理空间容量", "answer_label": "D", "answer_explain": "用于交换空间的磁盘利用率已达97.7%,其他设备的利用率为5%,CPU 的利用率为20%, 说明在任务作业不多的情况下交换操作非常频繁，因此判断物理内存严重短缺。", "answer": "D || 解析：用于交换空间的磁盘利用率已达97.7%,其他设备的利用率为5%,CPU 的利用率为20%, 说明在任务作业不多的情况下交换操作非常频繁，因此判断物理内存严重短缺。"}
{"id": "436", "type": "单项选择题", "question": "40. 假定有一个请求分页存储管理系统，测得系统各相关设备的利用率为：CPU 的利用率为10%,磁盘交换 区的利用率为99.7%,其他 I/O 设备的利用率为5%。下面( )措施将可能改进 CPU 的利用率。 I. 增大内存的容量 III. 减少多道程序的度数 V. 使用更快速的磁盘交换区 A.I 、 I 、III 、IV B.I 、III II. 增大磁盘交换区的容量 IV. 增加多道程序的度数 VI. 使用更快速的CPU C.II 、III 、V D.II 、VI", "answer_label": "B", "answer_explain": "选项I 正确：增大内存的容量。增大内存可使每个程序得到更多的页框，能减少缺页率，进 而减少换入/换出过程，可提高CPU 的利用率。选项Ⅱ错误：增大磁盘交换区的容量。因为系统 实际已处于频繁的换入/换出过程中，不是因为磁盘交换区容量不够，因此增大磁盘交换区的容 量无用。选项Ⅲ正确：减少多道程序的度数。可以提高CPU 的利用率，因为从给定的条件知 道磁盘交换区的利用率为99.7%,说明系统现在已经处于频繁的换入/换出过程中，可减少主存 中的程序。选项IV  错误：增加多道程序的度数。系统处于频繁的换入/换出过程中，再增加主 存中的用户进程数，只能导致系统的换入/换出更频繁，使性能更差。选项V 错误：使用更快速 的磁盘交换区。因为系统现在处于频繁的换入/换出过程中，即使采用更快的磁盘交换区，其换\n入/换出频率也不会改变，因此没用。选项VI 错误：使用更快速的CPU 。系统处于频繁的换入/ 换出过程中，CPU 处于空闲状态，利用率不高，提高CPU 的速度无济于事。综上分析：选项I、 III 可以改进 CPU 的利用率。", "answer": "B || 解析：选项I 正确：增大内存的容量。增大内存可使每个程序得到更多的页框，能减少缺页率，进 而减少换入/换出过程，可提高CPU 的利用率。选项Ⅱ错误：增大磁盘交换区的容量。因为系统 实际已处于频繁的换入/换出过程中，不是因为磁盘交换区容量不够，因此增大磁盘交换区的容 量无用。选项Ⅲ正确：减少多道程序的度数。可以提高CPU 的利用率，因为从给定的条件知 道磁盘交换区的利用率为99.7%,说明系统现在已经处于频繁的换入/换出过程中，可减少主存 中的程序。选项IV  错误：增加多道程序的度数。系统处于频繁的换入/换出过程中，再增加主 存中的用户进程数，只能导致系统的换入/换出更频繁，使性能更差。选项V 错误：使用更快速 的磁盘交换区。因为系统现在处于频繁的换入/换出过程中，即使采用更快的磁盘交换区，其换\n入/换出频率也不会改变，因此没用。选项VI 错误：使用更快速的CPU 。系统处于频繁的换入/ 换出过程中，CPU 处于空闲状态，利用率不高，提高CPU 的速度无济于事。综上分析：选项I、 III 可以改进 CPU 的利用率。"}
{"id": "437", "type": "单项选择题", "question": "41. 在请求分页存储管理系统中，为了提高 TLB 命中率，可行的方法是( ) I. 增大TLB 容量 II. 采用多级页表 III. 提高页面大小 IV. 降低页面大小 A.I和II B.I和IV C.I、IⅡ 和III D.II 和III", "answer_label": "A", "answer_explain": "增大TLB 容量可以提高TLB 命中率，因为可以缓存更多的地址映射。采用多级页表对TLB  命中率没有影响。提高页面大小可用较少的页面覆盖更大的地址空间，从而减少页表项，因此可 以提高TLB 命中率。反之，降低页面大小则会降低TLB 命中率。", "answer": "A || 解析：增大TLB 容量可以提高TLB 命中率，因为可以缓存更多的地址映射。采用多级页表对TLB  命中率没有影响。提高页面大小可用较少的页面覆盖更大的地址空间，从而减少页表项，因此可 以提高TLB 命中率。反之，降低页面大小则会降低TLB 命中率。"}
{"id": "438", "type": "单项选择题", "question": "42.【2011统考真题】在缺页处理过程中，操作系统执行的操作可能是( ) I. 修改页表 II. 磁盘 I/O III. 分配页框 A. 仅I、II B. 仅I C. 仅II D.I、Ⅱ 和II", "answer_label": "D", "answer_explain": "缺页中断产生后，需要在内存中找到空闲页框并分配给需要访问的页(可能涉及页面置换), 之后缺页中断处理程序调用设备驱动程序做磁盘 I/O, 将位于外存上的页面调入内存，调入后需 要修改页表，将页表中代表该页是否在内存的标志位(或有效位)置为1,并将物理页框号填入 相应位置，若必要还需修改其他相关表项等。", "answer": "D || 解析：缺页中断产生后，需要在内存中找到空闲页框并分配给需要访问的页(可能涉及页面置换), 之后缺页中断处理程序调用设备驱动程序做磁盘 I/O, 将位于外存上的页面调入内存，调入后需 要修改页表，将页表中代表该页是否在内存的标志位(或有效位)置为1,并将物理页框号填入 相应位置，若必要还需修改其他相关表项等。"}
{"id": "439", "type": "单项选择题", "question": "43.【2011统考真题】当系统发生抖动时，可以采取的有效措施是() I. 撤销部分进程 II. 增加磁盘交换区的容量 III. 提高用户进程的优先级 A. 仅I B. 仅 C. 仅 Ⅲ D.仅I、II", "answer_label": "A", "answer_explain": "在具有对换功能的操作系统中，通常把外存分为文件区和对换区。前者用于存放文件，后者 用于存放从内存换出的进程。抖动现象是指刚刚被换出的页很快又要被访问，为此又要换出其他 页，而该页又很快被访问，如此频繁地置换页面，以致大部分时间都花在页面置换上，导致系统 性能下降。撤销部分进程可以减少所要用到的页面数，防止抖动。对换区大小和进程优先级都与 抖动无关。", "answer": "A || 解析：在具有对换功能的操作系统中，通常把外存分为文件区和对换区。前者用于存放文件，后者 用于存放从内存换出的进程。抖动现象是指刚刚被换出的页很快又要被访问，为此又要换出其他 页，而该页又很快被访问，如此频繁地置换页面，以致大部分时间都花在页面置换上，导致系统 性能下降。撤销部分进程可以减少所要用到的页面数，防止抖动。对换区大小和进程优先级都与 抖动无关。"}
{"id": "440", "type": "单项选择题", "question": "44.【2012统考真题】下列关于虚拟存储器的叙述中，正确的是( ) A. 虚拟存储只能基于连续分配技术 B. 虚拟存储只能基于非连续分配技术 C. 虚拟存储容量只受外存容量的限制 D. 虚拟存储容量只受内存容量的限制", "answer_label": "B", "answer_explain": "当采用连续分配方式时，会使相当一部分内存空间都处于暂时或“永久”的空闲状态，造成 内存资源的严重浪费，也无法从逻辑上扩大内存容量，因此虚拟内存的实现只能建立在离散分配 的内存管理的基础上。有以下三种实现方式：请求分页；请求分段；请求段页式。虚存的实际容 量受外存和内存容量之和限制，虚存的最大容量是由计算机的地址位数决定的。", "answer": "B || 解析：当采用连续分配方式时，会使相当一部分内存空间都处于暂时或“永久”的空闲状态，造成 内存资源的严重浪费，也无法从逻辑上扩大内存容量，因此虚拟内存的实现只能建立在离散分配 的内存管理的基础上。有以下三种实现方式：请求分页；请求分段；请求段页式。虚存的实际容 量受外存和内存容量之和限制，虚存的最大容量是由计算机的地址位数决定的。"}
{"id": "441", "type": "单项选择题", "question": "45.【2013统考真题】若用户进程访问内存时产生缺页，则下列选项中，操作系统可能执行的操作是( ) I. 处理越界错 II. 置换页 III. 分配内存 A.仅I、II B.仅Ⅱ、III C. 仅I、III D.I、IⅡ 和II", "answer_label": "B", "answer_explain": "用户进程访问内存时缺页，会发生缺页中断。发生缺页中断时，系统执行的操作可能是置换 页面或分配内存。越界检查发生在查询页表之前，而此处产生了缺页中断，说明已经正常进行到 查询页表的阶段，系统此时没有产生越界错，因此不会进行越界出错处理。", "answer": "B || 解析：用户进程访问内存时缺页，会发生缺页中断。发生缺页中断时，系统执行的操作可能是置换 页面或分配内存。越界检查发生在查询页表之前，而此处产生了缺页中断，说明已经正常进行到 查询页表的阶段，系统此时没有产生越界错，因此不会进行越界出错处理。"}
{"id": "442", "type": "单项选择题", "question": "46.【2014统考真题】下列措施中，能加快虚实地址转换的是( ) I. 增大快表(TLB) 容量 II. 让页表常驻内存 III. 增大交换区(swap) A. 仅I B.仅I C. 仅I、II D.仅Ⅱ、III", "answer_label": "C", "answer_explain": "虚实地址转换是指逻辑地址和物理地址的转换。增大快表容量能把更多的表项装入快表，会 加快虚实地址转换的速度；让页表常驻内存可以省去一些不在内存中的页表从磁盘上调入的过 程，也能加快虚实地址转换；增大交换区对虚实地址转换速度无影响，因此选项I、Ⅱ正确。", "answer": "C || 解析：虚实地址转换是指逻辑地址和物理地址的转换。增大快表容量能把更多的表项装入快表，会 加快虚实地址转换的速度；让页表常驻内存可以省去一些不在内存中的页表从磁盘上调入的过 程，也能加快虚实地址转换；增大交换区对虚实地址转换速度无影响，因此选项I、Ⅱ正确。"}
{"id": "443", "type": "单项选择题", "question": "47.【2014统考真题】在页式虚拟存储管理系统中，采用某些页面置换算法会出现 Belady 异常现象，即进程 的缺页次数会随着分配给该进程的页框个数的增加而增加。下列算法中，可能出现 Belady 异常现象的 是( )【微信公 研七七】 I.LRU 算法 II.FIFO 算法 III.OPT 算法 A. 仅 Ⅱ B. 仅I、II C. 仅 I 、Ⅲ D. 仅Ⅱ、Ⅲ", "answer_label": "A", "answer_explain": "只有FIFO 算法会导致Belady 异常。", "answer": "A || 解析：只有FIFO 算法会导致Belady 异常。"}
{"id": "444", "type": "单项选择题", "question": "48. 【2015统考真题】在请求分页系统中，页面分配策略与页面置换策略不能组合使用的是( ) A. 可变分配，全局置换 B. 可变分配，局部置换 C. 固定分配，全局置换 D. 固定分配，局部置换 ", "answer_label": "C", "answer_explain": "对各进程进行固定分配时页面数不变，不可能出现全局置换。而选项 A 、B 、D 是现代操作 系统中常见的3种策略。", "answer": "C || 解析：对各进程进行固定分配时页面数不变，不可能出现全局置换。而选项 A 、B 、D 是现代操作 系统中常见的3种策略。"}
{"id": "444", "type": "单项选择题", "question": "49. 【2015统考真题】系统为某进程分配了4个页框，该进程已访问的页号序列为2,0,2,9,3,4,2,8,2,4,8, 4,5。若进程要访问的下一页的页号为7,依据LRU 算法，应淘汰页的页号是( ) A.2 B.3 C.4 D.8  ", "answer_label": "A", "answer_explain": "可以采用书中常规的解法思路，也可以采用便捷法。对页号序列从后往前计数，直到数到4 (页框数)个不同的数字为止，这个停止的数字就是要淘汰的页号(最近最久未使用的页),题中 为页号2。", "answer": "A || 解析：可以采用书中常规的解法思路，也可以采用便捷法。对页号序列从后往前计数，直到数到4 (页框数)个不同的数字为止，这个停止的数字就是要淘汰的页号(最近最久未使用的页),题中 为页号2。"}
{"id": "444", "type": "单项选择题", "question": "50. 【2016统考真题】某系统采用改进型 CLOCK 置换算法，页表项中字段 A 为访问位，M 为修改位。A=0 表示页最近没有被访问，A=1 表示页最近被访问过。M=0 表示页未被修改过，M=1 表示页被修改过。按 (A,M) 所有可能的取值，将页分为(0,0),(1,0),(0,1)和(1,1)四类，则该算法淘汰页的次序为( ) A.(0,0),(0,1),(1,0),(1,1) B.(0,0),(1,0),(0,1),(1,1) C.(0,0),(0,1),(1,1),(1,0) D.(0,0),(1,1),(0,1),(1,0)", "answer_label": "A", "answer_explain": "改进型 CLOCK 置换算法执行的步骤如下：1)从指针的当前位置开始，扫描帧缓冲区。在这次扫描过程中，对使用位不做任何修改。 选择遇到的第一个帧 (A=0,M=0)        用于替换。\n2)若第1)步失败，则重新扫描，查找 (A=0,M=1)         的帧。选择遇到的第一个这样的帧 用于替换。在这个扫描过程中，对每个跳过的帧，将其使用位设置成0。\n3)若第2)步失败，则指针将回到它的最初位置，并且集合中所有帧的使用位均为0。重复 第1)步，并在有必要时重复第2)步，这样将可以找到供替换的帧。\n因此，该算法淘汰页的次序为(0,0),(0,1),(1,0),(1,1)。", "answer": "A || 解析：改进型 CLOCK 置换算法执行的步骤如下：1)从指针的当前位置开始，扫描帧缓冲区。在这次扫描过程中，对使用位不做任何修改。 选择遇到的第一个帧 (A=0,M=0)        用于替换。\n2)若第1)步失败，则重新扫描，查找 (A=0,M=1)         的帧。选择遇到的第一个这样的帧 用于替换。在这个扫描过程中，对每个跳过的帧，将其使用位设置成0。\n3)若第2)步失败，则指针将回到它的最初位置，并且集合中所有帧的使用位均为0。重复 第1)步，并在有必要时重复第2)步，这样将可以找到供替换的帧。\n因此，该算法淘汰页的次序为(0,0),(0,1),(1,0),(1,1)。"}
{"id": "445", "type": "单项选择题", "question": "51. 【2016统考真题】某进程访问页面的序列如下所示(注意，抖动和工作集已从最新大纲中删除)。 若工作集的窗口大小为6,则在t时刻的工作集为( ) A.{6,0,3,2} B.{2,3,0,4} C.{0,4,3,2,9} D.{4,5,6,0,3,2} ", "answer_label": "A", "answer_explain": "在任意时刻t, 都存在一个集合，它包含所有最近k 次(该题窗口大小为6)内存访问所访问 过的页面。这个集合w(k,t) 就是工作集。题中最近6次访问的页面分别为6,0,3,2,3,2,去除重 复的页面，形成的工作集为{6,0,3,2}。", "answer": "A || 解析：在任意时刻t, 都存在一个集合，它包含所有最近k 次(该题窗口大小为6)内存访问所访问 过的页面。这个集合w(k,t) 就是工作集。题中最近6次访问的页面分别为6,0,3,2,3,2,去除重 复的页面，形成的工作集为{6,0,3,2}。"}
{"id": "445", "type": "单项选择题", "question": "52. 【 2 0 1 9 统 考 真 题 】 某 系 统 采 用 LRU 页 置 换 算 法 和 局 部 置 换 策 略 ， 若 系 统 为 进 程 P 预 分 配 了 4 个 页 框 ， 进 程 P 访问页号的序列为0,1,2,7,0,5,3,5,0,2,7,6,则进程访问上述页的过程中，产生页置换的总次 数 是 ( ) A.3 B.4 C.5 D.6 ", "answer_label": "C", "answer_explain": "最近最久未使用 (LRU)   算法每次执行页面置换时会换出最近最久未使用过的页面。第一次 访问5页面时，会把最久未被使用的1页面换出，第一次访问3页面时，会把最久未访问的2页 面换出。具体的页面置换情况如下图所示。\n需要注意的是，题中问的是页置换次数，而不是缺页次数，所以前4次缺页未换页的情况不 考虑在内，答案为5次，因此选择选项C。", "answer": "C || 解析：最近最久未使用 (LRU)   算法每次执行页面置换时会换出最近最久未使用过的页面。第一次 访问5页面时，会把最久未被使用的1页面换出，第一次访问3页面时，会把最久未访问的2页 面换出。具体的页面置换情况如下图所示。\n需要注意的是，题中问的是页置换次数，而不是缺页次数，所以前4次缺页未换页的情况不 考虑在内，答案为5次，因此选择选项C。"}
{"id": "446", "type": "单项选择题", "question": "53. 【2020统考真题】下列因素中，影响请求分页系统有效(平均)访存时间的是( ) I. 缺 页 率 II.磁盘读/写时间 III.内存访问时间 IV. 执行缺页处理程序的CPU 时 间 A. 仅 Ⅱ 、III B. 仅 I 、IV C. 仅 I 、III 、IV D.I 、I 、III 和 IV", "answer_label": "D", "answer_explain": "选项I 影响缺页中断的频率，缺页率越高，平均访存时间越长；选项Ⅱ和IV 影响缺页中断 的处理时间，中断处理时间越长，平均访存时间越长；选项Ⅲ影响访问页表和访问目标物理地 址的时间，所以选项I、IⅡ、Ⅲ 和IV 均正确。", "answer": "D || 解析：选项I 影响缺页中断的频率，缺页率越高，平均访存时间越长；选项Ⅱ和IV 影响缺页中断 的处理时间，中断处理时间越长，平均访存时间越长；选项Ⅲ影响访问页表和访问目标物理地 址的时间，所以选项I、IⅡ、Ⅲ 和IV 均正确。"}
{"id": "447", "type": "单项选择题", "question": "54. 【 2 0 2 1 统 考 真 题 】 某 请 求 分 页 存 储 系 统 的 页 大 小 为 4KB. 按 字 节 编 址 。 系 统 给 进 程 P 分 配 2 个 固 定 的 页框，并采用改进型 Clock 置换算法，进程 P 页 表 的 部 分 内 容 见 下 表 。 若 P 访问虚拟地址为02A01H 的存储单元，则经地址变换后得到的物理地址是( ) A.00A01H B.20A01H C.60A01H D.80A01H", "answer_label": "C", "answer_explain": "页面大小为4KB, 低12位是页内偏移。虚拟地址为02A01H,   页号为02H,02H    页对应的 页表项中存在位为0,进程P 分配的页框固定为2,且内存中已有两个页面存在。根据Clock 算 法，选择将3号页换出，将2号页放入60H 页框，经过地址变换后得到的物理地址是60A01H。", "answer": "C || 解析：页面大小为4KB, 低12位是页内偏移。虚拟地址为02A01H,   页号为02H,02H    页对应的 页表项中存在位为0,进程P 分配的页框固定为2,且内存中已有两个页面存在。根据Clock 算 法，选择将3号页换出，将2号页放入60H 页框，经过地址变换后得到的物理地址是60A01H。"}
{"id": "448", "type": "单项选择题", "question": "55.【2022统考真题】某进程访问的页 b 不在内存中，导致产生缺页异常，该缺页异常处理过程中不一定包 含的操作是( ) A. 淘汰内存中的页 B. 建立页号与页框号的对应关系 C. 将页b 从外存读入内存 D. 修改页表中页b 对应的存在位", "answer_label": "A", "answer_explain": "缺页异常需要从磁盘调页到内存中，将新调入的页与页框建立对应关系，并修改该页的存在 位，选项B 、C 、D 正确；若内存中有空闲页框，则不需要淘汰其他页，选项A 错误。", "answer": "A || 解析：缺页异常需要从磁盘调页到内存中，将新调入的页与页框建立对应关系，并修改该页的存在 位，选项B 、C 、D 正确；若内存中有空闲页框，则不需要淘汰其他页，选项A 错误。"}
{"id": "449", "type": "单项选择题", "question": "56.【2022统考真题】下列选项中，不会影响系统缺页率的是( ) A. 页置换算法 B.工作集的大小 C. 进程的数量 D. 页缓冲队列的长度", "answer_label": "D", "answer_explain": "页置换算法会影响缺页率，例如，LRU 算法的缺页率通常要比FIFO 算法的缺页率低，排除  选项A 。工作集的大小决定了分配给进程的物理块数，分配给进程的物理块数越多，缺页率就越  低，排除选项B。进程的数量越多，对内存资源的竞争越激烈，每个进程被分配的物理块数越少， 缺页率也就越高，排除选项C 。页缓冲队列是将被淘汰的页面缓存下来，暂时不写回磁盘，队列 长度会影响页面置换的速度，但不会影响缺页率。", "answer": "D || 解析：页置换算法会影响缺页率，例如，LRU 算法的缺页率通常要比FIFO 算法的缺页率低，排除  选项A 。工作集的大小决定了分配给进程的物理块数，分配给进程的物理块数越多，缺页率就越  低，排除选项B。进程的数量越多，对内存资源的竞争越激烈，每个进程被分配的物理块数越少， 缺页率也就越高，排除选项C 。页缓冲队列是将被淘汰的页面缓存下来，暂时不写回磁盘，队列 长度会影响页面置换的速度，但不会影响缺页率。"}
{"id": "450", "type": "单项选择题", "question": "57. 对于采用虚拟内存管理方式的系统，下列关于进程虚拟地址空间的叙述中，错误的是( ) A. 每个进程都有自己独立的虚拟地址空间 B.C 语言中malloc() 函数返回的是虚拟地址 C. 进程对数据段和代码段可以有不同的访问权限 D. 虚拟地址空间的大小由内存和硬盘的大小决定 4.1进程与线程", "answer_label": "D", "answer_explain": "虚拟地址空间的大小由底层的虚拟内存管理机制和操作系统决定，通常在不同的操作系统中有所不同，与内存和硬盘的大小没有关系，内存和硬盘的大小仅决定虚拟存储器实际可用容量的 最大值，选项D 错误。选项A 、C 显然正确。在进程的虚拟地址空间中，有专门用来存放动态分 配的变量的堆区，通过调用malloc() 函数动态地分配该空间，选项B 正确。", "answer": "D || 解析：虚拟地址空间的大小由底层的虚拟内存管理机制和操作系统决定，通常在不同的操作系统中有所不同，与内存和硬盘的大小没有关系，内存和硬盘的大小仅决定虚拟存储器实际可用容量的 最大值，选项D 错误。选项A 、C 显然正确。在进程的虚拟地址空间中，有专门用来存放动态分 配的变量的堆区，通过调用malloc() 函数动态地分配该空间，选项B 正确。"}
