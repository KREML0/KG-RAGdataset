{"id": "93", "type": "单项选择题", "question": "1. 一个进程映像是( ) A. 由协处理器执行的一个程序 B. 一个独立的程序+数据集 C.PCB 结构与程序和数据的组合 D. 一个独立的程序", "answer_label": "C", "answer_explain": "进程映像是PCB 、程序段和数据的组合，其中PCB 是进程存在的唯一标志。", "answer": "C || 解析：进程映像是PCB 、程序段和数据的组合，其中PCB 是进程存在的唯一标志。"}
{"id": "94", "type": "单项选择题", "question": "2. 进程之间交换数据不能通过()途径进行。 A. 共享文件 B. 消息传递 C. 访问进程地址空间 D. 访问共享存储区", "answer_label": "C", "answer_explain": "每个进程包含独立的地址空间，进程各自的地址空间是私有的，只能执行自己地址空间中的 程序，且只能访问自己地址空间中的数据，相互访问会导致指针的越界错误(学完内存管理将有 更好的认识)。因此，进程之间不能直接交换数据，但可利用操作系统提供的共享文件、消息传 递、共享存储区等进行通信。", "answer": "C || 解析：每个进程包含独立的地址空间，进程各自的地址空间是私有的，只能执行自己地址空间中的 程序，且只能访问自己地址空间中的数据，相互访问会导致指针的越界错误(学完内存管理将有 更好的认识)。因此，进程之间不能直接交换数据，但可利用操作系统提供的共享文件、消息传 递、共享存储区等进行通信。"}
{"id": "95", "type": "单项选择题", "question": "3. 进程与程序的根本区别是( ) A. 静态和动态特点 B. 是不是被调入内存 C. 是不是具有就绪、运行和等待三种状态 D. 是不是占有处理器", "answer_label": "A", "answer_explain": "动态性是进程最重要的特性，以此来区分文件形式的静态程序。操作系统引入进程的概念， 是为了从变化的角度动态地分析和研究程序的执行。", "answer": "A || 解析：动态性是进程最重要的特性，以此来区分文件形式的静态程序。操作系统引入进程的概念， 是为了从变化的角度动态地分析和研究程序的执行。"}
{"id": "96", "type": "单项选择题", "question": "4. 下列关于进程的描述中，最不符合操作系统对进程的理解的是() A. 进程是在多程序环境中的完整程序 B. 进程可以由程序、数据和 PCB 描述 C. 线程(Thread) 是一种特殊的进程 D. 进程是程序在一个数据集合上的运行过程，它是系统进行资源分配和调度的一个独立单元", "answer_label": "A", "answer_explain": "进程是一个独立的运行单位，也是操作系统进行资源分配和调度的基本单位，它包括PCB、 程序和数据以及执行栈区，仅仅说进程是在多程序环境下的完整程序是不合适的，因为程序是静 态的，它以文件形式存放在计算机的硬盘内，而进程是动态的。", "answer": "A || 解析：进程是一个独立的运行单位，也是操作系统进行资源分配和调度的基本单位，它包括PCB、 程序和数据以及执行栈区，仅仅说进程是在多程序环境下的完整程序是不合适的，因为程序是静 态的，它以文件形式存放在计算机的硬盘内，而进程是动态的。"}
{"id": "97", "type": "单项选择题", "question": "5. 下列关于并发进程特性的叙述中，正确的是() A. 进程是一个动态过程，其生命周期是连续的 B. 并发进程执行完毕后，一定能够得到相同的结果 C. 并发进程对共享变量的操作结果与执行速度无关 D. 并发进程的运行结果具有不可再现性", "answer_label": "D", "answer_explain": "并发进程可能因等待资源或因被抢占 CPU 而暂停运行，其生命周期是不连续的。执行速度  会影响进程之间的执行顺序和内存冲突问题，从而导致不同的操作结果。并发进程之间存在相互 竞争和制约，导致每次运行可能得到不同的结果，选项D 正确。", "answer": "D || 解析：并发进程可能因等待资源或因被抢占 CPU 而暂停运行，其生命周期是不连续的。执行速度  会影响进程之间的执行顺序和内存冲突问题，从而导致不同的操作结果。并发进程之间存在相互 竞争和制约，导致每次运行可能得到不同的结果，选项D 正确。"}
{"id": "98", "type": "单项选择题", "question": "6. 下列关于进程的叙述中，正确的是( ) A. 进程获得处理器运行是通过调度得到的 B. 优先级是进程调度的重要依据，一旦确定不能改动 C. 在单处理器系统中，任何时刻都只有一个进程处于运行态 D. 进程申请处理器而得不到满足时，其状态变为阻塞态", "answer_label": "A", "answer_explain": "选项 B  错在优先级分静态和动态两种，动态优先级是根据运行情况而随时调整的。选项 C 错在系统发生死锁时有可能进程全部都处于阻塞态，CPU 空闲。选项D 错在进程申请处理器得不 到满足时就处于就绪态，等待处理器的调度。", "answer": "A || 解析：选项 B  错在优先级分静态和动态两种，动态优先级是根据运行情况而随时调整的。选项 C 错在系统发生死锁时有可能进程全部都处于阻塞态，CPU 空闲。选项D 错在进程申请处理器得不 到满足时就处于就绪态，等待处理器的调度。"}
{"id": "99", "type": "单项选择题", "question": "7. 并发进程执行的相对速度是( ) A. 由进程的程序结构决定的 B. 由进程自己来控制的 C. 与进程调度策略有关 D. 在进程被创建时确定的", "answer_label": "C", "answer_explain": "并发进程执行的相对速度与进程调度策略有关，因为进程调度策略决定了哪些进程可以获得 处理机，以及获得处理机的时间长短，从而影响进程执行的速度和效率。", "answer": "C || 解析：并发进程执行的相对速度与进程调度策略有关，因为进程调度策略决定了哪些进程可以获得 处理机，以及获得处理机的时间长短，从而影响进程执行的速度和效率。"}
{"id": "100", "type": "单项选择题", "question": "8. 下列任务中，( )不是由进程创建原语完成的。 A.申 请 PCB 并初始化 B. 为进程分配内存空问 C. 为进程分配CPU D. 将进程插入就绪队列", "answer_label": "C", "answer_explain": "进程创建原语的执行过程：申请空白PCB,  并为新进程申请一个唯一的数字标识符。为新进 程分配资源，包括内存、I/O 设备等。初始化PCB,  将新进程插入就绪队列。从上述过程可以看 出，为进程分配CPU 不是由进程创建原语完成的，而是由进程调度实现的。", "answer": "C || 解析：进程创建原语的执行过程：申请空白PCB,  并为新进程申请一个唯一的数字标识符。为新进 程分配资源，包括内存、I/O 设备等。初始化PCB,  将新进程插入就绪队列。从上述过程可以看 出，为进程分配CPU 不是由进程创建原语完成的，而是由进程调度实现的。"}
{"id": "101", "type": "单项选择题", "question": "9. 下列关于进程和程序的叙述中，错误的是( ) A. 一个进程在其生命周期中可执行多个程序 B. 一个进程在同一时刻可执行多个程序 C. 一个程序的多次运行可形成多个不同的进程 D. 一个程序的一次执行可产生多个进程", "answer_label": "B", "answer_explain": "一个进程可以顺序地执行一个或多个程序，只要在执行过程中改变其CPU 状态和内存空间 即可，但不能同时执行多个程序，选项B 错误，选项A 正确。一个程序可以对应多个进程，即多 个进程可以执行同一个程序。例如，同一个文本编辑器可以被多个用户或多个窗口同时运行，每 次运行都形成一个新进程。一个程序在执行过程中也可产生多个进程。例如，一个程序可以通过 系统调用fork() 或 create()来创建子进程，从而实现并发处理或分布式计算。选项C 和 D 正确。", "answer": "B || 解析：一个进程可以顺序地执行一个或多个程序，只要在执行过程中改变其CPU 状态和内存空间 即可，但不能同时执行多个程序，选项B 错误，选项A 正确。一个程序可以对应多个进程，即多 个进程可以执行同一个程序。例如，同一个文本编辑器可以被多个用户或多个窗口同时运行，每 次运行都形成一个新进程。一个程序在执行过程中也可产生多个进程。例如，一个程序可以通过 系统调用fork() 或 create()来创建子进程，从而实现并发处理或分布式计算。选项C 和 D 正确。"}
{"id": "102", "type": "单项选择题", "question": "10. 下列选项中，导致创建新进程的操作是( ) I. 用户登录 II. 高级调度发生时 III.操作系统响应用户提出的请求 IV. 用户打开了一个浏览器程序 A. 仅I 和IV B. 仅Ⅱ和IV C.I 、ⅡI 和 IV D. 全部", "answer_label": "D", "answer_explain": "用户登录时，操作系统会为用户创建一个登录进程，用于验证用户身份和提供用户界面。高 级调度即作业调度，会从后备队列上选择一个作业调入内存，并为之创建相应的进程。操作系统\n响应用户提出的请求时，通常会为用户创建一个子进程，用于执行用户指定的任务或程序。用户 打开一个浏览器程序时，也是一种操作系统响应用户请求的情况，同样会创建一个新进程。", "answer": "D || 解析：用户登录时，操作系统会为用户创建一个登录进程，用于验证用户身份和提供用户界面。高 级调度即作业调度，会从后备队列上选择一个作业调入内存，并为之创建相应的进程。操作系统\n响应用户提出的请求时，通常会为用户创建一个子进程，用于执行用户指定的任务或程序。用户 打开一个浏览器程序时，也是一种操作系统响应用户请求的情况，同样会创建一个新进程。"}
{"id": "103", "type": "单项选择题", "question": "11. 操作系统是根据()来对并发执行的进程进行控制和管理的。 A. 进程的基本状态 B. 进程控制块 C. 多道程序设计 D. 进程的优先权", "answer_label": "B", "answer_explain": "在进程的整个生命周期中，系统总是通过其 PCB  对进程进行控制。也就是说，系统是根据 进程的PCB 而非任何其他因素来感知到进程存在的，PCB 是进程存在的唯一标志。同时 PCB 常 驻内存。A 和 D 选项的内容都包含在进程PCB 中。", "answer": "B || 解析：在进程的整个生命周期中，系统总是通过其 PCB  对进程进行控制。也就是说，系统是根据 进程的PCB 而非任何其他因素来感知到进程存在的，PCB 是进程存在的唯一标志。同时 PCB 常 驻内存。A 和 D 选项的内容都包含在进程PCB 中。"}
{"id": "104", "type": "单项选择题", "question": "12. 在任何时刻，一个进程的状态变化( )引起另一个进程的状态变化。 A. 必定 B. 一定不 C. 不一定 D. 不可能", "answer_label": "C", "answer_explain": "一个进程的状态变化可能引起另一个进程的状态变化。例如，一个进程时间片用完，可能引 起另一个就绪进程的运行。同时，一个进程的状态变化也可能不会引起另一个进程的状态变化。 例如，一个进程由阻塞态转变为就绪态就不会引起其他进程的状态变化。", "answer": "C || 解析：一个进程的状态变化可能引起另一个进程的状态变化。例如，一个进程时间片用完，可能引 起另一个就绪进程的运行。同时，一个进程的状态变化也可能不会引起另一个进程的状态变化。 例如，一个进程由阻塞态转变为就绪态就不会引起其他进程的状态变化。"}
{"id": "105", "type": "单项选择题", "question": "13. 在单处理器系统中，若同时存在10个进程，则处于就绪队列中的进程最多有( )个。 A.1 B.8 C.9 D.10", "answer_label": "C", "answer_explain": "在单处理器系统中，不可能出现10个进程都处于就绪态的情况。但9个进程处于就绪态、 1个进程处于运行态是可能的。此外还要想到，可能10个进程都处于阻塞态。", "answer": "C || 解析：在单处理器系统中，不可能出现10个进程都处于就绪态的情况。但9个进程处于就绪态、 1个进程处于运行态是可能的。此外还要想到，可能10个进程都处于阻塞态。"}
{"id": "106", "type": "单项选择题", "question": "14. 一个进程释放了一台打印机，它可能会改变()的状态。 A.自身进程 B.输入/输出进程 C. 另一个等待打印机的进程 D. 所有等待打印机的进程", "answer_label": "C", "answer_explain": "由于打印机是独占资源，当一个进程释放打印机后，另一个等待打印机的进程就可能从阻塞 态转到就绪态。当然，也存在一个进程执行完毕后由运行态转为终止态时释放打印机的情况，但 这并不是由于释放打印机引起的，相反是因为运行完成才释放了打印机。", "answer": "C || 解析：由于打印机是独占资源，当一个进程释放打印机后，另一个等待打印机的进程就可能从阻塞 态转到就绪态。当然，也存在一个进程执行完毕后由运行态转为终止态时释放打印机的情况，但 这并不是由于释放打印机引起的，相反是因为运行完成才释放了打印机。"}
{"id": "107", "type": "单项选择题", "question": "15. 系统进程所请求的一次I/O 操作完成后，将使进程状态从( ) A. 运行态变为就绪态 B. 运行态变为阻塞态 C. 就绪态变为运行态 D. 阻塞态变为就绪态", "answer_label": "D", "answer_explain": "I/O操作完成之前进程在等待结果，状态为阻塞态；完成后进程等待事件就绪，变为就绪态。", "answer": "D || 解析：I/O操作完成之前进程在等待结果，状态为阻塞态；完成后进程等待事件就绪，变为就绪态。"}
{"id": "108", "type": "单项选择题", "question": "16. 一个进程的基本状态可以从其他两种基本状态转变过去，这个基本的状态一定是( ) A. 运行态 B. 阻塞态 C. 就绪态 D. 终止态", "answer_label": "C", "answer_explain": "只有就绪态可以既由运行态转变过去又能由阻塞态转变过去。时间片到，运行态变为就绪态； 当所需要资源到达时，进程由阻塞态转变为就绪态。", "answer": "C || 解析：只有就绪态可以既由运行态转变过去又能由阻塞态转变过去。时间片到，运行态变为就绪态； 当所需要资源到达时，进程由阻塞态转变为就绪态。"}
{"id": "109", "type": "单项选择题", "question": "17. 在分时系统中，通常处于( )的进程最多。 A. 运行态 B. 就绪态 C. 阻塞态 D. 终止态", "answer_label": "B", "answer_explain": "分时系统中处于就绪态的进程最多，这些进程都在争夺 CPU 的使用权，而CPU 的数量是有 限的。处于运行态的进程只能有一个或少数几个。处于阻塞态的进程也不会太多，阻塞事件的发 生频率不会太高。处于终止态的进程也不多，这些进程已释放资源，不再占用内存空间。", "answer": "B || 解析：分时系统中处于就绪态的进程最多，这些进程都在争夺 CPU 的使用权，而CPU 的数量是有 限的。处于运行态的进程只能有一个或少数几个。处于阻塞态的进程也不会太多，阻塞事件的发 生频率不会太高。处于终止态的进程也不多，这些进程已释放资源，不再占用内存空间。"}
{"id": "110", "type": "单项选择题", "question": "18. 并发进程失去封闭性，是指( ) A. 多个相对独立的进程以各自的速度向前推进 B. 并发进程的执行结果与速度无关 C. 并发进程执行时，在不同时刻发生的错误 D. 并发进程共享变量，其执行结果与速度有关", "answer_label": "D", "answer_explain": "程序封闭性是指进程执行的结果只取决于进程本身，不受外界影响。也就是说，进程在执行 过程中不管是不停顿地执行，还是走走停停，进程的执行速度都不会改变它的执行结果。失去封 闭性后，不同速度下的执行结果不同。", "answer": "D || 解析：程序封闭性是指进程执行的结果只取决于进程本身，不受外界影响。也就是说，进程在执行 过程中不管是不停顿地执行，还是走走停停，进程的执行速度都不会改变它的执行结果。失去封 闭性后，不同速度下的执行结果不同。"}
{"id": "111", "type": "单项选择题", "question": "19. 通常用户进程被建立后，() A. 便一直存在于系统中，直到被操作人员撤销 B. 随着进程运行的正常或不正常结束而撤销 C. 随着时间片轮转而撤销与建立 D. 随着进程的阻塞或者唤醒而撤销与建立", "answer_label": "B", "answer_explain": "进程有它的生命周期，不会一直存在于系统中，也不一定需要用户显式地撤销。进程在时间 片结束时只是就绪，而不是撤销。阻塞和唤醒是进程生存期的中间状态。进程可在完成时撤销， 或在出现内存错误等时撤销。", "answer": "B || 解析：进程有它的生命周期，不会一直存在于系统中，也不一定需要用户显式地撤销。进程在时间 片结束时只是就绪，而不是撤销。阻塞和唤醒是进程生存期的中间状态。进程可在完成时撤销， 或在出现内存错误等时撤销。"}
{"id": "112", "type": "单项选择题", "question": "20. 进程在处理器上执行时，( ) A. 进程之间是无关的，具有封闭特性 B.进程之间都有交互性，相互依赖、相互制约，具有并发性 C. 具有并发性，即同时执行的特性 D. 进程之间可能是无关的，但也可能是有交互性的", "answer_label": "D", "answer_explain": "选项 A 和 B 都说得太绝对，进程之间可能具有相关性，也可能是相互独立的。选项 C 错在 “ 同 时 ” 。", "answer": "D || 解析：选项 A 和 B 都说得太绝对，进程之间可能具有相关性，也可能是相互独立的。选项 C 错在 “ 同 时 ” 。"}
{"id": "113", "type": "单项选择题", "question": "21. 下列关于父进程和子进程的叙述中，正确的是( ) A. 为了标志父子关系，可让子进程和父进程拥有相同的PID B. 父进程和子进程是相互独立的，可以并发执行 C.撤销子进程时，一定会同时撤销父进程 D. 父进程创建了子进程，要等父进程执行完后，子进程才能执行", "answer_label": "B", "answer_explain": "虽然父进程创建了子进程，它们有一定的关系，但仍然是两个不同的进程，拥有各自的PID,    选项A 错误。父进程和子进程是相互独立的，两个进程能并发执行，且互不影响，选项B 正确， 选项D 错误。撤销一个进程并不一定会导致另一个进程也被撤销，父进程撤销后，子进程可能有 两种状态：①子进程一并被终止；②子进程成为孤儿进程，被 init 进程领养。子进程撤销不会导致父进程撤销，C 错误。", "answer": "B || 解析：虽然父进程创建了子进程，它们有一定的关系，但仍然是两个不同的进程，拥有各自的PID,    选项A 错误。父进程和子进程是相互独立的，两个进程能并发执行，且互不影响，选项B 正确， 选项D 错误。撤销一个进程并不一定会导致另一个进程也被撤销，父进程撤销后，子进程可能有 两种状态：①子进程一并被终止；②子进程成为孤儿进程，被 init 进程领养。子进程撤销不会导致父进程撤销，C 错误。"}
{"id": "114", "type": "单项选择题", "question": "22. 若一个进程实体由 PCB 、共享正文段、数据堆段和数据栈段组成，请指出下列 C 语言程序中的内容及 相关数据结构各位于哪一段中。 I. 全局赋值变量，( ) II. 未赋值的局部变量，( ) ⅢI.函数调用实参传递值，( ) IV. 用 malloc(要求动态分配的存储区，( ) V. 常量值(如1995、”\"string\"),( ) VI.进程的优先级，( ) A.PCB B. 正文段 C. 堆段 D. 栈段", "answer_label": "B、D 、D 、C 、B 、A", "answer_explain": "C 语言编写的程序在使用内存时一般分为三个段：正文段(代码和赋值数据段)、数据堆段 和数据栈段。二进制代码和常量存放在正文段，动态分配的存储区存放在数据堆段，临时使用的 变量存放在数据栈段。由此，我们可以确定全局赋值变量在正文段赋值数据段，未赋值的局部变 量和实参传递在栈段，动态内存分配在堆段，常量在正文段，进程的优先级只能在PCB 内。", "answer": "B、D 、D 、C 、B 、A || 解析：C 语言编写的程序在使用内存时一般分为三个段：正文段(代码和赋值数据段)、数据堆段 和数据栈段。二进制代码和常量存放在正文段，动态分配的存储区存放在数据堆段，临时使用的 变量存放在数据栈段。由此，我们可以确定全局赋值变量在正文段赋值数据段，未赋值的局部变 量和实参传递在栈段，动态内存分配在堆段，常量在正文段，进程的优先级只能在PCB 内。"}
{"id": "115", "type": "单项选择题", "question": "23. 同一程序经过多次创建，运行在不同的数据集上，形成了( )的进程。 A. 不同 B. 相同 C. 同步 D. 互斥", "answer_label": "A", "answer_explain": "进程是程序的一次执行过程，它不仅包括程序的代码，还包括程序的数据和状态。同一个程 序经过多次创建，运行在不同的数据集上，会形成不同的进程，它们之间没有必然的联系。", "answer": "A || 解析：进程是程序的一次执行过程，它不仅包括程序的代码，还包括程序的数据和状态。同一个程 序经过多次创建，运行在不同的数据集上，会形成不同的进程，它们之间没有必然的联系。"}
{"id": "116", "type": "单项选择题", "question": "24.PCB 是进程存在的唯一标志，下列()不属于PCB。 A. 进程 ID B.CPU 状态 C. 堆栈指针 D. 全局变量", "answer_label": "D", "answer_explain": "进程实体主要是代码、数据和 PCB。因此，要清楚了解 PCB 内所含的数据结构内容，主要 有四大类：进程标志信息、进程控制信息、进程资源信息、CPU 现场信息。由此可知，全局变量 与PCB 无关，而只与用户代码有关。", "answer": "D || 解析：进程实体主要是代码、数据和 PCB。因此，要清楚了解 PCB 内所含的数据结构内容，主要 有四大类：进程标志信息、进程控制信息、进程资源信息、CPU 现场信息。由此可知，全局变量 与PCB 无关，而只与用户代码有关。"}
{"id": "117", "type": "单项选择题", "question": "25. 一个计算机系统中，进程的最大数量主要受到()限制。 A. 内存大小 B. 用户数目 C. 打开的文件数 D. 外部设备数量", "answer_label": "A", "answer_explain": "进程创建需要占用系统内存来存放 PCB  的数据结构，因此一个系统能够创建的进程总数是 有限的，进程的最大数量取决于系统内存的大小，它在系统安装时就已确定(若后期内存增加， 则系统能够创建的进程总数也会增加)。而用户数量、外设数量和文件等均与此无关。", "answer": "A || 解析：进程创建需要占用系统内存来存放 PCB  的数据结构，因此一个系统能够创建的进程总数是 有限的，进程的最大数量取决于系统内存的大小，它在系统安装时就已确定(若后期内存增加， 则系统能够创建的进程总数也会增加)。而用户数量、外设数量和文件等均与此无关。"}
{"id": "118", "type": "单项选择题", "question": "26. 进程创建完成后会进入一个序列，这个序列称为( ) A. 阻塞队列 B. 挂起序列 C. 就绪队列 D. 运行队列", "answer_label": "C", "answer_explain": "我们先要考虑创建进程的过程，当该进程所需的资源分配完成而只等 CPU  时，进程的状态 为就绪态，因此所有的就绪PCB 一般以链表方式链成一个序列，称为就绪队列。", "answer": "C || 解析：我们先要考虑创建进程的过程，当该进程所需的资源分配完成而只等 CPU  时，进程的状态 为就绪态，因此所有的就绪PCB 一般以链表方式链成一个序列，称为就绪队列。"}
{"id": "119", "type": "单项选择题", "question": "27. 进程自身决定( ) A. 从运行态到阻塞态 B. 从运行态到就绪态 C. 从就绪态到运行态 D. 从阻塞态到就绪态", "answer_label": "A", "answer_explain": "只有从运行态到阻塞态的转换是由进程自身决定的。从运行态到就绪态的转换是由于进程的 时间片用完，“主动”调用程序转向就绪态。虽然从就绪态到运行态的转换同样是由调度程序决 定的，但进程是“被动的”。从阻塞态到就绪态的转换是由协作进程决定的。", "answer": "A || 解析：只有从运行态到阻塞态的转换是由进程自身决定的。从运行态到就绪态的转换是由于进程的 时间片用完，“主动”调用程序转向就绪态。虽然从就绪态到运行态的转换同样是由调度程序决 定的，但进程是“被动的”。从阻塞态到就绪态的转换是由协作进程决定的。"}
{"id": "120", "type": "单项选择题", "question": "28. 下列关于原语操作的叙述中，错误的是( ) A. 操作系统使用原语对进程进行管理和控制 B. 原语在执行过程中不允许被中断 C. 原语在内核态下执行，常驻内存 D. 原语被定义为“原子操作”,意思是其执行速度非常快", "answer_label": "D", "answer_explain": "原语是由若干条指令组成的、用于实现某个特定功能的程序段。它与一般的程序的区别如下： 它是“原子操作”,即一个操作中的所有动作要么全做，要么全不做，在执行过程中不允许被中 断，因此“原子操作”并不是指执行速度快，选项D 错误。对进程的管理和控制功能是通过各种  原语实现的，如创建原语等。原语是操作系统内核的组成部分，它常驻内存，且在内核态下执行。", "answer": "D || 解析：原语是由若干条指令组成的、用于实现某个特定功能的程序段。它与一般的程序的区别如下： 它是“原子操作”,即一个操作中的所有动作要么全做，要么全不做，在执行过程中不允许被中 断，因此“原子操作”并不是指执行速度快，选项D 错误。对进程的管理和控制功能是通过各种  原语实现的，如创建原语等。原语是操作系统内核的组成部分，它常驻内存，且在内核态下执行。"}
{"id": "121", "type": "单项选择题", "question": "29. 用信箱实现进程间互通信息的通信机制要有两个通信原语，它们是( ) A. 发送原语和执行原语 B. 就绪原语和执行原语 C. 发送原语和接收原语 D. 就绪原语和接收原语", "answer_label": "C", "answer_explain": "用信箱实现进程间互通信息的通信机制要有两个通信原语，它们是发送原语和接收原语。", "answer": "C || 解析：用信箱实现进程间互通信息的通信机制要有两个通信原语，它们是发送原语和接收原语。"}
{"id": "122", "type": "单项选择题", "question": "30. 速度最快的进程通信方式是( ) A. 消息传递 B.Socket C. 共享内存 D. 管道", "answer_label": "C", "answer_explain": "消息传递需要在内核和用户空间中进行数据的拷贝，而且需要对消息进行格式化和排队，这 些都会增加通信的开销。套接字 (Socket)   通常用于不同机器之间的进程通信，需要经过传输层 以下的协议栈，而且可能涉及数据的加密和压缩，这些都会降低通信的速度。共享内存允许多个 进程直接访问同一块物理内存，不需要任何数据的拷贝和中介，是最快的进程通信方式。管道需 要在内核和用户空间进行数据的拷贝，而且一般是单向传输，降低了通信的效率。", "answer": "C || 解析：消息传递需要在内核和用户空间中进行数据的拷贝，而且需要对消息进行格式化和排队，这 些都会增加通信的开销。套接字 (Socket)   通常用于不同机器之间的进程通信，需要经过传输层 以下的协议栈，而且可能涉及数据的加密和压缩，这些都会降低通信的速度。共享内存允许多个 进程直接访问同一块物理内存，不需要任何数据的拷贝和中介，是最快的进程通信方式。管道需 要在内核和用户空间进行数据的拷贝，而且一般是单向传输，降低了通信的效率。"}
{"id": "123", "type": "单项选择题", "question": "31. 信箱通信是一种()通信方式。 A. 直接通信 B. 间接通信 C. 低级通信 D. 信号量", "answer_label": "B", "answer_explain": "信箱通信属于消息传递中的间接通信方式，因为信箱通信借助于收发双方进程之外的共享数 据结构作为通信中转，发送方和接收方不直接建立联系，没有处理时间上的限制，发送方可以在 任何时间发送信息，接收方也可以在任何时间接收信息。", "answer": "B || 解析：信箱通信属于消息传递中的间接通信方式，因为信箱通信借助于收发双方进程之外的共享数 据结构作为通信中转，发送方和接收方不直接建立联系，没有处理时间上的限制，发送方可以在 任何时间发送信息，接收方也可以在任何时间接收信息。"}
{"id": "124", "type": "单项选择题", "question": "32. 下列关于信号发送和处理的描述中，错误的是( ) A. 一个进程可以给自己发送信号 B .操作系统的内核可以给进程发送信号 C.操作系统的内核对每种信号都有默认处理程序 D. 用户可以对每种信号自定义处理函数", "answer_label": "D", "answer_explain": "有些信号是不能被用户自定义处理函数的，只能执行操作系统默认的处理程序，选项D 错误。", "answer": "D || 解析：有些信号是不能被用户自定义处理函数的，只能执行操作系统默认的处理程序，选项D 错误。"}
{"id": "125", "type": "单项选择题", "question": "33. 下列关于信号的处理的描述中，错误的是( ) A. 当进程从内核态转为用户态时，会检查是否有待处理的信号 B. 当进程从用户态转为内核态时，也会检查是否有待处理的信号 C.操作系统对某些信号的处理是可以忽略的 D. 操作系统允许进程通过系统调用，自定义某些信号的处理程序", "answer_label": "B", "answer_explain": "信号的处理时机只会在进程从内核态转为用户态时。当进程从用户态转为内核态时，不会检 查是否有待处理的信号，选项B 错误。操作系统对某些信号的默认处理可能就是忽略。", "answer": "B || 解析：信号的处理时机只会在进程从内核态转为用户态时。当进程从用户态转为内核态时，不会检 查是否有待处理的信号，选项B 错误。操作系统对某些信号的默认处理可能就是忽略。"}
{"id": "126", "type": "单项选择题", "question": "34. 下面的叙述中，正确的是( ) A. 引入线程后，处理器只能在线程间切换 B. 引入线程后，处理器仍在进程间切换 C. 线程的切换，不会引起进程的切换 D. 线程的切换，可能引起进程的切换", "answer_label": "D", "answer_explain": "在同一进程中，线程的切换不会引起进程的切换。当从一个进程中的线程切换到另一个进程 中的线程时，才会引起进程的切换，因此选项A 、B 、C 错误。", "answer": "D || 解析：在同一进程中，线程的切换不会引起进程的切换。当从一个进程中的线程切换到另一个进程 中的线程时，才会引起进程的切换，因此选项A 、B 、C 错误。"}
{"id": "127", "type": "单项选择题", "question": "35. 下列关于线程的叙述中，正确的是() A. 线程包含 CPU 现场，可以独立执行程序 B. 每个线程都有自己独立的地址空间 C. 每个进程只能包含一个线程 D. 同一进程中的线程间通信也必须使用系统调用函数", "answer_label": "A", "answer_explain": "线程的CPU 现场是指线程运行时所需的一组寄存器的值，包括程序计数器、状态寄存器、 通用寄存器和栈指针等。当线程切换时，操作系统会保存当前线程的 CPU  现场，并恢复下一  个线程的CPU 现场。线程是CPU 调度的基本单位，当然可以独立执行程序，选项A 正确。线  程没有自己独立的地址空间，它共享其所属进程的空间，选项B 错误。进程可以创建多个线程， 选项 C 错误。同一个进程中的线程间通信可以直接通过它们共享的存储空间，选项D 错误。", "answer": "A || 解析：线程的CPU 现场是指线程运行时所需的一组寄存器的值，包括程序计数器、状态寄存器、 通用寄存器和栈指针等。当线程切换时，操作系统会保存当前线程的 CPU  现场，并恢复下一  个线程的CPU 现场。线程是CPU 调度的基本单位，当然可以独立执行程序，选项A 正确。线  程没有自己独立的地址空间，它共享其所属进程的空间，选项B 错误。进程可以创建多个线程， 选项 C 错误。同一个进程中的线程间通信可以直接通过它们共享的存储空间，选项D 错误。"}
{"id": "128", "type": "单项选择题", "question": "36. 下面的叙述中，正确的是() A. 线程是比进程更小的能独立运行的基本单位，可以脱离进程独立运行 B. 引入线程可提高程序并发执行的程度，可进一步提高系统效率 C. 线程的引入增加了程序执行时的时空开销 D. 一个进程一定包含多个线程", "answer_label": "B", "answer_explain": "线程是进程内一个相对独立的执行单元，但不能脱离进程单独运行，只能在进程中运行。引 入线程是为了减少程序执行时的时空开销。一个进程可包含一个或多个线程。", "answer": "B || 解析：线程是进程内一个相对独立的执行单元，但不能脱离进程单独运行，只能在进程中运行。引 入线程是为了减少程序执行时的时空开销。一个进程可包含一个或多个线程。"}
{"id": "129", "type": "单项选择题", "question": "37. 下面的叙述中，正确的是() A. 同一进程内的线程可并发执行，不同进程的线程只能串行执行 B. 同一进程内的线程只能串行执行，不同进程的线程可并发执行 C. 同一进程或不同进程内的线程都只能串行执行 D. 同一进程或不同进程内的线程都可以并发执行", "answer_label": "D", "answer_explain": "同一个进程或不同进程内的线程可以并发执行，并发是指多个线程在一段时间内交替执行， 而不一定是同时执行的。在多核CPU 中，同一个进程或不同进程内的线程可以并行执行，并行是 指多个线程在同一时刻同时执行。若实现了并行，则一定也实现了并发。", "answer": "D || 解析：同一个进程或不同进程内的线程可以并发执行，并发是指多个线程在一段时间内交替执行， 而不一定是同时执行的。在多核CPU 中，同一个进程或不同进程内的线程可以并行执行，并行是 指多个线程在同一时刻同时执行。若实现了并行，则一定也实现了并发。"}
{"id": "130", "type": "单项选择题", "question": "38. 下列选项中，( )不是线程的优点。 A. 提高系统并发性 B. 节约系统资源 C. 便于进程通信 D. 增强进程安全性", "answer_label": "D", "answer_explain": "线程的优点有提高系统并发性、节约系统资源、便于进程通信等，但线程并不能增强进程安 全性，因为线程共享进程的地址空间和资源，若一个线程出错，则可能影响整个进程的运行。", "answer": "D || 解析：线程的优点有提高系统并发性、节约系统资源、便于进程通信等，但线程并不能增强进程安 全性，因为线程共享进程的地址空间和资源，若一个线程出错，则可能影响整个进程的运行。"}
{"id": "131", "type": "单项选择题", "question": "39. 下列关于进程和线程的说法中，正确的是( ) A. 一个进程可以包含一个或多个线程，一个线程可以属于一个或多个进程 B. 多线程技术具有明显的优越性，如速度快、通信简便、设备并行性高等 C. 由于线程不作为资源分配单位，线程之间可以无约束地并行执行 D. 线程又称轻量级进程，因为线程都比进程小", "answer_label": "B", "answer_explain": "一个进程可以包含一个或多个线程，但一个线程只能属于一个进程，选项A 错误。线程共享 进程的资源，但线程之间不能无约束地并行执行，因为线程之间还需要进行同步和互斥，以免造 成数据的不一致和冲突，选项C 错误。线程也称轻量级进程，但并不能说所有线程都比进程小， 选项D 错误。", "answer": "B || 解析：一个进程可以包含一个或多个线程，但一个线程只能属于一个进程，选项A 错误。线程共享 进程的资源，但线程之间不能无约束地并行执行，因为线程之间还需要进行同步和互斥，以免造 成数据的不一致和冲突，选项C 错误。线程也称轻量级进程，但并不能说所有线程都比进程小， 选项D 错误。"}
{"id": "132", "type": "单项选择题", "question": "40. 在以下描述中，( )并不是多线程系统的特长。 A. 利用线程并行地执行矩阵乘法运算 B.Web 服务器利用线程响应HTTP 请求 C. 键盘驱动程序为每个正在运行的应用配备一个线程，用以响应该应用的键盘输入 D. 基于 GUI 的调试程序用不同的线程分别处理用户输入、计算和跟踪等操作", "answer_label": "C", "answer_explain": "整个系统只有一个键盘，而且键盘输入是人的操作，速度比较慢，完全可以使用一个线程来 处理整个系统的键盘输入。", "answer": "C || 解析：整个系统只有一个键盘，而且键盘输入是人的操作，速度比较慢，完全可以使用一个线程来 处理整个系统的键盘输入。"}
{"id": "133", "type": "单项选择题", "question": "41.在进程转换时，下列( )转换是不可能发生的。 A. 就绪态 → 运行态 B.运行态 → 就绪态 C. 运行态 → 阻塞态 D. 阻塞态 → 运行态", "answer_label": "D", "answer_explain": "阻塞的进程在获得所需资源时只能由阻塞态转变为就绪态，并插入就绪队列，而不能直接转 变为运行态。", "answer": "D || 解析：阻塞的进程在获得所需资源时只能由阻塞态转变为就绪态，并插入就绪队列，而不能直接转 变为运行态。"}
{"id": "134", "type": "单项选择题", "question": "42. 当 ( )时，进程从执行状态转变为就绪态。 A. 进程被调度程序选中 B.时间片到 C. 等待某一事件 D. 等待的事件发生", "answer_label": "B", "answer_explain": "当进程的时间片到时，进程由运行态转变为就绪态，等待下一个时间片的到来。", "answer": "B || 解析：当进程的时间片到时，进程由运行态转变为就绪态，等待下一个时间片的到来。"}
{"id": "135", "type": "单项选择题", "question": "43. 两个合作进程(Cooperating Processes)无法利用()交换数据。 A. 文件系统 B. 共享内存 C. 高级语言程序设计中的全局变量 D. 消息传递系统", "answer_label": "C", "answer_explain": "不同的进程拥有不同的代码段和数据段，全局变量是对同一进程而言的，在不同的进程中是 不同的变量，没有任何联系，所以不能用于交换数据。此题也可用排除法做，选项 A、B、D  均 是课本上所讲的。管道是一种文件", "answer": "C || 解析：不同的进程拥有不同的代码段和数据段，全局变量是对同一进程而言的，在不同的进程中是 不同的变量，没有任何联系，所以不能用于交换数据。此题也可用排除法做，选项 A、B、D  均 是课本上所讲的。管道是一种文件。"}
{"id": "136", "type": "单项选择题", "question": "44. 以下可能导致一个进程从运行态变为就绪态的事件是( ) A. 一次I/O 操作结束 B.运行进程需做I/O操作 C. 运行进程结束 D. 出现了比现在进程优先级更高的进程", "answer_label": "D", "answer_explain": "进程处于运行态时，它必须已获得所需的资源，在运行结束后就撤销。只有在时间片到或出 现了比现在进程优先级更高的进程时才转变成就绪态。选项A 使进程从阻塞态到就绪态，选项B 使进程从运行态到阻塞态，选项C 使进程撤销。", "answer": "D || 解析：进程处于运行态时，它必须已获得所需的资源，在运行结束后就撤销。只有在时间片到或出 现了比现在进程优先级更高的进程时才转变成就绪态。选项A 使进程从阻塞态到就绪态，选项B 使进程从运行态到阻塞态，选项C 使进程撤销。"}
{"id": "137", "type": "单项选择题", "question": "45. ( )必会引起进程切换。 A. 一个进程创建后，进入就绪态 B. 一个进程从运行态变为就绪态 C. 一个进程从阻塞态变为就绪态 D. 以上答案都不对", "answer_label": "B", "answer_explain": "进程切换是指CPU 调度不同的进程执行，当一个进程从运行态变为就绪态时，CPU 调度另 一个进程执行，引起进程切换。", "answer": "B || 解析：进程切换是指CPU 调度不同的进程执行，当一个进程从运行态变为就绪态时，CPU 调度另 一个进程执行，引起进程切换。"}
{"id": "138", "type": "单项选择题", "question": "46. 进程处于( )时，它处于非阻塞态。 A. 等待从键盘输入数据 B. 等待协作进程的一个信号 C. 等待操作系统分配CPU 时间 D. 等待网络数据进入内存", "answer_label": "C", "answer_explain": "进程有三种基本状态，处于阻塞态的进程由于某个事件不满足而等待。这样的事件一般是I/O 操 作，如键盘等，或是因互斥或同步数据引起的等待，如等待信号或等待进入互斥临界区代码段等，等 待网络数据进入内存是为了进程同步。而等待CPU 调度的进程处于就绪态，只有它是非阻塞态。", "answer": "C || 解析：进程有三种基本状态，处于阻塞态的进程由于某个事件不满足而等待。这样的事件一般是I/O 操 作，如键盘等，或是因互斥或同步数据引起的等待，如等待信号或等待进入互斥临界区代码段等，等 待网络数据进入内存是为了进程同步。而等待CPU 调度的进程处于就绪态，只有它是非阻塞态。"}
{"id": "139", "type": "单项选择题", "question": "47. 一个进程被唤醒，意味着( ) A. 该进程可以重新竞争 CPU B. 优先级变大 C.PCB 移动到就绪队列之首 D. 进程变为运行态", "answer_label": "A", "answer_explain": "当一个进程被唤醒时，这个进程就进入了就绪态，等待进程调度而占有 CPU  运行。进程被 唤醒在某种情形下优先级可以增大，但一般不会变为最大，而由固定的算法来计算。也不会在唤 醒后位于就绪队列的队首，就绪队列是按照一定的规则赋予其位置的，如先来先服务，或者高优 先级优先，或者短进程优先等，更不能直接占有处理器运行。", "answer": "A || 解析：当一个进程被唤醒时，这个进程就进入了就绪态，等待进程调度而占有 CPU  运行。进程被 唤醒在某种情形下优先级可以增大，但一般不会变为最大，而由固定的算法来计算。也不会在唤 醒后位于就绪队列的队首，就绪队列是按照一定的规则赋予其位置的，如先来先服务，或者高优 先级优先，或者短进程优先等，更不能直接占有处理器运行。"}
{"id": "140", "type": "单项选择题", "question": "48. 进程创建时，不需要做的是( ) A. 填写一个该进程的进程表项 B. 分配该进程适当的内存 C. 将该进程插入就绪队列 D. 为该进程分配 CPU", "answer_label": "D", "answer_explain": "进程创建原语完成的工作是：向系统申请一个空闲PCB, 为被创建进程分配必要的资源，然 后将其PCB 初始化，并将此PCB  插入就绪队列，最后返回一个进程标志号。当调度程序为进程 分配 CPU 后，进程开始运行。所以进程创建的过程中不会包含分配CPU 的过程，这不是进程创 建者的工作，而是调度程序的工作。", "answer": "D || 解析：进程创建原语完成的工作是：向系统申请一个空闲PCB, 为被创建进程分配必要的资源，然 后将其PCB 初始化，并将此PCB  插入就绪队列，最后返回一个进程标志号。当调度程序为进程 分配 CPU 后，进程开始运行。所以进程创建的过程中不会包含分配CPU 的过程，这不是进程创 建者的工作，而是调度程序的工作。"}
{"id": "141", "type": "单项选择题", "question": "49. 计算机两个系统中两个协作进程之间不能用来进行进程间通信的是( ) A. 数据库 B. 共享内存 C. 消息传递机制 D. 管道", "answer_label": "A", "answer_explain": "进程之间的通信方式主要有管道、消息传递、共享内存、文件映射和套接字等。数据库不能 直接作为进程之间的通信方式。", "answer": "A || 解析：进程之间的通信方式主要有管道、消息传递、共享内存、文件映射和套接字等。数据库不能 直接作为进程之间的通信方式。"}
{"id": "142", "type": "单项选择题", "question": "50. 下面关于用户级线程和内核级线程的描述中，错误的是() A. 采用轮转调度算法，进程中设置内核级线程和用户级线程的效果完全不同 B. 跨进程的用户级线程调度也不需要内核参与，控制简单 C. 用户级线程可以在任何操作系统中运行 D. 若系统中只有用户级线程，则CPU 的调度对象是进程", "answer_label": "B", "answer_explain": "用户级线程的调度仍以进程为单位，各个进程轮流执行一个时间片，假设进程A 包含1个用 户级线程，而进程B 包含100个用户级线程，此时进程A 中单个线程的运行时间将是进程 B 中各 个线程平均运行时间的100倍；内核级线程的调度是以线程为单位的，各个线程轮流执行一个时间 片，同样假设进程A  包含1个内核级线程，而进程B 包含100个内核级线程，此时进程B 的运行 时间将是进程A 的100倍，选项A 正确。用户级线程的调度单位是进程，跨进程的线程调度需要 内核支持，选项B 错误。用户级线程是由用户程序或函数库实现的，不依赖于操作系统的支持，选 项C 正确。用户级线程对操作系统是透明的，CPU 调度的对象仍然是进程，选项D 正确。", "answer": "B || 解析：用户级线程的调度仍以进程为单位，各个进程轮流执行一个时间片，假设进程A 包含1个用 户级线程，而进程B 包含100个用户级线程，此时进程A 中单个线程的运行时间将是进程 B 中各 个线程平均运行时间的100倍；内核级线程的调度是以线程为单位的，各个线程轮流执行一个时间 片，同样假设进程A  包含1个内核级线程，而进程B 包含100个内核级线程，此时进程B 的运行 时间将是进程A 的100倍，选项A 正确。用户级线程的调度单位是进程，跨进程的线程调度需要 内核支持，选项B 错误。用户级线程是由用户程序或函数库实现的，不依赖于操作系统的支持，选 项C 正确。用户级线程对操作系统是透明的，CPU 调度的对象仍然是进程，选项D 正确。"}
{"id": "143", "type": "单项选择题", "question": "51. 在内核级线程相对于用户级线程的优点的如下描述中，错误的是() A. 同一进程内的线程切换，系统开销小 B. 当内核线程阻塞时，CPU 将会调度同一进程中的其他内核线程执行 C. 内核级线程的程序实体可以在内核态运行 D. 对多处理器系统，核心可以同时调度同一进程的多个线程并行运行", "answer_label": "A", "answer_explain": "在内核级线程中，同一进程中的线程切换，需要从用户态转到内核态进行，系统开销较大，选 项 A 错误。CPU 调度是在内核中进行的，在内核级线程中，调度是在线程一级进行的，因此内核 可以同时调度同一进程的多个线程在多CPU 上并行运行(用户级线程则不行),选项B 正确、选项 D 正确。内核级线程可以在内核态执行系统调用子程序，直接利用系统调用为它服务，因此选项C  正确。注意，用户级线程是在用户空间中实现的，不能直接利用系统调用获得内核的服务，当用户 级线程要获得内核服务时，必须借助于操作系统的帮助，因此用户级线程只能在用户态运行。", "answer": "A || 解析：在内核级线程中，同一进程中的线程切换，需要从用户态转到内核态进行，系统开销较大，选 项 A 错误。CPU 调度是在内核中进行的，在内核级线程中，调度是在线程一级进行的，因此内核 可以同时调度同一进程的多个线程在多CPU 上并行运行(用户级线程则不行),选项B 正确、选项 D 正确。内核级线程可以在内核态执行系统调用子程序，直接利用系统调用为它服务，因此选项C  正确。注意，用户级线程是在用户空间中实现的，不能直接利用系统调用获得内核的服务，当用户 级线程要获得内核服务时，必须借助于操作系统的帮助，因此用户级线程只能在用户态运行。"}
{"id": "144", "type": "单项选择题", "question": "52. 下列关于用户级线程相对于内核级线程的优点的描述中，错误的是() A. 一个线程阻塞不影响另一个线程的运行 B. 线程的调度不需要内核直接参与，控制简单 C. 线程切换代价小 D. 允许每个进程定制自己的调度算法，线程管理比较灵活", "answer_label": "A", "answer_explain": "进程中的某个用户级线程被阻塞，则整个进程也被阻塞，即进程中的其他用户级线程也被阻\n塞，选项A 错误。用户级线程的调度是在用户空间进行的，节省了模式切换的开销，不同进程可 以根据自身的需要，对自己的线程选择不同的调度算法，因此选项 B、C 和 D 都正确。", "answer": "A || 解析：进程中的某个用户级线程被阻塞，则整个进程也被阻塞，即进程中的其他用户级线程也被阻\n塞，选项A 错误。用户级线程的调度是在用户空间进行的，节省了模式切换的开销，不同进程可 以根据自身的需要，对自己的线程选择不同的调度算法，因此选项 B、C 和 D 都正确。"}
{"id": "145", "type": "单项选择题", "question": "53. 下列关于用户级线程的优点的描述中，不正确的是( ) A. 线程切换不需要切换到内核态 B. 支持不同的应用程序采用不同的调度算法 C. 在不同操作系统上不经修改就可直接运行 D. 同一个进程内的多个线程可以同时调度到多个处理器上执行", "answer_label": "D", "answer_explain": "用户级线程是不需要内核支持而在用户程序中实现的线程，不能利用多处理器的并行性，因 为操作系统只能看到进程。其余说法均正确。", "answer": "D || 解析：用户级线程是不需要内核支持而在用户程序中实现的线程，不能利用多处理器的并行性，因 为操作系统只能看到进程。其余说法均正确。"}
{"id": "146", "type": "单项选择题", "question": "54. 下列选项中，可能导致用户级线程切换的事件是( ) A. 系统调用 B.I/O 请求 C. 异常处理 D. 线程同步", "answer_label": "D", "answer_explain": "本题可用排除法。用户级线程的切换是由应用程序自己控制的，不需要操作系统的干预，操 作系统感受不到用户级线程的存在。因此，系统调用、I/O请求和异常处理这些涉及内核态的事  件都不会导致用户级线程切换，但会导致内核级线程切换。线程同步是指多个线程之间协调执行 顺序的机制，如互斥锁、信号量、条件变量等。当一个线程在等待同步条件时，应用程序可以选 择切换到另一个就绪的用户级线程，以提高CPU 的利用率。", "answer": "D || 解析：本题可用排除法。用户级线程的切换是由应用程序自己控制的，不需要操作系统的干预，操 作系统感受不到用户级线程的存在。因此，系统调用、I/O请求和异常处理这些涉及内核态的事  件都不会导致用户级线程切换，但会导致内核级线程切换。线程同步是指多个线程之间协调执行 顺序的机制，如互斥锁、信号量、条件变量等。当一个线程在等待同步条件时，应用程序可以选 择切换到另一个就绪的用户级线程，以提高CPU 的利用率。"}
{"id": "147", "type": "单项选择题", "question": "55. 下列关于用户级线程的描述中，错误的是() A. 用户级线程由线程库进行管理 B. 用户级线程只有在创建和调度时需要内核的干预 C. 操作系统无法直接调度用户级线程 D. 线程库中线程的切换不会导致进程切换", "answer_label": "B", "answer_explain": "用户级线程不依赖于操作系统内核，而是由用户程序自己实现的，选项A 正确。用户级线程 的创建和调度都是在用户态下实现的，不需要切换到内核态，选项B 错误。操作系统只能看到一  个单线程进程，而不知道进程内部有多个用户级线程，选项C 正确。线程库中线程的切换只涉及  用户栈和寄存器等上下文的保存和恢复，不涉及内核栈和页表等内核上下文的切换，选项D 正确。", "answer": "B || 解析：用户级线程不依赖于操作系统内核，而是由用户程序自己实现的，选项A 正确。用户级线程 的创建和调度都是在用户态下实现的，不需要切换到内核态，选项B 错误。操作系统只能看到一  个单线程进程，而不知道进程内部有多个用户级线程，选项C 正确。线程库中线程的切换只涉及  用户栈和寄存器等上下文的保存和恢复，不涉及内核栈和页表等内核上下文的切换，选项D 正确。"}
{"id": "148", "type": "单项选择题", "question": "56. 下面的说法中，正确的是( ) A. 不论是系统支持的线程还是用户级线程，其切换都需要内核的支持 B.线程是资源分配的单位，进程是调度和分派的单位 C. 不管系统中是否有线程，进程都是拥有资源的独立单位 D. 在引入线程的系统中，进程仍是资源调度和分派的基本单位", "answer_label": "C", "answer_explain": "引入线程后，进程仍然是资源分配的单位。内核级线程是处理器调度和分派的单位，线程本 身不具有资源，它可以共享所属进程的全部资源，选项C 正确，选项B 、D 明显错误。至于选项 A,  可以这样来理解：假如有一个内核进程，它映射到用户级后有多个线程，那么这些线程之间 的切换不需要在内核级切换进程，也就不需要内核的支持。", "answer": "C || 解析：引入线程后，进程仍然是资源分配的单位。内核级线程是处理器调度和分派的单位，线程本 身不具有资源，它可以共享所属进程的全部资源，选项C 正确，选项B 、D 明显错误。至于选项 A,  可以这样来理解：假如有一个内核进程，它映射到用户级后有多个线程，那么这些线程之间 的切换不需要在内核级切换进程，也就不需要内核的支持。"}
{"id": "149", "type": "单项选择题", "question": "57. 在多对一的线程模型中，当一个多线程进程中的某个线程被阻塞后，( ) A. 该进程的其他线程仍可继续运行 B. 整个进程都将阻塞 C. 该阻塞线程将被撤销 D. 该阻塞线程将永远不可能再执行", "answer_label": "B", "answer_explain": "在多对一的线程模型中，只有一个内核级线程，用户级线程的“多”对操作系统透明，因此 操作系统内核只能感知到一个调度单位的存在。因此，该进程的一个线程被阻塞后，该进程就被 阻塞，进程的其他线程当然也被阻塞。注意，作为对比，在一对一模型中将每个用户级线程都映 射到一个内核级线程，因此当某个线程被阻塞时，不会导致整个进程被阻塞。", "answer": "B || 解析：在多对一的线程模型中，只有一个内核级线程，用户级线程的“多”对操作系统透明，因此 操作系统内核只能感知到一个调度单位的存在。因此，该进程的一个线程被阻塞后，该进程就被 阻塞，进程的其他线程当然也被阻塞。注意，作为对比，在一对一模型中将每个用户级线程都映 射到一个内核级线程，因此当某个线程被阻塞时，不会导致整个进程被阻塞。"}
{"id": "150", "type": "单项选择题", "question": "58. 并发性较好的多线程模型有() I. 一对一模型 II. 多对一模型 IⅢI. 多对多模型 A. 仅I B.I和I C.I和II D.I 、I和III", "answer_label": "C", "answer_explain": "一对一模型和多对多模型能充分利用内核级线程，发挥多处理机的优势，能同时调度同一个 进程中的多个线程并发执行，具有较好的并发性。", "answer": "C || 解析：一对一模型和多对多模型能充分利用内核级线程，发挥多处理机的优势，能同时调度同一个 进程中的多个线程并发执行，具有较好的并发性。"}
{"id": "151", "type": "单项选择题", "question": "59. 下列关于多对一模型的叙述中，错误的是( ) A. 一个进程的多个线程不能并行运行在多个处理器上 B. 进程中的用户级线程由进程自己管理 C. 线程切换会导致进程切换 D. 一个线程的系统调用会导致整个进程阻塞", "answer_label": "C", "answer_explain": "多对一模型中的线程切换不会导致进程切换，而是在用户空间进行的。其余说法均正确。", "answer": "C || 解析：多对一模型中的线程切换不会导致进程切换，而是在用户空间进行的。其余说法均正确。"}
{"id": "152", "type": "单项选择题", "question": "60.【2010统考真题】下列选项中，导致创建新进程的操作是( ) I. 用户登录成功 II. 设备分配 III.启动程序执行 A.仅I 和I B. 仅Ⅱ和III C.仅I和III D.I 、II 、III", "answer_label": "C", "answer_explain": "创建进程的原因主要有：①用户登录；②高级调度；③系统处理用户程序的请求；④用户程 序的应用请求。对于选项 I, 用户登录成功后，系统要为此创建一个用户管理的进程，包括用户 桌面、环境等，所有用户进程都会在该进程下创建和管理。对于选项Ⅱ,设备分配是通过在系统 中设置相应的数据结构实现的，不需要创建进程，这是操作系统中I/O 核心子系统的内容。对于 选项Ⅲ,启动程序执行是引起创建进程的典型事件，启动程序执行属于③或④。", "answer": "C || 解析：创建进程的原因主要有：①用户登录；②高级调度；③系统处理用户程序的请求；④用户程 序的应用请求。对于选项 I, 用户登录成功后，系统要为此创建一个用户管理的进程，包括用户 桌面、环境等，所有用户进程都会在该进程下创建和管理。对于选项Ⅱ,设备分配是通过在系统 中设置相应的数据结构实现的，不需要创建进程，这是操作系统中I/O 核心子系统的内容。对于 选项Ⅲ,启动程序执行是引起创建进程的典型事件，启动程序执行属于③或④。"}
{"id": "153", "type": "单项选择题", "question": "61.【2011统考真题】在支持多线程的系统中，进程P 创建的若干线程不能共享的是( ) A. 进程 P 的代码段 B. 进程P 中打开的文件 C. 进程P 的全局变量 D. 进程 P 中某线程的栈指针", "answer_label": "D", "answer_explain": "进程是资源分配的基本单位，线程是 CPU  调度的基本单位。进程的代码段、进程打开的文 件、进程的全局变量等都是进程的资源，唯有进程中某线程的栈指针(包含在线程TCB 中)是属 于线程的，属于进程的资源可以共享，属于线程的栈指针是独享的，对其他线程透明。", "answer": "D || 解析：进程是资源分配的基本单位，线程是 CPU  调度的基本单位。进程的代码段、进程打开的文 件、进程的全局变量等都是进程的资源，唯有进程中某线程的栈指针(包含在线程TCB 中)是属 于线程的，属于进程的资源可以共享，属于线程的栈指针是独享的，对其他线程透明。"}
{"id": "154", "type": "单项选择题", "question": "62.【2012统考真题】下列关于进程和线程的叙述中，正确的是() A. 不管系统是否支持线程，进程都是资源分配的基本单位 B. 线程是资源分配的基本单位，进程是调度的基本单位 C. 系统级线程和用户级线程的切换都需要内核的支持 D. 同一进程中的各个线程拥有各自不同的地址空间", "answer_label": "A", "answer_explain": "在引入线程后，进程依然是资源分配的基本单位，线程是调度的基本单位，同一进程中的各 个线程共享进程的地址空间。在用户级线程中，有关线程管理的所有工作都由应用程序完成，无 须内核的干预，内核意识不到线程的存在。", "answer": "A || 解析：在引入线程后，进程依然是资源分配的基本单位，线程是调度的基本单位，同一进程中的各 个线程共享进程的地址空间。在用户级线程中，有关线程管理的所有工作都由应用程序完成，无 须内核的干预，内核意识不到线程的存在。"}
{"id": "155", "type": "单项选择题", "question": "63.【2014统考真题】 一个进程的读磁盘操作完成后，操作系统针对该进程必做的是() A. 修改进程状态为就绪态 B. 降低进程优先级 C. 给进程分配用户内存空间 D. 增加进程时间片大小", "answer_label": "A", "answer_explain": "进程申请读磁盘操作时，因为要等待I/O 操作完成，会把自身阻塞，此时进程变为阻塞态； I/O 操作完成后，进程得到了想要的资源，会从阻塞态转换到就绪态(这是操作系统的行为)。而 降低进程优先级、分配用户内存空间和增加进程的时间片大小都不一定会发生，选择选项A。", "answer": "A || 解析：进程申请读磁盘操作时，因为要等待I/O 操作完成，会把自身阻塞，此时进程变为阻塞态； I/O 操作完成后，进程得到了想要的资源，会从阻塞态转换到就绪态(这是操作系统的行为)。而 降低进程优先级、分配用户内存空间和增加进程的时间片大小都不一定会发生，选择选项A。"}
{"id": "156", "type": "单项选择题", "question": "64.【2014统考真题】下列关于管道(Pipe) 通信的叙述中，正确的是( ) A. 一个管道可实现双向数据传输 B.管道的容量仅受磁盘容量大小限制 C. 进程对管道进行读操作和写操作都可能被阻塞 D. 一个管道只能有一个读进程或一个写进程对其操作", "answer_label": "C", "answer_explain": "普通管道只允许单向通信，数据只能往一个方向流动，要实现双向数据传输，就需要定义两 个方向相反的管道，选项A 错误。管道是一种存储在内存中的、固定大小的缓冲区，管道的大小  通常为内存的一页，其大小并不是受磁盘容量大小的限制，选项B 错误。由于管道的读/写操作都 可能遇到缓冲区满或空的情况，当管道满时，写操作会被阻塞，直到有数据读出；而当管道空时， 读操作会被阻塞，直到有数据写入，因此选项C 正确。一个管道可以有多个读进程或多个写进程  对其进行操作，但是这会增加数据竞争和混乱的风险，为了避免这种情况，应使用互斥锁或信号 量等同步机制来保证每次只有一个进程对管道进行读或写操作，选项D 错误。", "answer": "C || 解析：普通管道只允许单向通信，数据只能往一个方向流动，要实现双向数据传输，就需要定义两 个方向相反的管道，选项A 错误。管道是一种存储在内存中的、固定大小的缓冲区，管道的大小  通常为内存的一页，其大小并不是受磁盘容量大小的限制，选项B 错误。由于管道的读/写操作都 可能遇到缓冲区满或空的情况，当管道满时，写操作会被阻塞，直到有数据读出；而当管道空时， 读操作会被阻塞，直到有数据写入，因此选项C 正确。一个管道可以有多个读进程或多个写进程  对其进行操作，但是这会增加数据竞争和混乱的风险，为了避免这种情况，应使用互斥锁或信号 量等同步机制来保证每次只有一个进程对管道进行读或写操作，选项D 错误。"}
{"id": "157", "type": "单项选择题", "question": "65.【2015统考真题】下列选项中，会导致进程从执行态变为就绪态的事件是( ) A. 执行 P(wait) 操作 B.申请内存失败 C. 启动I/O 设备 D. 被高优先级进程抢占", "answer_label": "D", "answer_explain": "P(wait)操作表示进程请求某一资源，选项A、B 和 C 都因为请求某一资源会进入阻塞态，而 选项D 只是被剥夺了CPU 资源，进入就绪态，一旦得到CPU 即可运行。", "answer": "D || 解析：P(wait)操作表示进程请求某一资源，选项A、B 和 C 都因为请求某一资源会进入阻塞态，而 选项D 只是被剥夺了CPU 资源，进入就绪态，一旦得到CPU 即可运行。"}
{"id": "158", "type": "单项选择题", "question": "66.【2018统考真题】下列选项中，可能导致当前进程P 阻塞的事件是( ) I. 进程P 申请临界资源 II. 进程P 从磁盘读数据 III. 系统将CPU 分配给高优先权的进程 A. 仅I B. 仅Ⅱ C.仅I、II D.I 、II 、III", "answer_label": "C", "answer_explain": "进程等待某资源为可用(不包括CPU)   或等待输入/输出完成均会进入阻塞态，因此选项I、 Ⅱ正确；选项Ⅲ中的情况发生时，进程进入就绪态，因此选项Ⅲ错误。", "answer": "C || 解析：进程等待某资源为可用(不包括CPU)   或等待输入/输出完成均会进入阻塞态，因此选项I、 Ⅱ正确；选项Ⅲ中的情况发生时，进程进入就绪态，因此选项Ⅲ错误。"}
{"id": "159", "type": "单项选择题", "question": "67.【2019统考真题】下列选项中，可能会将进程唤醒的事件是( ) I.I/O 结束 II.某进程退出临界区 III. 当前进程的时间片用完 A.仅I B. 仅II C.仅I、II D.I 、II 、III", "answer_label": "C", "answer_explain": "当被阻塞进程等待的某资源(不包括CPU)  可用时，进程将被唤醒。I/O 结束后，等待该I/O  结束而被阻塞的有关进程会被唤醒，选项I 正确；某进程退出临界区后，之前因需要进入该临界 区而被阻塞的有关进程会被唤醒，选项Ⅱ正确；当前进程的时间片用完后进入就绪队列等待重新 调度，优先级最高的进程获得CPU 资源从就绪态变成执行态，选项Ⅲ错误。", "answer": "C || 解析：当被阻塞进程等待的某资源(不包括CPU)  可用时，进程将被唤醒。I/O 结束后，等待该I/O  结束而被阻塞的有关进程会被唤醒，选项I 正确；某进程退出临界区后，之前因需要进入该临界 区而被阻塞的有关进程会被唤醒，选项Ⅱ正确；当前进程的时间片用完后进入就绪队列等待重新 调度，优先级最高的进程获得CPU 资源从就绪态变成执行态，选项Ⅲ错误。"}
{"id": "160", "type": "单项选择题", "question": "68.【2019统考真题】下列关于线程的描述中，错误的是() A. 内核级线程的调度由操作系统完成 B.操作系统为每个用户级线程建立一个线程控制块 C. 用户级线程间的切换比内核级线程间的切换效率高 D. 用户级线程可以在不支持内核级线程的操作系统上实现", "answer_label": "B", "answer_explain": "应用程序没有进行内核级线程管理的代码，只有一个到内核级线程的编程接口，内核为进程 及其内部的每个线程维护上下文信息，调度也是在内核中由操作系统完成的，选项A正确。用户 级线程的控制块是由用户空间的库函数维护的，操作系统并不知道用户级线程的存在，用户级线 程的控制块一般存放在用户空间的数据结构中，如链表或数组，由用户空间的线程库来管理。操 作系统只负责为每个进程建立一个进程控制块，操作系统只能看到进程，而看不到用户级线程， 所以不会为每个用户级线程建立一个线程控制块。但是，内核级线程的线程控制块是由操作系统 创建的，当一个进程创建一个内核级线程时，操作系统会为该线程分配一个线程控制块，并将其 加入内核的线程管理数据结构，选项B错误。用户级线程的切换可以在用户空间完成，内核级线 程的切换需要操作系统帮助进行调度，因此用户级线程的切换效率更高，选项C正确。用户级线 程的管理工作可以只在用户空间中进行，因此可以在不支持内核级线程的操作系统上实现，选项 D正确。", "answer": "B || 解析：应用程序没有进行内核级线程管理的代码，只有一个到内核级线程的编程接口，内核为进程 及其内部的每个线程维护上下文信息，调度也是在内核中由操作系统完成的，选项A正确。用户 级线程的控制块是由用户空间的库函数维护的，操作系统并不知道用户级线程的存在，用户级线 程的控制块一般存放在用户空间的数据结构中，如链表或数组，由用户空间的线程库来管理。操 作系统只负责为每个进程建立一个进程控制块，操作系统只能看到进程，而看不到用户级线程， 所以不会为每个用户级线程建立一个线程控制块。但是，内核级线程的线程控制块是由操作系统 创建的，当一个进程创建一个内核级线程时，操作系统会为该线程分配一个线程控制块，并将其 加入内核的线程管理数据结构，选项B错误。用户级线程的切换可以在用户空间完成，内核级线 程的切换需要操作系统帮助进行调度，因此用户级线程的切换效率更高，选项C正确。用户级线 程的管理工作可以只在用户空间中进行，因此可以在不支持内核级线程的操作系统上实现，选项 D正确。"}
{"id": "161", "type": "单项选择题", "question": "69.【2020统考真题】下列关于父进程与子进程的叙述中，错误的是( ) A. 父进程与子进程可以并发执行 B. 父进程与子进程共享虚拟地址空间 C. 父进程与子进程有不同的进程控制块 D. 父进程与子进程不能同时使用同一临界资源", "answer_label": "B", "answer_explain": "父进程与子进程当然可以并发执行，选项A 正确。父进程可与子进程共享一部分资源，但不\n能共享虚拟地址空间，在创建子进程时，会为子进程分配资源，如虚拟地址空间等，选项B 错误。 临界资源一次只能为一个进程所用，选项D 正确。进程控制块 (PCB)   是进程存在的唯一标志， 每个进程都有自己的PCB , 选 项C 正确。", "answer": "B || 解析：父进程与子进程当然可以并发执行，选项A 正确。父进程可与子进程共享一部分资源，但不\n能共享虚拟地址空间，在创建子进程时，会为子进程分配资源，如虚拟地址空间等，选项B 错误。 临界资源一次只能为一个进程所用，选项D 正确。进程控制块 (PCB)   是进程存在的唯一标志， 每个进程都有自己的PCB , 选 项C 正确。"}
{"id": "162", "type": "单项选择题", "question": "70.【2021统考真题】下列操作中，操作系统在创建新进程时，必须完成的是() I. 申请空白的进程控制块 II. 初始化进程控制块 III. 设置进程状态为执行态 A.仅I B. 仅I、II C.仅I、II D. 仅Ⅱ、II", "answer_label": "B", "answer_explain": "操作系统感知进程的唯一方式是通过进程控制块 (PCB),     所以创建一个新进程就是为其申 请一个空白的进程控制块，并且初始化一些必要的进程信息，如初始化进程标志信息初始化CPU  状态信息、设置进程优先级等。选项I、Ⅱ正确。创建一个进程时，一般会为其分配除CPU 外的 大多数资源，所以一般将其设置为就绪态，让它等待调度程序的调度。", "answer": "B || 解析：操作系统感知进程的唯一方式是通过进程控制块 (PCB),     所以创建一个新进程就是为其申 请一个空白的进程控制块，并且初始化一些必要的进程信息，如初始化进程标志信息初始化CPU  状态信息、设置进程优先级等。选项I、Ⅱ正确。创建一个进程时，一般会为其分配除CPU 外的 大多数资源，所以一般将其设置为就绪态，让它等待调度程序的调度。"}
{"id": "163", "type": "单项选择题", "question": "71.【2022统考真题】下列事件或操作中，可能导致进程 P由执行态变为阻塞态的是( ) I. 进程P 读文件 II. 进程P 的时间片用完 III. 进程P 申请外设 IV. 进程P 执行信号量的 wait() 操作 A. 仅I、IV B. 仅Ⅱ、III C.仅II、IV D. 仅I、III、IV", "answer_label": "D", "answer_explain": "进程P 读文件时，进程从执行态进入阻塞态，等待磁盘I/O 完成，选项I 正确。进程P 的时 间片用完，导致进程从执行态进入就绪态，转入就绪队列等待下次被调度，选项Ⅱ错误。进程P 申请外设，若外设是独占设备且正在被其他进程使用，则进程P 从执行态进入阻塞态，等待系统 分配外设，选项Ⅲ正确。进程P 执行信号量的wait(操作，若信号量的值小于或等于0,则进程 进入阻塞态，等待其他进程用signal() 操作唤醒，选项IV 正确。", "answer": "D || 解析：进程P 读文件时，进程从执行态进入阻塞态，等待磁盘I/O 完成，选项I 正确。进程P 的时 间片用完，导致进程从执行态进入就绪态，转入就绪队列等待下次被调度，选项Ⅱ错误。进程P 申请外设，若外设是独占设备且正在被其他进程使用，则进程P 从执行态进入阻塞态，等待系统 分配外设，选项Ⅲ正确。进程P 执行信号量的wait(操作，若信号量的值小于或等于0,则进程 进入阻塞态，等待其他进程用signal() 操作唤醒，选项IV 正确。"}
{"id": "164", "type": "单项选择题", "question": "72.【2023统考真题】下列操作完成时，导致 CPU 从内核态转为用户态的是() A. 阻塞进程 B. 执行CPU 调度 C. 唤醒进程 D. 执行系统调用", "answer_label": "D", "answer_explain": "操作系统通过执行软中断指令陷入内核态执行系统调用，系统调用执行完成后，恢复被中断 的进程或设置新进程的CPU 现场，然后返回被中断进程或新进程。只有系统调用是用户进程调用 内核功能，CPU 从用户态切换到内核态，执行完后再返回到用户态。选项A 、B 、C 的操作都是 在内核态进行的，执行前后都可能处在内核态，只有中断返回时才切换为用户态。", "answer": "D || 解析：操作系统通过执行软中断指令陷入内核态执行系统调用，系统调用执行完成后，恢复被中断 的进程或设置新进程的CPU 现场，然后返回被中断进程或新进程。只有系统调用是用户进程调用 内核功能，CPU 从用户态切换到内核态，执行完后再返回到用户态。选项A 、B 、C 的操作都是 在内核态进行的，执行前后都可能处在内核态，只有中断返回时才切换为用户态。"}
{"id": "165", "type": "单项选择题", "question": "73.【2023统考真题】下列由当前线程引起的事件或执行的操作中，可能导致该线程由执行态变为就绪态 的是( )【 号：研七 A.键盘输入 B. 缺页异常 C. 主动出让CPU D. 执行信号量的wait()操作", "answer_label": "C", "answer_explain": "在等待键盘输入的操作中，当前线程处于阻塞态，键盘输入完成后，再调出相应的中断服务 程序进行处理，由中断服务程序负责唤醒当前线程，选项A 错误。当线程检测到缺页异常时，会 调用缺页异常处理程序从外存调入缺失的页面，线程状态从执行态转为阻塞态，选项B 错误。当 线程的时间片用完后，主动放弃 CPU,   此时若线程还未执行完，就进入就绪队列等待下次调度， 此时线程状态从执行态转为就绪态，选项C 正确。线程执行wait() 后，若成功获取资源，则线程 状态不变，若未能获取资源，则线程进入阻塞态，选项D 错误。", "answer": "C || 解析：在等待键盘输入的操作中，当前线程处于阻塞态，键盘输入完成后，再调出相应的中断服务 程序进行处理，由中断服务程序负责唤醒当前线程，选项A 错误。当线程检测到缺页异常时，会 调用缺页异常处理程序从外存调入缺失的页面，线程状态从执行态转为阻塞态，选项B 错误。当 线程的时间片用完后，主动放弃 CPU,   此时若线程还未执行完，就进入就绪队列等待下次调度， 此时线程状态从执行态转为就绪态，选项C 正确。线程执行wait() 后，若成功获取资源，则线程 状态不变，若未能获取资源，则线程进入阻塞态，选项D 错误。"}
{"id": "166", "type": "单项选择题", "question": "74.【2024统考真题】下列选项中，操作系统在终止进程时不一定执行的是( ) A. 终止子进程 B. 回收进程占用的设备 C. 释放进程控制块 D. 回收为进程分配的内存", "answer_label": "A", "answer_explain": "当操作系统终止进程时，所有的进程资源(如内存空间、进程控制块、设备、打开文件、I/O  缓冲区等)都会被释放。有些系统不允许子进程在父进程已终止的情况下存在，对于这类系统， 若一个进程终止，则它的所有子进程也终止，这种现象称为级联终止。但是，不是所有操作系统 都是这么设计的，因此终止子进程不一定在终止进程时执行。", "answer": "A || 解析：当操作系统终止进程时，所有的进程资源(如内存空间、进程控制块、设备、打开文件、I/O  缓冲区等)都会被释放。有些系统不允许子进程在父进程已终止的情况下存在，对于这类系统， 若一个进程终止，则它的所有子进程也终止，这种现象称为级联终止。但是，不是所有操作系统 都是这么设计的，因此终止子进程不一定在终止进程时执行。"}
{"id": "167", "type": "单项选择题", "question": "75.【2024统考真题】若进程 P 中的线程 T 先打开文件，得到文件描述符 fd, 再创建两个线程 Ta 和 Tb, 则 在下列资源中，Ta 与 Tb 可共享的是( ) I. 进程P 的地址空间 II. 线程T 的栈 III.文件描述符fd A. 仅I B. 仅I、III C.仅I、III D.I 、I 、III 2.2 CPU调度", "answer_label": "B", "answer_explain": "线程可理解为轻量级进程，仅拥有一点必不可少、能保证独立运行的资源。例如，在每个线程 中都有一个用于控制线程运行的线程控制块(TCB)、  用于指示被执行指令序列的程序计数器、保 留局部变量、少数状态参数和返回地址等的一组寄存器和堆栈。因此，线程T 的栈空间是线程T 所 独有的，不会被线程Ta 和Tb 共享。多个线程共享所属进程所拥有的资源，进程P 的线程可以访问 进程P 的全部地址空间和资源(如已打开的文件、定时器、信号量机构等)以及它申请到的I/O 设 备等。综上所述，Ta 和 Tb 可共享的是进程P 的地址空间和文件描述符fd。", "answer": "B || 解析：线程可理解为轻量级进程，仅拥有一点必不可少、能保证独立运行的资源。例如，在每个线程 中都有一个用于控制线程运行的线程控制块(TCB)、  用于指示被执行指令序列的程序计数器、保 留局部变量、少数状态参数和返回地址等的一组寄存器和堆栈。因此，线程T 的栈空间是线程T 所 独有的，不会被线程Ta 和Tb 共享。多个线程共享所属进程所拥有的资源，进程P 的线程可以访问 进程P 的全部地址空间和资源(如已打开的文件、定时器、信号量机构等)以及它申请到的I/O 设 备等。综上所述，Ta 和 Tb 可共享的是进程P 的地址空间和文件描述符fd。"}
{"id": "168", "type": "单项选择题", "question": "1. 中级调度的目的是( ) A. 提高CPU 的效率 B. 降低系统开销 C. 提高 CPU 的利用率 D. 节省内存", "answer_label": "D", "answer_explain": "中级调度的主要目的是节省内存，将内存中处于阻塞态或长期不运行的进程挂起到外存，从 而腾出空间给其他进程使用。当这些进程重新具备运行条件时，再从外存调入内存，恢复运行。", "answer": "D || 解析：中级调度的主要目的是节省内存，将内存中处于阻塞态或长期不运行的进程挂起到外存，从 而腾出空间给其他进程使用。当这些进程重新具备运行条件时，再从外存调入内存，恢复运行。"}
{"id": "169", "type": "单项选择题", "question": "2. 进程从创建态转换到就绪态的工作由( )完成。 A. 进程调度 B. 中级调度 C. 高级调度 D. 低级调度", "answer_label": "C", "answer_explain": "进程从创建态转换到就绪态是由高级调度完成的。高级调度(作业调度)的主要任务是从后 备队列中选择一个或一批作业，为其创建PCB, 分配内存等其他资源，并将其插入就绪队列。", "answer": "C || 解析：进程从创建态转换到就绪态是由高级调度完成的。高级调度(作业调度)的主要任务是从后 备队列中选择一个或一批作业，为其创建PCB, 分配内存等其他资源，并将其插入就绪队列。"}
{"id": "170", "type": "单项选择题", "question": "3. 下列哪些指标是调度算法设计时应该考虑的?( ) I. 公平性 II. 资源利用率 III. 互斥性 IV. 平均周转时间 A.I 、II B.I 、II 、IV. C.I 、III 、IV D. 全部都是", "answer_label": "B", "answer_explain": "设计调度算法时应考虑的指标有很多，比较常见的有公平性、资源利用率、平均周转时间、 平均等待时间、平均响应时间。互斥性不是调度算法设计时需要考虑的指标，而是一种同步机制， 用来保证多个进程访问临界资源时不会发生冲突。公众号：小兔网盘免费分享无水印PDF", "answer": "B || 解析：设计调度算法时应考虑的指标有很多，比较常见的有公平性、资源利用率、平均周转时间、 平均等待时间、平均响应时间。互斥性不是调度算法设计时需要考虑的指标，而是一种同步机制， 用来保证多个进程访问临界资源时不会发生冲突。公众号：小兔网盘免费分享无水印PDF"}
{"id": "171", "type": "单项选择题", "question": "4. 时间片轮转调度算法是为了() A. 多个用户能及时干预系统 B. 使系统变得高效 C. 优先级较高的进程得到及时响应 D. 需要 CPU 时间最少的进程最先做", "answer_label": "A", "answer_explain": "时间片轮转的主要目的是，使得多个交互的用户能够得到及时响应，使得每个用户以为“独 占”计算机的使用，因此它并没有偏好，也不会对特殊进程做特殊服务。时间片轮转增加了系统 开销，所以不会使得系统高效运转，吞吐量和周转时间均不如批处理。但其较快速的响应时间使 得用户能够与计算机进行交互，改善了人机环境，满足用户需求。", "answer": "A || 解析：时间片轮转的主要目的是，使得多个交互的用户能够得到及时响应，使得每个用户以为“独 占”计算机的使用，因此它并没有偏好，也不会对特殊进程做特殊服务。时间片轮转增加了系统 开销，所以不会使得系统高效运转，吞吐量和周转时间均不如批处理。但其较快速的响应时间使 得用户能够与计算机进行交互，改善了人机环境，满足用户需求。"}
{"id": "172", "type": "单项选择题", "question": "5. 在单处理器的多进程系统中，进程什么时候占用处理器及决定占用时间的长短是由( )决定的。 A. 进程相应的代码长度 B. 进程总共需要运行的时间 C. 进程特点和进程调度策略 D. 进程完成什么功能", "answer_label": "C", "answer_explain": "进程调度的时机与进程特点有关，如进程是CPU 繁忙型还是I/O 繁忙型、自身的优先级等。 但仅有这些特点是不够的，能否得到调度还取决于进程调度策略，若采用优先级调度算法，则进  程的优先级才起作用。至于占用处理器运行时间的长短，则要看进程自身，若进程是I/O 繁忙型， 运行过程中要频繁访问 I/O 端口，即可能频繁放弃CPU, 所以占用CPU 的时间不会长，一旦放  弃 CPU,  则必须等待下次调度。若进程是CPU 繁忙型，则一旦占有CPU,  就可能运行很长时间， 但运行时间还取决于进程调度策略，大部分情况下，交互式系统为改善用户的响应时间，大多数  采用时间片轮转算法，这种算法在进程占用CPU 达到一定时间后，会强制将其换下，以保证其他  进程的CPU 使用权。因此选择选项C。", "answer": "C || 解析：进程调度的时机与进程特点有关，如进程是CPU 繁忙型还是I/O 繁忙型、自身的优先级等。 但仅有这些特点是不够的，能否得到调度还取决于进程调度策略，若采用优先级调度算法，则进  程的优先级才起作用。至于占用处理器运行时间的长短，则要看进程自身，若进程是I/O 繁忙型， 运行过程中要频繁访问 I/O 端口，即可能频繁放弃CPU, 所以占用CPU 的时间不会长，一旦放  弃 CPU,  则必须等待下次调度。若进程是CPU 繁忙型，则一旦占有CPU,  就可能运行很长时间， 但运行时间还取决于进程调度策略，大部分情况下，交互式系统为改善用户的响应时间，大多数  采用时间片轮转算法，这种算法在进程占用CPU 达到一定时间后，会强制将其换下，以保证其他  进程的CPU 使用权。因此选择选项C。"}
{"id": "173", "type": "单项选择题", "question": "6. 在某单处理器系统中，若此刻有多个就绪态进程，则下列叙述中错误的是() A. 进程调度的目标是让进程轮流使用处理器 B. 当一个进程运行结束后，会调度下一个就绪进程运行 C. 上下文切换是进程调度的实现手段 D. 处于临界区的进程在退出临界区前，无法被调度", "answer_label": "D", "answer_explain": "处于临界区的进程也可能因中断或抢占而导致调度。此外，若进程在临界区内请求的是一个 需要等待的资源，比如打印机，则它主动放弃 CPU,   让其他进程运行。", "answer": "D || 解析：处于临界区的进程也可能因中断或抢占而导致调度。此外，若进程在临界区内请求的是一个 需要等待的资源，比如打印机，则它主动放弃 CPU,   让其他进程运行。"}
{"id": "174", "type": "单项选择题", "question": "7. 下列内容中，不属于进程上下文的是( ) A. 进程现场信息 B. 进程控制信息 C. 中断向量 D. 用户堆栈", "answer_label": "C", "answer_explain": "当一个进程被执行时，CPU 的所有寄存器中的值(进程的现场信息)、进程的状态和控制信 息以及堆栈中的内容被称为该进程的上下文。中断向量不属于进程上下文的一部分，而是一组指 向中断处理程序的指针，存放在内存的固定位置。", "answer": "C || 解析：当一个进程被执行时，CPU 的所有寄存器中的值(进程的现场信息)、进程的状态和控制信 息以及堆栈中的内容被称为该进程的上下文。中断向量不属于进程上下文的一部分，而是一组指 向中断处理程序的指针，存放在内存的固定位置。"}
{"id": "175", "type": "单项选择题", "question": "8. 下列关于进程上下文切换的叙述中，错误的是() A. 进程上下文指进程的代码、数据以及支持进程执行的所有运行环境 B. 进程上下文切换机制实现了不同进程在一个处理器中交替运行的功能 C. 进程上下文切换过程中必须保存换下进程在切换处的程序计数器的值 D. 进程上下文切换过程中必须将换下进程的代码和数据从主存保存到磁盘", "answer_label": "D", "answer_explain": "上下文切换发生在操作系统调度一个新进程到处理器上运行的时候。一个重要的上下文信息 就是程序计数器 (PC)    的值，当前进程被打断的PC 值作为寄存器上下文的一部分保存在进程现 场信息中。进程上下文切换过程中不涉及主存和磁盘的数据交换，选项D 错误。", "answer": "D || 解析：上下文切换发生在操作系统调度一个新进程到处理器上运行的时候。一个重要的上下文信息 就是程序计数器 (PC)    的值，当前进程被打断的PC 值作为寄存器上下文的一部分保存在进程现 场信息中。进程上下文切换过程中不涉及主存和磁盘的数据交换，选项D 错误。"}
{"id": "176", "type": "单项选择题", "question": "9. 在支持页式存储管理和多线程技术的系统中，当一个进程中的线程 T1 切换到同一个进程中的线程T2 执行时，操作系统需要执行的操作是( ) I. 更新程序计数器的值 II. 更新栈基址寄存器的值 III. 更新页基址寄存器的值 IV. 更新进程打开文件表 A.I 、I 、III 、IV B.II 、IV C.I、II D.I 、III 、IV", "answer_label": "C", "answer_explain": "当线程切换时，操作系统需要保存当前线程的程序计数器的值，并恢复新线程的程序计数器， 以便从新线程的正确位置开始执行。在多线程条件下，每个线程拥有各自独立的栈，当线程切换  时，需要保存当前线程的栈基址寄存器的值，并加载新线程的栈基址，以便正确管理栈空间。同 一个进程中的线程共享进程的虚拟地址空间，因此不需要更新页基址寄存器的值。一个进程所打 开的文件也是被这个进程中的所有线程共享的，因此不需要更新进程打开文件表。", "answer": "C || 解析：当线程切换时，操作系统需要保存当前线程的程序计数器的值，并恢复新线程的程序计数器， 以便从新线程的正确位置开始执行。在多线程条件下，每个线程拥有各自独立的栈，当线程切换  时，需要保存当前线程的栈基址寄存器的值，并加载新线程的栈基址，以便正确管理栈空间。同 一个进程中的线程共享进程的虚拟地址空间，因此不需要更新页基址寄存器的值。一个进程所打 开的文件也是被这个进程中的所有线程共享的，因此不需要更新进程打开文件表。"}
{"id": "177", "type": "单项选择题", "question": "10.( )有利于CPU 繁忙型的作业，而不利于I/O 繁忙型的作业。 A. 时间片轮转调度算法 B. 先来先服务调度算法 C. 短作业(进程)优先算法 D. 优先权调度算法", "answer_label": "B", "answer_explain": "FCFS 调度算法比较有利于长作业，而不利于短作业。CPU 繁忙型作业是指该类作业需要占 用很长的CPU 时间，而很少请求I/O 操作，因此 CPU 繁忙型作业类似于长作业，采用 FCFS 可 从容完成计算。I/O 繁忙型作业是指作业执行时需频繁请求 I/O 操作，即可能频繁放弃CPU, 所  以占用CPU 的时间不会太长，一旦放弃CPU,   则必须重新排队等待调度，所以采用SJF  比较适 合。时间片轮转法对于短作业和长作业的时间片都一样，所以地位也几乎一样。优先级调度有利于优先级高的进程，而优先级和作业时间长度是没有必然联系的。因此选择选项B。", "answer": "B || 解析：FCFS 调度算法比较有利于长作业，而不利于短作业。CPU 繁忙型作业是指该类作业需要占 用很长的CPU 时间，而很少请求I/O 操作，因此 CPU 繁忙型作业类似于长作业，采用 FCFS 可 从容完成计算。I/O 繁忙型作业是指作业执行时需频繁请求 I/O 操作，即可能频繁放弃CPU, 所  以占用CPU 的时间不会太长，一旦放弃CPU,   则必须重新排队等待调度，所以采用SJF  比较适 合。时间片轮转法对于短作业和长作业的时间片都一样，所以地位也几乎一样。优先级调度有利于优先级高的进程，而优先级和作业时间长度是没有必然联系的。因此选择选项B。"}
{"id": "178", "type": "单项选择题", "question": "11.下面有关选择进程调度算法的准则中，不正确的是( ) A. 尽快响应交互式用户的请求 B. 尽量提高处理器利用率 C. 尽可能提高系统吞吐量 D. 适当增长进程就绪队列的等待时间", "answer_label": "D", "answer_explain": "在选择进程调度算法时应考虑以下几个准则：①公平：确保每个进程获得合理的CPU 份额； ②有效：使CPU 尽可能地忙碌；③响应时间：使交互用户的响应时间尽可能短；④周转时间：使 批处理用户等待输出的时间尽可能短；⑤吞吐量：使单位时间处理的进程数尽可能最多。由此可 见选项D 不正确。", "answer": "D || 解析：在选择进程调度算法时应考虑以下几个准则：①公平：确保每个进程获得合理的CPU 份额； ②有效：使CPU 尽可能地忙碌；③响应时间：使交互用户的响应时间尽可能短；④周转时间：使 批处理用户等待输出的时间尽可能短；⑤吞吐量：使单位时间处理的进程数尽可能最多。由此可 见选项D 不正确。"}
{"id": "179", "type": "单项选择题", "question": "12.实时系统的进程调度，通常采用()算法。 A. 先来先服务 B. 时间片轮转 C. 抢占式的优先级高者优先 D. 高响应比优先", "answer_label": "C", "answer_explain": "实时系统必须能足够及时地处理某些紧急的外部事件，因此普遍用高优先级，并用“可抢占” 来确保实时处理。", "answer": "C || 解析：实时系统必须能足够及时地处理某些紧急的外部事件，因此普遍用高优先级，并用“可抢占” 来确保实时处理。"}
{"id": "180", "type": "单项选择题", "question": "13. 支持多道程序设计的操作系统在运行过程中，不断地选择新进程运行来实现 CPU 的共享，但其中() 不是引起操作系统选择新进程的直接原因。 A. 运行进程的时间片用完 C. 运行进程要等待某一事件发生", "answer_label": "D", "answer_explain": "操作系统选择新进程的直接原因是当前运行的进程不能继续运行。当运行的进程由于时间片  用完、运行结束、出错、需要等待事件的发生、自我阻塞等，均可以激活调度程序进行重新调度， 选择就绪队列的队首进程投入运行。新进程加入就绪队列不是引起调度的直接原因，当CPU 正在  运行其他进程时，该进程仍需等待。即使是在采用高优先级调度算法的系统中，一个最高优先级 的进程进入就绪队列，也需要考虑是否允许抢占，当不允许抢占时，仍需等待。", "answer": "D || 解析：操作系统选择新进程的直接原因是当前运行的进程不能继续运行。当运行的进程由于时间片  用完、运行结束、出错、需要等待事件的发生、自我阻塞等，均可以激活调度程序进行重新调度， 选择就绪队列的队首进程投入运行。新进程加入就绪队列不是引起调度的直接原因，当CPU 正在  运行其他进程时，该进程仍需等待。即使是在采用高优先级调度算法的系统中，一个最高优先级 的进程进入就绪队列，也需要考虑是否允许抢占，当不允许抢占时，仍需等待。"}
{"id": "181", "type": "单项选择题", "question": "14.进程(线程)调度的时机有() I. 运行的进程(线程)运行完毕 ⅢI.运行的进程(线程)的时间片用完 V.运行的进程(线程)出现错误 A.II 、III 、IV 和 V B.I 和 III B. 运行进程出错 D.有新进程被创建进入就绪态 I. 运行的进程(线程)所需资源未准备好 IV. 运行的进程(线程)自我阻塞 C.II 、IV 和 V D. 全部都是", "answer_label": "D", "answer_explain": "进程(线程)调度的时机包括：运行的进程(线程)运行完毕、运行的进程(线程)自我阻 塞、运行的进程(线程)的时间片用完、运行的进程(线程)所需的资源没有准备好(会阻塞进 程)、运行的进程(线程)出现错误(会终止进程)。因此，选项I 、I 、II 、IV   和 V 都正确。", "answer": "D || 解析：进程(线程)调度的时机包括：运行的进程(线程)运行完毕、运行的进程(线程)自我阻 塞、运行的进程(线程)的时间片用完、运行的进程(线程)所需的资源没有准备好(会阻塞进 程)、运行的进程(线程)出现错误(会终止进程)。因此，选项I 、I 、II 、IV   和 V 都正确。"}
{"id": "182", "type": "单项选择题", "question": "15. 设有4个作业同时到达，每个作业的执行时间均为2h,它们在一台处理器上按单道式运行，则平均周转 时间为( )【微信公 A.1h B.5h C.2.5h D.8h", "answer_label": "B", "answer_explain": "4个作业的周转时间分别是2h,4h,6h,8h,所以4个作业的总周转时间为2+4+6+8=20h。 此时，平均周转时间=各个作业周转时间之和/作业数=20/4=5小时。", "answer": "B || 解析：4个作业的周转时间分别是2h,4h,6h,8h,所以4个作业的总周转时间为2+4+6+8=20h。 此时，平均周转时间=各个作业周转时间之和/作业数=20/4=5小时。"}
{"id": "183", "type": "单项选择题", "question": "16.若每个作业只能建立一个进程，为了照顾短作业用户，应采用( );为了照顾紧急作业用户，应采用 ( );为了能实现人机交互，应采用( );而能使短作业、长作业和交互作业用户都满意，应采用( ) A.FCFS 调度算法 B.短作业优先调度算法 C. 时间片轮转调度算法 D. 多级反馈队列调度算法 E.剥夺式优先级调度算法", "answer_label": "B、E 、C 、D", "answer_explain": "照顾短作业用户，选择短作业优先调度算法；照顾紧急作业用户，即选择优先级高的作业优先 调度，采用基于优先级的剥夺调度算法；实现人机交互，要保证每个作业都能在一定时间内轮到， 采用时间片轮转法；使各种作业用户满意，要处理多级反馈，所以选择多级反馈队列调度算法。", "answer": "B、E 、C 、D || 解析：照顾短作业用户，选择短作业优先调度算法；照顾紧急作业用户，即选择优先级高的作业优先 调度，采用基于优先级的剥夺调度算法；实现人机交互，要保证每个作业都能在一定时间内轮到， 采用时间片轮转法；使各种作业用户满意，要处理多级反馈，所以选择多级反馈队列调度算法。"}
{"id": "184", "type": "单项选择题", "question": "17.( )优先级是在创建进程时确定的，确定之后在整个运行期间不再改变。 A. 先来先服务 B. 动态 C.短作业 D. 静态", "answer_label": "D", "answer_explain": "优先级调度算法分静态和动态两种。静态优先级在进程创建时确定，之后不再改变。", "answer": "D || 解析：优先级调度算法分静态和动态两种。静态优先级在进程创建时确定，之后不再改变。"}
{"id": "185", "type": "单项选择题", "question": "18. 现在有三个同时到达的作业 J₁,J₂,J₃, 它们的执行时间分别是T₁,T₂,T₃, 且 T₁<T₂<T₃ 。 系统按单道方式 运行且采用短作业优先调度算法，则平均周转时间是( ) A.T₁+T₂+T₃ B.(3T₁+2T₂+T₃)/3 C.(T₁+T₂+T₃)/3 D.(T₁+2T₂+3T₃)/3", "answer_label": "B", "answer_explain": "系统采用短作业优先调度算法，作业的执行顺序为J₁,J₂,J₃,J₁     的周转时间为T₁,J₂   的周转时间为\nT₁+T₂,J₃   的周转时间为T₁+T₂+T₃,    则平均周转时间为(T₁+T₁+T₂+T₁+T₂+T₃)/3=(3T₁+2T₂+T₃)/3。", "answer": "B || 解析：系统采用短作业优先调度算法，作业的执行顺序为J₁,J₂,J₃,J₁     的周转时间为T₁,J₂   的周转时间为\nT₁+T₂,J₃   的周转时间为T₁+T₂+T₃,    则平均周转时间为(T₁+T₁+T₂+T₁+T₂+T₃)/3=(3T₁+2T₂+T₃)/3。"}
{"id": "186", "type": "单项选择题", "question": "19. 设有三个作业，其运行时间分别是2h,5h,3h, 假定它们同时到达，并在同一台处理器上以单道方式运行， 则平均周转时间最小的执行顺序是( ) A.J1,J²,J₃ B.J₃,J₂,J₁ C.J₂,J₁,J₃ D.J₁,J₃,J₂", "answer_label": "D", "answer_explain": "在同一台处理器上以单道方式运行时，要想获得最短的平均周转时间，用短作业优先调度算 法会有较好的效果。就本题目而言：选项A 的平均周转时间=(2+7+10)/3h=19/3h;     选项B 的 平均周转时间=(3+8+10)/3h=7h 。 选项C 的平均周转时间=(5+7+10)/3h=22/3h;     选项 D 的 平均周转时间=(2+5+10)/3h=17/3h。", "answer": "D || 解析：在同一台处理器上以单道方式运行时，要想获得最短的平均周转时间，用短作业优先调度算 法会有较好的效果。就本题目而言：选项A 的平均周转时间=(2+7+10)/3h=19/3h;     选项B 的 平均周转时间=(3+8+10)/3h=7h 。 选项C 的平均周转时间=(5+7+10)/3h=22/3h;     选项 D 的 平均周转时间=(2+5+10)/3h=17/3h。"}
{"id": "187", "type": "单项选择题", "question": "20. 采用时间片轮转调度算法分配CPU 时，当处于运行态的进程用完一个时间片后，它的状态是( )状态。 A. 阻塞 B. 运行 C. 就绪 D.消亡", "answer_label": "C", "answer_explain": "处于运行态的进程用完一个时间片后，其状态会变为就绪态，等待下一次处理器调度。进程执 行完最后的语句并使用系统调用exit 请求操作系统删除它或出现一些异常情况时，进程才会终止。", "answer": "C || 解析：处于运行态的进程用完一个时间片后，其状态会变为就绪态，等待下一次处理器调度。进程执 行完最后的语句并使用系统调用exit 请求操作系统删除它或出现一些异常情况时，进程才会终止。"}
{"id": "188", "type": "单项选择题", "question": "21. 一个作业8:00到达系统，估计运行时间为1h。若10:00开始执行该作业，其响应比是() A.2 B.1 C.3 D.0.5", "answer_label": "C", "answer_explain": "", "answer": "C || 解析："}
{"id": "189", "type": "单项选择题", "question": "22.关于优先权大小的论述中，正确的是( ) A. 计算型作业的优先权，应高于I/O 型作业的优先权 B. 用户进程的优先权，应高于系统进程的优先权 C. 在动态优先权中，随着作业等待时间的增加，其优先权将随之下降 D. 在动态优先权中，随着进程执行时间的增加，其优先权降低", "answer_label": "D", "answer_explain": "优先级算法中，I/O  繁忙型作业要优于计算繁忙型作业，系统进程的优先权应高于用户进程  的优先权。作业的优先权与长作业、短作业或系统资源要求的多少没有必然的关系。在动态优先  权中，随着进程执行时间的增加其优先权随之降低，随着作业等待时间的增加其优先权相应上升。", "answer": "D || 解析：优先级算法中，I/O  繁忙型作业要优于计算繁忙型作业，系统进程的优先权应高于用户进程  的优先权。作业的优先权与长作业、短作业或系统资源要求的多少没有必然的关系。在动态优先  权中，随着进程执行时间的增加其优先权随之降低，随着作业等待时间的增加其优先权相应上升。"}
{"id": "190", "type": "单项选择题", "question": "23. 下列调度算法中，( )调度算法是绝对可抢占的。 A. 先来先服务 B.时间片轮转 C. 优先级 D. 短进程优先", "answer_label": "B", "answer_explain": "时间片轮转算法是按固定的时间配额来运行的，时间一到，不管是否完成，当前的进程必须 撤下，调度新的进程，因此它是由时间配额决定的、是绝对可抢占的。而优先级算法和短进程优 先算法都可分为抢占式和不可抢占式。", "answer": "B || 解析：时间片轮转算法是按固定的时间配额来运行的，时间一到，不管是否完成，当前的进程必须 撤下，调度新的进程，因此它是由时间配额决定的、是绝对可抢占的。而优先级算法和短进程优 先算法都可分为抢占式和不可抢占式。"}
{"id": "191", "type": "单项选择题", "question": "24.作业是用户提交的，进程是由系统自动生成的，除此之外，两者的区别是() A.两者执行不同的程序段 B. 前者以用户任务为单位，后者以操作系统控制为单位 C. 前者是批处理的，后者是分时的 D. 后者是可并发执行，前者则不同", "answer_label": "B", "answer_explain": "作业是从用户角度出发的，它由用户提交，以用户任务为单位；进程是从操作系统出发的， 由系统生成，是操作系统的资源分配和独立运行的基本单位。", "answer": "B || 解析：作业是从用户角度出发的，它由用户提交，以用户任务为单位；进程是从操作系统出发的， 由系统生成，是操作系统的资源分配和独立运行的基本单位。"}
{"id": "192", "type": "单项选择题", "question": "25.进程调度算法采用固定时间片轮转调度算法，当时间片过大时，就会使时间片轮转法算法转化为( ) 调度算法。 A.高响应比优先 B. 先来先服务 C. 短进程优先 D. 以上选项都不对", "answer_label": "B", "answer_explain": "时间片轮转调度算法在实际运行中也按先后顺序使用时间片，时间片过大时，我们可以认为 其大于进程需要的运行时间，即转变为先来先服务调度算法。", "answer": "B || 解析：时间片轮转调度算法在实际运行中也按先后顺序使用时间片，时间片过大时，我们可以认为 其大于进程需要的运行时间，即转变为先来先服务调度算法。"}
{"id": "193", "type": "单项选择题", "question": "26.有以下的进程需要调度执行(见下表): 1)若用非抢占式短进程优先调度算法，问这5个进程的平均周转时间是多少? 2)若采用抢占式短进程优先调度算法，问这5个进程的平均周转时间是多少? A.8.62;6.34 B.8.62;6.8 C.10.62;6.34 D.10.62;6.8", "answer_label": "D", "answer_explain": "对于这种类型的题目，我们可以采用广义甘特图来求解，甘特图的画法在1.2节的习题中已 经有所介绍。我们直接给出甘特图(见下图),以非抢占为例。\n在0时刻，进程 P₁ 到达，于是处理器分配给 P₁,   因为是不可抢占的，所以P₁一旦获得处理 器，就会运行直到结束；在时刻9,所有进程已经到达，根据短进程优先调度，会把处理器分配 给 P₃,   接下来就是 Ps;   然后，因为P₂,P⁴    的预计运行时间一样，所以在P₂ 和 P₄ 之间用先来先服 务调度，优先把处理器分配给P₂,   最后再分配给P₄,   完成任务。\n周转时间=完成时间-作业到达时间，从图中显然可以得到各进程的完成时间，于是 P₁ 的  周转时间是9-0=9;P₂ 的周转时间是16-0.4=15.6;P₃ 的周转时间是10-1=9;P₄ 的周转时间  是20-5.5=14.5; P₅ 的周转时间是12-7=5;平均周转时间为(9+15.6+9+14.5+5)/5=10.62。\n同理，抢占式的周转时间也可通过画甘特图求得，而且直观、不易出错。\n抢占式的平均周转时间为6.8。\n甘特图在操作系统中有着广泛的应用，本节习题中会有不少这种类型的题目，若读者按照上 面的方法求解，则解题时就可以做到胸有成竹。", "answer": "D || 解析：对于这种类型的题目，我们可以采用广义甘特图来求解，甘特图的画法在1.2节的习题中已 经有所介绍。我们直接给出甘特图(见下图),以非抢占为例。\n在0时刻，进程 P₁ 到达，于是处理器分配给 P₁,   因为是不可抢占的，所以P₁一旦获得处理 器，就会运行直到结束；在时刻9,所有进程已经到达，根据短进程优先调度，会把处理器分配 给 P₃,   接下来就是 Ps;   然后，因为P₂,P⁴    的预计运行时间一样，所以在P₂ 和 P₄ 之间用先来先服 务调度，优先把处理器分配给P₂,   最后再分配给P₄,   完成任务。\n周转时间=完成时间-作业到达时间，从图中显然可以得到各进程的完成时间，于是 P₁ 的  周转时间是9-0=9;P₂ 的周转时间是16-0.4=15.6;P₃ 的周转时间是10-1=9;P₄ 的周转时间  是20-5.5=14.5; P₅ 的周转时间是12-7=5;平均周转时间为(9+15.6+9+14.5+5)/5=10.62。\n同理，抢占式的周转时间也可通过画甘特图求得，而且直观、不易出错。\n抢占式的平均周转时间为6.8。\n甘特图在操作系统中有着广泛的应用，本节习题中会有不少这种类型的题目，若读者按照上 面的方法求解，则解题时就可以做到胸有成竹。"}
{"id": "194", "type": "单项选择题", "question": "27.有5个批处理作业 A,B,C,D,E 几乎同时到达，其预计运行时间分别为10,6,2,4,8,其优先级(由外部 设定)分别为3,5,2,1,4,这里5为最高优先级。以下各种调度算法中，平均周转时间为14的是( )调 度算法。 A. 时间片轮转(时间片为1) B. 优先级调度 C. 先来先服务(按照顺序10,6,2,4,8) D.短作业优先", "answer_label": "D", "answer_explain": "当这五个批处理作业采用短作业优先调度算法时，平均周转时间=[2+(2+4)+(2+4+6)+(2+ 4+6+8)+(2+4+6+8+10)]/5=14。\n这道题主要考查读者对各种优先调度算法的认识。若按照18题中的方法求解，则可能要花 费一定的时间，但这是值得的，因为可以起到熟练基本方法的效果。在考试中很少会遇到操作量\n和计算量如此大的题目，所以读者不用担心。", "answer": "D || 解析：当这五个批处理作业采用短作业优先调度算法时，平均周转时间=[2+(2+4)+(2+4+6)+(2+ 4+6+8)+(2+4+6+8+10)]/5=14。\n这道题主要考查读者对各种优先调度算法的认识。若按照18题中的方法求解，则可能要花 费一定的时间，但这是值得的，因为可以起到熟练基本方法的效果。在考试中很少会遇到操作量\n和计算量如此大的题目，所以读者不用担心。"}
{"id": "195", "type": "单项选择题", "question": "28. 使用抢占式最短剩余时间优先调度算法对下列进程进行调度，总周转时间是( ) A.25h B.26h C.27h D.28h", "answer_label": "C", "answer_explain": "根据各个进程的到达时间和预计运行时间，画出甘特图如下。由此可知，各个进程的周转时 间分别为4h 、1h 、8h 、12h 、2h,   所 以 总 周 转 时 间 为 4 + 1 + 8 + 1 2 + 2 = 2 7h。", "answer": "C || 解析：根据各个进程的到达时间和预计运行时间，画出甘特图如下。由此可知，各个进程的周转时 间分别为4h 、1h 、8h 、12h 、2h,   所 以 总 周 转 时 间 为 4 + 1 + 8 + 1 2 + 2 = 2 7h。"}
{"id": "196", "type": "单项选择题", "question": "29. 假设系统采用多级反馈队列调度算法，系统中设置了三个不同优先级的队列A 、B和 C, 优先级A>B>C, A 的时间片为10ms,B 的时间片为20ms,C 的时间片为30ms。当 t=0 时，进程 P₁ 到达，P₁ 所需的运行 时间为90ms; 当 t=30ms 时，进程P₂ 到达，P₂ 所需的运行时间为30ms,不考虑任何其他系统开销，进程 P₁ 的周转时间为() A.90ms B.100ms C.110ms D.120ms", "answer_label": "D", "answer_explain": "新进程总是先进入第一级队列的队尾。在0～10ms 时 段 ，P₁ 在队列A 上运行；在10～30ms 时 段 ，P₁ 在队列B  上运行；当t=30ms    时 ，P₂ 进入队列A,    因此在30～40ms 时 段 ，P₂ 在队列A 上运行；在40～60ms 时 段 ，P₂ 在队列B 上运行，此时 P₂ 运行结束；最后P₁  在60～90ms 和90~ 120ms 时段内，于队列C  上运行2个时间片，因此P₁ 的总周转时间为120ms。", "answer": "D || 解析：新进程总是先进入第一级队列的队尾。在0～10ms 时 段 ，P₁ 在队列A 上运行；在10～30ms 时 段 ，P₁ 在队列B  上运行；当t=30ms    时 ，P₂ 进入队列A,    因此在30～40ms 时 段 ，P₂ 在队列A 上运行；在40～60ms 时 段 ，P₂ 在队列B 上运行，此时 P₂ 运行结束；最后P₁  在60～90ms 和90~ 120ms 时段内，于队列C  上运行2个时间片，因此P₁ 的总周转时间为120ms。"}
{"id": "197", "type": "单项选择题", "question": "30. 分时操作系统通常采用()调度算法来为用户服务。 A. 时间片轮转 B. 先来先服务 C. 短作业优先 D. 优先级", "answer_label": "A", "answer_explain": "分时系统需要同时满足多个用户的需要，因此把处理器时间轮流分配给多个用户作业使用， 即采用时间片轮转调度算法。", "answer": "A || 解析：分时系统需要同时满足多个用户的需要，因此把处理器时间轮流分配给多个用户作业使用， 即采用时间片轮转调度算法。"}
{"id": "198", "type": "单项选择题", "question": "31. 在进程调度算法中，对短进程不利的是( ) A. 短进程优先调度算法 B. 先来先服务调度算法 C. 高响应比优先调度算法 D. 多级反馈队列调度算法", "answer_label": "B", "answer_explain": "先来先服务调度算法中，若一个长进程(作业)先到达系统，则会使后面的许多短进程(作 业)等待很长的时间，因此对短进程(作业)不利。", "answer": "B || 解析：先来先服务调度算法中，若一个长进程(作业)先到达系统，则会使后面的许多短进程(作 业)等待很长的时间，因此对短进程(作业)不利。"}
{"id": "199", "type": "单项选择题", "question": "32. 假设系统中所有进程同时到达，则使进程平均周转时间最短的是()调度算法。 A. 先来先服务 B. 短进程优先 C. 时间片轮转 D. 优先级", "answer_label": "B", "answer_explain": "短进程优先调度算法具有最短的平均周转时间。平均周转时间=各进程周转时间之和/进程数。因 为每个进程的执行时间都是固定的，所以变化的是等待时间，只有短进程优先算法能最小化等待时间。", "answer": "B || 解析：短进程优先调度算法具有最短的平均周转时间。平均周转时间=各进程周转时间之和/进程数。因 为每个进程的执行时间都是固定的，所以变化的是等待时间，只有短进程优先算法能最小化等待时间。"}
{"id": "200", "type": "单项选择题", "question": "33. 多级反馈队列调度算法不具备的特性是( ) A. 资源利用率高 B. 响应速度快 C. 系统开销小 D. 并行度高", "answer_label": "C", "answer_explain": "系统开销小不是多级反馈队列调度算法的特性，而正好相反，该算法需要设置多个就绪队列， 并且要在不同的队列之间进行进程的转移和抢占，因此增加了系统开销。", "answer": "C || 解析：系统开销小不是多级反馈队列调度算法的特性，而正好相反，该算法需要设置多个就绪队列， 并且要在不同的队列之间进行进程的转移和抢占，因此增加了系统开销。"}
{"id": "201", "type": "单项选择题", "question": "34. 下列调度算法中，系统开销最小的调度算法是( ) A. 高响应比优先调度算法 B. 多级反馈队列调度算法 C. 先来先服务调度算法 D. 时间片轮转调度算法", "answer_label": "C", "answer_explain": "高响应比优先算法需要根据进程的等待时间和服务时间来计算响应比；多级反馈队列算法涉 及多个队列的管理，以及进程在队列之间的转移，它们的系统开销都较大。时间片轮转算法虽然 简单，但它需要为每个进程分配一个固定的时间片，并且在时间片用完时进行上下文切换，因此 它的系统开销也不小。先来先服务算法是一种最简单的调度算法，它只需按照进程到达的先后顺 序进行调度，无须进行任何优先级或时间片的判断和分配，因此系统开销最小。", "answer": "C || 解析：高响应比优先算法需要根据进程的等待时间和服务时间来计算响应比；多级反馈队列算法涉 及多个队列的管理，以及进程在队列之间的转移，它们的系统开销都较大。时间片轮转算法虽然 简单，但它需要为每个进程分配一个固定的时间片，并且在时间片用完时进行上下文切换，因此 它的系统开销也不小。先来先服务算法是一种最简单的调度算法，它只需按照进程到达的先后顺 序进行调度，无须进行任何优先级或时间片的判断和分配，因此系统开销最小。"}
{"id": "202", "type": "单项选择题", "question": "35. 下列进程调度算法中，可能导致饥饿现象的有( ) I.先来先服务调度算法 II.短作业优先调度算法 III. 优先级调度算法 IV.时间片轮转调度算法 A.I 和 I B.II 和 III C.II 、II 和 IV D.III", "answer_label": "B", "answer_explain": "先来先服务算法和时间片轮转算法都不会出现饥饿现象，因为它们都是按照进程到达的顺序 或固定的时间片来调度的，不会因为进程的特征而忽略某些进程。短作业优先算法(也可视为一 种特殊的优先级算法)和优先级算法都可能出现饥饿现象，因为它们都是根据进程的服务时间或 优先级来调度的，这样就可能导致一些长作业或低优先级的进程长期得不到调度。", "answer": "B || 解析：先来先服务算法和时间片轮转算法都不会出现饥饿现象，因为它们都是按照进程到达的顺序 或固定的时间片来调度的，不会因为进程的特征而忽略某些进程。短作业优先算法(也可视为一 种特殊的优先级算法)和优先级算法都可能出现饥饿现象，因为它们都是根据进程的服务时间或 优先级来调度的，这样就可能导致一些长作业或低优先级的进程长期得不到调度。"}
{"id": "203", "type": "单项选择题", "question": "36. 与单处理机调度相比，多处理机调度需要额外考虑的调度目标是() I. 负载平衡 II. 处理器亲和性 III. 进程周转时间 A.I 和 I B.IⅡ 和 III C.I 和 II D.I 、Ⅱ 和 II", "answer_label": "A", "answer_explain": "多处理机调度需要额外考虑负载平衡和处理器亲和性两个调度目标。负载平衡是指应尽量让 每个CPU 都同等地忙碌，处理器亲和性是指应尽量让一个进程运行在同一个 CPU 上。", "answer": "A || 解析：多处理机调度需要额外考虑负载平衡和处理器亲和性两个调度目标。负载平衡是指应尽量让 每个CPU 都同等地忙碌，处理器亲和性是指应尽量让一个进程运行在同一个 CPU 上。"}
{"id": "204", "type": "单项选择题", "question": "37. 【2009统考真题】下列进程调度算法中，综合考虑进程等待时间和执行时间的是( ) A. 时间片轮转调度算法 B. 短进程优先调度算法 C. 先来先服务调度算法 D. 高响应比优先调度算法", "answer_label": "D", "answer_explain": "响应比=(等待时间+执行时间)/执行时间。 它综合考虑了每个进程的等待时间和执行时 间，对于同时到达的长进程和短进程，短进程会优先执行，以提高系统吞吐量；而长进程的响应 比可以随等待时间的增加而提高，不会产生进程无法调度的情况。", "answer": "D || 解析：响应比=(等待时间+执行时间)/执行时间。 它综合考虑了每个进程的等待时间和执行时 间，对于同时到达的长进程和短进程，短进程会优先执行，以提高系统吞吐量；而长进程的响应 比可以随等待时间的增加而提高，不会产生进程无法调度的情况。"}
{"id": "205", "type": "单项选择题", "question": "38.【2010统考真题】下列选项中，降低进程优先级的合理时机是( ) A. 进程时间片用完 B. 进程刚完成I/O 操作，进入就绪队列 C. 进程长期处于就绪队列 D. 进程从就绪态转为运行态", "answer_label": "A", "answer_explain": "选项 A 中进程时间片用完，可降低其优先级以让其他进程被调度进入执行状态。选项 B 中 进程刚完成I/O, 进入就绪队列等待被 CPU 调度，为了让其尽快处理I/O 结果，因此应提高优先 级。选项C 中进程长期处于就绪队列，为不至于产生饥饿现象，也应适当提高优先级。选项D 中 进程的优先级不应该在此时降低，而应在时间片用完后再降低。", "answer": "A || 解析：选项 A 中进程时间片用完，可降低其优先级以让其他进程被调度进入执行状态。选项 B 中 进程刚完成I/O, 进入就绪队列等待被 CPU 调度，为了让其尽快处理I/O 结果，因此应提高优先 级。选项C 中进程长期处于就绪队列，为不至于产生饥饿现象，也应适当提高优先级。选项D 中 进程的优先级不应该在此时降低，而应在时间片用完后再降低。"}
{"id": "206", "type": "单项选择题", "question": "39.【2011统考真题】下列选项中，满足短作业优先且不会发生饥饿现象的是( )调度算法。 A. 先来先服务 B. 高响应比优先 C. 时间片轮转 D. 非抢占式短作业优先", "answer_label": "B", "answer_explain": "响应比=(等待时间+执行时间)/执行时间。高响应比优先算法在等待时间相同的情况下， 作业执行时间越短，响应比越高，满足短任务优先。随着长作业等待时间的增加，响应比会变大， 执行机会也会增大，因此不会发生饥饿现象。先来先服务和时间片轮转不符合短任务优先，非抢 占式短任务优先会产生饥饿现象。", "answer": "B || 解析：响应比=(等待时间+执行时间)/执行时间。高响应比优先算法在等待时间相同的情况下， 作业执行时间越短，响应比越高，满足短任务优先。随着长作业等待时间的增加，响应比会变大， 执行机会也会增大，因此不会发生饥饿现象。先来先服务和时间片轮转不符合短任务优先，非抢 占式短任务优先会产生饥饿现象。"}
{"id": "207", "type": "单项选择题", "question": "40.【2012统考真题】一个多道批处理系统中仅有 P₁ 和 P₂ 两个作业，P₂ 比 P1 晚 5ms 到达，它的计算和I/O 操作顺序如下： P₁: 计算60ms,I/O 80ms,计算20ms P₂: 计算120ms,I/O 40ms,计算40ms 若不考虑调度和切换时间，则完成两个作业需要的时间最少是( ) A.240ms B.260ms C.340ms D.360ms", "answer_label": "B", "answer_explain": "由于P₂ 比 P₁ 晚 5ms 到 达 ，P₁ 先占用CPU,   作业运行的甘特图如下。", "answer": "B || 解析：由于P₂ 比 P₁ 晚 5ms 到 达 ，P₁ 先占用CPU,   作业运行的甘特图如下。"}
{"id": "208", "type": "单项选择题", "question": "41.【2012统考真题】若某单处理器多进程系统中有多个就绪态进程，则下列关于处理机调度的叙述中，错 误的是( ) A. 在进程结束时能进行处理机调度 B. 创建新进程后能进行处理机调度 C. 在进程处于临界区时不能进行处理机调度 D. 在系统调用完成并返回用户态时能进行处理机调度", "answer_label": "C", "answer_explain": "选项A 、B 、D 显然属于可以进行CPU 调度的情况。对于选项C,   处于临界区的进程也可能 因中断或抢占而导致调度，此外，若进程在临界区内请求的是一个需要等待的资源，比如打印机， 则它主动放弃 CPU,   让其他进程运行。", "answer": "C || 解析：选项A 、B 、D 显然属于可以进行CPU 调度的情况。对于选项C,   处于临界区的进程也可能 因中断或抢占而导致调度，此外，若进程在临界区内请求的是一个需要等待的资源，比如打印机， 则它主动放弃 CPU,   让其他进程运行。"}
{"id": "209", "type": "单项选择题", "question": "42. 【2013统考真题】某系统正在执行三个进程 P₁,P₂ 和 P³, 各进程的计算 (CPU) 时间和I/O 时间比例如 下表所示。为提高系统资源利用率，合理的进程优先级设置应为( ) A.P₁>P₂>P₃ B.P₃>P₂>P₁ C.P₂>P₁=P₃ D.P1>P₂=P₃", "answer_label": "B", "answer_explain": "为了合理地设置进程优先级，应综合考虑进程的CPU 时间和I/O 时间。对于优先级调度算法， 一般来说，I/O 型作业的优先权高于计算型作业的优先权，这是由于I/O 操作需要及时完成，它没  有办法长时间地保存所要输入/输出的数据，所以考虑到系统资源利用率，要选择I/O 繁忙型作业  有更高的优先级。", "answer": "B || 解析：为了合理地设置进程优先级，应综合考虑进程的CPU 时间和I/O 时间。对于优先级调度算法， 一般来说，I/O 型作业的优先权高于计算型作业的优先权，这是由于I/O 操作需要及时完成，它没  有办法长时间地保存所要输入/输出的数据，所以考虑到系统资源利用率，要选择I/O 繁忙型作业  有更高的优先级。"}
{"id": "210", "type": "单项选择题", "question": "43.【2014统考真题】下列调度算法中，不可能导致饥饿现象的是( ) A. 时间片轮转 B. 静态优先数调度 C. 非抢占式短任务优先 D. 抢占式短任务优先", "answer_label": "A", "answer_explain": "采用静态优先级调度且系统总是出现优先级高的任务时，优先级低的任务总是得不到 CPU  而产生饥饿现象；而短任务优先调度不管是抢占式的还是非抢占的，当系统总是出现新来的短任 务时，长任务会总是得不到CPU, 产生饥饿现象，因此选项B 、C 、D 都错误。", "answer": "A || 解析：采用静态优先级调度且系统总是出现优先级高的任务时，优先级低的任务总是得不到 CPU  而产生饥饿现象；而短任务优先调度不管是抢占式的还是非抢占的，当系统总是出现新来的短任 务时，长任务会总是得不到CPU, 产生饥饿现象，因此选项B 、C 、D 都错误。"}
{"id": "211", "type": "单项选择题", "question": "44.【2016统考真题】某单 CPU 系统中有输入和输出设备各1台，现有3个并发执行的作业，每个作业的输 入、计算和输出时间均分别为2ms,3ms 和 4ms, 且都按输入、计算和输出的顺序执行，则执行完3个作 业需要的时间最少是( ) A.15ms B.17ms C.22ms D.27ms", "answer_label": "B", "answer_explain": "这类调度题目最好画图。因CPU、输入设备、输出设备都只有一个，因此各操作步骤不能重 叠，画出运行时的甘特图后，就能清楚地看到不同作业间的时序关系，如下图所示。", "answer": "B || 解析：这类调度题目最好画图。因CPU、输入设备、输出设备都只有一个，因此各操作步骤不能重 叠，画出运行时的甘特图后，就能清楚地看到不同作业间的时序关系，如下图所示。"}
{"id": "212", "type": "单项选择题", "question": "45. 【2017统考真题】假设4个作业到达系统的时刻和运行时间如下表所示。系统在 t=2 时开始作业调 度。若分别采用先来先服务和短作业优先调度算法，则选中的作业分别是() A.J2,J₃ B.J₁,J₄ C.J₂,J₄ D.J₁,J₃", "answer_label": "D", "answer_explain": "注意，系统是在t=2   时开始作业调度的，此时 J₄ 还没有到达。FCFS 调度算法的特点是作业 来得越早，优先级就越高，因此选择 J₁。SJF 调度算法的特点是作业运行时间越短，优先级就越 高 ， 因 此 选 择J₃。", "answer": "D || 解析：注意，系统是在t=2   时开始作业调度的，此时 J₄ 还没有到达。FCFS 调度算法的特点是作业 来得越早，优先级就越高，因此选择 J₁。SJF 调度算法的特点是作业运行时间越短，优先级就越 高 ， 因 此 选 择J₃。"}
{"id": "213", "type": "单项选择题", "question": "46.【2017统考真题】下列有关基于时间片的进程调度的叙述中，错误的是( ) A. 时间片越短，进程切换的次数越多，系统开销越大 B. 当前进程的时间片用完后，该进程状态由执行态变为阻塞态 C. 时钟中断发生后，系统会修改当前进程在时间片内的剩余时间 D. 影响时间片大小的主要因素包括响应时间、系统开销和进程数量等", "answer_label": "B", "answer_explain": "进程切换带来系统开销，切换次数越多，开销就越大，选项A 正确。当前进程的时间片用完 后，其状态由执行态变为就绪态，选项B 错误。时钟中断是系统中特定的周期性时钟节拍，操作系 统通过它来确定时间间隔，实现时间的延时和任务的超时，选项C 正确。现代操作系统为了保证性 能最优，通常根据响应时间、系统开销、进程数量、进程运行时间等因素确定时间片大小，选项D 正 确 。", "answer": "B || 解析：进程切换带来系统开销，切换次数越多，开销就越大，选项A 正确。当前进程的时间片用完 后，其状态由执行态变为就绪态，选项B 错误。时钟中断是系统中特定的周期性时钟节拍，操作系 统通过它来确定时间间隔，实现时间的延时和任务的超时，选项C 正确。现代操作系统为了保证性 能最优，通常根据响应时间、系统开销、进程数量、进程运行时间等因素确定时间片大小，选项D 正 确 。"}
{"id": "214", "type": "单项选择题", "question": "47. 【2018统考真题】某系统采用基于优先权的非抢占式进程调度策略，完成一次进程调度和进程切换的 系统时间开销为1 μs。在 T 时刻就绪队列中有3个进程P₁、P₂ 和 P₃, 其在就绪队列中的等待时间、需 要的 CPU 时间和优先权如下表所示。若优先权值大的进程优先获得CPU, 从 T 时刻起系统开始进程调 度，则系统的平均周转时间为()【微信 研七七】 A.54μs B.73μs C.74μs D.75μs", "answer_label": "D", "answer_explain": "由优先权可知，进程的执行顺序为P₂→P₃→P₁ 。P₂ 的周转时间为1+15+24=40μs;P³   的周 转时间为18+1+24+1+36=80μs;P1  的周转时间为30+1+24+1+36+1+12=105μs;  平均 周转时间为(40+80+105)/3=225/3=75μs,   因此选择选项D。", "answer": "D || 解析：由优先权可知，进程的执行顺序为P₂→P₃→P₁ 。P₂ 的周转时间为1+15+24=40μs;P³   的周 转时间为18+1+24+1+36=80μs;P1  的周转时间为30+1+24+1+36+1+12=105μs;  平均 周转时间为(40+80+105)/3=225/3=75μs,   因此选择选项D。"}
{"id": "215", "type": "单项选择题", "question": "48. 【2019统考真题】系统采用二级反馈队列调度算法进行进程调度。就绪队列 Q1 采用时间片轮转调度 算法，时间片为10ms; 就绪队列 Q₂ 采用短进程优先调度算法；系统优先调度 Q₁ 队列中的进程，当 Q₁ 为空时系统才会调度 Q₂ 中的进程；新创建的进程首先进入Q1;Q1 中的进程执行一个时间片后，若未结 束，则转入Q2 。若当前Q1,Q₂ 为空，系统依次创建进程 P₁,P₂ 后即开始进程调度，P₁,P₂ 需要的 CPU 时间分别为30ms 和20ms, 则进程P₁,P₂ 在系统中的平均等待时间为( ) A.25ms B.20ms C.15ms D.10ms", "answer_label": "C", "answer_explain": "进程P₁ 和 P₂ 依次创建后进入队列 Q₁,   根据时间片调度算法的规则，进程 P₁ 和P₂ 将依次被 分配10ms 的 CPU 时间，两个进程分别执行完一个时间片后都会被转入队列Q₂,   就绪队列Q₂ 采 用短进程优先调度算法，此时 P₁ 还需要20ms 的 CPU 时 间 ，P₂ 还需要10ms 的 CPU 时间，所以 P₂ 会被优先调度执行，10ms  后进程P₂ 执行完成，之后P₁ 再调度执行，再过20ms 后 P₁ 也执行完 成。运行图表述如下。\n进程P₁ 、P₂ 的等待时间分别为图中的虚横线部分，平均等待时间=(P₁ 的等待时间+ P₂ 的 等待时间)/2=(20+10)/2=15,因此答案选C。", "answer": "C || 解析：进程P₁ 和 P₂ 依次创建后进入队列 Q₁,   根据时间片调度算法的规则，进程 P₁ 和P₂ 将依次被 分配10ms 的 CPU 时间，两个进程分别执行完一个时间片后都会被转入队列Q₂,   就绪队列Q₂ 采 用短进程优先调度算法，此时 P₁ 还需要20ms 的 CPU 时 间 ，P₂ 还需要10ms 的 CPU 时间，所以 P₂ 会被优先调度执行，10ms  后进程P₂ 执行完成，之后P₁ 再调度执行，再过20ms 后 P₁ 也执行完 成。运行图表述如下。\n进程P₁ 、P₂ 的等待时间分别为图中的虚横线部分，平均等待时间=(P₁ 的等待时间+ P₂ 的 等待时间)/2=(20+10)/2=15,因此答案选C。"}
{"id": "216", "type": "单项选择题", "question": "49. 【2020统考真题】下列与进程调度有关的因素中，在设计多级反馈队列调度算法时需要考虑的是( ) I. 就绪队列的数量 II. 就绪队列的优先级 III. 各就绪队列的调度算法 IV. 进程在就绪队列间的迁移条件 A. 仅 I 、II B. 仅 II 、IV C. 仅Ⅱ、ⅢI 、IV D.I 、I 、ⅢI 和 IV", "answer_label": "D", "answer_explain": "多级反馈队列调度算法需要综合考虑优先级数量、优先级之间的转换规则等，就绪队列的数 量会影响长进程的最终完成时间，选项I 正确；就绪队列的优先级会影响进程执行的顺序，选项 Ⅱ正确；各就绪队列的调度算法会影响各队列中进程的调度顺序，选项Ⅲ正确；进程在就绪队列 中的迁移条件会影响各进程在各队列中的执行时间，选项IV 正确。", "answer": "D || 解析：多级反馈队列调度算法需要综合考虑优先级数量、优先级之间的转换规则等，就绪队列的数 量会影响长进程的最终完成时间，选项I 正确；就绪队列的优先级会影响进程执行的顺序，选项 Ⅱ正确；各就绪队列的调度算法会影响各队列中进程的调度顺序，选项Ⅲ正确；进程在就绪队列 中的迁移条件会影响各进程在各队列中的执行时间，选项IV 正确。"}
{"id": "217", "type": "单项选择题", "question": "50. 【2021统考真题】在下列内核的数据结构或程序中，分时系统实现时间片轮转调度需要使用的是( ) I. 进程控制块 II. 时钟中断处理程序 III. 进程就绪队列 IV. 进程阻塞队列 A. 仅Ⅱ、II B.仅 I、IV C. 仅 I 、I 、II D. 仅 I 、II 、IV", "answer_label": "C", "answer_explain": "时钟中断处理程序是一种特殊的中断处理程序，它负责在每个时钟周期结束时执行一些操  作，如内核中时钟变量的值、当前进程占用CPU 的时间、当前进程在时间片内的剩余执行时间。 时钟中断处理程序的触发条件是系统定时器(一种可编程的硬件芯片)以固定的频率(称为节拍  率)产生一个中断信号，通知CPU 进行中断处理。在分时系统的时间片轮转调度中，当时钟中断  处理程序检查到当前进程的时间片用完时，就触发进程调度，调度程序从就绪队列中选择一个进  程为其分配时间片，并且修改该进程的进程控制块中的进程状态等信息，同时将时间片用完的进  程放入就绪队列或让其结束运行，选项 I 、Ⅱ 、Ⅲ  正确。阻塞队列中的进程只有被唤醒并进入就  绪队列后，才能参与调度，所以该调度过程不使用阻塞队列。", "answer": "C || 解析：时钟中断处理程序是一种特殊的中断处理程序，它负责在每个时钟周期结束时执行一些操  作，如内核中时钟变量的值、当前进程占用CPU 的时间、当前进程在时间片内的剩余执行时间。 时钟中断处理程序的触发条件是系统定时器(一种可编程的硬件芯片)以固定的频率(称为节拍  率)产生一个中断信号，通知CPU 进行中断处理。在分时系统的时间片轮转调度中，当时钟中断  处理程序检查到当前进程的时间片用完时，就触发进程调度，调度程序从就绪队列中选择一个进  程为其分配时间片，并且修改该进程的进程控制块中的进程状态等信息，同时将时间片用完的进  程放入就绪队列或让其结束运行，选项 I 、Ⅱ 、Ⅲ  正确。阻塞队列中的进程只有被唤醒并进入就  绪队列后，才能参与调度，所以该调度过程不使用阻塞队列。"}
{"id": "218", "type": "单项选择题", "question": "51. 【2021统考真题】下列事件中，可能引起进程调度程序执行的是() I. 中断处理结束 II. 进程阻塞 IⅢI. 进程执行结束 IV. 进程的时间片用完 A. 仅 I 、III B. 仅Ⅱ、IV C. 仅 III 、IV D.I 、I 、III 和 IV", "answer_label": "D", "answer_explain": "中断处理阶段运行的是中断处理程序，中断处理结束后，需要返回原程序或重新选择程序运 行，而后者需要进行进程调度，例如在时间片轮转调度中，时钟中断处理结束后，若当前进程的 时间片用完，则会发生进程调度。当前进程阻塞时，将其放入阻塞队列，若就绪队列不空，则调 度新进程执行。进程执行结束会导致当前进程释放 CPU,  并从就绪队列中选择一个进程获得 CPU 。进程时间片用完，会导致当前进程让出CPU,   同时选择就绪队列的队首进程获得CPU。", "answer": "D || 解析：中断处理阶段运行的是中断处理程序，中断处理结束后，需要返回原程序或重新选择程序运 行，而后者需要进行进程调度，例如在时间片轮转调度中，时钟中断处理结束后，若当前进程的 时间片用完，则会发生进程调度。当前进程阻塞时，将其放入阻塞队列，若就绪队列不空，则调 度新进程执行。进程执行结束会导致当前进程释放 CPU,  并从就绪队列中选择一个进程获得 CPU 。进程时间片用完，会导致当前进程让出CPU,   同时选择就绪队列的队首进程获得CPU。"}
{"id": "219", "type": "单项选择题", "question": "52.【2022统考真题】进程 Po 、P₁ 、P₂ 和 P₃ 进入就绪队列的时刻、优先级(值越小优先权越高)及 CPU 执 行时间如下表所示。若系统采用基于优先权的抢占式进程调度算法，则从0ms 时刻开始调度，到4个进 程都运行结束为止，发生进程调度的总次数为() A.4 B.5 C.6 D.7", "answer_label": "C", "answer_explain": "需要注意的是，在0时刻，Po 获得CPU 也是一次进程调度，所以0时刻调度进程P₀ 获得 CPU;  10ms 时 P₂ 进入就绪队列，调度P₂ 抢占获得 CPU;15ms    时 P₃ 进入就绪队列，调度P₃ 抢占获得 CPU;25ms    时 P₃ 执行完毕，调度P₂ 获得CPU;40ms    时 P₂ 执行完毕，调度P₀ 获得CPU;130ms    时 P₀ 执行完毕，调度P₁ 获得CPU;190ms    时 P₁ 执行完毕，结束；总共调度6次。", "answer": "C || 解析：需要注意的是，在0时刻，Po 获得CPU 也是一次进程调度，所以0时刻调度进程P₀ 获得 CPU;  10ms 时 P₂ 进入就绪队列，调度P₂ 抢占获得 CPU;15ms    时 P₃ 进入就绪队列，调度P₃ 抢占获得 CPU;25ms    时 P₃ 执行完毕，调度P₂ 获得CPU;40ms    时 P₂ 执行完毕，调度P₀ 获得CPU;130ms    时 P₀ 执行完毕，调度P₁ 获得CPU;190ms    时 P₁ 执行完毕，结束；总共调度6次。"}
{"id": "220", "type": "单项选择题", "question": "53.【2023统考真题】进程 P₁ 、P₂ 和 P₃ 进入就绪队列的时刻、优先级(值越大优先权越高)和CPU 执行时 间如下表所示。若系统采用基于优先权的抢占式 CPU 调度算法，从0ms 时刻开始进行调度，则 P₁、P₂ 和 P₃ 的平均周转时间为( ) A.60ms B.61ms C.70ms D.71ms", "answer_label": "B", "answer_explain": "采用抢占式优先权调度算法，三个作业的执行顺序如下图所示。\n周转时间=完成时间-到达时间。P₁的周转时间=115-0=115ms;P₂  的周转时间=75-20= 55ms;P₃   的周转时间=43-30=13ms, 所以平均周转时间=(115+55+13)/3=61ms。", "answer": "B || 解析：采用抢占式优先权调度算法，三个作业的执行顺序如下图所示。\n周转时间=完成时间-到达时间。P₁的周转时间=115-0=115ms;P₂  的周转时间=75-20= 55ms;P₃   的周转时间=43-30=13ms, 所以平均周转时间=(115+55+13)/3=61ms。"}
{"id": "221", "type": "单项选择题", "question": "54. 【2024统考真题】假设某系统使用时间片轮转调度算法进行 CPU 调度，时间片大小为5ms, 系统共有 10个进程，初始时均处于就绪队列，执行结束前仅处于执行态或就绪态。若队尾的进程P 所需的CPU 时间最短，时间为25ms, 不考虑系统开销，则进程P 的周转时间为() A.200ms B.205ms C.250ms D.295ms", "answer_label": "C", "answer_explain": "系统使用时间片轮转调度算法，最初共有10个进程处于就绪队列，进程P 处于队尾，时间 片大小为5ms。假设当t=0   时开始进程调度，就绪队列的前9个进程依次运行一个时间片，则当 t=45ms   时调度进程P 运行，运行5ms 后，当t=50ms   时又开始新一轮循环。进程 P 所需的CPU 时间为25ms, 共需5轮循环，其他进程所需的CPU 时间都比进程P 的长，这5轮循环中其余9 个进程都不会运行结束，因此进程 P 的周转时间为50×5=250ms。", "answer": "C || 解析：系统使用时间片轮转调度算法，最初共有10个进程处于就绪队列，进程P 处于队尾，时间 片大小为5ms。假设当t=0   时开始进程调度，就绪队列的前9个进程依次运行一个时间片，则当 t=45ms   时调度进程P 运行，运行5ms 后，当t=50ms   时又开始新一轮循环。进程 P 所需的CPU 时间为25ms, 共需5轮循环，其他进程所需的CPU 时间都比进程P 的长，这5轮循环中其余9 个进程都不会运行结束，因此进程 P 的周转时间为50×5=250ms。"}
{"id": "222", "type": "单项选择题", "question": "55. 【2024统考真题】在支持页式存储管理的系统中，进程切换时操作系统需要执行的操作是( ) I. 更新程序计数器的值 II. 更新栈基址寄存器的值 III. 更新页表基地址寄存器的值 A. 仅 II B. 仅 I 、II C. 仅I 、III D.I 、II 、III 2.3同步与互斥", "answer_label": "D", "answer_explain": "进程切换时，需要进行上下文切换，主要完成：①将当前 CPU  中各寄存器的内容保存到当 前进程的 PCB 中；②将新进程的现场信息装入CPU 的各个寄存器。③将控制转至新进程执行， 即更新程序计数器 (PC)   的值。栈基址寄存器用来指明系统内核栈位置的寄存器，页表基址寄存 器用来指明当前进程顶级页表基地址的寄存器，属于进程控制信息。因此，选项 I 、Ⅱ 、Ⅲ  均需 要 更 新 。", "answer": "D || 解析：进程切换时，需要进行上下文切换，主要完成：①将当前 CPU  中各寄存器的内容保存到当 前进程的 PCB 中；②将新进程的现场信息装入CPU 的各个寄存器。③将控制转至新进程执行， 即更新程序计数器 (PC)   的值。栈基址寄存器用来指明系统内核栈位置的寄存器，页表基址寄存 器用来指明当前进程顶级页表基地址的寄存器，属于进程控制信息。因此，选项 I 、Ⅱ 、Ⅲ  均需 要 更 新 。"}
{"id": "223", "type": "单项选择题", "question": "1. 下列对临界区的论述中，正确的是() A. 临界区是指进程中用于实现进程互斥的那段代码 B. 临界区是指进程中用于实现进程同步的那段代码 C. 临界区是指进程中用于实现进程通信的那段代码 D. 临界区是指进程中用于访问临界资源的那段代码", "answer_label": "D", "answer_explain": "多个进程可以共享系统中的资源，一次仅允许一个进程使用的资源称为临界资源。访问临界 资源的那段代码称为临界区。", "answer": "D || 解析：多个进程可以共享系统中的资源，一次仅允许一个进程使用的资源称为临界资源。访问临界 资源的那段代码称为临界区。"}
{"id": "224", "type": "单项选择题", "question": "2. 不需要信号量就能实现的功能是( ) A. 进程同步 B. 进程互斥 C.执行的前驱关系 D. 进程的并发执行", "answer_label": "D", "answer_explain": "在多道程序技术中，信号量机制是一种有效实现进程同步和互斥的工具。进程执行的前趋关 系实质上是指进程的同步关系。除此之外，只有进程的并发执行不需要信号量来控制，因此正确 答案为选项D。", "answer": "D || 解析：在多道程序技术中，信号量机制是一种有效实现进程同步和互斥的工具。进程执行的前趋关 系实质上是指进程的同步关系。除此之外，只有进程的并发执行不需要信号量来控制，因此正确 答案为选项D。"}
{"id": "225", "type": "单项选择题", "question": "3. 若一个信号量的初值为3,经过多次PV 操作后当前值为-1,这表示等待进入临界区的进程数是( ) A.1 B.2 C.3 D.4", "answer_label": "A", "answer_explain": "信号量是一个特殊的整型变量，只有初始化和PV 操作才能改变其值。通常，信号量分为互 斥量和资源量，互斥量的初值一般为1,表示临界区只允许一个进程进入，从而实现互斥。当互 斥量等于0时，表示临界区已有一个进程进入，临界区外尚无进程等待；当互斥量小于0时，表 示临界区中有一个进程，互斥量的绝对值表示在临界区外等待进入的进程数。同理，资源信号量 的初值可以是任意整数，表示可用的资源数，当资源量小于0时，表示所有资源已全部用完，而 且还有进程正在等待使用该资源，等待的进程数就是资源量的绝对值。", "answer": "A || 解析：信号量是一个特殊的整型变量，只有初始化和PV 操作才能改变其值。通常，信号量分为互 斥量和资源量，互斥量的初值一般为1,表示临界区只允许一个进程进入，从而实现互斥。当互 斥量等于0时，表示临界区已有一个进程进入，临界区外尚无进程等待；当互斥量小于0时，表 示临界区中有一个进程，互斥量的绝对值表示在临界区外等待进入的进程数。同理，资源信号量 的初值可以是任意整数，表示可用的资源数，当资源量小于0时，表示所有资源已全部用完，而 且还有进程正在等待使用该资源，等待的进程数就是资源量的绝对值。"}
{"id": "226", "type": "单项选择题", "question": "4. 一个正在访问临界资源的进程由于申请等待 I/O 操作而被中断时，它() A. 允许其他进程进入与该进程相关的临界区 B. 不允许其他进程进入任何临界区 C. 允许其他进程抢占处理器，但不得进入该进程的临界区 D. 不允许任何进程抢占处理器", "answer_label": "C", "answer_explain": "进程进入临界区必须满足互斥条件，当进程进入临界区但尚未离开时就被迫进入阻塞是可以 的，系统中经常出现这样的情形。在此状态下，只要其他进程在运行过程中不寻求进入该进程的 临界区，就应允许其运行，即分配CPU 。该进程所锁定的临界区是不允许其他进程访问的，其他 进程若要访问，必定会在临界区的“锁”上阻塞，期待该进程下次运行时可以离开并将临界区交 给它。所以正确答案为选项C。", "answer": "C || 解析：进程进入临界区必须满足互斥条件，当进程进入临界区但尚未离开时就被迫进入阻塞是可以 的，系统中经常出现这样的情形。在此状态下，只要其他进程在运行过程中不寻求进入该进程的 临界区，就应允许其运行，即分配CPU 。该进程所锁定的临界区是不允许其他进程访问的，其他 进程若要访问，必定会在临界区的“锁”上阻塞，期待该进程下次运行时可以离开并将临界区交 给它。所以正确答案为选项C。"}
{"id": "227", "type": "单项选择题", "question": "5. 两个旅行社甲和乙为旅客到某航空公司订飞机票，形成互斥资源的是( ) A. 旅行社 B. 航空公司 C. 飞机票 D. 旅行社与航空公司", "answer_label": "C", "answer_explain": "一张飞机票不能售给不同的旅客，因此飞机票是互斥资源，其他因素只是为完成飞机票订票 的中间过程，与互斥资源无关。", "answer": "C || 解析：一张飞机票不能售给不同的旅客，因此飞机票是互斥资源，其他因素只是为完成飞机票订票 的中间过程，与互斥资源无关。"}
{"id": "228", "type": "单项选择题", "question": "6. 临界区是指并发进程访问共享变量段的( ) A. 管理信息 B. 信息存储 C. 数据 D. 代码程序", "answer_label": "D", "answer_explain": "所谓临界区，并不是指临界资源，如共享的数据、代码或硬件设备等，而是指访问临界资源 的那段代码程序，如P/V 操作、加减锁等。操作系统访问临界资源时，关心的是临界区的操作过 程，具体对临界资源做何操作是应用程序的事情，操作系统并不关心。", "answer": "D || 解析：所谓临界区，并不是指临界资源，如共享的数据、代码或硬件设备等，而是指访问临界资源 的那段代码程序，如P/V 操作、加减锁等。操作系统访问临界资源时，关心的是临界区的操作过 程，具体对临界资源做何操作是应用程序的事情，操作系统并不关心。"}
{"id": "229", "type": "单项选择题", "question": "7. 以下不是同步机制应遵循的准则的是( ) A. 让权等待 B. 空闲让进 C. 忙则等待 D. 无限等待", "answer_label": "D", "answer_explain": "同步机制的4个准则是空闲让进、忙则等待、让权等待和有限等待。", "answer": "D || 解析：同步机制的4个准则是空闲让进、忙则等待、让权等待和有限等待。"}
{"id": "230", "type": "单项选择题", "question": "8. 以下( )不属于临界资源。 A. 打印机 B. 非共享数据 C. 共享变量 D. 共享缓冲区", "answer_label": "B", "answer_explain": "临界资源是互斥共享资源，非共享数据不属于临界资源。打印机、共享变量和共享缓冲区都 只允许一次供一个进程使用。", "answer": "B || 解析：临界资源是互斥共享资源，非共享数据不属于临界资源。打印机、共享变量和共享缓冲区都 只允许一次供一个进程使用。"}
{"id": "231", "type": "单项选择题", "question": "9. 以下( )属于临界资源。 A. 磁盘存储介质 B. 公用队列 C. 私用数据 D. 可重入的程序代码", "answer_label": "B", "answer_explain": "临界资源与共享资源的区别在于，在一段时间内能否允许被多个进程访问(并发使用),显 然磁盘属于共享设备。公用队列可供多个进程使用，但一次只可供一个进程使用，试想若多个进 程同时使用公用队列，势必造成队列中的数据混乱而无法使用。私用数据仅供一个进程使用，不 存在临界区问题，可重入的程序代码一次可供多个进程使用。", "answer": "B || 解析：临界资源与共享资源的区别在于，在一段时间内能否允许被多个进程访问(并发使用),显 然磁盘属于共享设备。公用队列可供多个进程使用，但一次只可供一个进程使用，试想若多个进 程同时使用公用队列，势必造成队列中的数据混乱而无法使用。私用数据仅供一个进程使用，不 存在临界区问题，可重入的程序代码一次可供多个进程使用。"}
{"id": "232", "type": "单项选择题", "question": "10. 在操作系统中，要对并发进程进行同步的原因是( ) A. 进程必须在有限的时间内完成 B. 进程具有动态性 C. 并发进程是异步的 D. 进程具有结构性", "answer_label": "C", "answer_explain": "同步是指为了完成某项任务而建立的多个进程的相互合作关系，由于并发进程的执行是异步 的(按各自独立的、不可预知的速度向前推进),需要保证进程之间操作的先后次序的约束。例 如，读进程和写进程对同一段缓冲区的读和写就需要进行同步，以保证正确的执行顺序。", "answer": "C || 解析：同步是指为了完成某项任务而建立的多个进程的相互合作关系，由于并发进程的执行是异步 的(按各自独立的、不可预知的速度向前推进),需要保证进程之间操作的先后次序的约束。例 如，读进程和写进程对同一段缓冲区的读和写就需要进行同步，以保证正确的执行顺序。"}
{"id": "233", "type": "单项选择题", "question": "11. 进程 A 和进程B 通过共享缓冲区协作完成数据处理，进程 A 负责产生数据并放入缓冲区，进程B 从缓 冲区读数据并输出。进程 A 和 进 程 B 之间的制约关系是( )【 微信公 众号：研七七】 A. 互斥关系 B. 同步关系 C. 互斥和同步关系 D. 无制约关系", "answer_label": "C", "answer_explain": "并发进程因为共享资源而产生相互之间的制约关系，可以分为两类：①互斥关系，指进程之 间因相互竞争使用独占型资源(互斥资源)所产生的制约关系；②同步关系，指进程之间为协同 工作需要交换信息、相互等待而产生的制约关系。本题中两个进程之间的制约关系是同步关系， 进程B 必须在进程A 将数据放入缓冲区后才能从缓冲区中读出数据。此外，共享的缓冲区一定是 互斥访问的，所以它们也具有互斥关系。", "answer": "C || 解析：并发进程因为共享资源而产生相互之间的制约关系，可以分为两类：①互斥关系，指进程之 间因相互竞争使用独占型资源(互斥资源)所产生的制约关系；②同步关系，指进程之间为协同 工作需要交换信息、相互等待而产生的制约关系。本题中两个进程之间的制约关系是同步关系， 进程B 必须在进程A 将数据放入缓冲区后才能从缓冲区中读出数据。此外，共享的缓冲区一定是 互斥访问的，所以它们也具有互斥关系。"}
{"id": "234", "type": "单项选择题", "question": "12. 在操作系统中，P,V 操作是一种( ) A. 机器指令 B. 系统调用命令 C. 作业控制命令 D. 低级进程通信原语", "answer_label": "D", "answer_explain": "P 、V 操作是一种低级的进程通信原语，它是不能被中断的。", "answer": "D || 解析：P 、V 操作是一种低级的进程通信原语，它是不能被中断的。"}
{"id": "235", "type": "单项选择题", "question": "13.P 操作可能导致( ) A. 进程就绪 B. 进程结束 C. 进程阻塞 D. 新进程创建", "answer_label": "C", "answer_explain": "P 操作即 wait 操作，表示等待某种资源直到可用。若这种资源暂时不可用，则进程进入阻塞 态。注意，执行P 操作时的进程处于运行态。", "answer": "C || 解析：P 操作即 wait 操作，表示等待某种资源直到可用。若这种资源暂时不可用，则进程进入阻塞 态。注意，执行P 操作时的进程处于运行态。"}
{"id": "236", "type": "单项选择题", "question": "14. 原语是( ) A. 运行在用户态的过程 B. 操作系统的内核 C. 可中断的指令序列 D. 不可分割的指令序列", "answer_label": "D", "answer_explain": "原语 (Primitive/Atomic       Action),顾名思义，就是原子性的、不可分割的操作。其严格定义 为：由若干机器指令构成的完成某种特定功能的一段程序，其执行必须是连续的，在执行过程中 不允许被中断。", "answer": "D || 解析：原语 (Primitive/Atomic       Action),顾名思义，就是原子性的、不可分割的操作。其严格定义 为：由若干机器指令构成的完成某种特定功能的一段程序，其执行必须是连续的，在执行过程中 不允许被中断。"}
{"id": "237", "type": "单项选择题", "question": "15. ( )定义了共享数据结构和各种进程在该数据结构上的全部操作。 A. 管程 B. 类程 C. 线程 D. 程序", "answer_label": "A", "answer_explain": "管程定义了一个数据结构和能为并发进程所执行(在该数据结构上)的一组操作，这组操作 能同步进程并改变管程中的数据。", "answer": "A || 解析：管程定义了一个数据结构和能为并发进程所执行(在该数据结构上)的一组操作，这组操作 能同步进程并改变管程中的数据。"}
{"id": "238", "type": "单项选择题", "question": "16. 用 V 操作唤醒一个等待进程时，被唤醒进程变为( )态。 A. 运行 B. 等待 C. 就绪 D. 完成", "answer_label": "C", "answer_explain": "只有就绪进程能获得处理器资源，被唤醒的进程并不能直接转换为运行态。", "answer": "C || 解析：只有就绪进程能获得处理器资源，被唤醒的进程并不能直接转换为运行态。"}
{"id": "239", "type": "单项选择题", "question": "17. 在用信号量机制实现互斥时，互斥信号量的初值为( ) A.0 B.1 C.2 D.3", "answer_label": "B", "answer_explain": "互斥信号量的初值设置为1,P 操作成功则将其减1,禁止其他进程进入； V 操作成功则将其 加1,允许等待队列中的一个进程进入。", "answer": "B || 解析：互斥信号量的初值设置为1,P 操作成功则将其减1,禁止其他进程进入； V 操作成功则将其 加1,允许等待队列中的一个进程进入。"}
{"id": "240", "type": "单项选择题", "question": "18. 用 P,V 操作实现进程同步，信号量的初值为( ) A.-1 B.0 C.1 D. 由用户确定", "answer_label": "D", "answer_explain": "与互斥信号量初值一般置1不同，用P,V 操作实现进程同步时，信号量的初值应根据具体情 况来确定。若期望的消息尚未产生，则对应的初值应设为0;若期望的消息已存在，则信号量的 初值应设为一个非0的正整数。", "answer": "D || 解析：与互斥信号量初值一般置1不同，用P,V 操作实现进程同步时，信号量的初值应根据具体情 况来确定。若期望的消息尚未产生，则对应的初值应设为0;若期望的消息已存在，则信号量的 初值应设为一个非0的正整数。"}
{"id": "241", "type": "单项选择题", "question": "19. 可以被多个进程在任意时刻共享的代码必须是( ) A. 顺序代码 B. 机器语言代码 C .不允许任何修改的代码 D. 无转移指令代码", "answer_label": "C", "answer_explain": "若代码可被多个进程在任意时刻共享，则要求任意一个进程在调用此段代码时都以同样的方 式运行；而且进程在运行过程中被中断后再继续执行，其执行结果不受影响。这必然要求代码不 能被任何进程修改，否则无法满足共享的要求。这样的代码就是可重入代码，也称纯代码，即允 许多个进程同时访问的代码。", "answer": "C || 解析：若代码可被多个进程在任意时刻共享，则要求任意一个进程在调用此段代码时都以同样的方 式运行；而且进程在运行过程中被中断后再继续执行，其执行结果不受影响。这必然要求代码不 能被任何进程修改，否则无法满足共享的要求。这样的代码就是可重入代码，也称纯代码，即允 许多个进程同时访问的代码。"}
{"id": "242", "type": "单项选择题", "question": "20. 一个进程映像由程序、数据及PCB 组成，其中( )必须用可重入编码编写。 A.PCB B. 程序 C. 数据 D. 共享程序段", "answer_label": "D", "answer_explain": "共享程序段可能同时被多个进程使用，所以必须可重入编码，否则无法实现共享的功能。", "answer": "D || 解析：共享程序段可能同时被多个进程使用，所以必须可重入编码，否则无法实现共享的功能。"}
{"id": "243", "type": "单项选择题", "question": "21. 下列关于互斥锁的说法中，正确的是( ) A. 互斥锁只能用于多线程之间，不能用于多进程之间 B. 互斥锁只能用于多进程之间，不能用于多线程之间 C. 互斥锁可用于多线程或多进程之间，但只能由创建它的线程或进程来加锁和解锁 D. 互斥锁可用于多线程或多进程之间，但只能由对它加锁的线程或进程来解锁", "answer_label": "D", "answer_explain": "互斥锁可用于多线程或多进程之间，但只有对它加锁的线程或进程才能解锁它。若一个线程 或进程试图解锁一个不属于它(加锁)的互斥锁，则返回错误码。", "answer": "D || 解析：互斥锁可用于多线程或多进程之间，但只有对它加锁的线程或进程才能解锁它。若一个线程 或进程试图解锁一个不属于它(加锁)的互斥锁，则返回错误码。"}
{"id": "244", "type": "单项选择题", "question": "22. 在使用互斥锁进行同步互斥时，下列( )情况会导致死锁。 A. 一个线程对同一个互斥锁连续加锁两次 B. 一个线程尝试对一个已加锁的互斥锁再次加锁 C. 两个线程分别对两个不同的互斥锁先后加锁，但顺序相反 D. 一个线程对一个互斥锁加锁后忘记解锁", "answer_label": "C", "answer_explain": "若两个线程分别对两个不同的互斥锁先后加锁，但顺序相反，则可能导致死锁，这是典型 的循环等待现象。例如，线程1先对互斥锁A 加锁，然后尝试对互斥锁B 加锁；同时，线程2 先对 B 加锁，然后尝试对A 加锁，两个线程都在等待对方释放资源，从而无法继续推进。", "answer": "C || 解析：若两个线程分别对两个不同的互斥锁先后加锁，但顺序相反，则可能导致死锁，这是典型 的循环等待现象。例如，线程1先对互斥锁A 加锁，然后尝试对互斥锁B 加锁；同时，线程2 先对 B 加锁，然后尝试对A 加锁，两个线程都在等待对方释放资源，从而无法继续推进。"}
{"id": "245", "type": "单项选择题", "question": "23. 用来实现进程同步与互斥的PV 操作实际上是由()过程组成的。 A. 一个可被中断的 B. 一个不可被中断的 C. 两个可被中断的 D. 两个不可被中断的", "answer_label": "D", "answer_explain": "P 操作和V 操作都属于原语操作，不可被中断。", "answer": "D || 解析：P 操作和V 操作都属于原语操作，不可被中断。"}
{"id": "246", "type": "单项选择题", "question": "24. 对于两个并发进程，设互斥信号量为mutex (初值为1),若mutex=0, 则表示( ) A. 没有进程进入临界区 B. 有一个进程进入临界区 C. 有一个进程进入临界区，另一个进程等待进入 D. 有一个进程在等待进入", "answer_label": "B", "answer_explain": "mutex 的初值为1,表示允许一个进程进入临界区，当有一个进程进入临界区且没有进程等 待进入时，mutex 减1,变为0。  |mutex| 为等待进入的进程数。因此选择选项B。", "answer": "B || 解析：mutex 的初值为1,表示允许一个进程进入临界区，当有一个进程进入临界区且没有进程等 待进入时，mutex 减1,变为0。  |mutex| 为等待进入的进程数。因此选择选项B。"}
{"id": "247", "type": "单项选择题", "question": "25.对于两个并发进程，设互斥信号量为mutex (初值为1),若mutex=-1, 则 ( ) A. 表示没有进程进入临界区 B. 表示有一个进程进入临界区 C. 表示有一个进程进入临界区，另一个进程等待进入 D. 表示有两个进程进入临界区", "answer_label": "C", "answer_explain": "当有一个进程进入临界区且有另一个进程等待进入临界区时，mutex     =-1。当 mutex 小于0 时，其绝对值等于等待进入临界区的进程数。", "answer": "C || 解析：当有一个进程进入临界区且有另一个进程等待进入临界区时，mutex     =-1。当 mutex 小于0 时，其绝对值等于等待进入临界区的进程数。"}
{"id": "248", "type": "单项选择题", "question": "26. 一个进程因在互斥信号量 mutex 上执行 V(mutex) 操作而导致唤醒另一个进程时，执行 V 操作后mutex 的 值 为 ( ) A. 大于0 B. 小于0 C. 大于等于0 D. 小于等于0", "answer_label": "D", "answer_explain": "由题意可知，系统原来存在等待进入临界区的进程， mutex  小于或等于- 1,因此在执行 V(mutex)操作后，mutex 的值小于或等于0。", "answer": "D || 解析：由题意可知，系统原来存在等待进入临界区的进程， mutex  小于或等于- 1,因此在执行 V(mutex)操作后，mutex 的值小于或等于0。"}
{"id": "249", "type": "单项选择题", "question": "27. 一个系统中共有5个并发进程涉及某个相同的变量 A, 变量 A 的相关临界区是由()个临界区构成 的。 A.1 B.3 C.5 D.6", "answer_label": "C", "answer_explain": "这里的临界区是指访问临界资源A 的那段代码(临界区的定义)。那么5个并发进程共有5个 操作共享变量A 的代码段。", "answer": "C || 解析：这里的临界区是指访问临界资源A 的那段代码(临界区的定义)。那么5个并发进程共有5个 操作共享变量A 的代码段。"}
{"id": "250", "type": "单项选择题", "question": "28.下述( )选项不是管程的组成部分。 A. 局限于管程的共享数据结构 B. 对管程内数据结构进行操作的一组过程 C. 管程外过程调用管程内数据结构的说明 D. 对局限于管程的数据结构设置初始值的语句", "answer_label": "C", "answer_explain": "管程由局限于管程的共享变量说明、对管程内的数据结构进行操作的一组过程及对局限于管 程的数据设置初始值的语句组成。", "answer": "C || 解析：管程由局限于管程的共享变量说明、对管程内的数据结构进行操作的一组过程及对局限于管 程的数据设置初始值的语句组成。"}
{"id": "251", "type": "单项选择题", "question": "29. 以下关于管程的叙述中，错误的是() A. 管程是进程同步工具，解决信号量机制大量同步操作分散的问题 B. 管程每次只允许一个进程进入管程 C. 管程中signal 操作的作用和信号量机制中的V 操作相同 D. 管程是被进程调用的，管程是语法范围，无法创建和撤销", "answer_label": "C", "answer_explain": "管程的signal操作与信号量机制中的V 操作不同，信号量机制中的V 操作一定会改变信号量  的值S=S+1 。 而管程中的signal 操作是针对某个条件变量的，若不存在因该条件而阻塞的进程， 则signal 不会产生任何影响。", "answer": "C || 解析：管程的signal操作与信号量机制中的V 操作不同，信号量机制中的V 操作一定会改变信号量  的值S=S+1 。 而管程中的signal 操作是针对某个条件变量的，若不存在因该条件而阻塞的进程， 则signal 不会产生任何影响。"}
{"id": "252", "type": "单项选择题", "question": "30. 对信号量S 执行P 操作后，使该进程进入资源等待队列的条件是( ) A.S.value<0 B.S.value<=0 C.S.value>0 D.S.value>=0", "answer_label": "A", "answer_explain": "参见记录型信号量的解析。此处极易出S.value的物理概念题，现在总结如下：\n①S.value>0, 表示某类可用资源的数量。每次P 操作，意味着请求分配一个单位的资源。\n②S.value≤0,表示某类资源已经没有，或者说还有因请求该资源而被阻塞的进程，S.value 的绝对值表示等待进程数量。\n一定要看清题目中的陈述是执行P  操作前还是执行 P 操作后。\n31.   ①C    ②B\n①系统中有n 个进程，只要这些进程不都处于阻塞态，则至少有一个进程正在处理器上运行 (处理器至少有一个),因此就绪队列中的进程个数最多有n-1   个。选项 B 容易被错选，以为出 现了处理器为空、就绪队列全满的情况，实际调度无此状态。\n②本题易错选C, 阻塞队列有n-1 个进程是可能发生的，但不是最多的情况。不少读者会忽 略死锁的情况，死锁就是n 个进程都被阻塞，因此阻塞队列最多可以有n 个进程。", "answer": "A || 解析：参见记录型信号量的解析。此处极易出S.value的物理概念题，现在总结如下：\n①S.value>0, 表示某类可用资源的数量。每次P 操作，意味着请求分配一个单位的资源。\n②S.value≤0,表示某类资源已经没有，或者说还有因请求该资源而被阻塞的进程，S.value 的绝对值表示等待进程数量。\n一定要看清题目中的陈述是执行P  操作前还是执行 P 操作后。\n31.   ①C    ②B\n①系统中有n 个进程，只要这些进程不都处于阻塞态，则至少有一个进程正在处理器上运行 (处理器至少有一个),因此就绪队列中的进程个数最多有n-1   个。选项 B 容易被错选，以为出 现了处理器为空、就绪队列全满的情况，实际调度无此状态。\n②本题易错选C, 阻塞队列有n-1 个进程是可能发生的，但不是最多的情况。不少读者会忽 略死锁的情况，死锁就是n 个进程都被阻塞，因此阻塞队列最多可以有n 个进程。"}
{"id": "253", "type": "单项选择题", "question": "31. 若系统有 n 个进程，则就绪队列中进程的个数最多有(①个；阻塞队列中进程的个数最多有(②)个。 ①A.n+1 B.n C.n-1 D.1 ②A.n+1 B.n C.n-1 D.1", "answer_label": "B", "answer_explain": "PV 操作是一种低级的进程通信原语，不是系统调用，因此选项Ⅱ正确；P 操作和V 操作都 属于原子操作，所以 PV 操作由两个不可被中断的过程组成，因此选项IV 正确。", "answer": "B || 解析：PV 操作是一种低级的进程通信原语，不是系统调用，因此选项Ⅱ正确；P 操作和V 操作都 属于原子操作，所以 PV 操作由两个不可被中断的过程组成，因此选项IV 正确。"}
{"id": "254", "type": "单项选择题", "question": "32. 下列关于PV 操作的说法中，正确的是( ) I.PV 操作是一种系统调用命令 II.PV 操作是一种低级进程通信原语 III.PV 操作是由一个不可被中断的过程组成 IV.PV 操作是由两个不可被中断的过程组成 A.I 、III B.II 、IV C.I 、II 、IV D.I 、IV", "answer_label": "C", "answer_explain": "临界资源是指每次仅允许一个进程访问的资源。每个进程中访问临界资源的那段代码称为临 界区。选项I 错误，银行家算法是避免死锁的算法。选项Ⅱ错误，每个进程中访问临界资源的那 段代码称为临界区。选项Ⅲ正确，公用队列可供多个进程使用，但一次只可供一个程序使用。 选项IV 错误，私用数据仅供一个进程使用，不存在临界区问题。综上分析，正确答案为选项C。", "answer": "C || 解析：临界资源是指每次仅允许一个进程访问的资源。每个进程中访问临界资源的那段代码称为临 界区。选项I 错误，银行家算法是避免死锁的算法。选项Ⅱ错误，每个进程中访问临界资源的那 段代码称为临界区。选项Ⅲ正确，公用队列可供多个进程使用，但一次只可供一个程序使用。 选项IV 错误，私用数据仅供一个进程使用，不存在临界区问题。综上分析，正确答案为选项C。"}
{"id": "255", "type": "单项选择题", "question": "33. 下列关于临界区和临界资源的说法中，正确的是( ) I. 银行家算法可以用来解决临界区(Critical Section)问题 I. 临界区是指进程中用于实现进程互斥的那段代码 II. 公用队列属于临界资源 IV. 私用数据属于临界资源 A.I 、II B.I 、IV C. 仅II D. 以上答案都错误", "answer_label": "B", "answer_explain": "对S 进行了28次P 操作和18次V 操作，即S-28+18=0,         得信号量的初值为10;然后， 对信号量S 进行了15次P 操作和2次V 操作，即S-15+2=10-15+2=-3,S                   信号量的负值 的绝对值表示等待队列中的进程数。所以有3个进程等待在信号量S 的队列中。", "answer": "B || 解析：对S 进行了28次P 操作和18次V 操作，即S-28+18=0,         得信号量的初值为10;然后， 对信号量S 进行了15次P 操作和2次V 操作，即S-15+2=10-15+2=-3,S                   信号量的负值 的绝对值表示等待队列中的进程数。所以有3个进程等待在信号量S 的队列中。"}
{"id": "256", "type": "单项选择题", "question": "34. 有一个计数信号量S: 1)假如若干进程对S 进行28次P 操作和18次V 操作后，信号量S 的值为0。 2)假如若干进程对信号量S 进行了15次P 操作和2次V 操作。 请问此时有多少个进程等待在信号量S 的队列中?( ) A.2 B.3 C.5 D.7", "answer_label": "B", "answer_explain": "本题的关键是，输出语句A2,B2  中读取的x 的值不同，由于A1,B1  执行有先后问题，使得在 执行A2,B2 前，x 的可能取值有两个，即1,-3;这样，输出z 的值可能是1+2=3或(- 3)+2=- 1; 输出c 的值可能是1×1=1或(-3)×(-3)=9。", "answer": "B || 解析：本题的关键是，输出语句A2,B2  中读取的x 的值不同，由于A1,B1  执行有先后问题，使得在 执行A2,B2 前，x 的可能取值有两个，即1,-3;这样，输出z 的值可能是1+2=3或(- 3)+2=- 1; 输出c 的值可能是1×1=1或(-3)×(-3)=9。"}
{"id": "257", "type": "单项选择题", "question": "35.有两个并发进程 P₁ 和 P₂, 其程序代码如下： 可能打印出的z 值有( ),可能打印出的c 值有()(其中x 为 P₁,P₂ 的共享变量)。 A.z=1,-3;c=-1,9 B.z=-1,3;c=1,9 C.z=-1,3,1;c=9 D.z=3;c=1,9", "answer_label": "D", "answer_explain": "并发进程之间的关系没有必然的要求，只有执行时间上的偶然重合，可能无关也可能有交往。", "answer": "D || 解析：并发进程之间的关系没有必然的要求，只有执行时间上的偶然重合，可能无关也可能有交往。"}
{"id": "258", "type": "单项选择题", "question": "36. 并发进程之间的关系是( ) A. 无关的 B.相关的 C.可能相关的 D. 可能是无关的，也可能是有交往的", "answer_label": "C", "answer_explain": "信号量的初值表示该类资源的总数，因此信号量的初值取3。每分配一个该类资源，信号量 减1,当信号量等于0时，表示该类资源刚好被分完；当信号量小于0时，表示还有进程正在等 待该类资源，信号量的绝对值就是等待进程的数量。因此，当没有进程使用时，信号量最大为3; 当有三个进程正在使用并有一个进程在等待时，信号量最小为-1。", "answer": "C || 解析：信号量的初值表示该类资源的总数，因此信号量的初值取3。每分配一个该类资源，信号量 减1,当信号量等于0时，表示该类资源刚好被分完；当信号量小于0时，表示还有进程正在等 待该类资源，信号量的绝对值就是等待进程的数量。因此，当没有进程使用时，信号量最大为3; 当有三个进程正在使用并有一个进程在等待时，信号量最小为-1。"}
{"id": "259", "type": "单项选择题", "question": "37. 若系统中有4个进程共享3台打印机，采用信号量机制控制打印机的共享使用，则信号量的取值范围是 ( ) A.[-1,4] B.[-2,2] C.[-1,3] D.[-3,2]", "answer_label": "C", "answer_explain": "根据Peterson 算法的原理，可知(1)和(2)处分别为turn=1   和 turn=0。", "answer": "C || 解析：根据Peterson 算法的原理，可知(1)和(2)处分别为turn=1   和 turn=0。"}
{"id": "260", "type": "单项选择题", "question": "38. 两个进程Po 和 P₁ 互斥的Peterson算法描述如下： 其中，(1)和(2)处的代码分别为( ) A.turn=0.turn=0 B.turn=0.turn=1 C.turn=1.turn=0 D.turn=1,turn=1", "answer_label": "A", "answer_explain": "flag 数组用于标记各个线程想进入临界区的意愿。当一个线程想要进入临界区时，它将自己 对应的flag 值置为true ; 当一个线程退出临界区时，它将自己对应的flag 值置为false 。这样，若 两个进程都争着想进入临界区，则可以让进程将进入临界区的机会谦让给对方。", "answer": "A || 解析：flag 数组用于标记各个线程想进入临界区的意愿。当一个线程想要进入临界区时，它将自己 对应的flag 值置为true ; 当一个线程退出临界区时，它将自己对应的flag 值置为false 。这样，若 两个进程都争着想进入临界区，则可以让进程将进入临界区的机会谦让给对方。"}
{"id": "261", "type": "单项选择题", "question": "39. 在Peterson 算法中，flag 数组的作用是( ) A. 表示每个线程是否想进入临界区 B. 表示每个线程是否已进入临界区 C.表示每个线程是否已退出临界区 D. 表示每个线程是否已完成任务", "answer_label": "A", "answer_explain": "turn 变量用于指示允许进入临界区的线程编号。当一个线程想要进入临界区时，它将turn 置 为对方的编号，表示优先让对方先进入。当一个线程检查到对方的flag为 true时，表示对方也想 进入，这时就需要根据turn 来决定谁先进入。若turm等于自己的编号，表示轮到自己进入，则可 以直接进入。若turn 等于对方的编号，表示轮到对方进入，则需等待对方退出。", "answer": "A || 解析：turn 变量用于指示允许进入临界区的线程编号。当一个线程想要进入临界区时，它将turn 置 为对方的编号，表示优先让对方先进入。当一个线程检查到对方的flag为 true时，表示对方也想 进入，这时就需要根据turn 来决定谁先进入。若turm等于自己的编号，表示轮到自己进入，则可 以直接进入。若turn 等于对方的编号，表示轮到对方进入，则需等待对方退出。"}
{"id": "262", "type": "单项选择题", "question": "40. 在 Peterson 算法中，turn 变量的作用是( ) A. 表示轮到哪个线程进入临界区 B. 表示哪个线程先发出访问请求 C. 表示哪个线程后发出访问请求 D. 表示哪个线程已进入临界区", "answer_label": "B", "answer_explain": "进程并发带来问题不仅包括同步互斥问题，还包括死锁等其他问题。生产者-消费者问题用 于解决进程的同步和互斥问题。共享一个数据对象仅涉及互斥访问的问题。", "answer": "B || 解析：进程并发带来问题不仅包括同步互斥问题，还包括死锁等其他问题。生产者-消费者问题用 于解决进程的同步和互斥问题。共享一个数据对象仅涉及互斥访问的问题。"}
{"id": "263", "type": "单项选择题", "question": "41. 生产者-消费者问题用于解决( ) A. 多个进程共享一个数据对象的问题 B. 多个进程之间的同步和互斥问题 C. 多个进程共享资源的死锁与饥饿问题 D. 利用信号量实现多个进程并发的问题", "answer_label": "A", "answer_explain": "当缓冲区为空时，消费者进程取产品会被阻塞，此时需等待生产者进程生产新产品。", "answer": "A || 解析：当缓冲区为空时，消费者进程取产品会被阻塞，此时需等待生产者进程生产新产品。"}
{"id": "264", "type": "单项选择题", "question": "42. 所有的消费者必须等待生产者先运行的前提条件是( ) A. 缓冲区空 B. 缓冲区满 C. 缓冲区不可用 D. 缓冲区半空", "answer_label": "D", "answer_explain": "生产者和消费者共享缓冲区，每次只允许一个生产者或消费者进入缓冲区，当有一个生产者 或消费者进入缓冲区时，其他生产者或消费者就必须阻塞等待。因此，生产者有可能唤醒其他生 产者或消费者，消费者也有可能唤醒其他生产者或消费者，四个选项均正确。", "answer": "D || 解析：生产者和消费者共享缓冲区，每次只允许一个生产者或消费者进入缓冲区，当有一个生产者 或消费者进入缓冲区时，其他生产者或消费者就必须阻塞等待。因此，生产者有可能唤醒其他生 产者或消费者，消费者也有可能唤醒其他生产者或消费者，四个选项均正确。"}
{"id": "265", "type": "单项选择题", "question": "43. 下列关于生产者-消费者问题的唤醒操作的说法中，正确的是() I.生产者唤醒其它生产者 II.生产者唤醒消费者 III. 消费者唤醒其它消费者 IV. 消费者唤醒生产者 A.I 和 I B.III 和 IV C.II 和 III D.I 、I 、III 和 IV", "answer_label": "A", "answer_explain": "所谓互斥使用某临界资源，是指在同一时间段只允许一个进程使用此资源，所以互斥信号量 的初值都为1。", "answer": "A || 解析：所谓互斥使用某临界资源，是指在同一时间段只允许一个进程使用此资源，所以互斥信号量 的初值都为1。"}
{"id": "266", "type": "单项选择题", "question": "44. 在 9 个 生 产 者 、 6 个 消 费 者 共 享 容 量 为 8 的 缓 冲 器 的 生 产 者 - 消 费 者 问 题 中 ， 互 斥 使 用 缓 冲 器 的 信 号 量 初 始 值 为 ( ) 【 A.1 B.6 C.8 D.9", "answer_label": "B", "answer_explain": "在生产者-消费者问题中，每次只能有一个生产者或消费者进入缓冲区，需要用一个互斥信 号量来控制，当有一个生产者或消费者进入缓冲区时，其他申请进入缓冲区的消费者会被阻塞。", "answer": "B || 解析：在生产者-消费者问题中，每次只能有一个生产者或消费者进入缓冲区，需要用一个互斥信 号量来控制，当有一个生产者或消费者进入缓冲区时，其他申请进入缓冲区的消费者会被阻塞。"}
{"id": "267", "type": "单项选择题", "question": "45. 消费者进程阻塞在wait(m)(m 是互斥信号量)的条件是( ) I. 没有空缓冲区 II. 没有满缓冲区 III. 有其他生产者已进入临界区 IV.有其他消费者已进入临界区 A.I 和 I B.III 和 IV C.I 和 III D.II 和 IV", "answer_label": "C", "answer_explain": "在读者-写者问题中，写者和写者之间、写者和读者之间必须互斥访问共享对象，读者和读 者之间则可以同时访问。", "answer": "C || 解析：在读者-写者问题中，写者和写者之间、写者和读者之间必须互斥访问共享对象，读者和读 者之间则可以同时访问。"}
{"id": "268", "type": "单项选择题", "question": "46. 在读者-写者问题中，能同时执行的是( ) A. 读者和写者 B. 不同的写者 C.不同的读者 D. 都不能", "answer_label": "D", "answer_explain": "在哲学家就餐问题中，若所有哲学家都是右撇子，则他们都会先拿起右边的筷子，然后等待 左边的筷子，这样就形成了一个循环等待链。但是，若其中有一些哲学家是左撇子，则他们会先 拿起左边的筷子，然后等待右边的筷子，这样就打破了循环等待链。", "answer": "D || 解析：在哲学家就餐问题中，若所有哲学家都是右撇子，则他们都会先拿起右边的筷子，然后等待 左边的筷子，这样就形成了一个循环等待链。但是，若其中有一些哲学家是左撇子，则他们会先 拿起左边的筷子，然后等待右边的筷子，这样就打破了循环等待链。"}
{"id": "269", "type": "单项选择题", "question": "47. 在哲学家就餐问题中，若同时存在左撇子和右撇子(将先拿起左边筷子的人称为左撇子，而将先拿起右 边筷子的人称为右撇子),则不会发生死锁，因为破坏了() A. 互斥条件 B. 请求与保持条件 C. 不剥夺条件 D. 循环等待条件", "answer_label": "C", "answer_explain": "信号量seat 表示桌子上可以坐下的位置数，因为只有五个位置，所以每次只能有四位哲学家 同时拿起左边的餐叉，才能保证不会发生死锁，所以seat 的初值应该为4。", "answer": "C || 解析：信号量seat 表示桌子上可以坐下的位置数，因为只有五个位置，所以每次只能有四位哲学家 同时拿起左边的餐叉，才能保证不会发生死锁，所以seat 的初值应该为4。"}
{"id": "270", "type": "单项选择题", "question": "48. 哲学家就餐问题的解决方案如下： semaphore*chopstick[5]; semaphore *seat; 哲学家i: P(seat); P(chopStick[i]); P(chopStick[(i+1)%5]); 吃饭 V (chopStick[i]); V(chopStick[(i+1)%5]); V(seat) 其中，信号量seat 的初值为( ) A.0 B.1 C.4 D.5", "answer_label": "C", "answer_explain": "因为进程并发，所以进程的执行具有不确定性，在P₁,P₂  执行到第一个P,V 操作前，应该是 相互无关的。现在考虑第一个对s  的 P,V  操作，因为进程P₂ 是P(s₁) 操作，所以它必须等待P₁ 执  行完 V(s₁)操作后才可继续运行，此时的x,y,z 值分别是2,3,4,当进程P₁ 执行完V(s)后便在P(s₂) 上阻塞，此时P₂ 可以运行直到V(s₂),   此时的x,y,z    值分别是5,3,9,进程P₁ 继续运行到结束，\n最终的x,y,z   值分别为5,12,9。", "answer": "C || 解析：因为进程并发，所以进程的执行具有不确定性，在P₁,P₂  执行到第一个P,V 操作前，应该是 相互无关的。现在考虑第一个对s  的 P,V  操作，因为进程P₂ 是P(s₁) 操作，所以它必须等待P₁ 执  行完 V(s₁)操作后才可继续运行，此时的x,y,z 值分别是2,3,4,当进程P₁ 执行完V(s)后便在P(s₂) 上阻塞，此时P₂ 可以运行直到V(s₂),   此时的x,y,z    值分别是5,3,9,进程P₁ 继续运行到结束，\n最终的x,y,z   值分别为5,12,9。"}
{"id": "271", "type": "单项选择题", "question": "49. 有两个优先级相同的并发程序 P₁ 和 P₂, 它们的执行过程如下所示。假设当前信号量 s1=0,s2=0 。 当 前的z=2, 进程运行结束后，x,y 和 z 的值分别是( ) A.5,9,9 B.5,9,4 C.5,12,9 D.5,12,4", "answer_label": "B", "answer_explain": "信号量表示相关资源的当前可用数量。当信号量K>0  时，表示还有K 个相关资源可用，所 以该资源的可用个数是1。而当信号量K<0    时，表示有|K|个进程在等待该资源。因为资源有剩 余，可见没有其他进程等待使用该资源，所以进程数为0。", "answer": "B || 解析：信号量表示相关资源的当前可用数量。当信号量K>0  时，表示还有K 个相关资源可用，所 以该资源的可用个数是1。而当信号量K<0    时，表示有|K|个进程在等待该资源。因为资源有剩 余，可见没有其他进程等待使用该资源，所以进程数为0。"}
{"id": "272", "type": "单项选择题", "question": "50. 【2010统考真题】设与某资源关联的信号量初值为3,当前值为1。若 M 表示该资源的可用个数，N 表 示等待该资源的进程数，则M,N 分别是( ) A.0,1 B.1,0 C.1,2 D.2,0", "answer_label": "D", "answer_explain": "这是 Peterson 算法的实际实现，保证进入临界区的进程合理安全。\n该算法为了防止两个进程为进入临界区而无限期等待，设置了变量turn,   表示允许进入临界 区的编号，每个进程在先设置自己的标志后再设置turn 标志，允许另一个进程进入。这时，再同 时检测另一个进程状态标志和允许进入标志，就可保证当两个进程同时要求进入临界区时只允许 一个进程进入临界区。保存的是较晚的一次赋值，因此较晚的进程等待，较早的进程进入。先到 先入，后到等待，从而完成临界区访问的要求。\n其实这里可想象为两个人进门，每个人进门前都会和对方客套一句“你走先”。若进门时没 别人，就当和空气说句废话，然后大步登门入室；若两人同时进门，就互相先请，但各自只客套 一次，所以先客套的人请完对方，就等着对方请自己，然后光明正大地进门。", "answer": "D || 解析：这是 Peterson 算法的实际实现，保证进入临界区的进程合理安全。\n该算法为了防止两个进程为进入临界区而无限期等待，设置了变量turn,   表示允许进入临界 区的编号，每个进程在先设置自己的标志后再设置turn 标志，允许另一个进程进入。这时，再同 时检测另一个进程状态标志和允许进入标志，就可保证当两个进程同时要求进入临界区时只允许 一个进程进入临界区。保存的是较晚的一次赋值，因此较晚的进程等待，较早的进程进入。先到 先入，后到等待，从而完成临界区访问的要求。\n其实这里可想象为两个人进门，每个人进门前都会和对方客套一句“你走先”。若进门时没 别人，就当和空气说句废话，然后大步登门入室；若两人同时进门，就互相先请，但各自只客套 一次，所以先客套的人请完对方，就等着对方请自己，然后光明正大地进门。"}
{"id": "273", "type": "单项选择题", "question": "51.【2010统考真题】进程 Po 和进程P₁ 的共享变量定义及其初值为： boolean flag[2]; int turn =0; flag[0]=false;flag[1]=false; 若进程 Po 和进程 P₁ 访问临界资源的类C 代码实现如下： 则并发执行进程Po 和进程P₁ 时产生的情况是( ) A. 不能保证进程互斥进入临界区，会出现“饥饿”现象 B. 不能保证进程互斥进入临界区，不会出现“饥饿”现象 C. 能保证进程互斥进入临界区，会出现“饥饿”现象 D. 能保证进程互斥进入临界区，不会出现“饥饿”现象", "answer_label": "C", "answer_explain": "x的值最终是多少，取决于最后是哪个进程对x 进行了写操作。一个进程一旦拿到了x 值，它 最后对x 写操作的值也就确定了。因此本题只需考虑两个进程拿到x 值的所有可能情况。对于进程 P₁,  最初取到的x 值可能是1,也可能是进程P₂ 完成后更新得到的x 值0,因此对于P₁,  最终写入 x的值可能是2(当它最初取到1时)和1(当它最初取到0时)。同理，对于P₂,   最初取到的x 值 可能是1,也可能是P₁ 完成后更新得到的x 值2,因此对于P₂,   最终写入x 的值可能是0(当它最 初取到1时)和1(当它最初取到2时)。因此，最终的x 值可能是0、1或2。", "answer": "C || 解析：x的值最终是多少，取决于最后是哪个进程对x 进行了写操作。一个进程一旦拿到了x 值，它 最后对x 写操作的值也就确定了。因此本题只需考虑两个进程拿到x 值的所有可能情况。对于进程 P₁,  最初取到的x 值可能是1,也可能是进程P₂ 完成后更新得到的x 值0,因此对于P₁,  最终写入 x的值可能是2(当它最初取到1时)和1(当它最初取到0时)。同理，对于P₂,   最初取到的x 值 可能是1,也可能是P₁ 完成后更新得到的x 值2,因此对于P₂,   最终写入x 的值可能是0(当它最 初取到1时)和1(当它最初取到2时)。因此，最终的x 值可能是0、1或2。"}
{"id": "274", "type": "单项选择题", "question": "52.【2011统考真题】有两个并发执行的进程 P₁ 和进程P₂, 共享初值为1的变量x 。P₁ 对 x 加 1 ,P₂ 对 x 减 1。加1和减1操作的指令序列分别如下： 两个操作完成后，x 的值( ) A. 可能为 - 1或3 B.只能为1 C. 可能为0,1或2 D. 可能为-1,0,1或2", "answer_label": "C", "answer_explain": "需要进行互斥的操作是对临界资源的访问，也就是说，不同线程对同一个进程内部的共享变 量的访问才有可能需要进行互斥，不同进程的线程、代码段或变量不存在互斥访问的问题，同一 个线程内部的局部变量也不存在互斥访问的问题。选项A 中的a 是线程内部的局部变量，不需要 互斥访问。选项D 是不同进程的线程代码段，不存在互斥访问的问题。选项B 是对进程内部的共\n132                   2 0 2 6 年 操 作 系 统 考 研 复 习 指 导\n享变量x 的读操作，不互斥也不影响执行结果，所以不需要互斥访问。选项C 是不同线程对同一 个进程内部的共享变量的写操作，需要互斥访问(类似于读者-写者问题)。", "answer": "C || 解析：需要进行互斥的操作是对临界资源的访问，也就是说，不同线程对同一个进程内部的共享变 量的访问才有可能需要进行互斥，不同进程的线程、代码段或变量不存在互斥访问的问题，同一 个线程内部的局部变量也不存在互斥访问的问题。选项A 中的a 是线程内部的局部变量，不需要 互斥访问。选项D 是不同进程的线程代码段，不存在互斥访问的问题。选项B 是对进程内部的共\n132                   2 0 2 6 年 操 作 系 统 考 研 复 习 指 导\n享变量x 的读操作，不互斥也不影响执行结果，所以不需要互斥访问。选项C 是不同线程对同一 个进程内部的共享变量的写操作，需要互斥访问(类似于读者-写者问题)。"}
{"id": "275", "type": "单项选择题", "question": "53. 【2016统考真题】进程 P₁ 和 P₂ 均包含并发执行的线程，部分伪代码描述如下所示。 下列选项中，需要互斥执行的操作是() A.a=1 与 a=2 B.a=x 与 b=X C.x+=1 与 x+=2 D.x+=1 与 x+=3", "answer_label": "B", "answer_explain": "使用TSL 指令实现进程互斥时，并没有阻塞态进程，等待进入临界区的进程一直停留在执行 while(TSL(&lock)) 的循环中，不会主动放弃CPU,  一直处于运行态，直到该进程的时间片用完放 弃处理机，转为就绪态，此时切换另一个就绪态进程占用处理机。这不同于信号量机制实现的互 斥。由此可知选项 A 和 C 错误，选项B 正确。TSL 指令本身就是原子操作，不需要关中断来保 证其不被打断。TSL 指令实现原子性的原理是，执行 TSL 指令的CPU 锁住内存总线，以禁止其 他 CPU  在本指令结束之前访问内存。此外，假如 while(TSL(&lock) 在关中断状态下执行，若 TSL(&lock) 一直为true,   不再开中断，则系统可能因此终止。因此选项D 错误。", "answer": "B || 解析：使用TSL 指令实现进程互斥时，并没有阻塞态进程，等待进入临界区的进程一直停留在执行 while(TSL(&lock)) 的循环中，不会主动放弃CPU,  一直处于运行态，直到该进程的时间片用完放 弃处理机，转为就绪态，此时切换另一个就绪态进程占用处理机。这不同于信号量机制实现的互 斥。由此可知选项 A 和 C 错误，选项B 正确。TSL 指令本身就是原子操作，不需要关中断来保 证其不被打断。TSL 指令实现原子性的原理是，执行 TSL 指令的CPU 锁住内存总线，以禁止其 他 CPU  在本指令结束之前访问内存。此外，假如 while(TSL(&lock) 在关中断状态下执行，若 TSL(&lock) 一直为true,   不再开中断，则系统可能因此终止。因此选项D 错误。"}
{"id": "276", "type": "单项选择题", "question": "54. 【2016统考真题】使用 TSL(Test and SetLock)指令实现进程互斥的伪代码如下所示。 下列与该实现机制相关的叙述中，正确的是( ) A. 退出临界区的进程负责唤醒阻塞态进程 B. 等待进入临界区的进程不会主动放弃 CPU C. 上述伪代码满足“让权等待”的同步准则 D.while(TSL(&lock)) 语句应在关中断状态下执行", "answer_label": "A", "answer_explain": "管程是由一组数据及定义在这组数据之上的对这组数据的操作组成的软件模块，这组操作能  初始化并改变管程中的数据和同步进程。管程不仅能实现进程间的互斥，还能实现进程间的同步， 因此选项A 错误、B 正确；管程具有如下特性：①局部于管程的数据只能被局部于管程内的过程 所访问；②一个进程只有通过调用管程内的过程才能进入管程访问共享数据；③每次仅允许一个 进程在管程内执行某个内部过程，因此选项C 和 D 正确。", "answer": "A || 解析：管程是由一组数据及定义在这组数据之上的对这组数据的操作组成的软件模块，这组操作能  初始化并改变管程中的数据和同步进程。管程不仅能实现进程间的互斥，还能实现进程间的同步， 因此选项A 错误、B 正确；管程具有如下特性：①局部于管程的数据只能被局部于管程内的过程 所访问；②一个进程只有通过调用管程内的过程才能进入管程访问共享数据；③每次仅允许一个 进程在管程内执行某个内部过程，因此选项C 和 D 正确。"}
{"id": "277", "type": "单项选择题", "question": "55. ) A. 管程只能用于实现进程的互斥 B. 管程是由编程语言支持的进程同步机制 C.任何时候只能有一个进程在管程中执行 D. 管程中定义的变量只能被管程内的过程访问 5 6 . 【 2 0 1 8 统 考 真 题 】 属 于 同 一 进 程 的 两 个 线 程 thread1 和 thread2 并 发 执 行 ， 共 享 初 值 为 0 的 全 局 变 量 x。 thread1和 thread2实现对全局变量x 加1的机器级代码描述如下。 在所有可能的指令执行序列中，使x 的值为2的序列个数是( ) A.1 B.2 C.3 D.4", "answer_label": "B", "answer_explain": "仔细阅读两个线程代码可知，threadl  和 thread2 均是对x 进行加1操作， x 的初始值为0,若 要使得最终x=2,     只能先执行完thread1 再执行 thread2,   或先执行完thread2 再执行thread1,    因 此仅有2种可能。", "answer": "B || 解析：仔细阅读两个线程代码可知，threadl  和 thread2 均是对x 进行加1操作， x 的初始值为0,若 要使得最终x=2,     只能先执行完thread1 再执行 thread2,   或先执行完thread2 再执行thread1,    因 此仅有2种可能。"}
{"id": "278", "type": "单项选择题", "question": "57.【2018统考真题】若x 是管程内的条件变量，则当进程执行 x.wait( ) 时所做的工作是( ) A. 实现对变量 x 的互斥访问 B. 唤醒一个在x 上阻塞的进程 C. 根据x 的值判断该进程是否进入阻塞态 D. 阻塞该进程，并将之插入x 的阻塞队列中", "answer_label": "D", "answer_explain": "“条件变量”是管程内部说明和使用的一种特殊变量，其作用类似于信号量机制中的“信号 量”,都用于实现进程同步。需要注意的是，在同一时刻，管程中只能有一个进程在执行。若进 程 A 执行了x.wait()操作，则该进程会阻塞，并挂到条件变量x 对应的阻塞队列上。这样，管程 的使用权被释放，就可以有另一个进程进入管程。若进程B 执行了x.signal() 操作，则会唤醒 x 对 应的阻塞队列的队首进程。只有一个进程要离开管程时才能调用signal() 操作。", "answer": "D || 解析：“条件变量”是管程内部说明和使用的一种特殊变量，其作用类似于信号量机制中的“信号 量”,都用于实现进程同步。需要注意的是，在同一时刻，管程中只能有一个进程在执行。若进 程 A 执行了x.wait()操作，则该进程会阻塞，并挂到条件变量x 对应的阻塞队列上。这样，管程 的使用权被释放，就可以有另一个进程进入管程。若进程B 执行了x.signal() 操作，则会唤醒 x 对 应的阻塞队列的队首进程。只有一个进程要离开管程时才能调用signal() 操作。"}
{"id": "279", "type": "单项选择题", "question": "58.【2018统考真题】在下列同步机制中，可以实现让权等待的是( ) A.Peterson 方法 B.swap 指令 C. 信号量方法 D.TestAndSet 指令", "answer_label": "C", "answer_explain": "硬件方法实现进程同步时不能实现让权等待，选项B 和 D 错误；Peterson 算法满足有限等待 但不满足让权等待，选项 A 错误；记录型信号量由于引入阻塞机制，消除了不让权等待的情况， 选项 C 正确。", "answer": "C || 解析：硬件方法实现进程同步时不能实现让权等待，选项B 和 D 错误；Peterson 算法满足有限等待 但不满足让权等待，选项 A 错误；记录型信号量由于引入阻塞机制，消除了不让权等待的情况， 选项 C 正确。"}
{"id": "280", "type": "单项选择题", "question": "59.【2020统考真题】下列准则中，实现临界区互斥机制必须遵循的是( ) I. 两个进程不能同时进入临界区 II.允许进程访问空闲的临界资源 III. 进程等待进入临界区的时间是有限的 IV.不能进入临界区的执行态进程立即放弃CPU A. 仅 I 、IV B.仅I、III C. 仅 I 、Ⅱ 、II D. 仅 I 、II 、IV 2.4死锁", "answer_label": "C", "answer_explain": "实现临界区互斥需满足多个准则。“忙则等待”准则，即两个进程不能同时访问临界区，选  项 I 正确。“空闲让进”准则，若临界区空闲，则允许其他进程访问，选项Ⅱ正确。“有限等待” 准则，即进程应该在有限时间内访问临界区，选项Ⅲ正确。选项 I 、Ⅱ 和Ⅲ是互斥机制必须遵  循的原则。选项IV 是“让权等待”准则，不一定非得实现，如皮特森算法。", "answer": "C || 解析：实现临界区互斥需满足多个准则。“忙则等待”准则，即两个进程不能同时访问临界区，选  项 I 正确。“空闲让进”准则，若临界区空闲，则允许其他进程访问，选项Ⅱ正确。“有限等待” 准则，即进程应该在有限时间内访问临界区，选项Ⅲ正确。选项 I 、Ⅱ 和Ⅲ是互斥机制必须遵  循的原则。选项IV 是“让权等待”准则，不一定非得实现，如皮特森算法。"}
{"id": "281", "type": "单项选择题", "question": "1. 下列情况中，可能导致死锁的是( ) A. 进程释放资源 B. 一个进程进入死循环 C. 多个进程竞争资源出现了循环等待 D. 多个进程竞争使用共享型的设备", "answer_label": "C", "answer_explain": "引起死锁的4个必要条件是：互斥、占有并等待、非剥夺和循环等待。本题中，出现了循环  等待的现象，意味着可能导致死锁。进程释放资源不会导致死锁，进程自己进入死循环只能产生  “饥饿”,不涉及其他进程。共享型设备允许多个进程申请使用，因此不会造成死锁。再次提醒， 死锁一定要有两个或两个以上的进程才会导致，而饥饿可能由一个进程导致。", "answer": "C || 解析：引起死锁的4个必要条件是：互斥、占有并等待、非剥夺和循环等待。本题中，出现了循环  等待的现象，意味着可能导致死锁。进程释放资源不会导致死锁，进程自己进入死循环只能产生  “饥饿”,不涉及其他进程。共享型设备允许多个进程申请使用，因此不会造成死锁。再次提醒， 死锁一定要有两个或两个以上的进程才会导致，而饥饿可能由一个进程导致。"}
{"id": "282", "type": "单项选择题", "question": "2. 在哲学家进餐问题中，若所有哲学家同时拿起左筷子，则发生死锁，因为他们都需要右筷子才能用餐。 为了让尽可能多的哲学家可以同时用餐，并且不发生死锁，可以利用信号量 PV 操作实现同步互斥，下 列说法中正确的是()【 A. 使用信号量进行控制的方法一定可以避免死锁 B. 同时检查两支筷子是否可用的方法可以预防死锁，但是会导致饥饿问题 C. 限制允许拿起筷子的哲学家数量可以预防死锁，它破坏了“循环等待”条件 D. 对哲学家顺序编号，奇数号哲学家先拿左筷子，然后拿右筷子，而偶数号哲学家刚好相反，可以预防 死锁，它破坏了“互斥”条件", "answer_label": "C", "answer_explain": "信号量机制能确保临界资源的互斥访问，不能完全避免死锁，选项A 错误。同时检查两支筷 子是否可用的方法可以预防死锁，但是会导致资源浪费，因为可能有一些空闲的筷子无法使用， 但拿到筷子的哲学家用完餐后，释放筷子，其他哲学家就可以正常用餐，因此不会导致饥饿 现象，选项B 错误。若限制允许拿起筷子的哲学家数量，则不被允许的哲学家左边的哲学家一定 可以拿到两边的筷子，从而破坏“循环等待”条件，选项C 正确。对哲学家顺序编号，奇数号哲 学家先拿左筷子，然后拿右筷子，而偶数号哲学家刚好相反，则相邻的哲学家总有一个可以拿起 两边的筷子，但这破坏的是“循环等待”条件，而不是“互斥条件”, 选项D 错误。", "answer": "C || 解析：信号量机制能确保临界资源的互斥访问，不能完全避免死锁，选项A 错误。同时检查两支筷 子是否可用的方法可以预防死锁，但是会导致资源浪费，因为可能有一些空闲的筷子无法使用， 但拿到筷子的哲学家用完餐后，释放筷子，其他哲学家就可以正常用餐，因此不会导致饥饿 现象，选项B 错误。若限制允许拿起筷子的哲学家数量，则不被允许的哲学家左边的哲学家一定 可以拿到两边的筷子，从而破坏“循环等待”条件，选项C 正确。对哲学家顺序编号，奇数号哲 学家先拿左筷子，然后拿右筷子，而偶数号哲学家刚好相反，则相邻的哲学家总有一个可以拿起 两边的筷子，但这破坏的是“循环等待”条件，而不是“互斥条件”, 选项D 错误。"}
{"id": "283", "type": "单项选择题", "question": "3. 下列关于进程死锁的描述中，错误的是( ) A. 若每个进程只能同时申请或拥有一个资源，就不会发生死锁 B. 若多个进程可以无冲突共享访问所有资源，就不会发生死锁 C. 若所有进程的执行严格区分优先级，就不会发生死锁 D. 若进程资源请求之间不存在循环等待，就不会发生死锁", "answer_label": "C", "answer_explain": "进程的执行优先级并不能破坏死锁的四个必要条件。即使有高优先级和低优先级的进程，若 它们都请求或占有了不可抢占的资源，且形成了环路等待，则死锁仍可能发生。选项A 可以破坏 请求并保持条件，选项B 可以破坏互斥条件，选项D 可以破坏循环等待条件。", "answer": "C || 解析：进程的执行优先级并不能破坏死锁的四个必要条件。即使有高优先级和低优先级的进程，若 它们都请求或占有了不可抢占的资源，且形成了环路等待，则死锁仍可能发生。选项A 可以破坏 请求并保持条件，选项B 可以破坏互斥条件，选项D 可以破坏循环等待条件。"}
{"id": "284", "type": "单项选择题", "question": "4. 一次分配所有资源的方法可以预防死锁的发生，它破坏死锁4个必要条件( ) A. 互斥 B. 占有并请求 C. 非剥夺 D. 循环等待", "answer_label": "B", "answer_explain": "发生死锁的4个必要条件：互斥、占有并请求、非剥夺和循环等待。 一次分配所有资源的方 法是当进程需要资源时，一次性提出所有的请求，若请求的所有资源均满足则分配，只要有一项 不满足，就不分配任何资源，该进程阻塞，直到所有的资源空闲后，满足进程的所有需求时再分 配。这种分配方式不会部分地占有资源，因此打破了死锁的4个必要条件之一，实现了对死锁的 预防。但是，这种分配方式需要凑齐所有资源，因此当一个进程所需的资源较多时，资源的利用 率会较低，甚至会造成进程“饥饿”。", "answer": "B || 解析：发生死锁的4个必要条件：互斥、占有并请求、非剥夺和循环等待。 一次分配所有资源的方 法是当进程需要资源时，一次性提出所有的请求，若请求的所有资源均满足则分配，只要有一项 不满足，就不分配任何资源，该进程阻塞，直到所有的资源空闲后，满足进程的所有需求时再分 配。这种分配方式不会部分地占有资源，因此打破了死锁的4个必要条件之一，实现了对死锁的 预防。但是，这种分配方式需要凑齐所有资源，因此当一个进程所需的资源较多时，资源的利用 率会较低，甚至会造成进程“饥饿”。"}
{"id": "285", "type": "单项选择题", "question": "5. 系统产生死锁的可能原因是( ) A. 独占资源分配不当 B. 系统资源不足 C. 进程运行太快 D.CPU 内核太多", "answer_label": "A", "answer_explain": "系统死锁的可能原因主要是时间上和空间上的。时间上由于进程运行中推进顺序不当，即调 度时机不合适，不该切换进程时进行了切换，可能造成死锁；空间上的原因是对独占资源分配不 当，互斥资源部分分配又不可剥夺，极易造成死锁。那么,为什么系统资源不足不是造成死锁的 原因呢?系统资源不足只会对进程造成“饥饿”。例如，某系统只有三台打印机，若进程运行中 要申请四台，显然不能满足，该进程会永远等待下去。若该进程在创建时便声明需要四台打印机， 则操作系统立即就会拒绝，这实际上是资源分配不当的一种表现。不能以系统资源不足来描述剩 余资源不足的情形。", "answer": "A || 解析：系统死锁的可能原因主要是时间上和空间上的。时间上由于进程运行中推进顺序不当，即调 度时机不合适，不该切换进程时进行了切换，可能造成死锁；空间上的原因是对独占资源分配不 当，互斥资源部分分配又不可剥夺，极易造成死锁。那么,为什么系统资源不足不是造成死锁的 原因呢?系统资源不足只会对进程造成“饥饿”。例如，某系统只有三台打印机，若进程运行中 要申请四台，显然不能满足，该进程会永远等待下去。若该进程在创建时便声明需要四台打印机， 则操作系统立即就会拒绝，这实际上是资源分配不当的一种表现。不能以系统资源不足来描述剩 余资源不足的情形。"}
{"id": "286", "type": "单项选择题", "question": "6. 死锁的避免是根据( )采取措施实现的。 A. 配置足够的系统资源 B. 使进程的推进顺序合理 C. 破坏死锁的四个必要条件之一 D. 防止系统进入不安全状态", "answer_label": "D", "answer_explain": "死锁避免是指在资源动态分配过程中用某些算法加以限制，防止系统进入不安全状态从而避 免死锁的发生。选项B 是避免死锁后的结果，而不是措施的原理。", "answer": "D || 解析：死锁避免是指在资源动态分配过程中用某些算法加以限制，防止系统进入不安全状态从而避 免死锁的发生。选项B 是避免死锁后的结果，而不是措施的原理。"}
{"id": "287", "type": "单项选择题", "question": "7. 死锁预防是保证系统不进入死锁状态的静态策略，其解决办法是破坏产生死锁的四个必要条件之一。 下列方法中破坏了“循环等待”条件的是() A. 银行家算法 B. 一次性分配策略 C. 剥夺资源法 D. 资源有序分配策略", "answer_label": "D", "answer_explain": "资源有序分配策略可以限制循环等待条件的发生。选项 A 判断是否为不安全状态；选项 B 破坏了占有请求条件；选项C 破坏了非剥夺条件。", "answer": "D || 解析：资源有序分配策略可以限制循环等待条件的发生。选项 A 判断是否为不安全状态；选项 B 破坏了占有请求条件；选项C 破坏了非剥夺条件。"}
{"id": "288", "type": "单项选择题", "question": "8. 可以防止系统出现死锁的手段是( ) A. 用 PV 操作管理共享资源 B. 使进程互斥地使用共享资源 C. 采用资源静态分配策略 D. 定时运行死锁检测程序", "answer_label": "C", "answer_explain": "PV 操作不能破坏死锁条件，反而可能加强互斥和占有并等待条件。选项B 同理。选项C 可 以破坏请求并保持条件。选项D 只能在系统出现死锁时检测，却不能防止系统出现死锁。", "answer": "C || 解析：PV 操作不能破坏死锁条件，反而可能加强互斥和占有并等待条件。选项B 同理。选项C 可 以破坏请求并保持条件。选项D 只能在系统出现死锁时检测，却不能防止系统出现死锁。"}
{"id": "289", "type": "单项选择题", "question": "9. 某系统中有三个并发进程都需要四个同类资源，则该系统必然不会发生死锁的最少资源是( ) A.9 B.10 C.11 D.12", "answer_label": "B", "answer_explain": "资源数为9时，存在三个进程都占有三个资源，为死锁；资源数为10时，必然存在一个进 程能拿到4个资源，然后可以顺利执行完其他进程。", "answer": "B || 解析：资源数为9时，存在三个进程都占有三个资源，为死锁；资源数为10时，必然存在一个进 程能拿到4个资源，然后可以顺利执行完其他进程。"}
{"id": "290", "type": "单项选择题", "question": "10. 某系统中共有11台磁带机，X 个进程共享此磁带机设备，每个进程最多请求使用3台，则系统必然不会 死锁的最大X值是( ) A.4 B.5 C.6 D.7", "answer_label": "B", "answer_explain": "考虑一下极端情况：每个进程已经分配了两台磁带机，那么其中任何一个进程只要再分配一 台磁带机即可满足它的最大需求，该进程总能运行下去直到结束，然后将磁带机归还给系统再次分配给其他进程使用。因此，系统中只要满足2X+1=11   这个条件即可认为系统不会死锁，解得 X=5,  也就是说，系统中最多可以并发5个这样的进程是不会死锁的。或者，根据死锁公式，资 源数大于进程个数乘以“每个进程需要的最大资源数减1”就不会发生死锁，即m>n(w-1),       其 中 m 是磁带机的数量，n  是进程的数量，w 是每个进程最多请求的磁带机数量。代入可得11> n(3-1),    即 n<5.5,n      是正整数，因此系统必然不会死锁的最大n 值是5。", "answer": "B || 解析：考虑一下极端情况：每个进程已经分配了两台磁带机，那么其中任何一个进程只要再分配一 台磁带机即可满足它的最大需求，该进程总能运行下去直到结束，然后将磁带机归还给系统再次分配给其他进程使用。因此，系统中只要满足2X+1=11   这个条件即可认为系统不会死锁，解得 X=5,  也就是说，系统中最多可以并发5个这样的进程是不会死锁的。或者，根据死锁公式，资 源数大于进程个数乘以“每个进程需要的最大资源数减1”就不会发生死锁，即m>n(w-1),       其 中 m 是磁带机的数量，n  是进程的数量，w 是每个进程最多请求的磁带机数量。代入可得11> n(3-1),    即 n<5.5,n      是正整数，因此系统必然不会死锁的最大n 值是5。"}
{"id": "291", "type": "单项选择题", "question": "11.若系统中有5个某类资源供若干进程共享，则不会引起死锁的情况是() A. 有6个进程，每个进程需1个资源 B. 有5个进程，每个进程需2个资源 C. 有4个进程，每个进程需3个资源 D. 有3个进程，每个进程需4个资源", "answer_label": "A", "answer_explain": "A 项的每个进程只申请一个资源，破坏了请求并保持条件，必然不会发生死锁。或者，根据 死锁公式，假设系统共有 m 个资源，n 个进程，每个进程需要k 个资源，若满足m>n(k-1),        则 系统一定不会发生死锁，代入公式可知选项B 、C 、D 均可能发生死锁。", "answer": "A || 解析：A 项的每个进程只申请一个资源，破坏了请求并保持条件，必然不会发生死锁。或者，根据 死锁公式，假设系统共有 m 个资源，n 个进程，每个进程需要k 个资源，若满足m>n(k-1),        则 系统一定不会发生死锁，代入公式可知选项B 、C 、D 均可能发生死锁。"}
{"id": "292", "type": "单项选择题", "question": "12. 解除死锁通常不采用的方法是( ) A. 终止一个死锁进程 B. 终止所有死锁进程 C. 从死锁进程处抢夺资源 D. 从非死锁进程处抢夺资源", "answer_label": "D", "answer_explain": "解除死锁的方法有，①剥夺资源法：挂起某些死锁进程，并抢占它的资源，将这些资源分配 给其他的死锁进程；②撤销进程法：强制撤销部分甚至全部死锁进程并剥夺这些进程的资源。", "answer": "D || 解析：解除死锁的方法有，①剥夺资源法：挂起某些死锁进程，并抢占它的资源，将这些资源分配 给其他的死锁进程；②撤销进程法：强制撤销部分甚至全部死锁进程并剥夺这些进程的资源。"}
{"id": "293", "type": "单项选择题", "question": "13. 采用资源剥夺法可以解除死锁，还可以采用()方法解除死锁。 A. 执行并行操作 B. 撤销进程 C. 拒绝分配新资源 D. 修改信号量", "answer_label": "B", "answer_explain": "资源剥夺法允许一个进程强行剥夺其他进程所占有的系统资源。而撤销进程强行释放一个进 程已占有的系统资源，与资源剥夺法同理，都通过破坏死锁的“请求和保持”条件来解除死锁。 拒绝分配新资源只能维持死锁的现状，无法解除死锁。", "answer": "B || 解析：资源剥夺法允许一个进程强行剥夺其他进程所占有的系统资源。而撤销进程强行释放一个进 程已占有的系统资源，与资源剥夺法同理，都通过破坏死锁的“请求和保持”条件来解除死锁。 拒绝分配新资源只能维持死锁的现状，无法解除死锁。"}
{"id": "294", "type": "单项选择题", "question": "14. 在下列死锁的解决方法中，属于死锁预防策略的是( ) A. 银行家算法 B. 资源有序分配算法 C. 死锁检测算法 D. 资源分配图化简法", "answer_label": "B", "answer_explain": "其中，银行家算法为死锁避免算法，死锁检测算法和资源分配图化简法为死锁检测，根据排 除法可以得出资源有序分配算法为死锁预防策略。", "answer": "B || 解析：其中，银行家算法为死锁避免算法，死锁检测算法和资源分配图化简法为死锁检测，根据排 除法可以得出资源有序分配算法为死锁预防策略。"}
{"id": "295", "type": "单项选择题", "question": "15. 三个进程共享四个同类资源，这些资源的分配与释放只能一次一个。已知每个进程最多需要两个该类 资源，则该系统( ) A. 有些进程可能永远得不到该类资源 B. 必然有死锁 C. 进程请求该类资源必然能得到 D. 必然是死锁", "answer_label": "C", "answer_explain": "不会发生死锁。因为每个进程都分得一个资源时，还有一个资源可以让任意一个进程满足， 这样这个进程可以顺利运行完成进而释放它的资源。", "answer": "C || 解析：不会发生死锁。因为每个进程都分得一个资源时，还有一个资源可以让任意一个进程满足， 这样这个进程可以顺利运行完成进而释放它的资源。"}
{"id": "296", "type": "单项选择题", "question": "16. 以下有关资源分配图的描述中，正确的是() A. 有向边包括进程指向资源类的分配边和资源类指向进程申请边两类 B. 矩形框表示进程，其中圆点表示申请同一类资源的各个进程 C. 圆圈结点表示资源类 D. 资源分配图是一个有向图，用于表示某时刻系统资源与进程之间的状态", "answer_label": "D", "answer_explain": "进程指向资源的有向边称为申请边，资源指向进程的有向边称为分配边，选项A 张冠李戴； 矩形框表示资源，其中的圆点表示资源的数量，选项B 错；圆圈节点表示进程，选项C 错；选项 D 的说法是正确的。", "answer": "D || 解析：进程指向资源的有向边称为申请边，资源指向进程的有向边称为分配边，选项A 张冠李戴； 矩形框表示资源，其中的圆点表示资源的数量，选项B 错；圆圈节点表示进程，选项C 错；选项 D 的说法是正确的。"}
{"id": "297", "type": "单项选择题", "question": "17. 死锁的四个必要条件中，无法破坏的是( ) A. 环路等待资源 B. 互斥使用资源 C. 占有且等待资源 D. 非抢夺式分配", "answer_label": "B", "answer_explain": "所谓破坏互斥使用资源，是指允许多个进程同时访问资源，但有些资源根本不能同时访问， 如打印机只能互斥使用。因此，破坏互斥条件而预防死锁的方法不太可行，而且在有的场合应该 保护这种互斥性。其他三个条件都可以实现。", "answer": "B || 解析：所谓破坏互斥使用资源，是指允许多个进程同时访问资源，但有些资源根本不能同时访问， 如打印机只能互斥使用。因此，破坏互斥条件而预防死锁的方法不太可行，而且在有的场合应该 保护这种互斥性。其他三个条件都可以实现。"}
{"id": "298", "type": "单项选择题", "question": "18. 死锁与安全状态的关系是() A. 死锁状态有可能是安全状态 B. 安全状态有可能成为死锁状态 C. 不安全状态就是死锁状态 D. 死锁状态一定是不安全状态", "answer_label": "D", "answer_explain": "如下图所示，并非所有不安全状态都是死锁状态，但当系统进入不安全状态后，便可能进入死  锁状态；反之，只要系统处于安全状态，系统便可避免进入死锁状态；死锁状态必定是不安全状态。", "answer": "D || 解析：如下图所示，并非所有不安全状态都是死锁状态，但当系统进入不安全状态后，便可能进入死  锁状态；反之，只要系统处于安全状态，系统便可避免进入死锁状态；死锁状态必定是不安全状态。"}
{"id": "299", "type": "单项选择题", "question": "19. 死锁检测时检查的是() A. 资源有向图 B. 前驱图 C. 搜索树 D. 安全图", "answer_label": "A", "answer_explain": "死锁检测一般采用两种方法：资源有向图法和资源矩阵法。前驱图只是说明进程之间 的同步关系，搜索树用于数据结构的分析，安全图并不存在。注意死锁避免和死锁检测的 区别：死锁避免是指避免死锁发生，即死锁没有发生；死锁检测是指死锁已出现，要把它\n检测出来。", "answer": "A || 解析：死锁检测一般采用两种方法：资源有向图法和资源矩阵法。前驱图只是说明进程之间 的同步关系，搜索树用于数据结构的分析，安全图并不存在。注意死锁避免和死锁检测的 区别：死锁避免是指避免死锁发生，即死锁没有发生；死锁检测是指死锁已出现，要把它\n检测出来。"}
{"id": "300", "type": "单项选择题", "question": "20. 某个系统采用下列资源分配策略。若一个进程提出资源请求得不到满足，而此时没有由于等待资源而 被阻塞的进程，则自己就被阻塞。而当此时已有等待资源而被阻塞的进程，则检查所有由于等待资源而 被阻塞的进程。若它们有申请进程所需要的资源，则将这些资源取出并分配给申请进程。这种分配策 略 会 导 致 ( ) A. 死锁 B. 颠簸 C. 回退 D. 饥饿", "answer_label": "D", "answer_explain": "某个进程主动释放资源不会导致死锁，因为破坏了请求并保持条件，选项A 错。颠簸也就是 抖动，这是请求分页系统中页面调度不当而导致的现象，是下一章讨论的问题，这里权且断定选 项 B 是错的。回退是指从此时此刻的状态退回到一分钟之前的状态，假如一分钟之前拥有资源X,   它有可能释放了资源X, 那就不称回到一分钟之前的状态，也就不是回退，选项C 错。因为进程 过于“慷慨”,不断把自己已得到的资源送给别人，导致自己长期无法完成，所以是饥饿，选项 D 正确。", "answer": "D || 解析：某个进程主动释放资源不会导致死锁，因为破坏了请求并保持条件，选项A 错。颠簸也就是 抖动，这是请求分页系统中页面调度不当而导致的现象，是下一章讨论的问题，这里权且断定选 项 B 是错的。回退是指从此时此刻的状态退回到一分钟之前的状态，假如一分钟之前拥有资源X,   它有可能释放了资源X, 那就不称回到一分钟之前的状态，也就不是回退，选项C 错。因为进程 过于“慷慨”,不断把自己已得到的资源送给别人，导致自己长期无法完成，所以是饥饿，选项 D 正确。"}
{"id": "301", "type": "单项选择题", "question": "21. 系统的资源分配图在下列情况下，无法判断是否处于死锁状态的有() I. 出现了环路 II. 没有环路 III. 每种资源只有一个，并出现环路 IV. 每个进程结点至少有一条请求边 A.I 、II 、III 、IV B.I 、III 、IV C.I 、IV D. 以上答案都不正确", "answer_label": "C", "answer_explain": "出现了环路，只是满足了循环等待的必要条件，而满足必要条件不一定会导致死锁，选项 I  对；没有环路，破坏了循环等待条件，一定不会发生死锁，选项Ⅱ错；每种资源只有一个，又出 现了环路，这是死锁的充分条件，可以确定是否有死锁，选项Ⅲ错；即使每个进程至少有一条 请求边，若资源足够，则不会发生死锁，但若资源不充足，则有发生死锁的可能，选项IV  对。 综上所述，选择选项C。", "answer": "C || 解析：出现了环路，只是满足了循环等待的必要条件，而满足必要条件不一定会导致死锁，选项 I  对；没有环路，破坏了循环等待条件，一定不会发生死锁，选项Ⅱ错；每种资源只有一个，又出 现了环路，这是死锁的充分条件，可以确定是否有死锁，选项Ⅲ错；即使每个进程至少有一条 请求边，若资源足够，则不会发生死锁，但若资源不充足，则有发生死锁的可能，选项IV  对。 综上所述，选择选项C。"}
{"id": "302", "type": "单项选择题", "question": "22. 下列关于死锁的说法中，正确的有() I. 死锁状态一定是不安全状态 II. 产生死锁的根本原因是系统资源分配不足和进程推进顺序非法 III. 资源的有序分配策略可以破坏死锁的循环等待条件 IV. 采用资源剥夺法可以解除死锁，还可以采用撤销进程方法解除死锁 A.I 、III B.II C.IV D. 四个说法都对", "answer_label": "D", "answer_explain": "选项I 正确。\n选项Ⅱ正确：这是产生死锁的两大原因。\n选项Ⅲ正确：在对资源进行有序分配时，进程间不可能出现环形链，即不会出现循环等待。\n选项IV  正确：资源剥夺法允许一个进程强行剥夺其他进程占有的系统资源。而撤销进程强 行释放一个进程已占有的系统资源，与资源剥夺法同理，都通过破坏死锁的“请求和保持”条件 来解除死锁，所以选择选项D。", "answer": "D || 解析：选项I 正确。\n选项Ⅱ正确：这是产生死锁的两大原因。\n选项Ⅲ正确：在对资源进行有序分配时，进程间不可能出现环形链，即不会出现循环等待。\n选项IV  正确：资源剥夺法允许一个进程强行剥夺其他进程占有的系统资源。而撤销进程强 行释放一个进程已占有的系统资源，与资源剥夺法同理，都通过破坏死锁的“请求和保持”条件 来解除死锁，所以选择选项D。"}
{"id": "303", "type": "单项选择题", "question": "23. 下面是一个并发进程的程序代码，正确的是( ) A. 进程不会死锁，也不会“饥饿” B. 进程不会死锁，但是会“饥饿” C. 进程会死锁，但是不会“饥饿” D. 进程会死锁，也会“饥饿”", "answer_label": "B", "answer_explain": "遇到这种问题时千万不要慌张，下面我们来慢慢分析，给读者一个清晰的解题过程：\n仔细考察程序代码，可以看出这是一个扩展的单行线问题。也就是说，某单行线只允许单方 向的车辆通过，在单行线的入口设置信号量y,  在告示牌上显示某一时刻各方向来车的数量c1 和 c2,   要修改告示牌上的车辆数量必须互斥进行，为此设置信号量x1  和 x2 。若某方向的车辆需要 通过时，则首先要将该方向来车数量c1 或 c2 增加1,并查看自己是否是第一个进入单行线的车 辆，若是，则获取单行线的信号量 y,   并进入单行线。通过此路段以后出单行线时，将该方向的 车辆数c1 或 c2 减1(当然是利用x1 或×2来互斥修改),并查看自己是否是最后一辆车，若是， 则释放单行线的互斥量 y,   否则保留信号量 y,   让后继车辆继续通过。双方的操作如出一辙。考 虑出现一个极端情况，即当某方向的车辆首先占据单行线并后来者络绎不绝时，另一个方向的车 辆就再没有机会通过该单行线了。而这种现象是由于算法本身的缺陷造成的，不属于因为特殊序 列造成的饥饿，所以它是真正的饥饿现象。因为有信号量的控制，所以死锁的可能性没有了(双 方同时进入单行线，在中间相遇，造成双方均无法通过的情景)。\n①假设P₁ 进程稍快，P₂ 进程稍慢，同时运行；②P₁进程首先进入 if 条件语句，因此获得了y  的互斥访问权，P₂ 被阻塞；③在第一个P₁ 进程未释放y 之前，又有另一个 P₁ 进入，cl  的值变成2,  当第一个 P₁ 离开时，P₂ 仍然被阻塞，这种情形不断发生；④在这种情况下会发生什么事? P₁ 顺利 执行，P₂ 很郁闷，长期被阻塞。\n综上所述，不会发生死锁，但会出现饥饿现象。因此选 B。", "answer": "B || 解析：遇到这种问题时千万不要慌张，下面我们来慢慢分析，给读者一个清晰的解题过程：\n仔细考察程序代码，可以看出这是一个扩展的单行线问题。也就是说，某单行线只允许单方 向的车辆通过，在单行线的入口设置信号量y,  在告示牌上显示某一时刻各方向来车的数量c1 和 c2,   要修改告示牌上的车辆数量必须互斥进行，为此设置信号量x1  和 x2 。若某方向的车辆需要 通过时，则首先要将该方向来车数量c1 或 c2 增加1,并查看自己是否是第一个进入单行线的车 辆，若是，则获取单行线的信号量 y,   并进入单行线。通过此路段以后出单行线时，将该方向的 车辆数c1 或 c2 减1(当然是利用x1 或×2来互斥修改),并查看自己是否是最后一辆车，若是， 则释放单行线的互斥量 y,   否则保留信号量 y,   让后继车辆继续通过。双方的操作如出一辙。考 虑出现一个极端情况，即当某方向的车辆首先占据单行线并后来者络绎不绝时，另一个方向的车 辆就再没有机会通过该单行线了。而这种现象是由于算法本身的缺陷造成的，不属于因为特殊序 列造成的饥饿，所以它是真正的饥饿现象。因为有信号量的控制，所以死锁的可能性没有了(双 方同时进入单行线，在中间相遇，造成双方均无法通过的情景)。\n①假设P₁ 进程稍快，P₂ 进程稍慢，同时运行；②P₁进程首先进入 if 条件语句，因此获得了y  的互斥访问权，P₂ 被阻塞；③在第一个P₁ 进程未释放y 之前，又有另一个 P₁ 进入，cl  的值变成2,  当第一个 P₁ 离开时，P₂ 仍然被阻塞，这种情形不断发生；④在这种情况下会发生什么事? P₁ 顺利 执行，P₂ 很郁闷，长期被阻塞。\n综上所述，不会发生死锁，但会出现饥饿现象。因此选 B。"}
{"id": "304", "type": "单项选择题", "question": "24. 有两个并发进程，对于如下这段程序的运行，正确的说法是( ) A. 程序能正确运行，结果唯一 B. 程序不能正确运行，可能有两种结果 C. 程序不能正确运行，结果不确定 D. 程序不能正确运行，可能会死锁", "answer_label": "C", "answer_explain": "本题中两个进程不能正确地工作，运行结果的可能性详见下面的说明。\n1.x=1;                                               5.x=0;\n2.y=0;                                              6.t=0;fx>=1            theny=y+1;                                       7.ifx<=1      then      t=t+2;\n4.z=y;                                              8.u=t;\n不确定的原因是由于使用了公共变量x,   考查程序中与变量x 有关的语句共四处，执行的顺 序是1 → 2 → 3 →4 → 5 →6 → 7 →8时，结果是y=1,z=1,t=2,u=2,x=0;                 并发执行过程是1 → 2→5 →6→3 →4→7 →8时，结果是y=0,z=0,t=2,u=2,x=0;                      执行的顺序是5 →6 → 7 →8 → 1 →2 →3 →4时，结果是y=1,z=1,t=2,u=2,x=1;                    执行的顺序是5 →6 → 1 →2 →7 →8 →3 →4 时，结果是y=1,z=1,t=2,u=2,x=1 。       可见结果有多种可能性。\n显然，无论执行顺序如何，x 的结果只能是0或1,因此语句7的条件一定成立，即t=u=2\n的结果是一定的；而y=z   必定成立，只可能有0,1两种情况，又不可能出现x=1,y=z=0        的情 况，所以总共只有3种结果(答案中的3种)。", "answer": "C || 解析：本题中两个进程不能正确地工作，运行结果的可能性详见下面的说明。\n1.x=1;                                               5.x=0;\n2.y=0;                                              6.t=0;fx>=1            theny=y+1;                                       7.ifx<=1      then      t=t+2;\n4.z=y;                                              8.u=t;\n不确定的原因是由于使用了公共变量x,   考查程序中与变量x 有关的语句共四处，执行的顺 序是1 → 2 → 3 →4 → 5 →6 → 7 →8时，结果是y=1,z=1,t=2,u=2,x=0;                 并发执行过程是1 → 2→5 →6→3 →4→7 →8时，结果是y=0,z=0,t=2,u=2,x=0;                      执行的顺序是5 →6 → 7 →8 → 1 →2 →3 →4时，结果是y=1,z=1,t=2,u=2,x=1;                    执行的顺序是5 →6 → 1 →2 →7 →8 →3 →4 时，结果是y=1,z=1,t=2,u=2,x=1 。       可见结果有多种可能性。\n显然，无论执行顺序如何，x 的结果只能是0或1,因此语句7的条件一定成立，即t=u=2\n的结果是一定的；而y=z   必定成立，只可能有0,1两种情况，又不可能出现x=1,y=z=0        的情 况，所以总共只有3种结果(答案中的3种)。"}
{"id": "305", "type": "单项选择题", "question": "25. 一个进程在获得资源后，只能在使用完资源后由自己释放，这属于死锁必要条件的( ) A. 互斥条件 B. 请求和释放条件 C. 不剥夺条件 D. 防止系统进入不安全状态", "answer_label": "C", "answer_explain": "一个进程在获得资源后，只能在使用完资源后由自己释放，即它的资源不能被系统剥夺，答 案为选项C。", "answer": "C || 解析：一个进程在获得资源后，只能在使用完资源后由自己释放，即它的资源不能被系统剥夺，答 案为选项C。"}
{"id": "306", "type": "单项选择题", "question": "26. 假设具有5个进程的进程集合 P={Po,P₁,P₂,P₃,P₄}, 系统中有三类资源 A,B,C, 假设在某时刻有如下 状态，见下表。系统是处于安全状态的，则x,y,z 的取值可能是( ) I.1,4,0 II.0,6,2 III.1,1,1 IV.0,4,7 A.I 、II 、IV B.I、II C. 仅 I D.I 、III", "answer_label": "C", "answer_explain": "选项I:  根据need 矩阵可知，当Available 为(1,4,0)时，可满足P₂ 的需求；P₂ 结束后释放资源， Available 为(2,7,5)可以满足Po,P₁,P₃,P₄   中任意一个进程的需求，所以系统不会出现死锁，处于安 全状态。选项Ⅱ:当Available为(0,6,2)时，可以满足进程P₀,P₃ 的需求；这两个进程结束后释放资  源 ，Available 为(0,6,7),仅可以满足进程4的需求； P₄ 结束并释放后，Available 为(0,6,8),此时  不能满足余下任意一个进程的需求，因此当前处在非安全状态。选项Ⅲ:当Available为(1,1,1)时， 可以满足进程P₀,P₂  的需求；这两个进程结束后释放资源，Available 为(2,4,9),此时不能满足余下 任意一个进程的需求，处于非安全状态。选项IV:   当 Available为(0,4,7)时，可以满足P₀的需求， 进程结束后释放资源，Available 为(0,4,10),此时不能满足余下任意一个进程的需求，处于非安全  状 态 。\n综上分析：只有选项I 处于安全状态。", "answer": "C || 解析：选项I:  根据need 矩阵可知，当Available 为(1,4,0)时，可满足P₂ 的需求；P₂ 结束后释放资源， Available 为(2,7,5)可以满足Po,P₁,P₃,P₄   中任意一个进程的需求，所以系统不会出现死锁，处于安 全状态。选项Ⅱ:当Available为(0,6,2)时，可以满足进程P₀,P₃ 的需求；这两个进程结束后释放资  源 ，Available 为(0,6,7),仅可以满足进程4的需求； P₄ 结束并释放后，Available 为(0,6,8),此时  不能满足余下任意一个进程的需求，因此当前处在非安全状态。选项Ⅲ:当Available为(1,1,1)时， 可以满足进程P₀,P₂  的需求；这两个进程结束后释放资源，Available 为(2,4,9),此时不能满足余下 任意一个进程的需求，处于非安全状态。选项IV:   当 Available为(0,4,7)时，可以满足P₀的需求， 进程结束后释放资源，Available 为(0,4,10),此时不能满足余下任意一个进程的需求，处于非安全  状 态 。\n综上分析：只有选项I 处于安全状态。"}
{"id": "307", "type": "单项选择题", "question": "27. 死锁定理是用于处理死锁的()方法。 A. 预防死锁 B. 避免死锁 C. 检测死锁 D. 解除死锁", "answer_label": "C", "answer_explain": "死锁定理是用于检测死锁的方法。", "answer": "C || 解析：死锁定理是用于检测死锁的方法。"}
{"id": "308", "type": "单项选择题", "question": "28. 某系统有 m 个同类资源供n 个进程共享，若每个进程最多申请 k 个资源(k≥1), 采用银行家算法分配 资源，为保证系统不发生死锁，则各进程的最大需求量之和应() A. 等于 m B. 等于m+n C. 小于m+n D. 大于m+n", "answer_label": "C", "answer_explain": "按照银行家算法，只要保证系统中进程申请的最大资源数小于或等于m, 就一定存在一个安 全序列。考虑最极端的情况，假如有n-1    个进程都申请了1个资源，剩下一个进程申请了m 个 资源，则各进程的最大需求量之和为m+n-1,       此时能保证一定不会发生死锁。", "answer": "C || 解析：按照银行家算法，只要保证系统中进程申请的最大资源数小于或等于m, 就一定存在一个安 全序列。考虑最极端的情况，假如有n-1    个进程都申请了1个资源，剩下一个进程申请了m 个 资源，则各进程的最大需求量之和为m+n-1,       此时能保证一定不会发生死锁。"}
{"id": "309", "type": "单项选择题", "question": "29. 采用银行家算法可以避免死锁的发生，这是因为该算法() A. 可以抢夺已分配的资源 B. 能及时为各进程分配资源 C. 任何时刻都能保证每个进程能得到所需的资源 D. 任何时刻都能保证至少有一个进程可以得到所需的全部资源", "answer_label": "D", "answer_explain": "任何时刻都能保证至少有一个进程可以得到所需的全部资源，这意味着银行家算法可以保证 系统中至少存在一个安全序列，使每个进程都能按该顺序得到所需的全部资源并正常结束，不会\n出现死锁的情况。这也是银行家算法避免死锁的核心思想。", "answer": "D || 解析：任何时刻都能保证至少有一个进程可以得到所需的全部资源，这意味着银行家算法可以保证 系统中至少存在一个安全序列，使每个进程都能按该顺序得到所需的全部资源并正常结束，不会\n出现死锁的情况。这也是银行家算法避免死锁的核心思想。"}
{"id": "310", "type": "单项选择题", "question": "30. 用银行家算法避免死锁时，检测到( )时才分配资源。 A. 进程首次申请资源时对资源的最大需求量超过系统现存的资源量 B. 进程己占有的资源数与本次申请的资源数之和超过对资源的最大需求量 C. 进程已占有的资源数与本次申请的资源数之和不超过对资源的最大需求量，且现存资源量能满足尚 需的最大资源量 D. 进程已占有的资源数与本次申请的资源数之和不超过对资源的最大需求量，且现存资源量能满足本 次申请量，但不能满足尚需的最大资源量", "answer_label": "C", "answer_explain": "银行家算法要求，进程运行之前先声明它对各类资源的最大需求量，并保证它在任何时刻对 每类资源的请求量不超过它所声明的最大需求量。当进程已占有的资源数与本次申请的资源数之 和不超过对资源的最大需求量，且现存资源量能满足尚需的最大资源量时，才分配资源。", "answer": "C || 解析：银行家算法要求，进程运行之前先声明它对各类资源的最大需求量，并保证它在任何时刻对 每类资源的请求量不超过它所声明的最大需求量。当进程已占有的资源数与本次申请的资源数之 和不超过对资源的最大需求量，且现存资源量能满足尚需的最大资源量时，才分配资源。"}
{"id": "311", "type": "单项选择题", "question": "31. 下列各种方法中，可用于解除已发生死锁的是( ) A. 撤销部分或全部死锁进程 B. 剥夺部分或全部死锁进程的资源 C. 降低部分或全部死锁进程的优先级 D.A 和 B 都可以", "answer_label": "D", "answer_explain": "解除死锁的方法有两种：撤销死锁进程和剥夺死锁进程的资源。降低死锁进程的优先级是无 效的方法，因为它不能改变死锁进程对资源的需求和占有，也不能打破循环等待条件。", "answer": "D || 解析：解除死锁的方法有两种：撤销死锁进程和剥夺死锁进程的资源。降低死锁进程的优先级是无 效的方法，因为它不能改变死锁进程对资源的需求和占有，也不能打破循环等待条件。"}
{"id": "312", "type": "单项选择题", "question": "32. 假定某计算机系统有 R₁ 和 R₂ 两类可使用资源(其中R₁ 有两个单位，R₂ 有一个单位),它们被进程P₁ 和 P₂ 所共享，且己知两个进程均按下列顺序使用两类资源：申请 R₁→ 申请 R₂→ 申请 R₁→ 释放 R₁→ 释放R₂→ 释放R₁, 则在系统运行过程中，( )【 A. 不可能产生死锁 B. 有可能产生死锁，因为R₁ 资源不足 C. 有可能产生死锁，因为R₂ 资源不足 D. 只有一种进程执行序列可能导致死锁", "answer_label": "B", "answer_explain": "当两个进程都执行完第一步后，即进程P₁ 和进程P₂ 都申请到了一个 R  类资源时，随着两个 进程向前推进，无论哪个进程执行完第二步，系统都将进入死锁状态，进入死锁状态的原因是两 个进程都需要两个R  类资源才能运行，但系统中此时已经没有可供分配的R  类资源。假定进程 P₁ 成功执行了第二步，则死锁发生时资源分配图如下图所示。", "answer": "B || 解析：当两个进程都执行完第一步后，即进程P₁ 和进程P₂ 都申请到了一个 R  类资源时，随着两个 进程向前推进，无论哪个进程执行完第二步，系统都将进入死锁状态，进入死锁状态的原因是两 个进程都需要两个R  类资源才能运行，但系统中此时已经没有可供分配的R  类资源。假定进程 P₁ 成功执行了第二步，则死锁发生时资源分配图如下图所示。"}
{"id": "313", "type": "单项选择题", "question": "33. 某计算机系统中有8台打印机，由K 个进程竞争使用，每个进程最多需要3台打印机。该系统可能会发 生死锁的K 的最小值是( ) A.2 B.3 C.4 D.5", "answer_label": "C", "answer_explain": "这类题可用到组合数学中鸽巢原理的思想。考虑最极端的情况，因为每个进程最多需要3台 打印机，若每个进程已经占有了2台打印机，则只要还有多的打印机，总能满足一个进程达到3 台的条件，然后顺利执行，所以将8台打印机分给K 个进程，每个进程有2台打印机，这个情况 就是极端情况，K 为4。或者，假设M 是打印机的数量，K 是进程的数量，R 是每个进程最多需 要打印机的数量。根据死锁公式逆推可得，若M≤K(R-1),     则系统可能发生死锁。将本题的数据 代入，得到8≤K(3-1),     即 K≥4,    因此系统可能发生死锁的K 的最小值是4。", "answer": "C || 解析：这类题可用到组合数学中鸽巢原理的思想。考虑最极端的情况，因为每个进程最多需要3台 打印机，若每个进程已经占有了2台打印机，则只要还有多的打印机，总能满足一个进程达到3 台的条件，然后顺利执行，所以将8台打印机分给K 个进程，每个进程有2台打印机，这个情况 就是极端情况，K 为4。或者，假设M 是打印机的数量，K 是进程的数量，R 是每个进程最多需 要打印机的数量。根据死锁公式逆推可得，若M≤K(R-1),     则系统可能发生死锁。将本题的数据 代入，得到8≤K(3-1),     即 K≥4,    因此系统可能发生死锁的K 的最小值是4。"}
{"id": "314", "type": "单项选择题", "question": "34.【2011统考真题】某时刻进程的资源使用情况见下表，此时的安全序列是( ) A.P1,P₂,P3,P₄ B.P1,P₃,P₂,P₄ C.P1,P4,P3,P₂ D. 不存在", "answer_label": "D", "answer_explain": "本题应采用排除法，逐个代入分析。剩余资源分配给P₁, 待P₁ 执行完后，可用资源数为(2,2,1), 此时仅能满足P⁴ 的需求，排除选项A 、B;  接着分配给P₄,   待P₄ 执行完后，可用资源数为(2,2,2),  此时已无法满足任何进程的需求，排除选项C。\n此外，本题还可以使用银行家算法求解(对选择题来说显得过于复杂)。", "answer": "D || 解析：本题应采用排除法，逐个代入分析。剩余资源分配给P₁, 待P₁ 执行完后，可用资源数为(2,2,1), 此时仅能满足P⁴ 的需求，排除选项A 、B;  接着分配给P₄,   待P₄ 执行完后，可用资源数为(2,2,2),  此时已无法满足任何进程的需求，排除选项C。\n此外，本题还可以使用银行家算法求解(对选择题来说显得过于复杂)。"}
{"id": "315", "type": "单项选择题", "question": "35. 【2012统考真题】假设5个进程 Po,P1,P₂,P₃,P₄ 共享三类资源 R₁,R₂,R₃, 这些资源总数分别为18,6, 22 。To时刻的资源分配情况如下表所示，此时存在的一个安全序列是( ) A.Po,P₂,P4,P1,P₃ B.P1,Po,P₃,P4,P₂ C.P₂,P1,P₀,P₃,P₄ D.P3,P4,P₂,P1,P₀", "answer_label": "D", "answer_explain": "首先求得各进程的需求矩阵Need 与可利用资源向量 Available:\n比较Need 和 Available 发现，初始时进程 P₁ 与 P₃ 可满足需求，排除选项A 、C 。尝试给 P₁ 分配资源时，P₁ 完成后Available 将变为(6,3,6),无法满足P₀ 的需求，排除选项B 。尝试给P₃ 分 配资源时，P₃ 完成后Available 将变为(4,3,7),该向量能满足其他所有进程的需求。因此，以P₃开头的所有序列都是安全序列。", "answer": "D || 解析：首先求得各进程的需求矩阵Need 与可利用资源向量 Available:\n比较Need 和 Available 发现，初始时进程 P₁ 与 P₃ 可满足需求，排除选项A 、C 。尝试给 P₁ 分配资源时，P₁ 完成后Available 将变为(6,3,6),无法满足P₀ 的需求，排除选项B 。尝试给P₃ 分 配资源时，P₃ 完成后Available 将变为(4,3,7),该向量能满足其他所有进程的需求。因此，以P₃开头的所有序列都是安全序列。"}
{"id": "316", "type": "单项选择题", "question": "36.【2013统考真题】下列关于银行家算法的叙述中，正确的是( ) A. 银行家算法可以预防死锁 B. 当系统处于安全状态时，系统中一定无死锁进程 C. 当系统处于不安全状态时，系统中一定会出现死锁进程 D. 银行家算法破坏了死锁必要条件中的“请求和保持”条件", "answer_label": "B", "answer_explain": "银行家算法是避免死锁的方法，选项A 、D 错。根据下图，选项B 对，选项C 错 。", "answer": "B || 解析：银行家算法是避免死锁的方法，选项A 、D 错。根据下图，选项B 对，选项C 错 。"}
{"id": "317", "type": "单项选择题", "question": "37.【2014统考真题】某系统有n 台互斥使用的同类设备，三个并发进程分别需要3,4,5台设备，可确保系 统不发生死锁的设备数n 最 小 为 ( ) A.9 B.10 C.11 D.12", "answer_label": "B", "answer_explain": "根据死锁公式，当资源数量大于各个进程所需资源数-1 的总和时，不发生死锁，三个进程 分别需要3,4,5台设备，即当资源数量大于(3-1)+(4-1)+(5-1)=9时，不发生死锁。而当系 统中只有9台设备时，第一个进程分配2台，第二个进程分配3台，第三个进程分配4台，这种 情况下，三个进程均无法继续执行下去，发生死锁。当系统再增加1台设备，最后1台设备分配 给任意一个进程都可以顺利执行完成，因此保证系统不发生死锁的最小设备数为10。", "answer": "B || 解析：根据死锁公式，当资源数量大于各个进程所需资源数-1 的总和时，不发生死锁，三个进程 分别需要3,4,5台设备，即当资源数量大于(3-1)+(4-1)+(5-1)=9时，不发生死锁。而当系 统中只有9台设备时，第一个进程分配2台，第二个进程分配3台，第三个进程分配4台，这种 情况下，三个进程均无法继续执行下去，发生死锁。当系统再增加1台设备，最后1台设备分配 给任意一个进程都可以顺利执行完成，因此保证系统不发生死锁的最小设备数为10。"}
{"id": "318", "type": "单项选择题", "question": "38.【2015统考真题】若系统 S₁ 采用死锁避免方法，S₂ 采用死锁检测方法。下列叙述中，正确的是() I.S₁ 会限制用户申请资源的顺序，而 S₂ 不会 II.S₁ 需要进程运行所需的资源总量信息，而S₂ 不需要 III.S₁ 不会给可能导致死锁的进程分配资源，而S₂ 会 A. 仅I、II B. 仅Ⅱ、II C. 仅 I 、Ⅲ D.I 、II 、III", "answer_label": "B", "answer_explain": "死锁的处理采用三种策略：死锁预防、死锁避免、死锁检测和解除。\n死锁预防采用破坏产生死锁的4个必要条件中的一个或几个来防止发生死锁。其中之一的“破 坏循环等待条件”,一般采用顺序资源分配法，即限制了用户申请资源的顺序，因此I 的前半句 属于死锁预防的范畴。此外，银行家算法虽然会通过检测是否存在安全序列来判断申请资源的请 求是否合法，但安全序列并不是唯一的，也不是固定的，它只是一种可能的分配方案，而不是一 种必须遵循的规则，银行家算法更没有给出固定的申请资源的顺序，因此I 错误。\n银行家算法是最著名的死锁避免算法，其中的最大需求矩阵Max  定义了每个进程对 m 类 资  源的最大需求量，系统在执行安全性算法中都会检查此次资源试分配后，系统是否处于安全状态， 若不安全则将本次的试探分配作废。在死锁的检测和解除中，系统为进程分配资源时不采取任何  措施，但提供死锁检测和解除的手段， 一旦检测到系统发生死锁，就立即采取相应的措施来解除  死锁，因此不用关心进程所需的总资源量。选项Ⅱ、Ⅲ正确。", "answer": "B || 解析：死锁的处理采用三种策略：死锁预防、死锁避免、死锁检测和解除。\n死锁预防采用破坏产生死锁的4个必要条件中的一个或几个来防止发生死锁。其中之一的“破 坏循环等待条件”,一般采用顺序资源分配法，即限制了用户申请资源的顺序，因此I 的前半句 属于死锁预防的范畴。此外，银行家算法虽然会通过检测是否存在安全序列来判断申请资源的请 求是否合法，但安全序列并不是唯一的，也不是固定的，它只是一种可能的分配方案，而不是一 种必须遵循的规则，银行家算法更没有给出固定的申请资源的顺序，因此I 错误。\n银行家算法是最著名的死锁避免算法，其中的最大需求矩阵Max  定义了每个进程对 m 类 资  源的最大需求量，系统在执行安全性算法中都会检查此次资源试分配后，系统是否处于安全状态， 若不安全则将本次的试探分配作废。在死锁的检测和解除中，系统为进程分配资源时不采取任何  措施，但提供死锁检测和解除的手段， 一旦检测到系统发生死锁，就立即采取相应的措施来解除  死锁，因此不用关心进程所需的总资源量。选项Ⅱ、Ⅲ正确。"}
{"id": "319", "type": "单项选择题", "question": "39.【2016统考真题】系统中有3个不同的临界资源R₁,R₂ 和 R₃, 被4个进程 P₁,P₂,P₃,P₄ 共享。各进程对 资源的需求为：P₁ 申请R₁ 和 R₂,P₂ 申请 R₂ 和 R3,P₃ 申请 R₁ 和 R₃,P₄ 申请 R₂ 。若系统出现死锁，则 处于死锁状态的进程数至少是() A.1 B.2 C.3 D.4", "answer_label": "C", "answer_explain": "对于本题，需先画出如下所示的资源分配图。若系统出现死锁，则必然出现循环等待的情况。\nB\nO  R₁\nB\n0    R₂\nO  R₃\n从图中可以看出，若出现循环等待的情况，则至少有P₁、P₂、P₃ 三个进程在循环等待环中，在  该图中不可能出现两个进程发生循环等待的情况。现在考察P₁ 、P₂ 、P₃ 三个进程形成环路的情况，  若此时 P₁ 、P₂ 、P₃三个进程分别拥有R₁ 、R₂ 和 R₃,  则会形成P₁ 等待P₂ 释放R₂,P₂    等待 P₃ 释 放R₃,    P₃ 等待P₁ 释放R₁ 的循环等待情况。P₁ 、P₂ 、P₃ 三个进程分别拥有R₂ 、R₃ 和 R₁的情况的分析类似。 以上两种情况都会形成循环等待情况，至少有三个进程陷入死锁状态。若P₄ 事先已获取 R₂,   成 功  运行，则死锁进程数为3;若P₄ 尚未获取R₂,   未运行，则死锁进程数为4。因此，若系统出现死\n172                    2 0 2 6 年 操 作 系 统 考 研 复 习 指 导\n锁，则处于死锁状态的进程至少是3个。", "answer": "C || 解析：对于本题，需先画出如下所示的资源分配图。若系统出现死锁，则必然出现循环等待的情况。\nB\nO  R₁\nB\n0    R₂\nO  R₃\n从图中可以看出，若出现循环等待的情况，则至少有P₁、P₂、P₃ 三个进程在循环等待环中，在  该图中不可能出现两个进程发生循环等待的情况。现在考察P₁ 、P₂ 、P₃ 三个进程形成环路的情况，  若此时 P₁ 、P₂ 、P₃三个进程分别拥有R₁ 、R₂ 和 R₃,  则会形成P₁ 等待P₂ 释放R₂,P₂    等待 P₃ 释 放R₃,    P₃ 等待P₁ 释放R₁ 的循环等待情况。P₁ 、P₂ 、P₃ 三个进程分别拥有R₂ 、R₃ 和 R₁的情况的分析类似。 以上两种情况都会形成循环等待情况，至少有三个进程陷入死锁状态。若P₄ 事先已获取 R₂,   成 功  运行，则死锁进程数为3;若P₄ 尚未获取R₂,   未运行，则死锁进程数为4。因此，若系统出现死\n172                    2 0 2 6 年 操 作 系 统 考 研 复 习 指 导\n锁，则处于死锁状态的进程至少是3个。"}
{"id": "320", "type": "单项选择题", "question": "40.【2018统考真题】假设系统中有4个同类资源，进程P₁,P₂ 和 P₃ 需要的资源数分别为4,3和1,P₁,P₂ 和 P₃ 已申请到的资源数分别为2,1和0,则执行安全性检测算法的结果是() A. 不存在安全序列，系统处于不安全状态 B. 存在多个安全序列，系统处于安全状态 C. 存在唯一安全序列P₃,P1,P₂, 系统处于安全状态 D. 存在唯一安全序列P₃,P₂,P1, 系统处于安全状态", "answer_label": "A", "answer_explain": "由题意可知，仅剩最后一个同类资源，若将其分给 P₁ 或 P₂, 则均无法正常执行；若分给P₃, 则 P₃ 正常执行完成后，释放的这一个资源仍无法使P₁,P₂  正常执行，因此不存在安全序列。", "answer": "A || 解析：由题意可知，仅剩最后一个同类资源，若将其分给 P₁ 或 P₂, 则均无法正常执行；若分给P₃, 则 P₃ 正常执行完成后，释放的这一个资源仍无法使P₁,P₂  正常执行，因此不存在安全序列。"}
{"id": "321", "type": "单项选择题", "question": "41.【2019统考真题】下列关于死锁的叙述中，正确的是( ) I. 可以通过剥夺进程资源解除死锁 II. 死销的预防方法能确保系统不发生死销 III. 银行家算法可以判断系统是否处于死锁状态 IV. 当系统出现死锁时，必然有两个或两个以上的进程处于阻塞态 A. 仅Ⅱ、II B. 仅 I 、Ⅱ 、IV C. 仅I、Ⅱ、III D. 仅I、II、IV", "answer_label": "B", "answer_explain": "剥夺进程资源，将其分配给其他死锁进程，可以解除死锁，选项I 正确。死锁预防是死锁处  理策略(死锁预防、死锁避免、死锁检测)中最为严苛的一种策略，破坏死锁产生的4个必要条  件之一，可以确保系统不发生死锁，选项Ⅱ正确。银行家算法是一种死锁避免算法，用于计算动  态资源分配的安全性以避免系统进入死锁状态，不能用于判断系统是否处于死锁，选项Ⅲ错误。 通过简化资源分配图可以检测系统是否为死锁状态，当系统出现死锁时，资源分配图不可完全简  化，只有两个或两个以上的进程才会出现“环”而不能被简化，选项IV 正确。", "answer": "B || 解析：剥夺进程资源，将其分配给其他死锁进程，可以解除死锁，选项I 正确。死锁预防是死锁处  理策略(死锁预防、死锁避免、死锁检测)中最为严苛的一种策略，破坏死锁产生的4个必要条  件之一，可以确保系统不发生死锁，选项Ⅱ正确。银行家算法是一种死锁避免算法，用于计算动  态资源分配的安全性以避免系统进入死锁状态，不能用于判断系统是否处于死锁，选项Ⅲ错误。 通过简化资源分配图可以检测系统是否为死锁状态，当系统出现死锁时，资源分配图不可完全简  化，只有两个或两个以上的进程才会出现“环”而不能被简化，选项IV 正确。"}
{"id": "322", "type": "单项选择题", "question": "42.【2020统考真题】某系统中有 A 、B 两类资源各6个，t 时刻的资源分配及需求情况如下表所示。t 时刻 安全性检测结果是( ) A. 存在安全序列P₁,P₂,P₃ B. 存在安全序列P₂,P₁,P₃ C. 存在安全序列 P₂,P₃,P₁ D. 不存在安全序列", "answer_label": "B", "answer_explain": "首先求出需求矩阵：\nA  B       A  B          A  B\n由 Allocation 得知当前Available 为(1,0)。由需求矩阵可知，初始只能满足P₂ 的需求，选项A  错误。P₂ 释放资源后Available 变为(3,1),此时仅能满足P₁ 的需求，选项C 错 误 。P₁ 释放资源后 Available变为(5,4),可以满足P₃ 的需求，得到的安全序列为P₂,P₁,P₃,B  正确，选项D 错误。", "answer": "B || 解析：首先求出需求矩阵：\nA  B       A  B          A  B\n由 Allocation 得知当前Available 为(1,0)。由需求矩阵可知，初始只能满足P₂ 的需求，选项A  错误。P₂ 释放资源后Available 变为(3,1),此时仅能满足P₁ 的需求，选项C 错 误 。P₁ 释放资源后 Available变为(5,4),可以满足P₃ 的需求，得到的安全序列为P₂,P₁,P₃,B  正确，选项D 错误。"}
{"id": "323", "type": "单项选择题", "question": "43.【2021统考真题】若系统中有 n(n≥2) 个进程，每个进程均需要使用某类临界资源2个，则系统不会发 生死锁所需的该类资源总数至少是( ) A.2 B.n C.n+1 D.2n", "answer_label": "C", "answer_explain": "考虑极端情况，当临界资源数为 n 时，每个进程都拥有1个临界资源并等待另一个资源，会发 生死锁。当临界资源数为n+1   时，则n 个进程中至少有一个进程可以获得2个临界资源，顺利运行 完后释放自己的临界资源，使得其他进程也能顺利运行，不会产生死锁。或者，根据死锁公式 m>\nn(r-1),    其 中m 是系统中临界资源的总数，n 是并发进程的个数，r 是每个进程所需临界资源的个数。 若这个不等式成立，则系统不发生死锁。将本题的数据代入，得到m>n(2-1),       即只要系统中临界资  源的总数至少是n+1,     就可避免死锁。", "answer": "C || 解析：考虑极端情况，当临界资源数为 n 时，每个进程都拥有1个临界资源并等待另一个资源，会发 生死锁。当临界资源数为n+1   时，则n 个进程中至少有一个进程可以获得2个临界资源，顺利运行 完后释放自己的临界资源，使得其他进程也能顺利运行，不会产生死锁。或者，根据死锁公式 m>\nn(r-1),    其 中m 是系统中临界资源的总数，n 是并发进程的个数，r 是每个进程所需临界资源的个数。 若这个不等式成立，则系统不发生死锁。将本题的数据代入，得到m>n(2-1),       即只要系统中临界资  源的总数至少是n+1,     就可避免死锁。"}
{"id": "324", "type": "单项选择题", "question": "44.【2022统考真题】系统中有三个进程Po,P₁,P₂ 及三类资源 A 、B 、C。若某时刻系统分配资源的情况如 下表所示，则此时系统中存在的安全序列的个数为() A.1 B.2 C.3 D.4 3.1内存管理概念", "answer_label": "B", "answer_explain": "初始时系统中的可用资源数为<1,3,2>,只能满足Po的需求<0,2,1>,所以安全序列第一个只能 是 P₀,   将资源分配给P₀ 后 ，P₀ 执行完释放所占资源，可用资源数变为<1,3,2>+<2,0,1>=<3,3,3>, 此时可用资源数既能满足P₁,   又能满足P₂,   可以先分配给P₁,P₁    执行完释放资源再分配给P₂;   也可 以先分配给P₂,P₂    执行完释放资源再分配给P₁ 。所以安全序列可以是①P₀ 、P₁ 、P₂ 或②P₀ 、P₂ 、P¹。", "answer": "B || 解析：初始时系统中的可用资源数为<1,3,2>,只能满足Po的需求<0,2,1>,所以安全序列第一个只能 是 P₀,   将资源分配给P₀ 后 ，P₀ 执行完释放所占资源，可用资源数变为<1,3,2>+<2,0,1>=<3,3,3>, 此时可用资源数既能满足P₁,   又能满足P₂,   可以先分配给P₁,P₁    执行完释放资源再分配给P₂;   也可 以先分配给P₂,P₂    执行完释放资源再分配给P₁ 。所以安全序列可以是①P₀ 、P₁ 、P₂ 或②P₀ 、P₂ 、P¹。"}
{"id": "325", "type": "单项选择题", "question": "1. 下面关于存储管理的叙述中，正确的是() A. 存储保护的目的是限制内存的分配 B. 在内存为M 、有 N 个用户的分时系统中，每个用户占用M/N 的内存空间 C. 在虚拟内存系统中，只要磁盘空间无限大，作业就能拥有任意大的编址空间 D. 实现虚拟内存管理必须有相应硬件的支持", "answer_label": "D", "answer_explain": "选项A 、B 显然错误，选项C 中编址空间的大小取决于硬件的访存能力，一般由地址总线宽 度决定。选项D 中虚拟内存的管理需要由相关的硬件和软件支持，有请求分页页表机制、缺页中 断机构、地址变换机构等。", "answer": "D || 解析：选项A 、B 显然错误，选项C 中编址空间的大小取决于硬件的访存能力，一般由地址总线宽 度决定。选项D 中虚拟内存的管理需要由相关的硬件和软件支持，有请求分页页表机制、缺页中 断机构、地址变换机构等。"}
