{
  "chunk-c2534a02f1b3f01bcdf887749e6526e4": {
    "tokens": 706,
    "content": "12. 磁盘的管理 1.磁盘初始化 一个新的磁盘只是一个磁性记录材料的空白盘。在磁盘可以存储数据之前,必须将它分成扇区,以便磁盘控制器能够进行读/写操作,这个过程称为低级格式化(也称物理格式化)。每个扇区通常由头部、数据区域和尾部组成。头部和尾部包含了一些磁盘控制器的使用信息。 2.分区 在可以使用磁盘存储文件之前,还要完成两个步骤。第一步是,将磁盘分区,每个分区由一个或多个柱面组成,每个分区的起始扇区和大小都记录在磁盘主引导记录的分区表中。第二步是,对物理分区进行逻辑格式化(也称高级格式化),将初始的文件系统数据结构存储到磁盘上,这些数据结构包括空闲的空间和已分配的空间,以及一个初始为空的目录,建立根目录、对保存空闲磁盘块信息的数据结构进行初始化。 因为扇区的单位太小,为了提高效率,操作系统将多个相邻的扇区组合在一起,形成一簇(在Linux中称为块)。 3.引导块 计算机启动时需要运行一个初始化程序(自举程序),它初始化CPU、寄存器、设备控制器和内存等,接着启动操作系统。为此,自举程序找到磁盘上的操作系统内核,将它加载到内存,并转到起始地址,从而开始操作系统的运行。 自举程序通常存放在ROM中,为了避免改变自举代码而需要改变ROM硬件的问题,通常只在ROM 中保留很小的自举装入程序,而将完整功能的引导程序保存在磁盘的启动块上,启动块位于磁盘的固定位置。具有启动分区的磁盘称为启动磁盘或系统磁盘。 Windows 系统将引导代码存储在磁盘的第0号扇区,它称为主引导记录(MBR)。引导首先运行ROM中的代码,这个代码指示系统从MBR中读取引导代码。除了包含引导代码,MBR还包含一个磁盘分区表和一个标志(以指示从哪个分区引导系统)。当系统找到引导分区时,读取分区的第一个扇区,称为引导扇区,并继续余下的引导过程。 4.坏块 磁盘有移动部件且容错能力弱,因此容易导致一个或多个扇区损坏。 对于简单磁盘,坏块可手动处理,如MS-DOS的Format命令执行逻辑格式化时会扫描磁盘以检查坏块。坏块在FAT表上会标明,因此程序不会使用它们。 对于复杂的磁盘,控制器维护磁盘内的坏块列表。控制器可以采用备用块来逻辑地替代坏块,这种方案称为扇区备用。",
    "chunk_order_index": 0,
    "full_doc_id": "doc-c2534a02f1b3f01bcdf887749e6526e4",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:3f3a97e1996373f19dc07d9cd6445f7f",
      "default:extract:9943cd107d6a744e108d5de61a7e56e0"
    ],
    "create_time": 1761796144,
    "update_time": 1761796227,
    "_id": "chunk-c2534a02f1b3f01bcdf887749e6526e4"
  },
  "chunk-8a037d4e5404d755e89072cf77091d2b": {
    "tokens": 1200,
    "content": "7. 设备分配与回收 1.设备分配概述 设备分配是指根据用户的1/0请求分配所需的设备。分配的总原则是充分发挥设备的使用效率,尽可能地既让设备忙碌,又避免由于不合理的分配方法造成进程死锁。 2.设备分配的数据结构 在系统中,可能存在多个通道,每个通道可以连接多个控制器,每个控制器可以连接多个物理设备。设备分配的数据结构要能体现出这种从属关系。 1)设备控制表(DCT):系统为每个设备配置一张DCT,表中的表项就是设备的各个属性。在DCT中,应该有下列字段:设备类型、设备标识符、设备状态、指向控制器表的指针、重复执行次数或时间、设备队列的队首指针。 2)控制器控制表(COCT):每个设备控制器都对应一张COCT。操作系统根据COCT的信息对控制器进行操作和管理。 3)通道控制表(CHCT):每个通道都对应一张CHCT。操作系统根据CHCT 的信息对通道进行操作和管理。 4)系统设备表(SDT):整个系统只有一张SDT。它记录已连接到系统中的所有物理设备的情况,每个物理设备对应一个表目。 3.设备分配时应考虑的因素 (1)设备的固有属性 设备的固有属性可分成三种,对它们应采取不同的分配策略。 1)独占设备:将它分配给某个进程后,便由该进程独占,直至进程完成或释放该设备。 2)共享设备:可将它同时分配给多个进程,需要合理调度各个进程访问该设备的先后次序。 3)虚拟设备:虚拟设备属于可共享设备,可将它同时分配给多个进程使用。 (2)设备分配算法 针对设备分配,通常只采用以下两种分配算法: 1)FCFS算法。该算法根据各个进程对某个设备提出请求的先后次序,将这些进程排成一个设备请求队列,设备分配程序总是将设备首先分配给队首进程。 2)最高优先级优先算法。在利用该算法形成设备队列时,优先级高的进程排在设备队列前面,而对于优先级相同的I/O请求,则按FCFS 原则排队。 (3)设备分配中的安全性 设备分配中的安全性是指在设备分配中应防止发生进程死锁。 1)安全分配方式。每当进程发出I/O请求后,便进入阻塞态,直到其I/O操作完成时才被唤醒。优点是设备分配安全,缺点是CPU和I/0设备是串行工作的。 2)不安全分配方式。进程在发出 I/O 请求后仍继续运行,需要时又会发出第二个、第三个I/O请求等。仅当进程所请求的设备已被另一进程占用时,才进入阻塞态。优点是一个进程可同时操作多个设备,使进程推进迅速;缺点是有可能造成死锁。 4.设备分配的步骤 下面以独占设备为例,介绍设备分配的过程。 1)分配设备。首先根据1/0请求中的物理设备名,查找SDT,从中找出该设备的DCT,再根据DCT 中的设备状态字段,可知该设备的状态。若忙,则将进程PCB挂到设备等待队列中:若不忙,则根据一定的策略将设备分配给该进程。 2)分配控制器。设备分配后,根据DCT找到COCT,查询控制器的状态。若忙,则将进程PCB 挂到控制器等待队列中;若不忙,则将控制器分配给该进程。 3)分配通道。控制器分配后,根据COCT找到CHCT,查询通道的状态。若忙,则将进程PCB 挂到通道等待队列中;若不忙,则将通道分配给该进程。只有设备、控制器和通道都分配成功时,这次的设备分配才算成功。 5.逻辑设备名到物理设备名的映射 为了实现设备的独立性,进程中应使用逻辑设备名来请求某类设备。但是,系统只能识别物理设备名,因此在系统中需要配置一张逻辑设备表,用于将逻辑设备名映射为物理设备名。 逻辑设备表(Logical Unit Table,LUT)的每个表项中包含3项内容:逻辑设备名、物理设备名和设备驱动程序的入口地址。 在系统中,可采取两种方式设置逻辑设备表: 1)整个系统中只设置一张LUT。所有进程的设备分配情况都记录在同一张LUT中,这就要求所有用户不能使用相同的逻辑",
    "chunk_order_index": 0,
    "full_doc_id": "doc-787f02e01c2af5cb6c640f2ab2160b3a",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:f8b92219694731e532d38c34d80cb142",
      "default:extract:a4d0458357e5f832967b9df4e008f910"
    ],
    "create_time": 1761796144,
    "update_time": 1761796243,
    "_id": "chunk-8a037d4e5404d755e89072cf77091d2b"
  },
  "chunk-1d93c6dce65e857b6ccef73c51291bd2": {
    "tokens": 159,
    "content": "。 逻辑设备表(Logical Unit Table,LUT)的每个表项中包含3项内容:逻辑设备名、物理设备名和设备驱动程序的入口地址。 在系统中,可采取两种方式设置逻辑设备表: 1)整个系统中只设置一张LUT。所有进程的设备分配情况都记录在同一张LUT中,这就要求所有用户不能使用相同的逻辑设备名,主要适用于单用户系统。 2)为每个用户设置一张LUT。系统为每个用户设置一张LUT,同时在多用户系统中都配置系统设备表。因此,不同用户可以使用相同的逻辑设备名。",
    "chunk_order_index": 1,
    "full_doc_id": "doc-787f02e01c2af5cb6c640f2ab2160b3a",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:3c6f0939f918542cac519b6f32cf3b63",
      "default:extract:56826572ec8515e85460eb1e6348b1db"
    ],
    "create_time": 1761796144,
    "update_time": 1761796185,
    "_id": "chunk-1d93c6dce65e857b6ccef73c51291bd2"
  },
  "chunk-f8acab16bd51fe8f837419ef179fc637": {
    "tokens": 126,
    "content": "5. 设备独立性软件 也称与设备无关的软件,是I/O 系统的最高层软件,它的下层是设备驱动程序,其界限因操作系统和设备的不同而有所差异。比如,一些本应由设备独立性软件实现的功能,也可能放在设备驱动程序中实现。这样的差异主要是出于对操作系统、设备独立性软件和设备驱动程序运行效率等多方面因素的权衡。总体而言,设备独立性软件包括执行所有设备公有操作的软件。",
    "chunk_order_index": 0,
    "full_doc_id": "doc-f8acab16bd51fe8f837419ef179fc637",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:3a318be2fbf4d0116ebfc77d5c16e682",
      "default:extract:6d87764dacef74056954d0a75e917c10"
    ],
    "create_time": 1761796233,
    "update_time": 1761796257,
    "_id": "chunk-f8acab16bd51fe8f837419ef179fc637"
  },
  "chunk-1b86b922e001d35ad4f0f4fe7d20ef03": {
    "tokens": 549,
    "content": "3. DMA方式 DMA(直接存储器存取)方式的基本思想是,在I/O设备和内存之间开辟直接的数据交换通路,彻底“解放”CPU。DMA方式的特点如下: 1)基本传送单位是数据块。 2)所传送的数据,是从设备直接送入内存的,或者相反,而不再经过CPU。 3)仅在传送一个或多个数据块的开始和结束时,才需要CPU干预。 为了实现主机和控制器之间直接交换成块的数据,须在DMA控制器中设置如下4类寄存器: 1)命令/状态寄存器(CR)。 2)内存地址寄存器(MAR)。 3)数据寄存器(DR)。 4)数据计数器(DC)。 DMA方式的工作过程是:CPU接收到设备的DMA请求时,它向DMA控制器发出一条命令,同时设置MAR和DC初值,启动DMA控制器,然后继续其他工作。之后CPU就将I/O 控制权交给DMA控制器,由DMA 控制器负责数据传送。整个数据传送结束后,DMA控制器向CPU发送一个中断信号。 DMA方式的优点:数据传输以“块”为单位,CPU介入的频率进一步降低;数据传送不再经过CPU的寄存器,CPU和设备的并行操作程度得到了进一步提升。 4.通道控制方式 I/O通道是一种特殊的处理机,它可执行一系列通道指令。设置通道后,CPU只需向通道发送一条 I/O 指令,通道收到该指令后,执行通道程序,完成规定的I/O任务后,向CPU发出中断请求。通道方式可以实现CPU、通道和I/O设备三者的并行工作。 通道与一般处理机的区别是:通道指令的类型单一,没有自己的内存,通道所执行的通道程序是放在主机的内存中的,也就是说通道与CPU共享内存。 通道与DMA方式的区别是:DMA方式需要CPU来控制传输的数据块大小、传输的内存位置,而通道方式中这些信息是由通道控制的。另外,每个DMA 控制器对应一台设备与内存传递数据,而一个通道可以控制多台设备与内存的数据交换。",
    "chunk_order_index": 0,
    "full_doc_id": "doc-1b86b922e001d35ad4f0f4fe7d20ef03",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:23e0f2765b84232b942ec61be092ed46",
      "default:extract:43aaa1551d4af61d6f132ea143af77a5"
    ],
    "create_time": 1761796254,
    "update_time": 1761796288,
    "_id": "chunk-1b86b922e001d35ad4f0f4fe7d20ef03"
  },
  "chunk-7b1bf538616277d755ad8617bf408c12": {
    "tokens": 470,
    "content": "2. I/O 控制方式 I/O 控制是指控制设备和主机之间的数据传送。I/O控制方式共有4种。 1.程序直接控制方式 CPU对I/O 设备的控制采取轮询的I/O方式,也称程序轮询方式。CPU向设备控制器发出一条I/O指令,启动从I/O设备读取一个字(节),然后不断地循环测试设备状态(称为轮询),直到确定该字(节)已在设备控制器的数据寄存器中。于是CPU将数据寄存器中的数据取出,送入内存的指定单元。 这种方式简单且易于实现,但缺点也很明显。CPU的绝大部分时间都处于等待I/O设备状态的循环测试中,CPU和I/O设备只能串行工作,导致CPU的利用率相当低。 2.中断驱动方式 中断驱动方式的思想是允许I/O设备主动打断CPU的运行并请求服务,从而“解放”CPU,使得CPU向设备控制器发出一条I/O指令后可以继续做其他有用的工作。 从设备控制器的角度来看:设备控制器从 CPU 接收一个读命令,然后从设备读数据。一旦数据读入设备控制器的数据寄存器,便通过控制线给CPU发出中断信号,表示数据已准备好。 从CPU的角度来看:当前运行进程发出读命令,该进程将被阻塞,然后转去执行其他程序。在每个指令周期的末尾,CPU检查中断信号。当有来自设备控制器的中断时,CPU保存当前运行进程的上下文,转去执行中断处理程序以处理该中断请求。 相比于程序轮询I/O方式,在设备准备数据期间,CPU和设备并行工作,CPU的利用率得到明显提升。但是,中断驱动方式仍有两个明显的问题:①设备与内存之间的数据交换都必须经过 CPU中的寄存器;②CPU是以字(节)为单位进行干预的。",
    "chunk_order_index": 0,
    "full_doc_id": "doc-7b1bf538616277d755ad8617bf408c12",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:483a03fdfe359d5473a59f6fa4234b03",
      "default:extract:904bc52fa61706588eff4766efbb7a84"
    ],
    "create_time": 1761796260,
    "update_time": 1761796285,
    "_id": "chunk-7b1bf538616277d755ad8617bf408c12"
  },
  "chunk-264fa4087fad0830a27723388157eee3": {
    "tokens": 460,
    "content": "9. 设备驱动程序接口 设备驱动程序是I/O系统的上层与设备控制器之间的通信程序,其主要任务是接收上层应用发来的抽象 I/O请求,如read 或write命令,将它们转换为具体要求后发送给设备控制器,进而使其启动设备去执行任务;反之,它也将设备控制器发来的信号传送给上层应用。 设备驱动程序应具有以下功能:①接收由上层软件发来的命令和参数,并将抽象要求转换为与设备相关的具体要求。②检查用户I/O请求的合法性,了解设备的工作状态,传递与设备操作有关的参数,设置设备的工作方式。③发出I/O命令,若设备空闲,则立即启动它;若设备忙,则将请求者的PCB挂到设备队列上等待。④及时响应由设备控制器发来的中断请求,并根据其中断类型,调用相应的中断处理程序进行处理。 相比于普通的应用程序和系统程序,设备驱动程序具有以下差异:①设备驱动程序将抽象的I/O 请求转换成具体的I/O操作后,传送给设备控制器,并将设备控制器中记录的设备状态和I/O 操作的完成情况及时地反馈给请求进程。②设备驱动程序与设备采用的I/O控制方式紧密相关。③设备驱动程序与硬件密切相关,对于不同类型的设备,应配置不同的设备驱动程序。④由于设备驱动程序与硬件紧密相关,目前很多设备驱动程序的基本部分已固化在ROM中。⑤设备驱动程序应允许同时多次调用执行。 为了使所有的设备驱动程序都有统一的接口,一方面,要求每个设备驱动程序与操作系统之间都有相同或相近的接口;另一方面,要将抽象的设备名转换为具体的物理设备名,并且进一步找到相应的设备驱动程序入口。",
    "chunk_order_index": 0,
    "full_doc_id": "doc-264fa4087fad0830a27723388157eee3",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:1df0408effb875b4f75b42a7b2b94d1a",
      "default:extract:4393060b0f2d9c77a052d40dbb7bf1f6"
    ],
    "create_time": 1761796295,
    "update_time": 1761796329,
    "_id": "chunk-264fa4087fad0830a27723388157eee3"
  },
  "chunk-5eca8429d9d2d195386ae7d415efa68b": {
    "tokens": 596,
    "content": "11. 磁盘 磁盘(Disk)是表面涂有磁性物质的物理盘片,通过一个称为磁头的导体线圈从磁盘存取数据。在读/写操作期间,磁头固定,磁盘在下面高速旋转。磁盘盘面上的数据存储在一组同心圆中,称为磁道。每个磁道与磁头一样宽,一个盘面有上千个磁道。磁道又划分为几百个扇区,每个扇区固定存储大小(如1KB),一个扇区称为一个盘块。相邻磁道及相邻扇区间通过一定的间隙分隔开,以避免精度错误。注意,因为扇区按固定圆心角度划分,所以密度从最外道向里道增加,磁盘的存储能力受限于最内道的最大记录密度。 磁盘安装在一个磁盘驱动器中,它由磁头臂、用于旋转磁盘的转轴和用于数据输入/输出的电子设备组成。多个盘片垂直堆叠,组成磁盘组,每个盘面对应一个磁头,所有磁头固定在一起,与磁盘中心的距离相同且只能“共进退”。所有盘片上相对位置相同的磁道组成柱面。扇区是磁盘可寻址的最小单位,磁盘上能存储的物理块数由扇区数、磁道数及磁盘面数决定,磁盘地址用“柱面号·盘面号·扇区号”表示。 读/写磁盘数据块的过程如下:①根据柱面号移动磁头臂,让磁头移动到对应的柱面;②激活对应盘面的磁头;③当磁盘旋转时,磁头从对应扇区上划过,从而完成对指定扇区的读/写。 磁盘按不同的方式可分为若干类型:磁头相对于盘片的径向方向固定的称为固定头磁盘,这种磁盘中的每个磁道有一个磁头。磁头可移动的称为活动头磁盘,磁头臂可来回伸缩定位磁道。盘片永久固定在磁盘驱动器内的称为固定盘磁盘。盘片可移动和替换的称为可换盘磁盘。最早的磁盘由IBM公司研发,称为温彻斯特磁盘,它是一种磁头活动而盘片固定的磁盘存储器。",
    "chunk_order_index": 0,
    "full_doc_id": "doc-5eca8429d9d2d195386ae7d415efa68b",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:d44b0d9a1f59e2784fc992bce257d987",
      "default:extract:e863bf32689b3297f0b083bec9312643"
    ],
    "create_time": 1761796297,
    "update_time": 1761796337,
    "_id": "chunk-5eca8429d9d2d195386ae7d415efa68b"
  },
  "chunk-316f7e90e1f3c434878bc3dd44e3b172": {
    "tokens": 1001,
    "content": "13. 磁盘调度算法 磁盘的存取时间 一次磁盘读/写操作的时间由寻找(寻道)时间、旋转延迟时间和传输时间决定。 1)寻道时间。活动头磁盘在读/写信息前,将磁头移动到目的磁道所需的时间。 2)旋转延迟时间。磁头定位到要读/写扇区所需的时间。 3)传输时间。从磁盘读出或向磁盘写入数据所需的时间。 在磁盘的存取时间中,寻道时间占大头,它与磁盘调度算法密切相关;而延迟时间和传输时间都与磁盘旋转速度线性相关。因此,磁盘调度的主要目标是减少磁盘的平均寻道时间。 2.磁盘调度算法 (1)先来先服务(First Come First Served, FCFS)算法 FCFS 算法根据进程请求访问磁盘的先后顺序进行调度,这是一种最简单的调度算法。该算法的优点是具有公平性。若有大量进程竞争使用磁盘,则这种算法在性能上往往接近于随机调度。 (2)最短寻道时间优先(Shortest Seek Time First, SSTF)算法 SSTF 算法每次选择调度的是离当前磁头最近的磁道,使每次的寻道时间最短。但不能保证平均寻道时间最小,但能提供比FCFS算法更好的性能。这种算法会产生“饥饿”现象。 (3)扫描(SCAN)算法 SSTF 算法产生饥饿的原因是“磁头可能在一个小范围内来回地移动”。为了防止这个问题,可以规定:只有磁头移动到最外侧磁道时才能向内移动,移动到最内侧磁道时才能向外移动,这就是 SCAN 算法的思想。它是在SSTF算法的基础上规定了磁头移动的方向。磁头移动规律与电梯运行相似,因此也称电梯调度算法。SCAN算法对最近扫描过的区域不公平。 (4)循环扫描(Circular SCAN, C-SCAN)算法 在SCAN 算法的基础上规定磁头单向移动来提供服务,返回时直接快速移动至起始端而不服务任何请求。 采用 SCAN 算法和C-SCAN算法时,磁头总是严格地遵循从盘面的一端到另一端,在实际使用时还可以改进,即磁头只需移动到最远端的一个请求即可返回,不需要到达磁盘端点。这种改进后的SCAN 算法和C-SCAN算法称为LOOK调度和C-LOOK调度。 3.减少延迟时间的方法 除减少寻道时间外,减少延迟时间也是提高磁盘传输效率的重要因素。 可对一个盘面的扇区进行交替编号,即让逻辑上相邻的块在物理上保持一定的间隔,则读入多个连续块时能够减少延迟时间。 此外,可对不同的盘面进行错位命名,读完一个盘面的最后一个扇区后,还有一段时间处理,当磁头首次划过下一个盘面的第一个扇区时能直接读取,从而减少了延迟时间。 提高磁盘I/O速度的方法 1)采用磁盘高速缓存。 2)调整磁盘请求顺序。即上面介绍的各种磁盘调度算法。 3)提前读。在读磁盘当前块时,将下一磁盘块也读入内存缓冲区。 4)延迟写。仅在缓冲区首部设置延迟写标志,然后释放此缓冲区并将其链入空闲缓冲区链表的尾部,当其他进程申请到此缓冲区时,才真正将缓冲区信息写入磁盘块。 5)优化物理块的分布。除了上面介绍的扇区编号优化,当文件采用链接方式和索引方式组织时,应尽量将同一个文件的盘块安排在一个磁道或相邻的磁道上,以减少寻道时间。 6)虚拟盘。是指用内存空间去仿真磁盘,又叫RAM盘。 7)采用磁盘阵列RAID。",
    "chunk_order_index": 0,
    "full_doc_id": "doc-316f7e90e1f3c434878bc3dd44e3b172",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:14c8f852e0d0ef820eb0f3819d3ac0f9",
      "default:extract:9e20df4b2c4e24073894c2c083598d30"
    ],
    "create_time": 1761796336,
    "update_time": 1761796380,
    "_id": "chunk-316f7e90e1f3c434878bc3dd44e3b172"
  },
  "chunk-d38f67d322a4adb7d87a544b297f1adb": {
    "tokens": 595,
    "content": "4. 应用程序I/O接口 I/O接口的分类 在I/O 系统与高层之间的接口中,根据设备类型的不同,又进一步分为若干类。 (1)字符设备接口 字符设备是指数据的存取和传输是以字符为单位的设备,如键盘、打印机等。基本特征是传输速率较低、不可寻址,并且在输入/输出时通常采用中断驱动方式。 get 和 put 操作,由于字符设备不可寻址,只能采取顺序存取方式,通常为字符设备建立一个字符缓冲区。 in-control 指令,字符设备类型繁多,差异甚大,因此在接口中提供一种通用的 in-control 指令来处理它们。 字符设备都属于独占设备,为此接口中还需要提供打开和关闭操作,以实现互斥共享。 (2)块设备接口 块设备是指数据的存取和传输是以数据块为单位的设备,典型的块设备是磁盘。基本特征是传输速率较高、可寻址。磁盘设备的I/O常采用DMA方式。 块设备接口支持将上层发来的打开、读、写和关闭等抽象命令,映射为设备能识别的较低层的具体操作。 内存映射接口通过内存的字节数组来访问磁盘,而不提供读/写磁盘操作。 (3)网络设备接口 现代操作系统都提供面向网络的功能,因此还需要提供相应的网络软件和网络通信接口。 许多操作系统提供的网络I/O接口为网络套接字接口。 阻塞I/O和非阻塞I/O 操作系统的I/O接口还涉及两种模式:阻塞和非阻塞。 阻塞 I/O 是指当用户进程调用IO操作时,进程就被阻塞,并移到阻塞队列,I/O操作完成后,进程才被唤醒,移到就绪队列。 优点:操作简单,实现难度低,适合并发量小的应用开发。 缺点:I/O 执行阶段进程会一直阻塞下去。 非阻塞 I/O 是指当用户进程调用I/O操作时,不阻塞该进程,但进程需要不断询问I/O操作是否完成,在I/O执行阶段,进程还可以做其他事情。 优点:进程在等待I/O期间不会阻塞,可以做其他事情,适合并发量大的应用开发。 缺点:轮询方式询问I/O结果,会占用CPU的时间。",
    "chunk_order_index": 0,
    "full_doc_id": "doc-d38f67d322a4adb7d87a544b297f1adb",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:09e0047a1d49c890c6f858a4d0f0b00a",
      "default:extract:efac3425e319cab20226b3a5ae8bea33"
    ],
    "create_time": 1761796344,
    "update_time": 1761796372,
    "_id": "chunk-d38f67d322a4adb7d87a544b297f1adb"
  },
  "chunk-cae68eac226893284aa15ffc3283cc80": {
    "tokens": 434,
    "content": "10. I/O 操作举例 内核缓冲区是处于内核空间的缓冲区,用户缓冲区是处于用户空间的缓冲区。 程序调用“scanf(\"%c\",&d)”时,scanf()会关联一个用户缓冲区buf。 scanf()的第一阶段的工作是在C语言函数库中完成的: 1)检查与 scanf函数关联的用户缓冲区buf,若缓冲区中已有数据,则直接读取。若缓冲区为空,则触发系统调用read。 2)执行系统调用read,传入三个参数:fd(文件描述符)、buf(用户空间缓冲区)、count(读取的最大字节数)。 第二阶段的工作是系统调用,read 调用会展开成一段包含陷阱指令的代码,从用户态陷入内核态以执行相关的操作。 进入内核态后,系统调用服务例程申请一个内核缓冲区,并且最终转到真正执行I/O操作的设备驱动层。在中断方式下,系统调用服务例程执行过程的大致描述如下: 1)设置相应的I/O参数后,发起I/O的进程P进入阻塞态,CPU调度其他进程运行。 2)用户通过键盘输入字符,字符被送到键盘I/O接口的数据端口。 3)键盘I/O接口向CPU发出中断请求。 4)CPU响应中断并执行键盘中断处理程序,将字符从I/O接口的数据端口送入内核缓冲区。 5)进程P被唤醒,插入就绪队列,等待被调度。 6)进程P再次获得CPU后,系统调用服务例程将字符从内核缓冲区复制到用户缓冲区。 7)进程P从系统调用返回,之后scanf函数进行字符解析,最终将该字符存储到变量d中。",
    "chunk_order_index": 0,
    "full_doc_id": "doc-cae68eac226893284aa15ffc3283cc80",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:e4d665a128dfcdf8f77ace206c80ed50",
      "default:extract:676e65008dcfe986600674a3bd784f02"
    ],
    "create_time": 1761796379,
    "update_time": 1761796410,
    "_id": "chunk-cae68eac226893284aa15ffc3283cc80"
  },
  "chunk-2d306019ab3891600b9be43a126d8c4e": {
    "tokens": 1200,
    "content": "6. 高速缓存与缓冲区 磁盘高速缓存(Disk Cache) 操作系统中使用磁盘高速缓存技术来提高磁盘的I/O速度,对访问高速缓存要比访问原始磁盘数据更为高效。例如,正在运行进程的数据既存储在磁盘上,又存储在物理内存上,也被复制到CPU的二级和一级高速缓存中。不过,磁盘高速缓存技术不同于通常意义下的介于CPU与内存之间的小容量高速存储器,而是指利用内存中的存储空间来暂存从磁盘中读出的一系列盘块中的信息。因此,磁盘高速缓存逻辑上属于磁盘,物理上是驻留在内存中的盘块。 磁盘高速缓存在内存中分为两种形式:一种是在内存中开辟一个单独的空间作为缓存区,大小固定;另一种是将未利用的内存空间作为一个缓冲池,供请求分页系统和磁盘I/O时共享。 缓冲区(Buffer) 在设备管理子系统中,引入缓冲区的目的主要如下: 1)缓和CPU与I/O设备间速度不匹配的矛盾。 2)减少对CPU的中断频率,放宽对CPU中断响应时间的限制。 3)解决基本数据单元大小(数据粒度)不匹配的问题。 4)提高CPU和1/0设备之间的并行性。 缓冲区的实现方法如下: 1)采用硬件缓冲器,但由于成本太高,除一些关键部位外,一般不采用硬件缓冲器。 2)利用内存作为缓冲区,本节要介绍的正是由内存组成的缓冲区。 根据系统设置缓冲区的个数,缓冲技术可以分为如下几种: (1)单缓冲 每当用户进程发出一个I/O请求,操作系统便在内存中为之分配一个缓冲区。通常,一个缓冲区的大小就是一个块。在块设备输入时,假定从设备将一块数据输入缓冲区的时间为T,操作系统将该缓冲区中的数据传送到工作区的时间为M,而CPU对这一块数据进行处理的时间为C。 在单缓冲区中, T是可以和C并行的。 当T>C时,CPU处理完一块数据后,暂时不能将下一块数据传送到工作区,必须等待缓冲区装满数据,再将下一块数据从缓冲区传送到工作区,平均处理一块数据的时间为T+M。 当T<C时,缓冲区中装满数据后,暂时不能继续送入下一块数据,必须等待CPU处理完上一块数据,再将下一块数据从缓冲区传送到工作区,平均处理一块数据的时间为C+M。 总结:单缓冲区处理每块数据的平均时间为 Max(C,T)+M (2)双缓冲 为了加快输入和输出速度,提高设备利用率,引入了双缓冲机制,也称缓冲对换。当设备输入数据时,先将数据送入缓冲区1,装满后便转向缓冲区2。此时,操作系统可以从缓冲区1中取出数据,送入用户进程,并由CPU对数据进行处理。当缓冲区1中取出的数据处理完后,若缓冲区2已装满,则操作系统又从缓冲区2中取出数据送入用户进程处理,而设备又可以开始将数据送入缓冲区1。 在双缓冲区中,C和M是可以与T并行的。 当T>C+M时,说明设备输入的时间比数据传送和处理的时间多,可使设备连续输入。平均处理一块数据的时间为T。 当T<C+M时,说明设备输入的时间比数据传送和处理的时间少,可使CPU不必等待设备输入。平均处理一块数据的时间为 C+M。 总结:双缓冲区处理每块数据的平均时间为 Max(C+M,T)。 若两台机器之间仅配置了单缓冲,则它们在任意时刻都只能实现单方向的数据传输。为了实现双向数据传输,必须在两台机器中都设置两个缓冲区,一个用作发送缓冲区,另一个用作接收缓冲区。 (3)循环缓冲 在双缓冲机制中,当输入与输出的速度基本匹配时,能取得较好的效果。但若两者的速度相差甚远,则双缓冲区的效果不会太理想。为此,又引入了多缓冲机制,将多个缓冲区组成循环缓冲区的形式。 循环缓冲包含多个大小相等的缓冲区,每个缓冲区中有一个链接指针指向下一个缓冲区,最后一个缓冲区指针指向第一个缓冲区,多个缓冲区链接成一个循环队列。 循环缓冲中还需设置 in 和 out 两个指针,in指向第一个可以输入数据的空缓冲区,out指向第一个可以提取数据的满缓冲区。 (4)缓冲",
    "chunk_order_index": 0,
    "full_doc_id": "doc-bc08e11de25f64ccdfef8d727029a7db",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:ed5ac3366250326e7b1140bda95ad2ca",
      "default:extract:ea1cbff0f57148ecba6be199a78b2f82"
    ],
    "create_time": 1761796389,
    "update_time": 1761796439,
    "_id": "chunk-2d306019ab3891600b9be43a126d8c4e"
  },
  "chunk-e821a4c1e8eeab3120a42bec02ee8587": {
    "tokens": 658,
    "content": "等的缓冲区,每个缓冲区中有一个链接指针指向下一个缓冲区,最后一个缓冲区指针指向第一个缓冲区,多个缓冲区链接成一个循环队列。 循环缓冲中还需设置 in 和 out 两个指针,in指向第一个可以输入数据的空缓冲区,out指向第一个可以提取数据的满缓冲区。 (4)缓冲池 相比于缓冲区(仅是一块内存空间),缓冲池是包含一个用于管理自身的数据结构和一组操作函数的管理机制,用于管理多个缓冲区。缓冲池可供多个进程共享使用。 缓冲池由多个系统公用的缓冲区组成,缓冲区按其使用状况可以分为:①空缓冲队列;②输入队列;③输出队列。此外还应具有4种工作缓冲区:①用于收容输入数据的工作缓冲区(hin),②用于提取输入数据的工作缓冲区(sin),③用于收容输出数据的工作缓冲区(hout),④用于提取输出数据的工作缓冲区(sout)。 缓冲池中的缓冲区有以下4种工作方式。 1)收容输入。输入进程需要输入数据时,从空缓冲队列的队首摘下一个空缓冲区,作为收容输入工作缓冲区,然后将数据输入其中,装满后再将它挂到输入队列的队尾。 2)提取输入。计算进程需要输入数据时,从输入队列的队首取得一个缓冲区,作为提取输入工作缓冲区,从中提取数据,用完该数据后将它挂到空缓冲队列的列尾。 3)收容输出。计算进程需要输出数据时,从空缓冲队列的队首取得一个空缓冲区,作为收容输出工作缓冲区,当其中装满数据后,再将它挂到输出队列的队尾。 4)提取输出。输出进程需要输出数据时,从输出队列的队首取得一个装满输出数据的缓冲区,作为提取输出工作缓冲区,当数据提取完后,再将它挂到空缓冲队列的队尾。 3.高速缓存与缓冲区的对比 高速缓存是可以保存数据拷贝的高速存储器,访问高速缓存比访问原始数据更高效,速度更快。 相同点：都介于高速设备和低速设备之间。 区别： 存放数据：高速缓存存放的是低速设备上的某些数据的复制数据；缓冲区存放的是低速设备传递给高速设备的数据(或相反)。 目的：高速缓存存放的是高速设备经常要访问的数据；高速设备和低速设备的通信都要经过缓冲区。",
    "chunk_order_index": 1,
    "full_doc_id": "doc-bc08e11de25f64ccdfef8d727029a7db",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:766ce49e2dcadf05ea194254d864f70d",
      "default:extract:563775b1c4fbe4ce9abb0de342f04c8a"
    ],
    "create_time": 1761796389,
    "update_time": 1761796439,
    "_id": "chunk-e821a4c1e8eeab3120a42bec02ee8587"
  },
  "chunk-b97ef22d499b3d442bd72f94c0600b3e": {
    "tokens": 1200,
    "content": "1. I/O 设备 I/O 设备管理是操作系统设计中最凌乱也最具挑战性的部分。它包含了很多领域的不同设备及与设备相关的应用程序,因此很难有一个通用且一致的设计方案。 设备的分类 I/O 设备是指可以将数据输入计算机的外部设备,或者可以接收计算机输出数据的外部设备。I/O 设备的类型繁多,从不同的角度可将它们分为不同的类型。 按信息交换的单位分类,I/O设备可分为: 1)块设备。信息交换以数据块为单位,如磁盘、磁带等。磁盘设备的基本特征是传输速率较高、可寻址,即对它可随机地读/写任意一块。 2)字符设备。信息交换以字符为单位,如交互式终端机、打印机等。它们的基本特征是传输速率低、不可寻址,并且通常采用中断I/O方式。 按设备的传输速率分类,I/O设备可分为: 1)低速设备。传输速率仅为每秒几字节到数百字节,如键盘、鼠标等。 2)中速设备。传输速率为每秒数千字节至数万字节,如激光打印机等。 3)高速设备。传输速率在数百千字节至千兆字节,如磁盘、光盘等。 按设备的使用特性分类,I/O设备可分为: 1)人机交互设备。用于用户和计算机之间交互信息的设备,如键盘、显示器、打印机等。 2)存储设备。用于存储信息的设备,如磁盘、磁带、光盘等。 3)网络通信设备。用于计算机和计算机之间的通信,如网卡、调制解调器等。 按设备的共享属性分类,I/O设备可分为: 1)独占设备。同一时刻只能由一个进程占用的设备。一旦将这类设备分配给某进程,便由该进程独占,直至用完释放。低速设备一般是独占设备,如打印机。 2)共享设备。同一时间段内允许多个进程同时访问的设备。对于共享设备,可同时分配给多个进程,通过分时的方式共享使用。典型的共享设备是磁盘。 3)虚拟设备。通过SPOOLing 技术将独占设备改造为共享设备,将一个物理设备变为多个逻辑设备,从而可将设备同时分配给多个进程。 I/O接口 I/O接口(也称设备控制器)是CPU与设备之间的“桥梁”,以实现设备和计算机之间的数据交换。它接收发自CPU的命令,控制设备工作,使CPU能从繁杂的设备控制事务中解脱出来。设备控制器主要由三部分组成。 1)设备控制器与CPU的接口。用于实现CPU与设备控制器之间的通信。该接口有三类信号线:数据线、地址线和控制线。 2)设备控制器与设备的接口。一个设备控制器可以连接一个或多个设备,因此控制器中有一个或多个设备接口。 3)I/O逻辑。用于实现对设备的控制。它通过一组控制线与CPU交互,对从CPU收到的I/O命令进行译码。 设备控制器的主要功能有:①接收和识别命令;②数据交换;③标识和报告设备的状态;④地址识别;⑤数据缓冲;⑥差错控制。 I/O接口的类型 从不同的角度看,I/O接口可以分为不同的类型。 1)按数据传送方式,可分为并行接口和串行接口。 2)按主机访问 I/O设备的控制方式,可分为程序查询接口、中断接口和DMA接口等。 3)按功能选择的灵活性,可分为可编程接口和不可编程接口。 I/O端口 I/O端口是指设备控制器中可被CPU直接访问的寄存器,主要有以下三类寄存器。 数据寄存器:用于缓存从设备送来的输入数据,或从CPU送来的输出数据。 状态寄存器:保存设备的执行结果或状态信息,以供CPU读取。 控制寄存器:由CPU写入,以便启动命令或更改设备模式。 对I/O 端口的编址方式有与存储器独立编址和统一编址两种。 (1)独立编址 独立编址是指为每个端口分配一个I/O端口号。I/O端口的地址空间与主存地址空间是两个独立的地址空间。 优点:I/O端口译码简单,寻址速度更快。使用专用I/O指令,可使程序更加清晰。 缺点:I/O 指令少,程序设计的灵活性较差。CPU需要提供两组独立的控制信号,增加了控制的复杂性。 (2)统一编址 统一编址也称内存映射I/O,是指将主存地址",
    "chunk_order_index": 0,
    "full_doc_id": "doc-e7b28e64fec06193d6f8044f54a3af63",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:ea63d1f824d17396aa11071eca8c1546",
      "default:extract:8275799f4e410dc70d561b243c4dfcca"
    ],
    "create_time": 1761796418,
    "update_time": 1761796536,
    "_id": "chunk-b97ef22d499b3d442bd72f94c0600b3e"
  },
  "chunk-24e218fe981e25857a4b5fef1ad3838d": {
    "tokens": 188,
    "content": "两个独立的地址空间。 优点:I/O端口译码简单,寻址速度更快。使用专用I/O指令,可使程序更加清晰。 缺点:I/O 指令少,程序设计的灵活性较差。CPU需要提供两组独立的控制信号,增加了控制的复杂性。 (2)统一编址 统一编址也称内存映射I/O,是指将主存地址空间分出一部分给I/O端口进行编址,I/O端口和主存单元在同一地址空间的不同分段中。 优点:不需要专门的I/O指令,使得CPU访问I/O的操作更加灵活和方便。 缺点:端口地址占用了部分主存地址空间。译码电路更加复杂,降低了寻址速度。",
    "chunk_order_index": 1,
    "full_doc_id": "doc-e7b28e64fec06193d6f8044f54a3af63",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:f92094603e2648b74ceacd10cb1fb743",
      "default:extract:e4a653832849ca323a51a4fca0bfdd1d"
    ],
    "create_time": 1761796418,
    "update_time": 1761796446,
    "_id": "chunk-24e218fe981e25857a4b5fef1ad3838d"
  },
  "chunk-1e6791234c2dc9ee6f432df1989fc60b": {
    "tokens": 516,
    "content": "3. I/O 软件层次结构 为使复杂的I/O软件能具有清晰的结构、良好的可移植性和易适应性,目前普遍采用层次结构的I/O软件。整个I/O软件可以视为具有4个层次的系统结构,各层次及其功能如下: (1)用户层软件 实现与用户交互的接口,用户可直接调用在用户层提供的、与I/O操作有关的库函数,对设备进行操作。用户层I/O软件必须通过一组系统调用来获取操作系统服务。 (2)设备独立性软件 用于实现用户程序与设备驱动器的统一接口、设备命名、设备保护,以及设备的分配与释放等,同时为设备管理和数据传送提供必要的存储空间。 设备独立性也称设备无关性,其含义是指应用程序所用的设备不局限于某个具体的物理设备。为实现设备独立性而引入了逻辑设备和物理设备这两个概念。 使用逻辑设备名的好处是:①增加设备分配的灵活性;②易于实现I/O 重定向。 设备独立性软件的主要功能可分为以下两个方面。①执行所有设备的公有操作,包括:对设备的分配与回收:将逻辑设备名映射为物理设备名;对设备进行保护;缓冲管理:差错控制;提供独立于设备的大小统一的逻辑块。②向用户层(或文件层)提供统一接口。 (3)设备驱动程序 与硬件直接相关,每类设备需要配置一个设备驱动程序。设备驱动程序负责具体实现系统对设备发出的操作指令,驱动I/O设备工作的驱动程序,它是I/O进程与设备控制器之间的通信程序。 (4)中断处理程序 当I/O操作完成时,设备控制器发送一个中断信号,CPU响应中断后,根据中断类型号找到相应的中断处理程序进行处理,处理完后,再返回到被中断的进程。 中断处理层的主要任务有:进行进程上下文的切换,对处理中断信号源进行测试,读取设备状态和修改进程状态等。",
    "chunk_order_index": 0,
    "full_doc_id": "doc-1e6791234c2dc9ee6f432df1989fc60b",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:ff54958033c3f706ae0c0c86aa779a97",
      "default:extract:acd7f8b7fda253c31c5b603ed5ff9180"
    ],
    "create_time": 1761796454,
    "update_time": 1761796532,
    "_id": "chunk-1e6791234c2dc9ee6f432df1989fc60b"
  },
  "chunk-b309162a426d62e33a3be632483b375d": {
    "tokens": 526,
    "content": "8. SPOOLing 技术(假脱机技术) 为了缓和CPU的高速性与I/O设备的低速性之间的矛盾,引入了假脱机技术,它是操作系统中采用的一项将独占设备改造成共享设备的技术。该技术利用专门的外围控制机,先将低速I/O设备上的数据传送到高速磁盘上,或者相反。SPOOLing系统的组成如下。 (1)输入井和输出井 在磁盘上开辟出的两个存储区域。输入井模拟脱机输入时的磁盘,用于收容I/O设备输入的数据。输出井模拟脱机输出时的磁盘,用于收容用户程序的输出数据。 (2)输入缓冲区和输出缓冲区 在内存中开辟的两个缓冲区。输入缓冲区用于暂存由输入设备送来的数据,以后再传送到输入井。输出缓冲区用于暂存从输出井送来的数据,以后再传送到输出设备。 (3)输入进程和输出进程 输入进程用于模拟脱机输入时的外围控制机,将用户要求的数据从输入设备传送到输入缓冲区,再存放到输入井中。输出进程用于模拟脱机输出时的外围控制机,将用户要求输出的数据从内存传送到输出井,待输出设备空闲时,再将输出井中的数据经输出缓冲区输出至输出设备。 (4)井管理程序 用于控制作业与磁盘井之间信息的交换。 当多个用户进程发出打印输出请求时,SPOOLing 系统同意它们的请求,但并不真正立即将打印机分配给它们,而由假脱机管理进程为每个进程做如下两项工作: 1)在磁盘缓冲区中为进程申请一个空闲盘块,并将要打印的数据送入其中暂存。 2)为用户进程申请一张空白的用户请求打印表,并将用户的打印要求填入其中,再将该表挂到假脱机文件队列上。 SPOOLing 系统的特点:①提高了I/O速度;②将独占设备改造为共享设备;③实现了虚拟设备功能。 SPOOLing 技术是一种以空间换时间的技术。",
    "chunk_order_index": 0,
    "full_doc_id": "doc-b309162a426d62e33a3be632483b375d",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:d8a50f22392dc0049b92e5ed656583ce",
      "default:extract:8975b814a27f38deb044a687d308f30a"
    ],
    "create_time": 1761796552,
    "update_time": 1761796582,
    "_id": "chunk-b309162a426d62e33a3be632483b375d"
  },
  "chunk-8189302c7787e74dde6623016361fc8f": {
    "tokens": 548,
    "content": "14. 固态硬盘 固态硬盘的特性 固态硬盘(Solid State Disk, SSD)是一种基于闪存技术的存储器。一个SSD由一个或多个闪存芯片和闪存翻译层组成。闪存芯片替代传统磁盘中的机械驱动器,而闪存翻译层将来自CPU的逻辑块读/写请求翻译成对底层物理设备的读/写控制信号,因此闪存翻译层相当于扮演了磁盘控制器的角色。 一个闪存由B块组成,每块由P页组成。数据是以页为单位读/写的。以块为单位擦除,只有在一页所属的块整个被擦除后,才能写这一页。一旦一个块被擦除,块中的每个页就都可以直接再写一次。某个块进行了若干重复写后,就会磨损坏,不能再使用。 随机写很慢,有两个原因。首先,擦除块比较慢。其次,若写操作试图修改一个包含已有数据的页P,则该块中所有含有用数据的页都必须被复制到一个新(擦除过的)块中,然后才能进行对页P的写操作。 比起传统磁盘,SSD有很多优点,它由半导体存储器构成,没有移动的部件,因此随机访问速度比机械磁盘要快很多,也没有任何机械噪声和震动,能耗更低、抗震性好、安全性高等。 2.磨损均衡(Wear Leveling) 固态硬盘也有缺点,闪存的擦写寿命是有限的。若直接用普通闪存组装 SSD,读/写数据时会集中在SSD的一部分闪存,这部分闪存的寿命会损耗得特别快。 为了弥补 SSD的寿命缺陷,引入了磨损均衡。SSD磨损均衡技术大致分为两种: 1)动态磨损均衡。写入数据时,优先选择擦除次数少的新闪存块。 2)静态磨损均衡。就算没有数据写入,SSD也会监测并自动进行数据分配,让老的闪存块承担以读为主的存储任务。同时让较新的闪存块腾出空间,以承担更多以写为主的存储任务。",
    "chunk_order_index": 0,
    "full_doc_id": "doc-8189302c7787e74dde6623016361fc8f",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:5072f8dd594ebb3f28634c96478303be",
      "default:extract:d3d9133e170658fa981f9dc988a4305f"
    ],
    "create_time": 1761796556,
    "update_time": 1761796578,
    "_id": "chunk-8189302c7787e74dde6623016361fc8f"
  }
}