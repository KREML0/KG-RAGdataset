<?xml version='1.0' encoding='utf-8'?>
<graphml xmlns="http://graphml.graphdrawing.org/xmlns" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://graphml.graphdrawing.org/xmlns http://graphml.graphdrawing.org/xmlns/1.0/graphml.xsd">
  <key id="d11" for="edge" attr.name="created_at" attr.type="long" />
  <key id="d10" for="edge" attr.name="file_path" attr.type="string" />
  <key id="d9" for="edge" attr.name="source_id" attr.type="string" />
  <key id="d8" for="edge" attr.name="keywords" attr.type="string" />
  <key id="d7" for="edge" attr.name="description" attr.type="string" />
  <key id="d6" for="edge" attr.name="weight" attr.type="double" />
  <key id="d5" for="node" attr.name="created_at" attr.type="long" />
  <key id="d4" for="node" attr.name="file_path" attr.type="string" />
  <key id="d3" for="node" attr.name="source_id" attr.type="string" />
  <key id="d2" for="node" attr.name="description" attr.type="string" />
  <key id="d1" for="node" attr.name="entity_type" attr.type="string" />
  <key id="d0" for="node" attr.name="entity_id" attr.type="string" />
  <graph edgedefault="undirected">
    <node id="Memory Management">
      <data key="d0">Memory Management</data>
      <data key="d1">concept</data>
      <data key="d2">Memory Management is a core function of operating systems, responsible for the allocation, deallocation, and efficient use of memory space in computers.</data>
      <data key="d3">chunk-c6de281f0215ff49a87e3727a7c2bb2a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794376</data>
    </node>
    <node id="Operating System">
      <data key="d0">Operating System</data>
      <data key="d1">organization</data>
      <data key="d2">The Operating System manages computer hardware and software resources, including memory allocation and address translation.&lt;SEP&gt;Operating System is a system software that manages computer hardware and software resources and provides common services for computer programs.&lt;SEP&gt;Operating system manages memory, maintains the page table, and oversees address translation via the MMU.&lt;SEP&gt;The operating system manages and controls processes using data structures like the Process Control Block.</data>
      <data key="d3">chunk-595c1a74214288cf8d47eda3bbc75afe&lt;SEP&gt;chunk-c8697590fab35afe994351ccfc05bbac&lt;SEP&gt;chunk-5a8929ecef7cbf8892a009420c53322d&lt;SEP&gt;chunk-c6de281f0215ff49a87e3727a7c2bb2a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794884</data>
    </node>
    <node id="Main Memory">
      <data key="d0">Main Memory</data>
      <data key="d1">naturalobject</data>
      <data key="d2">Main Memory is the primary storage component of a computer where active programs and data are held for execution.&lt;SEP&gt;Main memory is the physical storage in which executable code and data are loaded for processing.</data>
      <data key="d3">chunk-c8697590fab35afe994351ccfc05bbac&lt;SEP&gt;chunk-c6de281f0215ff49a87e3727a7c2bb2a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794706</data>
    </node>
    <node id="User Process">
      <data key="d0">User Process</data>
      <data key="d1">concept</data>
      <data key="d2">A User Process is an instance of a program in execution, requiring memory space managed by the operating system.</data>
      <data key="d3">chunk-c6de281f0215ff49a87e3727a7c2bb2a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794376</data>
    </node>
    <node id="Program and Data">
      <data key="d0">Program and Data</data>
      <data key="d1">content</data>
      <data key="d2">Program and Data refer to the executable code and associated information required by software to run and perform tasks.</data>
      <data key="d3">chunk-c6de281f0215ff49a87e3727a7c2bb2a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794376</data>
    </node>
    <node id="Multi-Programming">
      <data key="d0">Multi-Programming</data>
      <data key="d1">concept</data>
      <data key="d2">Multi-Programming is the execution of multiple processes concurrently, requiring the operating system to manage memory allocation effectively.</data>
      <data key="d3">chunk-c6de281f0215ff49a87e3727a7c2bb2a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794376</data>
    </node>
    <node id="Virtual Storage Technology">
      <data key="d0">Virtual Storage Technology</data>
      <data key="d1">method</data>
      <data key="d2">Virtual Storage Technology enables logical memory expansion by using disk space to simulate additional main memory.</data>
      <data key="d3">chunk-c6de281f0215ff49a87e3727a7c2bb2a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794376</data>
    </node>
    <node id="Logical Address">
      <data key="d0">Logical Address</data>
      <data key="d1">concept</data>
      <data key="d2">A Logical Address is the address generated by a program, requiring translation to a physical address for memory access.&lt;SEP&gt;A logical address is the address generated by the CPU and composed of a page number and an offset within the page.&lt;SEP&gt;Logical address is the relative address assigned to each target module during compilation, starting from zero, and is used by processes during execution.&lt;SEP&gt;A logical address is a virtual address generated by a process, which is later mapped to a physical address.</data>
      <data key="d3">chunk-46462724e0de563d009072de78fa1d68&lt;SEP&gt;chunk-c8697590fab35afe994351ccfc05bbac&lt;SEP&gt;chunk-c6de281f0215ff49a87e3727a7c2bb2a&lt;SEP&gt;chunk-6a91872eefca67b87c6a12b37faf30eb</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794812</data>
    </node>
    <node id="Physical Address">
      <data key="d0">Physical Address</data>
      <data key="d1">concept</data>
      <data key="d2">A Physical Address is the actual location in main memory where data is stored.&lt;SEP&gt;A physical address is the actual memory address in main memory, generated by combining a block number and a page offset.&lt;SEP&gt;The Physical Address is the actual location in main memory where a page resides.&lt;SEP&gt;Physical address refers to the actual memory location in main memory where data and instructions are stored and accessed.&lt;SEP&gt;A physical address is the actual location in main memory where data is stored.</data>
      <data key="d3">chunk-c8697590fab35afe994351ccfc05bbac&lt;SEP&gt;chunk-28a7b83e6af7f15e967e78c26eccf799&lt;SEP&gt;chunk-46462724e0de563d009072de78fa1d68&lt;SEP&gt;chunk-c6de281f0215ff49a87e3727a7c2bb2a&lt;SEP&gt;chunk-6a91872eefca67b87c6a12b37faf30eb</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794814</data>
    </node>
    <node id="Memory Space Allocation">
      <data key="d0">Memory Space Allocation</data>
      <data key="d1">concept</data>
      <data key="d2">Memory Space Allocation refers to the process of assigning portions of memory to processes during runtime.</data>
      <data key="d3">chunk-c6de281f0215ff49a87e3727a7c2bb2a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794378</data>
    </node>
    <node id="Memory Space Recovery">
      <data key="d0">Memory Space Recovery</data>
      <data key="d1">concept</data>
      <data key="d2">Memory Space Recovery is the process by which the operating system reclaims memory after a process terminates.</data>
      <data key="d3">chunk-c6de281f0215ff49a87e3727a7c2bb2a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794378</data>
    </node>
    <node id="Memory Sharing">
      <data key="d0">Memory Sharing</data>
      <data key="d1">concept</data>
      <data key="d2">Memory Sharing allows multiple processes to access the same memory region under controlled conditions.&lt;SEP&gt;Memory sharing is a technique that allows multiple processes to share read-only memory regions, particularly for sharing executable code.</data>
      <data key="d3">chunk-00b255b459e05b4695b33c9dceed4321&lt;SEP&gt;chunk-c6de281f0215ff49a87e3727a7c2bb2a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794855</data>
    </node>
    <node id="Storage Protection">
      <data key="d0">Storage Protection</data>
      <data key="d1">concept</data>
      <data key="d2">Storage Protection ensures that processes operate only within their designated memory space, preventing interference with other processes.</data>
      <data key="d3">chunk-c6de281f0215ff49a87e3727a7c2bb2a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794378</data>
    </node>
    <node id="页面置换算法">
      <data key="d0">页面置换算法</data>
      <data key="d1">method</data>
      <data key="d2">Page replacement algorithm is a method used in operating systems to manage memory by selecting which page to evict when a new page needs to be loaded into memory and no free frames are available.&lt;SEP&gt;页面置换算法is a strategy used to determine which pages to replace when a page fault occurs; efficient algorithms reduce缺页率.</data>
      <data key="d3">chunk-e9724523b61c71a64ad927ea59b8337a&lt;SEP&gt;chunk-dd63fcc97211dcfcfa94d11eff1be6f8</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794759</data>
    </node>
    <node id="最佳置换算法">
      <data key="d0">最佳置换算法</data>
      <data key="d1">method</data>
      <data key="d2">Optimal (OPT) page replacement algorithm selects the page that will not be used for the longest time in the future, or never used again, to minimize the page fault rate. This algorithm is theoretical and cannot be implemented in practice.</data>
      <data key="d3">chunk-e9724523b61c71a64ad927ea59b8337a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794393</data>
    </node>
    <node id="先进先出置换算法">
      <data key="d0">先进先出置换算法</data>
      <data key="d1">method</data>
      <data key="d2">First-In-First-Out (FIFO) page replacement algorithm selects the page that has been in memory the longest for eviction. It is simple to implement but suffers from performance issues and can produce Belady’s anomaly.</data>
      <data key="d3">chunk-e9724523b61c71a64ad927ea59b8337a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794393</data>
    </node>
    <node id="最近最久未使用置换算法">
      <data key="d0">最近最久未使用置换算法</data>
      <data key="d1">method</data>
      <data key="d2">Least Recently Used (LRU) page replacement algorithm selects the page that has not been accessed for the longest time. It performs well in practice but requires hardware support such as registers and stacks, which increases implementation cost.</data>
      <data key="d3">chunk-e9724523b61c71a64ad927ea59b8337a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794393</data>
    </node>
    <node id="时钟置换算法">
      <data key="d0">时钟置换算法</data>
      <data key="d1">method</data>
      <data key="d2">Clock page replacement algorithm is a practical approximation of LRU. It uses a circular list of pages and a replacement pointer, along with access bits to track recent usage.</data>
      <data key="d3">chunk-e9724523b61c71a64ad927ea59b8337a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794393</data>
    </node>
    <node id="改进型时钟置换算法">
      <data key="d0">改进型时钟置换算法</data>
      <data key="d1">method</data>
      <data key="d2">Enhanced Clock page replacement algorithm improves upon the basic Clock algorithm by including a modify bit in addition to the access bit, allowing for better decision-making during page eviction.</data>
      <data key="d3">chunk-e9724523b61c71a64ad927ea59b8337a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794393</data>
    </node>
    <node id="访问位">
      <data key="d0">访问位</data>
      <data key="d1">data</data>
      <data key="d2">Access bit is a flag associated with each page that is set to 1 when the page is accessed, used to track whether a page has been recently used.</data>
      <data key="d3">chunk-e9724523b61c71a64ad927ea59b8337a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794393</data>
    </node>
    <node id="修改位">
      <data key="d0">修改位</data>
      <data key="d1">data</data>
      <data key="d2">Modify bit is a flag associated with each page that indicates whether the page has been modified since it was loaded into memory.</data>
      <data key="d3">chunk-e9724523b61c71a64ad927ea59b8337a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794393</data>
    </node>
    <node id="Belady异常">
      <data key="d0">Belady异常</data>
      <data key="d1">concept</data>
      <data key="d2">Belady’s anomaly is a phenomenon in which increasing the number of available frames in memory leads to an increase in the number of page faults, observed in FIFO page replacement.</data>
      <data key="d3">chunk-e9724523b61c71a64ad927ea59b8337a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794394</data>
    </node>
    <node id="缺页率">
      <data key="d0">缺页率</data>
      <data key="d1">concept</data>
      <data key="d2">Page fault rate is the frequency of page faults occurring during process execution, a key performance metric for memory management algorithms.&lt;SEP&gt;缺页率is a key factor affecting virtual memory performance, representing the frequency of page faults during program execution.</data>
      <data key="d3">chunk-e9724523b61c71a64ad927ea59b8337a&lt;SEP&gt;chunk-dd63fcc97211dcfcfa94d11eff1be6f8</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794759</data>
    </node>
    <node id="循环队列">
      <data key="d0">循环队列</data>
      <data key="d1">artifact</data>
      <data key="d2">Circular queue is a data structure used in the Clock algorithm to link pages in memory sequentially, allowing efficient traversal.</data>
      <data key="d3">chunk-e9724523b61c71a64ad927ea59b8337a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794394</data>
    </node>
    <node id="硬件支持">
      <data key="d0">硬件支持</data>
      <data key="d1">artifact</data>
      <data key="d2">Hardware support refers to specialized register and stack components required for efficient implementation of certain page replacement algorithms, particularly LRU.</data>
      <data key="d3">chunk-e9724523b61c71a64ad927ea59b8337a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794394</data>
    </node>
    <node id="物理块">
      <data key="d0">物理块</data>
      <data key="d1">artifact</data>
      <data key="d2">Physical block refers to the unit of memory allocated to processes, also known as frame in virtual memory management.&lt;SEP&gt;物理块是内存中与页面大小相同的存储单元，用于分配和管理物理内存。&lt;SEP&gt;物理块refers to the fixed-size units of physical memory allocated to a process, determining how much memory is available for page storage.</data>
      <data key="d3">chunk-67ae509cb7f3a2cdf2694e125b8725c3&lt;SEP&gt;chunk-e9724523b61c71a64ad927ea59b8337a&lt;SEP&gt;chunk-c195ab08b96907e43c39705a88501db8</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794794</data>
    </node>
    <node id="1类页面">
      <data key="d0">1类页面</data>
      <data key="d1">artifact</data>
      <data key="d2">Class 1 page refers to a page with access bit A=0 and modify bit M=0, indicating it has not been accessed recently and has not been modified, making it the best candidate for eviction in the Enhanced Clock algorithm.</data>
      <data key="d3">chunk-e9724523b61c71a64ad927ea59b8337a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794394</data>
    </node>
    <node id="2类页面">
      <data key="d0">2类页面</data>
      <data key="d1">artifact</data>
      <data key="d2">Class 2 page refers to a page with access bit A=0 and modify bit M=1, indicating it has not been accessed recently but has been modified, making it a secondary candidate for eviction.</data>
      <data key="d3">chunk-e9724523b61c71a64ad927ea59b8337a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794394</data>
    </node>
    <node id="3类页面">
      <data key="d0">3类页面</data>
      <data key="d1">artifact</data>
      <data key="d2">Class 3 page refers to a page with access bit A=1 and modify bit M=0, indicating it has been recently accessed but not modified, suggesting it may be accessed again soon.</data>
      <data key="d3">chunk-e9724523b61c71a64ad927ea59b8337a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794394</data>
    </node>
    <node id="4类页面">
      <data key="d0">4类页面</data>
      <data key="d1">artifact</data>
      <data key="d2">Class 4 page refers to a page with access bit A=1 and modify bit M=1, indicating it has been recently accessed and modified, and thus is likely to be accessed again.</data>
      <data key="d3">chunk-e9724523b61c71a64ad927ea59b8337a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794395</data>
    </node>
    <node id="Memory-Mapped Files">
      <data key="d0">Memory-Mapped Files</data>
      <data key="d1">concept</data>
      <data key="d2">Memory-Mapped Files is a system call provided by the operating system that establishes a mapping relationship between a disk file and a process's virtual address space.</data>
      <data key="d3">chunk-5a8929ecef7cbf8892a009420c53322d</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794440</data>
    </node>
    <node id="Virtual Memory">
      <data key="d0">Virtual Memory</data>
      <data key="d1">concept</data>
      <data key="d2">Virtual Memory is a memory management technique that provides an abstraction of a large, continuous address space to processes, enabling efficient use of physical memory and disk storage.&lt;SEP&gt;Virtual memory is a memory management technique that uses secondary storage to extend the apparent size of primary memory.&lt;SEP&gt;Virtual Memory is a memory management technique that uses secondary storage to extend the apparent size of physical memory.</data>
      <data key="d3">chunk-28a7b83e6af7f15e967e78c26eccf799&lt;SEP&gt;chunk-abb4ec292dd5335d76c0413487939cbe&lt;SEP&gt;chunk-5a8929ecef7cbf8892a009420c53322d</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794677</data>
    </node>
    <node id="Disk File">
      <data key="d0">Disk File</data>
      <data key="d1">artifact</data>
      <data key="d2">Disk File is a file stored on a persistent storage device, which can be accessed and manipulated through file system operations.</data>
      <data key="d3">chunk-5a8929ecef7cbf8892a009420c53322d</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794440</data>
    </node>
    <node id="Process Virtual Address Space">
      <data key="d0">Process Virtual Address Space</data>
      <data key="d1">concept</data>
      <data key="d2">Process Virtual Address Space is the range of memory addresses available to a running process, managed by the operating system.</data>
      <data key="d3">chunk-5a8929ecef7cbf8892a009420c53322d</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794440</data>
    </node>
    <node id="Page">
      <data key="d0">Page</data>
      <data key="d1">artifact</data>
      <data key="d2">Page refers to a fixed-size block of memory, typically used in virtual memory and file mapping systems, usually 4KB in size.&lt;SEP&gt;A page is a fixed-size unit of logical address space within a process, corresponding to a page frame in physical memory.</data>
      <data key="d3">chunk-46462724e0de563d009072de78fa1d68&lt;SEP&gt;chunk-5a8929ecef7cbf8892a009420c53322d</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794637</data>
    </node>
    <node id="File Content">
      <data key="d0">File Content</data>
      <data key="d1">data</data>
      <data key="d2">File Content refers to the actual data stored within a disk file, which is only loaded into memory when accessed.</data>
      <data key="d3">chunk-5a8929ecef7cbf8892a009420c53322d</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794440</data>
    </node>
    <node id="System Call">
      <data key="d0">System Call</data>
      <data key="d1">method</data>
      <data key="d2">System Call is a request made by a program to the operating system to perform a specific operation, such as file access or memory management.</data>
      <data key="d3">chunk-5a8929ecef7cbf8892a009420c53322d</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794440</data>
    </node>
    <node id="Multiple Processes">
      <data key="d0">Multiple Processes</data>
      <data key="d1">concept</data>
      <data key="d2">Multiple Processes refers to the capability of an operating system to run more than one process concurrently, enabling resource sharing and multitasking.</data>
      <data key="d3">chunk-5a8929ecef7cbf8892a009420c53322d</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794442</data>
    </node>
    <node id="Performance Optimization">
      <data key="d0">Performance Optimization</data>
      <data key="d1">concept</data>
      <data key="d2">Performance Optimization is the process of improving the efficiency and speed of operations, often through mechanisms like memory mapping.</data>
      <data key="d3">chunk-5a8929ecef7cbf8892a009420c53322d</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794442</data>
    </node>
    <node id="Shared Memory">
      <data key="d0">Shared Memory</data>
      <data key="d1">concept</data>
      <data key="d2">Shared Memory is a method by which multiple processes can access and communicate through a common memory area, often facilitated by memory mapping.</data>
      <data key="d3">chunk-5a8929ecef7cbf8892a009420c53322d</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794442</data>
    </node>
    <node id="动态分区分配">
      <data key="d0">动态分区分配</data>
      <data key="d1">method</data>
      <data key="d2">Dynamic partition allocation, also known as variable partition allocation, is a memory management technique where memory is dynamically allocated to processes based on their actual needs, with partition sizes matching the process requirements exactly.&lt;SEP&gt;动态分区分配dynamically allocates memory partitions based on program size, reducing internal fragmentation compared to fixed partitioning.</data>
      <data key="d3">chunk-fa7ddc38beb083a10e073654dee57a19&lt;SEP&gt;chunk-f59ab8ff80e1533c966b7cb6b20563dc</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794757</data>
    </node>
    <node id="外部碎片">
      <data key="d0">外部碎片</data>
      <data key="d1">concept</data>
      <data key="d2">External fragmentation refers to the small, unusable memory blocks that accumulate over time in memory, reducing memory utilization efficiency.</data>
      <data key="d3">chunk-f59ab8ff80e1533c966b7cb6b20563dc</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794474</data>
    </node>
    <node id="紧凑技术">
      <data key="d0">紧凑技术</data>
      <data key="d1">method</data>
      <data key="d2">Compaction technique is a method used to overcome external fragmentation by periodically moving and rearranging processes in memory to create larger contiguous blocks.</data>
      <data key="d3">chunk-f59ab8ff80e1533c966b7cb6b20563dc</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794474</data>
    </node>
    <node id="空闲分区链">
      <data key="d0">空闲分区链</data>
      <data key="d1">data</data>
      <data key="d2">The free partition chain is a data structure used in dynamic partition allocation to track and manage available memory partitions.</data>
      <data key="d3">chunk-f59ab8ff80e1533c966b7cb6b20563dc</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794474</data>
    </node>
    <node id="首次适应算法">
      <data key="d0">首次适应算法</data>
      <data key="d1">method</data>
      <data key="d2">First Fit algorithm allocates the first available memory partition that meets the size requirement, with free partitions ordered by increasing address.</data>
      <data key="d3">chunk-f59ab8ff80e1533c966b7cb6b20563dc</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794474</data>
    </node>
    <node id="邻近适应算法">
      <data key="d0">邻近适应算法</data>
      <data key="d1">method</data>
      <data key="d2">Next Fit algorithm, also known as circular first fit, continues searching from the last position where the previous search ended, aiming to reduce search time.</data>
      <data key="d3">chunk-f59ab8ff80e1533c966b7cb6b20563dc</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794474</data>
    </node>
    <node id="最佳适应算法">
      <data key="d0">最佳适应算法</data>
      <data key="d1">method</data>
      <data key="d2">Best Fit algorithm orders free partitions by size in ascending order and allocates the smallest partition that fits the process requirement.</data>
      <data key="d3">chunk-f59ab8ff80e1533c966b7cb6b20563dc</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794474</data>
    </node>
    <node id="最坏适应算法">
      <data key="d0">最坏适应算法</data>
      <data key="d1">method</data>
      <data key="d2">Worst Fit algorithm orders free partitions by size in descending order and allocates the largest available partition to the process.</data>
      <data key="d3">chunk-f59ab8ff80e1533c966b7cb6b20563dc</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794474</data>
    </node>
    <node id="快速适应算法">
      <data key="d0">快速适应算法</data>
      <data key="d1">method</data>
      <data key="d2">Fast Fit algorithm organizes free partitions by common size classes, each with its own free partition chain for faster allocation.</data>
      <data key="d3">chunk-f59ab8ff80e1533c966b7cb6b20563dc</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794476</data>
    </node>
    <node id="伙伴系统">
      <data key="d0">伙伴系统</data>
      <data key="d1">method</data>
      <data key="d2">The buddy system is a memory allocation method where all partitions are sized as powers of two, allowing efficient splitting and merging of blocks.</data>
      <data key="d3">chunk-f59ab8ff80e1533c966b7cb6b20563dc</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794476</data>
    </node>
    <node id="哈希算法">
      <data key="d0">哈希算法</data>
      <data key="d1">method</data>
      <data key="d2">Hash algorithm uses a hash function on free partition sizes to create a hash table, enabling fast lookup of corresponding free partition chains.</data>
      <data key="d3">chunk-f59ab8ff80e1533c966b7cb6b20563dc</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794476</data>
    </node>
    <node id="内存利用率">
      <data key="d0">内存利用率</data>
      <data key="d1">concept</data>
      <data key="d2">Memory utilization refers to the efficiency with which available memory is used; it declines due to external fragmentation.</data>
      <data key="d3">chunk-f59ab8ff80e1533c966b7cb6b20563dc</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794476</data>
    </node>
    <node id="空闲分区链表">
      <data key="d0">空闲分区链表</data>
      <data key="d1">data</data>
      <data key="d2">The free partition list is a data structure maintaining a list of available memory partitions for allocation, used in dynamic partition allocation.</data>
      <data key="d3">chunk-f59ab8ff80e1533c966b7cb6b20563dc</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794476</data>
    </node>
    <node id="段页式存储管理">
      <data key="d0">段页式存储管理</data>
      <data key="d1">method</data>
      <data key="d2">段页式存储管理是一种将分页存储管理和分段存储管理相结合的内存管理方法，通过段号、页号和页内偏移量实现逻辑地址到物理地址的转换。</data>
      <data key="d3">chunk-c195ab08b96907e43c39705a88501db8</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794508</data>
    </node>
    <node id="分页存储管理">
      <data key="d0">分页存储管理</data>
      <data key="d1">method</data>
      <data key="d2">分页存储管理是一种将进程地址空间划分为固定大小页面的内存管理方法，内存以物理块为单位进行分配。</data>
      <data key="d3">chunk-c195ab08b96907e43c39705a88501db8</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794508</data>
    </node>
    <node id="分段存储管理">
      <data key="d0">分段存储管理</data>
      <data key="d1">method</data>
      <data key="d2">分段存储管理是一种将进程地址空间划分为逻辑段的内存管理方法，每段具有独立的段号和长度。&lt;SEP&gt;分段存储管理organizes memory into variable-sized segments based on logical program divisions, supporting user needs in programming and access.</data>
      <data key="d3">chunk-fa7ddc38beb083a10e073654dee57a19&lt;SEP&gt;chunk-c195ab08b96907e43c39705a88501db8</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794757</data>
    </node>
    <node id="逻辑段">
      <data key="d0">逻辑段</data>
      <data key="d1">concept</data>
      <data key="d2">逻辑段是进程地址空间中按功能或逻辑划分的区域，每个段有唯一的段号。</data>
      <data key="d3">chunk-c195ab08b96907e43c39705a88501db8</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794508</data>
    </node>
    <node id="页面">
      <data key="d0">页面</data>
      <data key="d1">concept</data>
      <data key="d2">页面是分页存储管理中固定大小的存储单位，用于划分段和内存。</data>
      <data key="d3">chunk-c195ab08b96907e43c39705a88501db8</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794508</data>
    </node>
    <node id="段表">
      <data key="d0">段表</data>
      <data key="d1">artifact</data>
      <data key="d2">段表是为每个进程建立的地址转换数据结构，记录各段的页表始址。&lt;SEP&gt;段表是每个进程维护的映射表，记录各段在内存中的始址和长度，每个段对应一个段表项。</data>
      <data key="d3">chunk-14a72f660cb4c5e34ac9c9ddaed64956&lt;SEP&gt;chunk-c195ab08b96907e43c39705a88501db8</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794860</data>
    </node>
    <node id="页表">
      <data key="d0">页表</data>
      <data key="d1">artifact</data>
      <data key="d2">页表是每个段中用于记录页号到物理块号映射的数据结构。</data>
      <data key="d3">chunk-c195ab08b96907e43c39705a88501db8</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794508</data>
    </node>
    <node id="段表寄存器">
      <data key="d0">段表寄存器</data>
      <data key="d1">artifact</data>
      <data key="d2">段表寄存器用于存储当前进程段表的起始地址，加速地址变换过程。&lt;SEP&gt;段表寄存器用于存放段表的始址F和段表长度M，是地址变换的关键硬件组件。</data>
      <data key="d3">chunk-14a72f660cb4c5e34ac9c9ddaed64956&lt;SEP&gt;chunk-c195ab08b96907e43c39705a88501db8</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794860</data>
    </node>
    <node id="物理地址">
      <data key="d0">物理地址</data>
      <data key="d1">data</data>
      <data key="d2">物理地址是内存中实际存储位置的地址，通过逻辑地址计算获得。&lt;SEP&gt;An actual address on the main memory hardware used to access physical storage.&lt;SEP&gt;物理地址是通过段表始址与段内偏移量计算出的实际内存地址E = b + W。</data>
      <data key="d3">chunk-00e431215b94639001c5095d3c4f8b1c&lt;SEP&gt;chunk-14a72f660cb4c5e34ac9c9ddaed64956&lt;SEP&gt;chunk-c195ab08b96907e43c39705a88501db8</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794862</data>
    </node>
    <node id="逻辑地址">
      <data key="d0">逻辑地址</data>
      <data key="d1">data</data>
      <data key="d2">逻辑地址由段号、页号和页内偏移量组成，用于表示进程中的地址。&lt;SEP&gt;逻辑地址is a reference to memory that is relative to the start of a program or module and needs to be converted to a physical address during execution.&lt;SEP&gt;An address generated by a CPU that refers to a location in virtual memory.</data>
      <data key="d3">chunk-c09d18569a1b1c90198e18b0108e8c32&lt;SEP&gt;chunk-00e431215b94639001c5095d3c4f8b1c&lt;SEP&gt;chunk-c195ab08b96907e43c39705a88501db8</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794565</data>
    </node>
    <node id="页内偏移量">
      <data key="d0">页内偏移量</data>
      <data key="d1">concept</data>
      <data key="d2">页内偏移量是页面内部的字节偏移，定位数据在页内的具体位置。</data>
      <data key="d3">chunk-c195ab08b96907e43c39705a88501db8</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794509</data>
    </node>
    <node id="地址变换">
      <data key="d0">地址变换</data>
      <data key="d1">method</data>
      <data key="d2">地址变换是将逻辑地址转换为物理地址的过程，涉及段表和页表的查找。</data>
      <data key="d3">chunk-c195ab08b96907e43c39705a88501db8</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794509</data>
    </node>
    <node id="二维地址空间">
      <data key="d0">二维地址空间</data>
      <data key="d1">concept</data>
      <data key="d2">二维地址空间指段页式存储管理中以段和页为维度的地址结构。&lt;SEP&gt;分段管理的地址空间是二维的，由段号和段内偏移量构成。</data>
      <data key="d3">chunk-14a72f660cb4c5e34ac9c9ddaed64956&lt;SEP&gt;chunk-c195ab08b96907e43c39705a88501db8</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794860</data>
    </node>
    <node id="段号">
      <data key="d0">段号</data>
      <data key="d3">chunk-c195ab08b96907e43c39705a88501db8</data>
      <data key="d2">逻辑地址包含段号，用于定位进程的逻辑段。</data>
      <data key="d1">UNKNOWN</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794511</data>
    </node>
    <node id="页号">
      <data key="d0">页号</data>
      <data key="d3">chunk-c195ab08b96907e43c39705a88501db8</data>
      <data key="d2">逻辑地址包含页号，用于定位段中的页面。</data>
      <data key="d1">UNKNOWN</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794512</data>
    </node>
    <node id="程序的链接与装入">
      <data key="d0">程序的链接与装入</data>
      <data key="d1">concept</data>
      <data key="d2">程序的链接与装入is the process of transforming user source code into an executable program in memory, involving compilation, linking, and loading steps.</data>
      <data key="d3">chunk-c09d18569a1b1c90198e18b0108e8c32</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794520</data>
    </node>
    <node id="创建进程">
      <data key="d0">创建进程</data>
      <data key="d1">concept</data>
      <data key="d2">创建进程is the initial step of loading a program and data into memory to prepare it for execution.</data>
      <data key="d3">chunk-c09d18569a1b1c90198e18b0108e8c32</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794520</data>
    </node>
    <node id="用户源程序">
      <data key="d0">用户源程序</data>
      <data key="d1">content</data>
      <data key="d2">用户源程序refers to the original code written by a user that needs to be compiled and loaded into memory.</data>
      <data key="d3">chunk-c09d18569a1b1c90198e18b0108e8c32</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794520</data>
    </node>
    <node id="目标模块">
      <data key="d0">目标模块</data>
      <data key="d1">artifact</data>
      <data key="d2">目标模块are intermediate files generated by the compiler from source code, which need to be linked together.</data>
      <data key="d3">chunk-c09d18569a1b1c90198e18b0108e8c32</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794520</data>
    </node>
    <node id="库函数">
      <data key="d0">库函数</data>
      <data key="d1">artifact</data>
      <data key="d2">库函数are pre-written code segments that provide common functionality and are required by target modules.</data>
      <data key="d3">chunk-c09d18569a1b1c90198e18b0108e8c32</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794520</data>
    </node>
    <node id="装入模块">
      <data key="d0">装入模块</data>
      <data key="d1">artifact</data>
      <data key="d2">装入模块is a complete executable unit formed by linking target modules and required library functions.</data>
      <data key="d3">chunk-c09d18569a1b1c90198e18b0108e8c32</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794520</data>
    </node>
    <node id="编译">
      <data key="d0">编译</data>
      <data key="d1">method</data>
      <data key="d2">编译is the process of translating user source code into object code (target modules).</data>
      <data key="d3">chunk-c09d18569a1b1c90198e18b0108e8c32</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794520</data>
    </node>
    <node id="链接">
      <data key="d0">链接</data>
      <data key="d1">method</data>
      <data key="d2">链接is the process of combining target modules and their required library functions into a single load module.</data>
      <data key="d3">chunk-c09d18569a1b1c90198e18b0108e8c32</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794520</data>
    </node>
    <node id="装入">
      <data key="d0">装入</data>
      <data key="d1">method</data>
      <data key="d2">装入is the process of moving a load module into memory so it can be executed.</data>
      <data key="d3">chunk-c09d18569a1b1c90198e18b0108e8c32</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794521</data>
    </node>
    <node id="绝对装入">
      <data key="d0">绝对装入</data>
      <data key="d1">method</data>
      <data key="d2">绝对装入is a loading method used in single-program environments where the program is loaded at a fixed memory address, with no address translation.</data>
      <data key="d3">chunk-c09d18569a1b1c90198e18b0108e8c32</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794522</data>
    </node>
    <node id="可重定位装入">
      <data key="d0">可重定位装入</data>
      <data key="d1">method</data>
      <data key="d2">可重定位装入, also known as static relocation, involves loading a program at a location in memory and adjusting addresses at load time to reflect the actual memory location.</data>
      <data key="d3">chunk-c09d18569a1b1c90198e18b0108e8c32</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794522</data>
    </node>
    <node id="动态运行时装入">
      <data key="d0">动态运行时装入</data>
      <data key="d1">method</data>
      <data key="d2">动态运行时装入, also known as dynamic relocation, delays address translation until execution time, allowing the program to be moved in memory during execution.</data>
      <data key="d3">chunk-c09d18569a1b1c90198e18b0108e8c32</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794522</data>
    </node>
    <node id="重定位">
      <data key="d0">重定位</data>
      <data key="d1">concept</data>
      <data key="d2">重定位refers to the adjustment of addresses in a program to reflect its actual memory location during loading or execution.</data>
      <data key="d3">chunk-c09d18569a1b1c90198e18b0108e8c32</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794522</data>
    </node>
    <node id="重定位寄存器">
      <data key="d0">重定位寄存器</data>
      <data key="d1">artifact</data>
      <data key="d2">重定位寄存器is a hardware register used in dynamic relocation to store the starting address of a loaded module.</data>
      <data key="d3">chunk-c09d18569a1b1c90198e18b0108e8c32</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794522</data>
    </node>
    <node id="实际内存地址">
      <data key="d0">实际内存地址</data>
      <data key="d1">data</data>
      <data key="d2">实际内存地址is the absolute address in physical memory where a program or data item is stored.</data>
      <data key="d3">chunk-c09d18569a1b1c90198e18b0108e8c32</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794522</data>
    </node>
    <node id="静态链接">
      <data key="d0">静态链接</data>
      <data key="d1">method</data>
      <data key="d2">静态链接is a linking method where all modules are linked together before the program runs and remain fixed thereafter.</data>
      <data key="d3">chunk-c09d18569a1b1c90198e18b0108e8c32</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794523</data>
    </node>
    <node id="装入时动态链接">
      <data key="d0">装入时动态链接</data>
      <data key="d1">method</data>
      <data key="d2">装入时动态链接is a linking method where linking occurs during loading, enabling on-demand linking and code sharing.</data>
      <data key="d3">chunk-c09d18569a1b1c90198e18b0108e8c32</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794523</data>
    </node>
    <node id="运行时动态链接">
      <data key="d0">运行时动态链接</data>
      <data key="d1">method</data>
      <data key="d2">运行时动态链接is a linking method where linking occurs only when a module is actually needed during program execution.</data>
      <data key="d3">chunk-c09d18569a1b1c90198e18b0108e8c32</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794523</data>
    </node>
    <node id="单道程序环境">
      <data key="d0">单道程序环境</data>
      <data key="d1">concept</data>
      <data key="d2">单道程序环境refers to a computing environment where only one program runs at a time, suitable for absolute loading.</data>
      <data key="d3">chunk-c09d18569a1b1c90198e18b0108e8c32</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794523</data>
    </node>
    <node id="内存空间">
      <data key="d0">内存空间</data>
      <data key="d1">naturalobject</data>
      <data key="d2">内存空间is the physical memory available for storing and executing programs and data.</data>
      <data key="d3">chunk-c09d18569a1b1c90198e18b0108e8c32</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794523</data>
    </node>
    <node id="不连续的存储区">
      <data key="d0">不连续的存储区</data>
      <data key="d1">concept</data>
      <data key="d2">不连续的存储区is a memory allocation strategy where a program can be stored in non-adjacent memory regions.</data>
      <data key="d3">chunk-c09d18569a1b1c90198e18b0108e8c32</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794523</data>
    </node>
    <node id="程序段的共享">
      <data key="d0">程序段的共享</data>
      <data key="d1">concept</data>
      <data key="d2">程序段的共享allows multiple processes to use the same code segment in memory, reducing memory usage.</data>
      <data key="d3">chunk-c09d18569a1b1c90198e18b0108e8c32</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794523</data>
    </node>
    <node id="程序和数据">
      <data key="d0">程序和数据</data>
      <data key="d1">data</data>
      <data key="d2">程序和数据refers to the executable code and associated data that must be loaded into memory before a program can execute.</data>
      <data key="d3">chunk-c09d18569a1b1c90198e18b0108e8c32</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794523</data>
    </node>
    <node id="逻辑地址与实际内存地址">
      <data key="d0">逻辑地址与实际内存地址</data>
      <data key="d1">concept</data>
      <data key="d2">逻辑地址与实际内存地址describes the distinction between relative addresses used in program code and their corresponding absolute addresses in physical memory.</data>
      <data key="d3">chunk-c09d18569a1b1c90198e18b0108e8c32</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794523</data>
    </node>
    <node id="虚拟内存">
      <data key="d0">虚拟内存</data>
      <data key="d1">concept</data>
      <data key="d2">Virtual memory is a memory management technique that provides an illusion of a large, contiguous memory space by using both physical memory and secondary storage.</data>
      <data key="d3">chunk-00e431215b94639001c5095d3c4f8b1c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794560</data>
    </node>
    <node id="传统存储管理方式">
      <data key="d0">传统存储管理方式</data>
      <data key="d1">concept</data>
      <data key="d2">Traditional storage management methods are characterized by the need to load an entire job into memory at once and keep it resident until completion.</data>
      <data key="d3">chunk-00e431215b94639001c5095d3c4f8b1c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794560</data>
    </node>
    <node id="一次性">
      <data key="d0">一次性</data>
      <data key="d1">concept</data>
      <data key="d2">The characteristic of loading an entire program into memory in one go before execution begins.</data>
      <data key="d3">chunk-00e431215b94639001c5095d3c4f8b1c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794560</data>
    </node>
    <node id="驻留性">
      <data key="d0">驻留性</data>
      <data key="d1">concept</data>
      <data key="d2">The characteristic of a program remaining in memory throughout its execution without being swapped out.</data>
      <data key="d3">chunk-00e431215b94639001c5095d3c4f8b1c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794560</data>
    </node>
    <node id="局部性原理">
      <data key="d0">局部性原理</data>
      <data key="d1">concept</data>
      <data key="d2">The principle that programs tend to access a relatively small portion of their address space at any given time, including time and space locality.&lt;SEP&gt;局部性原理explains that programs tend to access a limited set of memory locations repeatedly, influencing page fault frequency.</data>
      <data key="d3">chunk-00e431215b94639001c5095d3c4f8b1c&lt;SEP&gt;chunk-dd63fcc97211dcfcfa94d11eff1be6f8</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794759</data>
    </node>
    <node id="时间局部性">
      <data key="d0">时间局部性</data>
      <data key="d1">concept</data>
      <data key="d2">The tendency for a program to access the same instructions or data items repeatedly over a short period.</data>
      <data key="d3">chunk-00e431215b94639001c5095d3c4f8b1c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794560</data>
    </node>
    <node id="空间局部性">
      <data key="d0">空间局部性</data>
      <data key="d1">concept</data>
      <data key="d2">The tendency for a program to access memory locations that are close to one another shortly after accessing a particular location.</data>
      <data key="d3">chunk-00e431215b94639001c5095d3c4f8b1c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794560</data>
    </node>
    <node id="内存-外存两级存储器结构">
      <data key="d0">内存-外存两级存储器结构</data>
      <data key="d1">concept</data>
      <data key="d2">A two-level storage architecture combining main memory and secondary storage, enabling virtual memory implementation.</data>
      <data key="d3">chunk-00e431215b94639001c5095d3c4f8b1c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794560</data>
    </node>
    <node id="虚拟存储器">
      <data key="d0">虚拟存储器</data>
      <data key="d1">concept</data>
      <data key="d2">A logical memory abstraction that appears larger than physical memory, created through virtual memory techniques.</data>
      <data key="d3">chunk-00e431215b94639001c5095d3c4f8b1c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794562</data>
    </node>
    <node id="多次性">
      <data key="d0">多次性</data>
      <data key="d1">concept</data>
      <data key="d2">The ability to load a process into memory in multiple steps, rather than all at once.</data>
      <data key="d3">chunk-00e431215b94639001c5095d3c4f8b1c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794562</data>
    </node>
    <node id="对换性">
      <data key="d0">对换性</data>
      <data key="d1">concept</data>
      <data key="d2">The ability to swap parts of a process between main memory and secondary storage during execution.</data>
      <data key="d3">chunk-00e431215b94639001c5095d3c4f8b1c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794562</data>
    </node>
    <node id="虚拟性">
      <data key="d0">虚拟性</data>
      <data key="d1">concept</data>
      <data key="d2">The feature of virtual memory that logically expands the apparent size of main memory beyond its physical limits.</data>
      <data key="d3">chunk-00e431215b94639001c5095d3c4f8b1c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794562</data>
    </node>
    <node id="请求分页存储管理">
      <data key="d0">请求分页存储管理</data>
      <data key="d1">method</data>
      <data key="d2">A memory management technique where pages of a program are loaded into memory on demand when referenced.</data>
      <data key="d3">chunk-00e431215b94639001c5095d3c4f8b1c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794562</data>
    </node>
    <node id="请求分段存储管理">
      <data key="d0">请求分段存储管理</data>
      <data key="d1">method</data>
      <data key="d2">A memory management approach where segments of a program are loaded into memory only when needed.</data>
      <data key="d3">chunk-00e431215b94639001c5095d3c4f8b1c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794562</data>
    </node>
    <node id="请求段页式存储管理">
      <data key="d0">请求段页式存储管理</data>
      <data key="d1">method</data>
      <data key="d2">A hybrid memory management method combining segmentation and paging, where segments are divided into pages and loaded on demand.</data>
      <data key="d3">chunk-00e431215b94639001c5095d3c4f8b1c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794562</data>
    </node>
    <node id="页表机制">
      <data key="d0">页表机制</data>
      <data key="d1">artifact</data>
      <data key="d2">A data structure used to track the mapping between logical and physical addresses in page-based virtual memory.</data>
      <data key="d3">chunk-00e431215b94639001c5095d3c4f8b1c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794562</data>
    </node>
    <node id="段表机制">
      <data key="d0">段表机制</data>
      <data key="d1">artifact</data>
      <data key="d2">A data structure used in segment-based memory management to track the location and size of program segments.</data>
      <data key="d3">chunk-00e431215b94639001c5095d3c4f8b1c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794563</data>
    </node>
    <node id="Page Buffering Algorithm">
      <data key="d0">Page Buffering Algorithm</data>
      <data key="d1">method</data>
      <data key="d2">The Page Buffering Algorithm enhances the original page replacement algorithm by introducing linked lists for unmodified and modified pages to reduce the overhead of page swapping.</data>
      <data key="d3">chunk-3c9d6c4c9f8b1850281a50533371f77d</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794563</data>
    </node>
    <node id="Free Page List">
      <data key="d0">Free Page List</data>
      <data key="d1">data</data>
      <data key="d2">The Free Page List stores unmodified pages that are not immediately written to disk, instead being placed at the end of the list for potential reuse.</data>
      <data key="d3">chunk-3c9d6c4c9f8b1850281a50533371f77d</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794563</data>
    </node>
    <node id="Modified Page List">
      <data key="d0">Modified Page List</data>
      <data key="d1">data</data>
      <data key="d2">The Modified Page List holds pages that have been modified and are pending eviction, temporarily stored in memory before being written to disk.</data>
      <data key="d3">chunk-3c9d6c4c9f8b1850281a50533371f77d</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794563</data>
    </node>
    <node id="Page Frame Recycling">
      <data key="d0">Page Frame Recycling</data>
      <data key="d1">concept</data>
      <data key="d2">Page Frame Recycling refers to the process of reclaiming memory pages from processes when system memory is insufficient, primarily targeting pages used by user processes.</data>
      <data key="d3">chunk-3c9d6c4c9f8b1850281a50533371f77d</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794563</data>
    </node>
    <node id="Kernel-Used Page Frames">
      <data key="d0">Kernel-Used Page Frames</data>
      <data key="d1">data</data>
      <data key="d2">Kernel-used page frames are typically non-recyclable and remain allocated for system-level operations.</data>
      <data key="d3">chunk-3c9d6c4c9f8b1850281a50533371f77d</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794563</data>
    </node>
    <node id="User-Process Page Frames">
      <data key="d0">User-Process Page Frames</data>
      <data key="d1">data</data>
      <data key="d2">User-process page frames are generally recyclable and can be reclaimed when needed to free up memory.</data>
      <data key="d3">chunk-3c9d6c4c9f8b1850281a50533371f77d</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794563</data>
    </node>
    <node id="Kswapd">
      <data key="d0">Kswapd</data>
      <data key="d1">organization</data>
      <data key="d2">Kswapd is a Linux kernel daemon responsible for monitoring memory usage and initiating page frame recycling when free page thresholds are exceeded.</data>
      <data key="d3">chunk-3c9d6c4c9f8b1850281a50533371f77d</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794563</data>
    </node>
    <node id="Memory Usage Threshold">
      <data key="d0">Memory Usage Threshold</data>
      <data key="d1">concept</data>
      <data key="d2">The Memory Usage Threshold is a predefined limit that triggers the page frame recycling process when the number of free pages falls below it.</data>
      <data key="d3">chunk-3c9d6c4c9f8b1850281a50533371f77d</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794563</data>
    </node>
    <node id="中断机构">
      <data key="d0">中断机构</data>
      <data key="d1">artifact</data>
      <data key="d2">Hardware or software mechanism that signals the operating system when a required memory page is not in physical memory.</data>
      <data key="d3">chunk-00e431215b94639001c5095d3c4f8b1c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794563</data>
    </node>
    <node id="地址变换机构">
      <data key="d0">地址变换机构</data>
      <data key="d1">method</data>
      <data key="d2">A component responsible for translating logical addresses into physical addresses in memory management.&lt;SEP&gt;地址变换机构负责从逻辑地址转换为物理地址，包括越界检查与物理地址计算。</data>
      <data key="d3">chunk-00e431215b94639001c5095d3c4f8b1c&lt;SEP&gt;chunk-14a72f660cb4c5e34ac9c9ddaed64956</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794862</data>
    </node>
    <node id="内存">
      <data key="d0">内存</data>
      <data key="d1">naturalobject</data>
      <data key="d2">Main memory (RAM) is the primary volatile storage for a computer system.</data>
      <data key="d3">chunk-00e431215b94639001c5095d3c4f8b1c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794565</data>
    </node>
    <node id="外存">
      <data key="d0">外存</data>
      <data key="d1">naturalobject</data>
      <data key="d2">Secondary storage (e.g., hard disk) used for long-term storage of data and programs.</data>
      <data key="d3">chunk-00e431215b94639001c5095d3c4f8b1c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794565</data>
    </node>
    <node id="对换区">
      <data key="d0">对换区</data>
      <data key="d1">naturalobject</data>
      <data key="d2">A designated area on secondary storage used for swapping out inactive memory pages.</data>
      <data key="d3">chunk-00e431215b94639001c5095d3c4f8b1c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794565</data>
    </node>
    <node id="Single Continuous Allocation">
      <data key="d0">Single Continuous Allocation</data>
      <data key="d1">method</data>
      <data key="d2">Single Continuous Allocation is a memory management method where memory is divided into a system area and a user area, with the user area occupied by only one user program at a time.&lt;SEP&gt;Single continuous allocation is a memory management technique that allocates the entire memory space to a single user program.</data>
      <data key="d3">chunk-5479cc3e41d3a11f68f2cb90f11aab62&lt;SEP&gt;chunk-2fa1a754b848fd3412be2058c0482b68</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794784</data>
    </node>
    <node id="System Area">
      <data key="d0">System Area</data>
      <data key="d1">location</data>
      <data key="d2">The System Area is the part of memory reserved for the operating system and is typically located in the low-address portion.</data>
      <data key="d3">chunk-2fa1a754b848fd3412be2058c0482b68</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794615</data>
    </node>
    <node id="User Area">
      <data key="d0">User Area</data>
      <data key="d1">location</data>
      <data key="d2">The User Area is the portion of memory available for user programs and, in single continuous allocation, holds only one user program at a time.</data>
      <data key="d3">chunk-2fa1a754b848fd3412be2058c0482b68</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794615</data>
    </node>
    <node id="User Program">
      <data key="d0">User Program</data>
      <data key="d1">concept</data>
      <data key="d2">A User Program is a single application running in the user area that monopolizes the entire user memory space in this allocation method.&lt;SEP&gt;A user program is a software application executed by a computer, requiring memory allocation for operation.</data>
      <data key="d3">chunk-5479cc3e41d3a11f68f2cb90f11aab62&lt;SEP&gt;chunk-2fa1a754b848fd3412be2058c0482b68</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794784</data>
    </node>
    <node id="External Fragmentation">
      <data key="d0">External Fragmentation</data>
      <data key="d1">concept</data>
      <data key="d2">External Fragmentation refers to the situation where free memory is scattered in small blocks, but this method avoids it by requiring a single contiguous block.&lt;SEP&gt;External fragmentation refers to the inefficient use of memory space due to non-contiguous allocation; it is not produced in page-based management.&lt;SEP&gt;External fragmentation is the free memory scattered in small, non-contiguous blocks, which does not occur in fixed partition allocation.</data>
      <data key="d3">chunk-2fa1a754b848fd3412be2058c0482b68&lt;SEP&gt;chunk-46462724e0de563d009072de78fa1d68&lt;SEP&gt;chunk-f688f41802e3a8adfb553475e4ca265e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794719</data>
    </node>
    <node id="Internal Fragmentation">
      <data key="d0">Internal Fragmentation</data>
      <data key="d1">concept</data>
      <data key="d2">Internal Fragmentation occurs when a program does not fully utilize its allocated memory, leaving unused space within the allocated block.&lt;SEP&gt;Internal fragmentation occurs when pages are not fully utilized, leading to unused space within allocated page frames.&lt;SEP&gt;Internal fragmentation is the wasted memory space within a partition when a program is smaller than the partition size, leading to inefficient memory utilization.</data>
      <data key="d3">chunk-2fa1a754b848fd3412be2058c0482b68&lt;SEP&gt;chunk-46462724e0de563d009072de78fa1d68&lt;SEP&gt;chunk-f688f41802e3a8adfb553475e4ca265e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794719</data>
    </node>
    <node id="Memory Utilization">
      <data key="d0">Memory Utilization</data>
      <data key="d1">concept</data>
      <data key="d2">Memory Utilization refers to the efficiency of memory usage, which is very low in single continuous allocation due to the exclusive occupation of the user area by a single program.</data>
      <data key="d3">chunk-2fa1a754b848fd3412be2058c0482b68</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794615</data>
    </node>
    <node id="Memory Protection">
      <data key="d0">Memory Protection</data>
      <data key="d1">concept</data>
      <data key="d2">Memory Protection is a mechanism that prevents one program from accessing another program's memory, which is not required in this method due to the single-user model.&lt;SEP&gt;Memory protection ensures that each process has a separate memory space and prevents interference between the operating system and user processes, as well as between different user processes.</data>
      <data key="d3">chunk-2fa1a754b848fd3412be2058c0482b68&lt;SEP&gt;chunk-6a91872eefca67b87c6a12b37faf30eb</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794812</data>
    </node>
    <node id="Basic Page Storage Management">
      <data key="d0">Basic Page Storage Management</data>
      <data key="d1">method</data>
      <data key="d2">Basic page storage management is a memory management technique that divides physical memory into fixed-size blocks called page frames, and logically divides the process address space into pages of the same size.</data>
      <data key="d3">chunk-46462724e0de563d009072de78fa1d68</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794637</data>
    </node>
    <node id="Page Frame">
      <data key="d0">Page Frame</data>
      <data key="d1">artifact</data>
      <data key="d2">A page frame is a fixed-size block in physical memory used to store a page of a process.&lt;SEP&gt;A Page Frame is a fixed-size block of physical memory used to store a page of virtual memory.</data>
      <data key="d3">chunk-28a7b83e6af7f15e967e78c26eccf799&lt;SEP&gt;chunk-46462724e0de563d009072de78fa1d68</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794679</data>
    </node>
    <node id="Physical Block">
      <data key="d0">Physical Block</data>
      <data key="d1">artifact</data>
      <data key="d2">A physical block refers to a fixed-size segment of main memory used in page-based allocation.</data>
      <data key="d3">chunk-46462724e0de563d009072de78fa1d68</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794637</data>
    </node>
    <node id="Logical Address Space">
      <data key="d0">Logical Address Space</data>
      <data key="d1">concept</data>
      <data key="d2">The logical address space is the address space as viewed by a process, divided into pages of equal size.</data>
      <data key="d3">chunk-46462724e0de563d009072de78fa1d68</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794637</data>
    </node>
    <node id="Page Size">
      <data key="d0">Page Size</data>
      <data key="d1">concept</data>
      <data key="d2">Page size is the fixed size of a page or page frame and should be a power of 2 for efficient address translation.</data>
      <data key="d3">chunk-46462724e0de563d009072de78fa1d68</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794637</data>
    </node>
    <node id="Page Number">
      <data key="d0">Page Number</data>
      <data key="d1">concept</data>
      <data key="d2">A page number is an index assigned to each page in the logical address space, starting from zero.</data>
      <data key="d3">chunk-46462724e0de563d009072de78fa1d68</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794638</data>
    </node>
    <node id="Page Frame Number">
      <data key="d0">Page Frame Number</data>
      <data key="d1">concept</data>
      <data key="d2">A page frame number is the index of a page frame in physical memory, starting from zero.</data>
      <data key="d3">chunk-46462724e0de563d009072de78fa1d68</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794638</data>
    </node>
    <node id="Address Structure">
      <data key="d0">Address Structure</data>
      <data key="d1">concept</data>
      <data key="d2">The address structure in paging consists of a page number and a page offset within the page.</data>
      <data key="d3">chunk-46462724e0de563d009072de78fa1d68</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794638</data>
    </node>
    <node id="Page Table">
      <data key="d0">Page Table</data>
      <data key="d1">data</data>
      <data key="d2">A page table is a data structure that maps each page of a process to its corresponding physical page frame, and contains entries with page numbers and block numbers.&lt;SEP&gt;The Page Table is a critical data structure that maps virtual page numbers to physical frame numbers in memory.&lt;SEP&gt;Page table is a data structure maintained by the operating system to map logical addresses to physical addresses.</data>
      <data key="d3">chunk-28a7b83e6af7f15e967e78c26eccf799&lt;SEP&gt;chunk-46462724e0de563d009072de78fa1d68&lt;SEP&gt;chunk-c8697590fab35afe994351ccfc05bbac</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794706</data>
    </node>
    <node id="Page Table Entry">
      <data key="d0">Page Table Entry</data>
      <data key="d1">artifact</data>
      <data key="d2">A page table entry contains the mapping from a logical page number to a physical block number.&lt;SEP&gt;A Page Table Entry contains metadata about a virtual page, including status, access, modification, and external storage address information.&lt;SEP&gt;A page table entry is a component in a process's page table that maps a virtual page to a physical page.</data>
      <data key="d3">chunk-28a7b83e6af7f15e967e78c26eccf799&lt;SEP&gt;chunk-46462724e0de563d009072de78fa1d68&lt;SEP&gt;chunk-00b255b459e05b4695b33c9dceed4321</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794855</data>
    </node>
    <node id="Page Table Register">
      <data key="d0">Page Table Register</data>
      <data key="d1">artifact</data>
      <data key="d2">The page table register (PTR) stores the starting address and length of the page table in memory.</data>
      <data key="d3">chunk-46462724e0de563d009072de78fa1d68</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794638</data>
    </node>
    <node id="Page Table Length">
      <data key="d0">Page Table Length</data>
      <data key="d1">data</data>
      <data key="d2">Page table length is the number of entries in a process's page table, used to check for address bound violations.</data>
      <data key="d3">chunk-46462724e0de563d009072de78fa1d68</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794638</data>
    </node>
    <node id="Page Offset">
      <data key="d0">Page Offset</data>
      <data key="d1">data</data>
      <data key="d2">The page offset is the displacement within a page, used to locate specific bytes within a page.</data>
      <data key="d3">chunk-46462724e0de563d009072de78fa1d68</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794640</data>
    </node>
    <node id="Basic Address Transformation Mechanism">
      <data key="d0">Basic Address Transformation Mechanism</data>
      <data key="d1">method</data>
      <data key="d2">The basic address transformation mechanism converts logical addresses into physical addresses using a page table.</data>
      <data key="d3">chunk-46462724e0de563d009072de78fa1d68</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794640</data>
    </node>
    <node id="Translation Lookaside Buffer">
      <data key="d0">Translation Lookaside Buffer</data>
      <data key="d1">artifact</data>
      <data key="d2">The translation lookaside buffer (TLB) is a high-speed cache that stores recently accessed page table entries to speed up address translation.&lt;SEP&gt;The Translation Lookaside Buffer is a high-speed cache that stores recent page table entries to speed up address translation.</data>
      <data key="d3">chunk-28a7b83e6af7f15e967e78c26eccf799&lt;SEP&gt;chunk-46462724e0de563d009072de78fa1d68</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794680</data>
    </node>
    <node id="Fast Table">
      <data key="d0">Fast Table</data>
      <data key="d1">artifact</data>
      <data key="d2">The fast table is another term for the TLB, used to accelerate address translation.</data>
      <data key="d3">chunk-46462724e0de563d009072de78fa1d68</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794640</data>
    </node>
    <node id="Slow Table">
      <data key="d0">Slow Table</data>
      <data key="d1">artifact</data>
      <data key="d2">The slow table refers to the main memory page table, used when the TLB does not contain the required mapping.</data>
      <data key="d3">chunk-46462724e0de563d009072de78fa1d68</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794640</data>
    </node>
    <node id="Two-Level Page Table">
      <data key="d0">Two-Level Page Table</data>
      <data key="d1">method</data>
      <data key="d2">A two-level page table is a hierarchical structure used to reduce the memory overhead of large page tables by splitting them into a second-level table.</data>
      <data key="d3">chunk-46462724e0de563d009072de78fa1d68</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794640</data>
    </node>
    <node id="Outer Page Table">
      <data key="d0">Outer Page Table</data>
      <data key="d1">artifact</data>
      <data key="d2">The outer page table, also known as the page directory, contains the base addresses of second-level page tables.</data>
      <data key="d3">chunk-46462724e0de563d009072de78fa1d68</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794640</data>
    </node>
    <node id="Page Directory Register">
      <data key="d0">Page Directory Register</data>
      <data key="d1">artifact</data>
      <data key="d2">The page directory register stores the base address of the outer page table or page directory.</data>
      <data key="d3">chunk-46462724e0de563d009072de78fa1d68</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794640</data>
    </node>
    <node id="Page Directory Number">
      <data key="d0">Page Directory Number</data>
      <data key="d1">concept</data>
      <data key="d2">The page directory number is the index used to access the outer page table to locate the second-level page table.</data>
      <data key="d3">chunk-46462724e0de563d009072de78fa1d68</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794641</data>
    </node>
    <node id="Second-Level Page Number">
      <data key="d0">Second-Level Page Number</data>
      <data key="d1">concept</data>
      <data key="d2">The second-level page number is used as an index into the second-level page table to find the physical block number.</data>
      <data key="d3">chunk-46462724e0de563d009072de78fa1d68</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794641</data>
    </node>
    <node id="Multi-Level Page Table">
      <data key="d0">Multi-Level Page Table</data>
      <data key="d1">method</data>
      <data key="d2">A multi-level page table is an extension of the two-level approach, used to manage very large address spaces by further dividing the outer page table.</data>
      <data key="d3">chunk-46462724e0de563d009072de78fa1d68</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794642</data>
    </node>
    <node id="Page Directory">
      <data key="d0">Page Directory</data>
      <data key="d1">artifact</data>
      <data key="d2">The page directory is another term for the outer page table used in two-level paging to manage second-level page tables.</data>
      <data key="d3">chunk-46462724e0de563d009072de78fa1d68</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794642</data>
    </node>
    <node id="Page Directory Base Address Register">
      <data key="d0">Page Directory Base Address Register</data>
      <data key="d1">artifact</data>
      <data key="d2">The page directory base address register stores the starting address of the page directory in memory.</data>
      <data key="d3">chunk-46462724e0de563d009072de78fa1d68</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794642</data>
    </node>
    <node id="Physical Block Number">
      <data key="d0">Physical Block Number</data>
      <data key="d3">chunk-28a7b83e6af7f15e967e78c26eccf799&lt;SEP&gt;chunk-46462724e0de563d009072de78fa1d68</data>
      <data key="d2">A physical address is created by combining the physical block number and the page offset.&lt;SEP&gt;The Physical Block Number identifies the specific frame in physical memory where a virtual page is stored.</data>
      <data key="d1">data</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794681</data>
    </node>
    <node id="Page Frame Allocation">
      <data key="d0">Page Frame Allocation</data>
      <data key="d1">concept</data>
      <data key="d2">Page frame allocation refers to the process by which the operating system assigns a number of page frames to a specific process in a paged virtual memory system.</data>
      <data key="d3">chunk-abb4ec292dd5335d76c0413487939cbe</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794654</data>
    </node>
    <node id="Resident Set Size">
      <data key="d0">Resident Set Size</data>
      <data key="d1">concept</data>
      <data key="d2">Resident set size is the set of page frames allocated to a process in memory, directly affecting the number of processes that can reside in memory and their performance.</data>
      <data key="d3">chunk-abb4ec292dd5335d76c0413487939cbe</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794654</data>
    </node>
    <node id="Page Fault Rate">
      <data key="d0">Page Fault Rate</data>
      <data key="d1">concept</data>
      <data key="d2">Page fault rate is the frequency with which a process accesses a page not in memory, influenced by the size of the resident set.</data>
      <data key="d3">chunk-abb4ec292dd5335d76c0413487939cbe</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794654</data>
    </node>
    <node id="Multiprogramming Degree">
      <data key="d0">Multiprogramming Degree</data>
      <data key="d1">concept</data>
      <data key="d2">Multiprogramming degree refers to the number of processes that can be simultaneously in memory, which increases as the resident set size decreases.</data>
      <data key="d3">chunk-abb4ec292dd5335d76c0413487939cbe</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794654</data>
    </node>
    <node id="Memory Allocation Strategy">
      <data key="d0">Memory Allocation Strategy</data>
      <data key="d1">concept</data>
      <data key="d2">Memory allocation strategy determines how physical memory blocks are assigned to processes in a request-paging system.</data>
      <data key="d3">chunk-abb4ec292dd5335d76c0413487939cbe</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794654</data>
    </node>
    <node id="Fixed Allocation">
      <data key="d0">Fixed Allocation</data>
      <data key="d1">method</data>
      <data key="d2">Fixed allocation is a memory management strategy where each process is assigned a fixed number of physical page frames, which remains constant during execution.</data>
      <data key="d3">chunk-abb4ec292dd5335d76c0413487939cbe</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794654</data>
    </node>
    <node id="Variable Allocation">
      <data key="d0">Variable Allocation</data>
      <data key="d1">method</data>
      <data key="d2">Variable allocation is a memory management strategy that allows the number of physical page frames assigned to a process to change dynamically during execution.</data>
      <data key="d3">chunk-abb4ec292dd5335d76c0413487939cbe</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794654</data>
    </node>
    <node id="Global Replacement">
      <data key="d0">Global Replacement</data>
      <data key="d1">method</data>
      <data key="d2">Global replacement is a page replacement strategy where any page in memory, regardless of which process it belongs to, can be selected for replacement.</data>
      <data key="d3">chunk-abb4ec292dd5335d76c0413487939cbe</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794654</data>
    </node>
    <node id="Local Replacement">
      <data key="d0">Local Replacement</data>
      <data key="d1">method</data>
      <data key="d2">Local replacement is a page replacement strategy where only pages belonging to the same process that experienced a page fault are considered for replacement.</data>
      <data key="d3">chunk-abb4ec292dd5335d76c0413487939cbe</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794656</data>
    </node>
    <node id="Fixed Allocation Local Replacement">
      <data key="d0">Fixed Allocation Local Replacement</data>
      <data key="d1">method</data>
      <data key="d2">Fixed allocation local replacement combines fixed page frame assignment with replacement limited to the process's own pages.</data>
      <data key="d3">chunk-abb4ec292dd5335d76c0413487939cbe</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794656</data>
    </node>
    <node id="Variable Allocation Global Replacement">
      <data key="d0">Variable Allocation Global Replacement</data>
      <data key="d1">method</data>
      <data key="d2">Variable allocation global replacement allows dynamic adjustment of page frames and permits replacement from any process in memory.</data>
      <data key="d3">chunk-abb4ec292dd5335d76c0413487939cbe</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794656</data>
    </node>
    <node id="Variable Allocation Local Replacement">
      <data key="d0">Variable Allocation Local Replacement</data>
      <data key="d1">method</data>
      <data key="d2">Variable allocation local replacement allows dynamic adjustment of page frames, with replacement limited to the process's own pages.</data>
      <data key="d3">chunk-abb4ec292dd5335d76c0413487939cbe</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794656</data>
    </node>
    <node id="Average Allocation Algorithm">
      <data key="d0">Average Allocation Algorithm</data>
      <data key="d1">method</data>
      <data key="d2">Average allocation algorithm distributes available physical page frames equally among all running processes.</data>
      <data key="d3">chunk-abb4ec292dd5335d76c0413487939cbe</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794656</data>
    </node>
    <node id="Proportional Allocation Algorithm">
      <data key="d0">Proportional Allocation Algorithm</data>
      <data key="d1">method</data>
      <data key="d2">Proportional allocation algorithm assigns physical page frames to processes based on their size or resource requirements.</data>
      <data key="d3">chunk-abb4ec292dd5335d76c0413487939cbe</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794656</data>
    </node>
    <node id="Priority Allocation Algorithm">
      <data key="d0">Priority Allocation Algorithm</data>
      <data key="d1">method</data>
      <data key="d2">Priority allocation algorithm assigns more page frames to high-priority or urgent processes.</data>
      <data key="d3">chunk-abb4ec292dd5335d76c0413487939cbe</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794656</data>
    </node>
    <node id="Preloading Page Strategy">
      <data key="d0">Preloading Page Strategy</data>
      <data key="d1">method</data>
      <data key="d2">Preloading page strategy involves predicting future page accesses and loading them into memory in advance.</data>
      <data key="d3">chunk-abb4ec292dd5335d76c0413487939cbe</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794656</data>
    </node>
    <node id="Demand Page Strategy">
      <data key="d0">Demand Page Strategy</data>
      <data key="d1">method</data>
      <data key="d2">Demand page strategy involves loading a page into memory only when it is requested by a process during execution.</data>
      <data key="d3">chunk-abb4ec292dd5335d76c0413487939cbe</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794657</data>
    </node>
    <node id="Swap Area">
      <data key="d0">Swap Area</data>
      <data key="d1">artifact</data>
      <data key="d2">Swap area is a dedicated region of secondary storage used to hold pages that have been swapped out of main memory.</data>
      <data key="d3">chunk-abb4ec292dd5335d76c0413487939cbe</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794657</data>
    </node>
    <node id="File Area">
      <data key="d0">File Area</data>
      <data key="d1">artifact</data>
      <data key="d2">File area is a region of secondary storage used to store files and program images.</data>
      <data key="d3">chunk-abb4ec292dd5335d76c0413487939cbe</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794658</data>
    </node>
    <node id="Disk I/O Speed">
      <data key="d0">Disk I/O Speed</data>
      <data key="d1">concept</data>
      <data key="d2">Disk I/O speed refers to the rate at which data can be read from or written to the disk, affecting page loading performance.</data>
      <data key="d3">chunk-abb4ec292dd5335d76c0413487939cbe</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794658</data>
    </node>
    <node id="UNIX Method">
      <data key="d0">UNIX Method</data>
      <data key="d1">method</data>
      <data key="d2">UNIX method is a page loading strategy where unused pages are loaded from the file area, while previously run and swapped-out pages are loaded from the swap area.</data>
      <data key="d3">chunk-abb4ec292dd5335d76c0413487939cbe</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794658</data>
    </node>
    <node id="Physical Page Frame">
      <data key="d0">Physical Page Frame</data>
      <data key="d1">artifact</data>
      <data key="d2">Physical page frame is a block of physical memory used to store a page of virtual memory.</data>
      <data key="d3">chunk-abb4ec292dd5335d76c0413487939cbe</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794658</data>
    </node>
    <node id="Page Fault">
      <data key="d0">Page Fault</data>
      <data key="d1">incident</data>
      <data key="d2">Page fault occurs when a process attempts to access a page not currently present in physical memory.</data>
      <data key="d3">chunk-abb4ec292dd5335d76c0413487939cbe</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794658</data>
    </node>
    <node id="Demand Paging">
      <data key="d0">Demand Paging</data>
      <data key="d1">concept</data>
      <data key="d2">Demand paging is a memory management technique where pages are loaded into memory only when they are needed.</data>
      <data key="d3">chunk-abb4ec292dd5335d76c0413487939cbe</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794658</data>
    </node>
    <node id="Request-Paging System">
      <data key="d0">Request-Paging System</data>
      <data key="d1">concept</data>
      <data key="d2">Request-paging system is a virtual memory management system where pages are loaded into memory only when accessed, supporting dynamic memory allocation and demand-based loading.</data>
      <data key="d3">chunk-abb4ec292dd5335d76c0413487939cbe</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794659</data>
    </node>
    <node id="Request Paging System">
      <data key="d0">Request Paging System</data>
      <data key="d1">concept</data>
      <data key="d2">The Request Paging System is an advanced memory management technique built on the basic paging system, enabling virtual memory by supporting demand paging and page replacement.</data>
      <data key="d3">chunk-28a7b83e6af7f15e967e78c26eccf799</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794677</data>
    </node>
    <node id="Basic Paging System">
      <data key="d0">Basic Paging System</data>
      <data key="d1">concept</data>
      <data key="d2">The Basic Paging System is a foundational memory management method that divides memory into fixed-size pages and frames for efficient memory allocation.</data>
      <data key="d3">chunk-28a7b83e6af7f15e967e78c26eccf799</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794677</data>
    </node>
    <node id="Status Bit P">
      <data key="d0">Status Bit P</data>
      <data key="d1">data</data>
      <data key="d2">The Status Bit P indicates whether a page is currently loaded into main memory or not.</data>
      <data key="d3">chunk-28a7b83e6af7f15e967e78c26eccf799</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794677</data>
    </node>
    <node id="Access Field A">
      <data key="d0">Access Field A</data>
      <data key="d1">data</data>
      <data key="d2">The Access Field A records how often a page has been accessed or the time elapsed since its last access.</data>
      <data key="d3">chunk-28a7b83e6af7f15e967e78c26eccf799</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794677</data>
    </node>
    <node id="Modify Bit M">
      <data key="d0">Modify Bit M</data>
      <data key="d1">data</data>
      <data key="d2">The Modify Bit M indicates whether a page has been modified in memory since it was loaded.</data>
      <data key="d3">chunk-28a7b83e6af7f15e967e78c26eccf799</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794677</data>
    </node>
    <node id="External Storage Address">
      <data key="d0">External Storage Address</data>
      <data key="d1">data</data>
      <data key="d2">The External Storage Address specifies the location on secondary storage where a page is stored when not in memory.</data>
      <data key="d3">chunk-28a7b83e6af7f15e967e78c26eccf799</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794679</data>
    </node>
    <node id="Page Fault Handler">
      <data key="d0">Page Fault Handler</data>
      <data key="d1">method</data>
      <data key="d2">The Page Fault Handler is a component of the operating system that manages the interrupt process triggered when a requested page is not in memory.</data>
      <data key="d3">chunk-28a7b83e6af7f15e967e78c26eccf799</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794679</data>
    </node>
    <node id="Page Fault Interrupt">
      <data key="d0">Page Fault Interrupt</data>
      <data key="d1">event</data>
      <data key="d2">The Page Fault Interrupt occurs when a requested page is not present in main memory, triggering a system intervention to load it.</data>
      <data key="d3">chunk-28a7b83e6af7f15e967e78c26eccf799</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794679</data>
    </node>
    <node id="Blocking Queue">
      <data key="d0">Blocking Queue</data>
      <data key="d1">data</data>
      <data key="d2">The Blocking Queue holds processes that are waiting for a page to be loaded into memory.</data>
      <data key="d3">chunk-28a7b83e6af7f15e967e78c26eccf799</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794679</data>
    </node>
    <node id="Ready Queue">
      <data key="d0">Ready Queue</data>
      <data key="d1">data</data>
      <data key="d2">The Ready Queue contains processes that are ready to execute once they obtain required resources.</data>
      <data key="d3">chunk-28a7b83e6af7f15e967e78c26eccf799</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794679</data>
    </node>
    <node id="Page Replacement Algorithm">
      <data key="d0">Page Replacement Algorithm</data>
      <data key="d1">method</data>
      <data key="d2">The Page Replacement Algorithm determines which page in memory should be replaced when a new page needs to be loaded and no free page frames are available.</data>
      <data key="d3">chunk-28a7b83e6af7f15e967e78c26eccf799</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794679</data>
    </node>
    <node id="Address Translation Mechanism">
      <data key="d0">Address Translation Mechanism</data>
      <data key="d1">method</data>
      <data key="d2">The Address Translation Mechanism converts virtual addresses to physical addresses using the page table and translation lookaside buffer (TLB).</data>
      <data key="d3">chunk-28a7b83e6af7f15e967e78c26eccf799</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794679</data>
    </node>
    <node id="Page Content">
      <data key="d0">Page Content</data>
      <data key="d1">data</data>
      <data key="d2">The Page Content refers to the actual data stored within a virtual page when loaded into memory.</data>
      <data key="d3">chunk-28a7b83e6af7f15e967e78c26eccf799</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794681</data>
    </node>
    <node id="Virtual Address">
      <data key="d0">Virtual Address</data>
      <data key="d1">data</data>
      <data key="d2">The Virtual Address is the logical address generated by a process that is later translated into a physical address.</data>
      <data key="d3">chunk-28a7b83e6af7f15e967e78c26eccf799</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794681</data>
    </node>
    <node id="Virtual Address Space">
      <data key="d0">Virtual Address Space</data>
      <data key="d1">concept</data>
      <data key="d2">Virtual address space is the unified logical address space created by the linker, starting from zero, used during program execution.</data>
      <data key="d3">chunk-c8697590fab35afe994351ccfc05bbac</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794706</data>
    </node>
    <node id="Address Relocation">
      <data key="d0">Address Relocation</data>
      <data key="d1">method</data>
      <data key="d2">Address relocation is the process of converting logical addresses into physical addresses during program loading.</data>
      <data key="d3">chunk-c8697590fab35afe994351ccfc05bbac</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794706</data>
    </node>
    <node id="Memory Management Unit">
      <data key="d0">Memory Management Unit</data>
      <data key="d1">artifact</data>
      <data key="d2">Memory Management Unit (MMU) is a hardware component that assists in translating logical addresses into physical addresses.&lt;SEP&gt;The memory management unit is responsible for translating logical addresses to physical addresses and performing bounds checking.</data>
      <data key="d3">chunk-c8697590fab35afe994351ccfc05bbac&lt;SEP&gt;chunk-6a91872eefca67b87c6a12b37faf30eb</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794812</data>
    </node>
    <node id="Process">
      <data key="d0">Process</data>
      <data key="d1">concept</data>
      <data key="d2">Process is an executing instance of a program that uses logical addresses and relies on address mapping for memory access.&lt;SEP&gt;A process is an instance of a program in execution, which may access shared code and maintain private data during runtime.</data>
      <data key="d3">chunk-00b255b459e05b4695b33c9dceed4321&lt;SEP&gt;chunk-c8697590fab35afe994351ccfc05bbac</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794857</data>
    </node>
    <node id="Linker">
      <data key="d0">Linker</data>
      <data key="d1">method</data>
      <data key="d2">Linker is a program that combines multiple target modules into a single executable program by assigning unified logical addresses.</data>
      <data key="d3">chunk-c8697590fab35afe994351ccfc05bbac</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794708</data>
    </node>
    <node id="Compiler">
      <data key="d0">Compiler</data>
      <data key="d1">method</data>
      <data key="d2">Compiler is a program that translates source code into target modules, assigning logical addresses starting from zero.</data>
      <data key="d3">chunk-c8697590fab35afe994351ccfc05bbac</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794708</data>
    </node>
    <node id="Fixed Partition Allocation">
      <data key="d0">Fixed Partition Allocation</data>
      <data key="d1">method</data>
      <data key="d2">Fixed partition allocation is a simple memory management technique in multiprogramming systems that divides user memory into fixed-size partitions, each holding one job at a time.&lt;SEP&gt;Fixed partition allocation divides memory into fixed-size partitions, each allocated to a user program.</data>
      <data key="d3">chunk-5479cc3e41d3a11f68f2cb90f11aab62&lt;SEP&gt;chunk-f688f41802e3a8adfb553475e4ca265e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794784</data>
    </node>
    <node id="User Memory Space">
      <data key="d0">User Memory Space</data>
      <data key="d1">concept</data>
      <data key="d2">User memory space is the portion of computer memory allocated to user processes, which is divided into fixed partitions in this method.</data>
      <data key="d3">chunk-f688f41802e3a8adfb553475e4ca265e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794719</data>
    </node>
    <node id="Partition Size Equal">
      <data key="d0">Partition Size Equal</data>
      <data key="d1">concept</data>
      <data key="d2">Partition size equal refers to a method of dividing memory into partitions of identical size.</data>
      <data key="d3">chunk-f688f41802e3a8adfb553475e4ca265e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794719</data>
    </node>
    <node id="Partition Size Unequal">
      <data key="d0">Partition Size Unequal</data>
      <data key="d1">concept</data>
      <data key="d2">Partition size unequal refers to a method where memory is divided into partitions of different sizes.</data>
      <data key="d3">chunk-f688f41802e3a8adfb553475e4ca265e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794719</data>
    </node>
    <node id="Partition Usage Table">
      <data key="d0">Partition Usage Table</data>
      <data key="d1">data</data>
      <data key="d2">Partition usage table is a data structure used to track the allocation and status of memory partitions for easier assignment and recovery.</data>
      <data key="d3">chunk-f688f41802e3a8adfb553475e4ca265e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794719</data>
    </node>
    <node id="Memory Partition">
      <data key="d0">Memory Partition</data>
      <data key="d1">artifact</data>
      <data key="d2">Memory partition is a fixed-size area of memory allocated to hold a single job in the fixed partition allocation method.</data>
      <data key="d3">chunk-f688f41802e3a8adfb553475e4ca265e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794719</data>
    </node>
    <node id="Job">
      <data key="d0">Job</data>
      <data key="d1">concept</data>
      <data key="d2">Job refers to a program or task being processed in a multiprogramming system, which is loaded into a single fixed memory partition.</data>
      <data key="d3">chunk-f688f41802e3a8adfb553475e4ca265e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794720</data>
    </node>
    <node id="内存分配与回收">
      <data key="d0">内存分配与回收</data>
      <data key="d1">concept</data>
      <data key="d2">内存分配与回收refers to the process of allocating and reclaiming memory space in computer systems, evolving with advancements in operating systems.</data>
      <data key="d3">chunk-fa7ddc38beb083a10e073654dee57a19</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794757</data>
    </node>
    <node id="存储管理方式">
      <data key="d0">存储管理方式</data>
      <data key="d1">concept</data>
      <data key="d2">存储管理方式describes the methods used by operating systems to manage memory resources, evolving from simple to advanced techniques.</data>
      <data key="d3">chunk-fa7ddc38beb083a10e073654dee57a19</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794757</data>
    </node>
    <node id="单一连续分配">
      <data key="d0">单一连续分配</data>
      <data key="d1">method</data>
      <data key="d2">单一连续分配is a memory management method where a single program occupies the entire memory space, used in early single-task operating systems.</data>
      <data key="d3">chunk-fa7ddc38beb083a10e073654dee57a19</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794757</data>
    </node>
    <node id="固定分区分配">
      <data key="d0">固定分区分配</data>
      <data key="d1">method</data>
      <data key="d2">固定分区分配divides memory into fixed-size partitions, allowing multiple programs to run concurrently but leading to internal fragmentation.</data>
      <data key="d3">chunk-fa7ddc38beb083a10e073654dee57a19</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794757</data>
    </node>
    <node id="离散分配方式">
      <data key="d0">离散分配方式</data>
      <data key="d1">method</data>
      <data key="d2">离散分配方式allocates memory in non-contiguous blocks, improving memory utilization, exemplified by page-based management.</data>
      <data key="d3">chunk-fa7ddc38beb083a10e073654dee57a19</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794757</data>
    </node>
    <node id="页式存储管理">
      <data key="d0">页式存储管理</data>
      <data key="d1">method</data>
      <data key="d2">页式存储管理is a memory management technique that divides memory into fixed-size pages, allowing efficient use of non-contiguous memory blocks.</data>
      <data key="d3">chunk-fa7ddc38beb083a10e073654dee57a19</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794757</data>
    </node>
    <node id="操作系统">
      <data key="d0">操作系统</data>
      <data key="d1">organization</data>
      <data key="d2">操作系统is a system software that manages computer hardware and software resources, enabling the evolution of memory management techniques.</data>
      <data key="d3">chunk-fa7ddc38beb083a10e073654dee57a19</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794759</data>
    </node>
    <node id="页面大小">
      <data key="d0">页面大小</data>
      <data key="d1">concept</data>
      <data key="d2">页面大小refers to the size of each memory page, influencing the frequency of page faults; larger pages generally result in lower缺页率.</data>
      <data key="d3">chunk-dd63fcc97211dcfcfa94d11eff1be6f8</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794759</data>
    </node>
    <node id="物理块数">
      <data key="d0">物理块数</data>
      <data key="d1">concept</data>
      <data key="d2">物理块数denotes the number of physical memory blocks allocated to a process, with higher allocation leading to lower缺页率.</data>
      <data key="d3">chunk-dd63fcc97211dcfcfa94d11eff1be6f8</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794759</data>
    </node>
    <node id="程序编制方法">
      <data key="d0">程序编制方法</data>
      <data key="d1">method</data>
      <data key="d2">程序编制方法refers to how a program is written, particularly its locality characteristics, which affect缺页率.</data>
      <data key="d3">chunk-dd63fcc97211dcfcfa94d11eff1be6f8</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794759</data>
    </node>
    <node id="已修改换出页面的链表">
      <data key="d0">已修改换出页面的链表</data>
      <data key="d1">artifact</data>
      <data key="d2">已修改换出页面的链表is a data structure used to track pages that have been modified and evicted, helping reduce disk I/O.</data>
      <data key="d3">chunk-dd63fcc97211dcfcfa94d11eff1be6f8</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794759</data>
    </node>
    <node id="磁盘I/O次数">
      <data key="d0">磁盘I/O次数</data>
      <data key="d1">data</data>
      <data key="d2">磁盘I/O次数refers to the number of input/output operations performed on disk, which can be reduced by optimizing page management.</data>
      <data key="d3">chunk-dd63fcc97211dcfcfa94d11eff1be6f8</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794759</data>
    </node>
    <node id="写回磁盘的频率">
      <data key="d0">写回磁盘的频率</data>
      <data key="d1">concept</data>
      <data key="d2">写回磁盘的频率indicates how often modified pages are written back to disk, a factor affecting system performance.</data>
      <data key="d3">chunk-dd63fcc97211dcfcfa94d11eff1be6f8</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794761</data>
    </node>
    <node id="Continuous Allocation Method">
      <data key="d0">Continuous Allocation Method</data>
      <data key="d1">method</data>
      <data key="d2">Continuous allocation method refers to the process of assigning a contiguous block of memory space to a user program.</data>
      <data key="d3">chunk-5479cc3e41d3a11f68f2cb90f11aab62</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794784</data>
    </node>
    <node id="Dynamic Partition Allocation">
      <data key="d0">Dynamic Partition Allocation</data>
      <data key="d1">method</data>
      <data key="d2">Dynamic partition allocation assigns memory partitions of varying sizes based on the program's requirements.</data>
      <data key="d3">chunk-5479cc3e41d3a11f68f2cb90f11aab62</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794784</data>
    </node>
    <node id="Memory Space">
      <data key="d0">Memory Space</data>
      <data key="d1">concept</data>
      <data key="d2">Memory space refers to the area of computer memory available for storing data and instructions.</data>
      <data key="d3">chunk-5479cc3e41d3a11f68f2cb90f11aab62</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794784</data>
    </node>
    <node id="抖动">
      <data key="d0">抖动</data>
      <data key="d1">concept</data>
      <data key="d2">抖动refers to the frequent page swapping in memory management, where pages are rapidly exchanged between main memory and secondary storage, leading to system inefficiency.</data>
      <data key="d3">chunk-67ae509cb7f3a2cdf2694e125b8725c3</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794794</data>
    </node>
    <node id="工作集">
      <data key="d0">工作集</data>
      <data key="d1">concept</data>
      <data key="d2">工作集is the set of pages a process accesses within a specific time interval, representing the pages likely to be accessed in the near future.</data>
      <data key="d3">chunk-67ae509cb7f3a2cdf2694e125b8725c3</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794794</data>
    </node>
    <node id="页面置换">
      <data key="d0">页面置换</data>
      <data key="d1">method</data>
      <data key="d2">页面置换is the process of replacing pages in main memory with pages from secondary storage to manage virtual memory.</data>
      <data key="d3">chunk-67ae509cb7f3a2cdf2694e125b8725c3</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794794</data>
    </node>
    <node id="驻留集">
      <data key="d0">驻留集</data>
      <data key="d1">concept</data>
      <data key="d2">驻留集is the set of pages currently present in main memory for a process, which should be large enough to contain the working set.</data>
      <data key="d3">chunk-67ae509cb7f3a2cdf2694e125b8725c3</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794794</data>
    </node>
    <node id="缺页">
      <data key="d0">缺页</data>
      <data key="d1">concept</data>
      <data key="d2">缺页occurs when a process attempts to access a page not currently in main memory, triggering a page fault and resulting in page loading from secondary storage.</data>
      <data key="d3">chunk-67ae509cb7f3a2cdf2694e125b8725c3</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794794</data>
    </node>
    <node id="进程">
      <data key="d0">进程</data>
      <data key="d1">concept</data>
      <data key="d2">进程is a running instance of a program, which accesses memory pages and relies on proper memory management for efficient execution.</data>
      <data key="d3">chunk-67ae509cb7f3a2cdf2694e125b8725c3</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794794</data>
    </node>
    <node id="CPU">
      <data key="d0">CPU</data>
      <data key="d1">artifact</data>
      <data key="d2">CPU is the central processing unit that manages instruction execution and performs address comparisons for memory access.</data>
      <data key="d3">chunk-6a91872eefca67b87c6a12b37faf30eb</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794812</data>
    </node>
    <node id="Upper Limit Register">
      <data key="d0">Upper Limit Register</data>
      <data key="d1">artifact</data>
      <data key="d2">The upper limit register stores the maximum address accessible by a user process in main memory.</data>
      <data key="d3">chunk-6a91872eefca67b87c6a12b37faf30eb</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794812</data>
    </node>
    <node id="Lower Limit Register">
      <data key="d0">Lower Limit Register</data>
      <data key="d1">artifact</data>
      <data key="d2">The lower limit register stores the minimum address accessible by a user process in main memory.</data>
      <data key="d3">chunk-6a91872eefca67b87c6a12b37faf30eb</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794812</data>
    </node>
    <node id="Relocation Register">
      <data key="d0">Relocation Register</data>
      <data key="d1">artifact</data>
      <data key="d2">The relocation register, also known as the base address register, holds the starting physical address of a process.</data>
      <data key="d3">chunk-6a91872eefca67b87c6a12b37faf30eb</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794812</data>
    </node>
    <node id="Bound Address Register">
      <data key="d0">Bound Address Register</data>
      <data key="d1">artifact</data>
      <data key="d2">The bound address register, also known as the limit register, stores the maximum logical address a process can access.</data>
      <data key="d3">chunk-6a91872eefca67b87c6a12b37faf30eb</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794812</data>
    </node>
    <node id="Privileged Instruction">
      <data key="d0">Privileged Instruction</data>
      <data key="d1">method</data>
      <data key="d2">Privileged instructions are special machine instructions that can only be executed by the operating system kernel and are used to load critical registers.</data>
      <data key="d3">chunk-6a91872eefca67b87c6a12b37faf30eb</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794814</data>
    </node>
    <node id="Operating System Kernel">
      <data key="d0">Operating System Kernel</data>
      <data key="d1">organization</data>
      <data key="d2">The operating system kernel is the core component of the operating system that manages system resources and can execute privileged instructions.</data>
      <data key="d3">chunk-6a91872eefca67b87c6a12b37faf30eb</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794814</data>
    </node>
    <node id="Read-Only Regions">
      <data key="d0">Read-Only Regions</data>
      <data key="d1">category</data>
      <data key="d2">Read-only regions are memory areas that can be shared among processes without modification.</data>
      <data key="d3">chunk-00b255b459e05b4695b33c9dceed4321</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794855</data>
    </node>
    <node id="Reentrant Code">
      <data key="d0">Reentrant Code</data>
      <data key="d1">concept</data>
      <data key="d2">Reentrant code, also known as pure code, is executable code that can be safely accessed by multiple processes simultaneously and must not be modified by any process.</data>
      <data key="d3">chunk-00b255b459e05b4695b33c9dceed4321</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794855</data>
    </node>
    <node id="Shared Code Area">
      <data key="d0">Shared Code Area</data>
      <data key="d1">category</data>
      <data key="d2">The shared code area is the physical or logical memory region containing code that is shared across multiple processes.</data>
      <data key="d3">chunk-00b255b459e05b4695b33c9dceed4321</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794855</data>
    </node>
    <node id="Private Data Area">
      <data key="d0">Private Data Area</data>
      <data key="d1">category</data>
      <data key="d2">A private data area is a memory region allocated per process to hold local data that may be modified during code execution.</data>
      <data key="d3">chunk-00b255b459e05b4695b33c9dceed4321</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794855</data>
    </node>
    <node id="Physical Page Number">
      <data key="d0">Physical Page Number</data>
      <data key="d1">data</data>
      <data key="d2">The physical page number is the actual memory location where a page of code or data resides in physical memory.</data>
      <data key="d3">chunk-00b255b459e05b4695b33c9dceed4321</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794855</data>
    </node>
    <node id="Segment Table Entry">
      <data key="d0">Segment Table Entry</data>
      <data key="d1">artifact</data>
      <data key="d2">A segment table entry is a component in a process's segment table that points to the start address of a shared segment.</data>
      <data key="d3">chunk-00b255b459e05b4695b33c9dceed4321</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794855</data>
    </node>
    <node id="Shared Code Segment">
      <data key="d0">Shared Code Segment</data>
      <data key="d1">category</data>
      <data key="d2">The shared code segment is the segment in memory containing code that is shared among multiple processes.</data>
      <data key="d3">chunk-00b255b459e05b4695b33c9dceed4321</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794857</data>
    </node>
    <node id="Paging System">
      <data key="d0">Paging System</data>
      <data key="d1">method</data>
      <data key="d2">The paging system is a memory management technique that uses fixed-size pages and page tables to map virtual addresses to physical addresses.</data>
      <data key="d3">chunk-00b255b459e05b4695b33c9dceed4321</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794857</data>
    </node>
    <node id="Segmentation System">
      <data key="d0">Segmentation System</data>
      <data key="d1">method</data>
      <data key="d2">The segmentation system is a memory management technique that divides memory into variable-sized segments, managed via segment tables.</data>
      <data key="d3">chunk-00b255b459e05b4695b33c9dceed4321</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794857</data>
    </node>
    <node id="Execution Time">
      <data key="d0">Execution Time</data>
      <data key="d1">concept</data>
      <data key="d2">Execution time refers to the period during which a program is actively running and modifying data in memory, particularly when executing reentrant code.</data>
      <data key="d3">chunk-00b255b459e05b4695b33c9dceed4321</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794857</data>
    </node>
    <node id="Code Sharing">
      <data key="d0">Code Sharing</data>
      <data key="d1">concept</data>
      <data key="d2">Code sharing is the practice of allowing multiple processes to execute the same code segment from a shared memory region, improving memory efficiency and system performance.</data>
      <data key="d3">chunk-00b255b459e05b4695b33c9dceed4321</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794857</data>
    </node>
    <node id="分页管理方式">
      <data key="d0">分页管理方式</data>
      <data key="d1">method</data>
      <data key="d2">分页管理方式是从计算机角度设计的内存管理方法，主要目的是提高内存利用率，对用户不可见。</data>
      <data key="d3">chunk-14a72f660cb4c5e34ac9c9ddaed64956</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794860</data>
    </node>
    <node id="分段管理方式">
      <data key="d0">分段管理方式</data>
      <data key="d1">method</data>
      <data key="d2">分段管理方式考虑了用户和程序员的需求，支持方便编程、信息保护与共享、动态增长及动态链接等功能。</data>
      <data key="d3">chunk-14a72f660cb4c5e34ac9c9ddaed64956</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794860</data>
    </node>
    <node id="逻辑地址空间">
      <data key="d0">逻辑地址空间</data>
      <data key="d1">concept</data>
      <data key="d2">逻辑地址空间是用户进程的虚拟地址空间，被划分为大小不等的段。</data>
      <data key="d3">chunk-14a72f660cb4c5e34ac9c9ddaed64956</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794860</data>
    </node>
    <node id="段">
      <data key="d0">段</data>
      <data key="d1">concept</data>
      <data key="d2">段是逻辑地址空间的划分单位，每段从0开始编址并分配连续的地址空间，段内连续但段间不要求连续。</data>
      <data key="d3">chunk-14a72f660cb4c5e34ac9c9ddaed64956</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794860</data>
    </node>
    <node id="逻辑地址结构">
      <data key="d0">逻辑地址结构</data>
      <data key="d1">concept</data>
      <data key="d2">逻辑地址结构由段号S与段内偏移量W组成，由用户显式提供。</data>
      <data key="d3">chunk-14a72f660cb4c5e34ac9c9ddaed64956</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794860</data>
    </node>
    <node id="段号S">
      <data key="d0">段号S</data>
      <data key="d1">data</data>
      <data key="d2">段号S是逻辑地址中表示段的编号，用于在段表中查找对应段表项。</data>
      <data key="d3">chunk-14a72f660cb4c5e34ac9c9ddaed64956</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794862</data>
    </node>
    <node id="段内偏移量W">
      <data key="d0">段内偏移量W</data>
      <data key="d1">data</data>
      <data key="d2">段内偏移量W是逻辑地址中表示段内位置的偏移值，用于定位段内具体地址。</data>
      <data key="d3">chunk-14a72f660cb4c5e34ac9c9ddaed64956</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794862</data>
    </node>
    <node id="共享段表">
      <data key="d0">共享段表</data>
      <data key="d1">artifact</data>
      <data key="d2">共享段表用于管理多个进程共享的段，每个共享段在表中有一个表项。</data>
      <data key="d3">chunk-14a72f660cb4c5e34ac9c9ddaed64956</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794862</data>
    </node>
    <node id="可重入代码">
      <data key="d0">可重入代码</data>
      <data key="d1">concept</data>
      <data key="d2">可重入代码是一种允许多个进程同时安全访问的代码，也称为纯代码。</data>
      <data key="d3">chunk-14a72f660cb4c5e34ac9c9ddaed64956</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794862</data>
    </node>
    <node id="存取控制保护">
      <data key="d0">存取控制保护</data>
      <data key="d1">method</data>
      <data key="d2">存取控制保护是分段管理中用于保护段的一种方法，控制对段的访问权限。</data>
      <data key="d3">chunk-14a72f660cb4c5e34ac9c9ddaed64956</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794862</data>
    </node>
    <node id="地址越界保护">
      <data key="d0">地址越界保护</data>
      <data key="d1">method</data>
      <data key="d2">地址越界保护是分段管理中用于防止非法访问的保护机制，检测段号或偏移量是否超出范围。</data>
      <data key="d3">chunk-14a72f660cb4c5e34ac9c9ddaed64956</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794862</data>
    </node>
    <node id="虚拟地址空间">
      <data key="d0">虚拟地址空间</data>
      <data key="d3">chunk-14a72f660cb4c5e34ac9c9ddaed64956</data>
      <data key="d2">分段管理方式以用户和程序员需求为核心，构建二维的虚拟地址空间。</data>
      <data key="d1">UNKNOWN</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794866</data>
    </node>
    <node id="Process Memory Image">
      <data key="d0">Process Memory Image</data>
      <data key="d1">concept</data>
      <data key="d2">The process memory image is the in-memory representation of a program when loaded for execution, consisting of various segments including code, data, heap, stack, and process control block.</data>
      <data key="d3">chunk-595c1a74214288cf8d47eda3bbc75afe</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794882</data>
    </node>
    <node id="Executable Program File">
      <data key="d0">Executable Program File</data>
      <data key="d1">artifact</data>
      <data key="d2">An executable program file is a file stored on disk that contains machine code and is loaded into memory to create a process.</data>
      <data key="d3">chunk-595c1a74214288cf8d47eda3bbc75afe</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794882</data>
    </node>
    <node id="Code Segment">
      <data key="d0">Code Segment</data>
      <data key="d1">artifact</data>
      <data key="d2">The code segment contains the binary machine code of a program, is read-only, and can be shared among multiple processes.</data>
      <data key="d3">chunk-595c1a74214288cf8d47eda3bbc75afe</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794882</data>
    </node>
    <node id="Data Segment">
      <data key="d0">Data Segment</data>
      <data key="d1">artifact</data>
      <data key="d2">The data segment stores data that the program manipulates during execution, including global and static variables.</data>
      <data key="d3">chunk-595c1a74214288cf8d47eda3bbc75afe</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794882</data>
    </node>
    <node id="Process Control Block">
      <data key="d0">Process Control Block</data>
      <data key="d1">artifact</data>
      <data key="d2">The Process Control Block (PCB) is a system-resident data structure used by the operating system to store and manage information about a process.</data>
      <data key="d3">chunk-595c1a74214288cf8d47eda3bbc75afe</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794882</data>
    </node>
    <node id="Heap">
      <data key="d0">Heap</data>
      <data key="d1">concept</data>
      <data key="d2">The heap is a memory region used for dynamic memory allocation during runtime, managed via functions like malloc and free.</data>
      <data key="d3">chunk-595c1a74214288cf8d47eda3bbc75afe</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794882</data>
    </node>
    <node id="Stack">
      <data key="d0">Stack</data>
      <data key="d1">concept</data>
      <data key="d2">The stack is a memory region used to manage function calls, growing downward from the highest address in user space.</data>
      <data key="d3">chunk-595c1a74214288cf8d47eda3bbc75afe</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794882</data>
    </node>
    <node id="Malloc Function">
      <data key="d0">Malloc Function</data>
      <data key="d1">method</data>
      <data key="d2">The malloc function is a standard C library function used to dynamically allocate memory on the heap.</data>
      <data key="d3">chunk-595c1a74214288cf8d47eda3bbc75afe</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794882</data>
    </node>
    <node id="Free Function">
      <data key="d0">Free Function</data>
      <data key="d1">method</data>
      <data key="d2">The free function is a standard C library function used to de-allocate memory previously allocated with malloc.</data>
      <data key="d3">chunk-595c1a74214288cf8d47eda3bbc75afe</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761794884</data>
    </node>
    <edge source="Memory Management" target="Operating System">
      <data key="d6">1.0</data>
      <data key="d7">The Operating System is responsible for managing memory through allocation, recovery, and protection.</data>
      <data key="d8">core function,system responsibility</data>
      <data key="d9">chunk-c6de281f0215ff49a87e3727a7c2bb2a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794379</data>
    </edge>
    <edge source="Memory Management" target="Main Memory">
      <data key="d6">1.0</data>
      <data key="d7">Memory Management controls how main memory is allocated and used by processes.</data>
      <data key="d8">dynamic allocation,physical resource management</data>
      <data key="d9">chunk-c6de281f0215ff49a87e3727a7c2bb2a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794379</data>
    </edge>
    <edge source="Memory Management" target="Program and Data">
      <data key="d6">1.0</data>
      <data key="d7">Memory Management ensures that programs and data are stored and accessed efficiently in main memory.</data>
      <data key="d8">memory access,storage requirement</data>
      <data key="d9">chunk-c6de281f0215ff49a87e3727a7c2bb2a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794380</data>
    </edge>
    <edge source="Memory Management" target="Virtual Storage Technology">
      <data key="d6">1.0</data>
      <data key="d7">Virtual Storage Technology allows memory management to expand system memory logically beyond physical limits.</data>
      <data key="d8">logical expansion,memory simulation</data>
      <data key="d9">chunk-c6de281f0215ff49a87e3727a7c2bb2a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794380</data>
    </edge>
    <edge source="Memory Management" target="Logical Address">
      <data key="d6">1.0</data>
      <data key="d7">Memory Management translates logical addresses used by programs into physical addresses for memory access.</data>
      <data key="d8">address translation,mapping</data>
      <data key="d9">chunk-c6de281f0215ff49a87e3727a7c2bb2a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794380</data>
    </edge>
    <edge source="Memory Management" target="Physical Address">
      <data key="d6">1.0</data>
      <data key="d7">Memory Management maps logical addresses to physical addresses in main memory.</data>
      <data key="d8">address resolution,memory placement</data>
      <data key="d9">chunk-c6de281f0215ff49a87e3727a7c2bb2a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794381</data>
    </edge>
    <edge source="Memory Management" target="Memory Space Allocation">
      <data key="d6">1.0</data>
      <data key="d7">Memory Management assigns memory space to active processes during runtime.</data>
      <data key="d8">memory distribution,process execution</data>
      <data key="d9">chunk-c6de281f0215ff49a87e3727a7c2bb2a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794381</data>
    </edge>
    <edge source="Memory Management" target="Memory Space Recovery">
      <data key="d6">1.0</data>
      <data key="d7">Memory Management recovers memory space after a process ends to free it for other uses.</data>
      <data key="d8">process termination,resource reclaim</data>
      <data key="d9">chunk-c6de281f0215ff49a87e3727a7c2bb2a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794381</data>
    </edge>
    <edge source="Memory Management" target="Memory Sharing">
      <data key="d6">1.0</data>
      <data key="d7">Memory Management enables controlled access to shared memory regions by multiple processes.</data>
      <data key="d8">coordination,multi-process access</data>
      <data key="d9">chunk-c6de281f0215ff49a87e3727a7c2bb2a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794382</data>
    </edge>
    <edge source="Memory Management" target="Storage Protection">
      <data key="d6">1.0</data>
      <data key="d7">Memory Management ensures that processes are isolated and cannot interfere with each other’s memory space.</data>
      <data key="d8">isolation,security</data>
      <data key="d9">chunk-c6de281f0215ff49a87e3727a7c2bb2a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794382</data>
    </edge>
    <edge source="Operating System" target="Multi-Programming">
      <data key="d6">1.0</data>
      <data key="d7">The Operating System enables multi-programming by managing memory allocation between multiple processes.</data>
      <data key="d8">concurrent execution,resource management</data>
      <data key="d9">chunk-c6de281f0215ff49a87e3727a7c2bb2a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794380</data>
    </edge>
    <edge source="Operating System" target="Memory-Mapped Files">
      <data key="d6">1.0</data>
      <data key="d7">The operating system manages the mapping, loading, and persistence of memory-mapped files.</data>
      <data key="d8">file I/O handling,resource management</data>
      <data key="d9">chunk-5a8929ecef7cbf8892a009420c53322d</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794443</data>
    </edge>
    <edge source="Operating System" target="Page Table">
      <data key="d6">1.0</data>
      <data key="d7">The operating system maintains the page table, which is essential for mapping logical addresses to physical ones.</data>
      <data key="d8">data management,memory mapping</data>
      <data key="d9">chunk-c8697590fab35afe994351ccfc05bbac</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794709</data>
    </edge>
    <edge source="Operating System" target="Process">
      <data key="d6">1.0</data>
      <data key="d7">The operating system manages memory for each process, ensuring logical addresses are correctly resolved.</data>
      <data key="d8">memory management,protection</data>
      <data key="d9">chunk-c8697590fab35afe994351ccfc05bbac</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794709</data>
    </edge>
    <edge source="Operating System" target="Process Control Block">
      <data key="d6">1.0</data>
      <data key="d7">The operating system uses the process control block to control and manage processes in memory.</data>
      <data key="d8">managed by,system control</data>
      <data key="d9">chunk-595c1a74214288cf8d47eda3bbc75afe</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794885</data>
    </edge>
    <edge source="Main Memory" target="Physical Address">
      <data key="d6">1.0</data>
      <data key="d7">Physical addresses refer to locations in main memory where data and instructions are physically stored.</data>
      <data key="d8">data storage,memory mapping</data>
      <data key="d9">chunk-c8697590fab35afe994351ccfc05bbac</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794709</data>
    </edge>
    <edge source="Logical Address" target="Page Number">
      <data key="d6">1.0</data>
      <data key="d7">A logical address is decomposed into a page number and a page offset during address translation.</data>
      <data key="d8">address decomposition,structure</data>
      <data key="d9">chunk-46462724e0de563d009072de78fa1d68</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794644</data>
    </edge>
    <edge source="Logical Address" target="Page Offset">
      <data key="d6">1.0</data>
      <data key="d7">A logical address is split into a page number and a page offset to locate the required data within the page.</data>
      <data key="d8">address decomposition,structure</data>
      <data key="d9">chunk-46462724e0de563d009072de78fa1d68</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794645</data>
    </edge>
    <edge source="Logical Address" target="Virtual Address Space">
      <data key="d6">1.0</data>
      <data key="d7">The logical address space is built by combining individual target modules into a unified virtual address space starting from zero.</data>
      <data key="d8">address space composition,logical organization</data>
      <data key="d9">chunk-c8697590fab35afe994351ccfc05bbac</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794709</data>
    </edge>
    <edge source="Logical Address" target="Process">
      <data key="d6">1.0</data>
      <data key="d7">Processes use logical addresses during execution to access memory, with the system handling address translation.</data>
      <data key="d8">execution context,memory access</data>
      <data key="d9">chunk-c8697590fab35afe994351ccfc05bbac</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794710</data>
    </edge>
    <edge source="Logical Address" target="Page Table">
      <data key="d6">1.0</data>
      <data key="d7">Logical addresses are mapped to physical addresses via the page table managed by the operating system.</data>
      <data key="d8">mapping relationship,memory translation</data>
      <data key="d9">chunk-c8697590fab35afe994351ccfc05bbac</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794710</data>
    </edge>
    <edge source="Physical Address" target="Physical Block Number">
      <data key="d6">2.0</data>
      <data key="d7">A physical address is created by combining the physical block number and the page offset.&lt;SEP&gt;The Physical Address is formed by combining the Physical Block Number with the page offset.</data>
      <data key="d8">address generation,component,composition,concatenation</data>
      <data key="d9">chunk-28a7b83e6af7f15e967e78c26eccf799&lt;SEP&gt;chunk-46462724e0de563d009072de78fa1d68</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794684</data>
    </edge>
    <edge source="Physical Address" target="Address Translation Mechanism">
      <data key="d6">1.0</data>
      <data key="d7">The final output of the Address Translation Mechanism is the Physical Address used for memory access.</data>
      <data key="d8">final result,output</data>
      <data key="d9">chunk-28a7b83e6af7f15e967e78c26eccf799</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794685</data>
    </edge>
    <edge source="Memory Sharing" target="Read-Only Regions">
      <data key="d6">1.0</data>
      <data key="d7">Memory sharing is applicable only to read-only memory regions to prevent unintended modifications.</data>
      <data key="d8">data sharing,memory access control</data>
      <data key="d9">chunk-00b255b459e05b4695b33c9dceed4321</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794858</data>
    </edge>
    <edge source="页面置换算法" target="最佳置换算法">
      <data key="d6">1.0</data>
      <data key="d7">The Optimal (OPT) page replacement algorithm is a variant of the page replacement algorithm designed as a theoretical benchmark for minimum page fault rate.</data>
      <data key="d8">algorithm variant,theoretical benchmark</data>
      <data key="d9">chunk-e9724523b61c71a64ad927ea59b8337a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794396</data>
    </edge>
    <edge source="页面置换算法" target="先进先出置换算法">
      <data key="d6">1.0</data>
      <data key="d7">The First-In-First-Out (FIFO) algorithm is a common implementation method of the page replacement algorithm.</data>
      <data key="d8">algorithm variant,implementation method</data>
      <data key="d9">chunk-e9724523b61c71a64ad927ea59b8337a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794396</data>
    </edge>
    <edge source="页面置换算法" target="最近最久未使用置换算法">
      <data key="d6">1.0</data>
      <data key="d7">The Least Recently Used (LRU) algorithm is a performance-optimized variant of the page replacement algorithm.</data>
      <data key="d8">algorithm variant,performance-driven</data>
      <data key="d9">chunk-e9724523b61c71a64ad927ea59b8337a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794397</data>
    </edge>
    <edge source="页面置换算法" target="时钟置换算法">
      <data key="d6">1.0</data>
      <data key="d7">The Clock algorithm is a practical approximation of the LRU algorithm used to reduce hardware complexity.</data>
      <data key="d8">algorithm variant,practical approximation</data>
      <data key="d9">chunk-e9724523b61c71a64ad927ea59b8337a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794397</data>
    </edge>
    <edge source="页面置换算法" target="访问位">
      <data key="d6">1.0</data>
      <data key="d7">The access bit is used in various page replacement algorithms to track whether a page has been recently accessed.</data>
      <data key="d8">data support,usage tracking</data>
      <data key="d9">chunk-e9724523b61c71a64ad927ea59b8337a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794398</data>
    </edge>
    <edge source="页面置换算法" target="缺页率">
      <data key="d6">1.0</data>
      <data key="d7">A good页面置换算法can minimize缺页率by making optimal replacement decisions.</data>
      <data key="d8">algorithm efficiency,influencing factor</data>
      <data key="d9">chunk-dd63fcc97211dcfcfa94d11eff1be6f8</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794762</data>
    </edge>
    <edge source="最佳置换算法" target="缺页率">
      <data key="d6">1.0</data>
      <data key="d7">The optimal page replacement algorithm is designed to achieve the lowest possible page fault rate.</data>
      <data key="d8">optimization goal,performance metric</data>
      <data key="d9">chunk-e9724523b61c71a64ad927ea59b8337a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794396</data>
    </edge>
    <edge source="先进先出置换算法" target="Belady异常">
      <data key="d6">1.0</data>
      <data key="d7">Belady’s anomaly is a performance limitation specific to the FIFO page replacement algorithm.</data>
      <data key="d8">algorithm limitation,performance anomaly</data>
      <data key="d9">chunk-e9724523b61c71a64ad927ea59b8337a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794397</data>
    </edge>
    <edge source="先进先出置换算法" target="物理块">
      <data key="d6">1.0</data>
      <data key="d7">The number of physical blocks affects the performance of the FIFO algorithm, including the occurrence of Belady’s anomaly.</data>
      <data key="d8">impact on performance,resource constraint</data>
      <data key="d9">chunk-e9724523b61c71a64ad927ea59b8337a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794397</data>
    </edge>
    <edge source="最近最久未使用置换算法" target="硬件支持">
      <data key="d6">1.0</data>
      <data key="d7">The LRU algorithm requires hardware support like registers and stacks, increasing its implementation cost.</data>
      <data key="d8">implementation requirement,performance cost</data>
      <data key="d9">chunk-e9724523b61c71a64ad927ea59b8337a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794397</data>
    </edge>
    <edge source="时钟置换算法" target="改进型时钟置换算法">
      <data key="d6">1.0</data>
      <data key="d7">The Enhanced Clock algorithm is an improved version of the basic Clock algorithm that incorporates both access and modify bits for better decisions.</data>
      <data key="d8">algorithm enhancement,enhanced version</data>
      <data key="d9">chunk-e9724523b61c71a64ad927ea59b8337a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794398</data>
    </edge>
    <edge source="改进型时钟置换算法" target="修改位">
      <data key="d6">1.0</data>
      <data key="d7">The modify bit is used in the Enhanced Clock algorithm to evaluate replacement cost during page eviction.</data>
      <data key="d8">data field,replacement decision</data>
      <data key="d9">chunk-e9724523b61c71a64ad927ea59b8337a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794398</data>
    </edge>
    <edge source="改进型时钟置换算法" target="1类页面">
      <data key="d6">1.0</data>
      <data key="d7">The Enhanced Clock algorithm prioritizes 1-class pages for eviction because they are least likely to be needed again and have not been modified.</data>
      <data key="d8">best candidate,eviction priority</data>
      <data key="d9">chunk-e9724523b61c71a64ad927ea59b8337a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794398</data>
    </edge>
    <edge source="改进型时钟置换算法" target="2类页面">
      <data key="d6">1.0</data>
      <data key="d7">The Enhanced Clock algorithm considers 2-class pages as the next best eviction candidates after 1-class pages.</data>
      <data key="d8">eviction priority,second best</data>
      <data key="d9">chunk-e9724523b61c71a64ad927ea59b8337a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794399</data>
    </edge>
    <edge source="改进型时钟置换算法" target="3类页面">
      <data key="d6">1.0</data>
      <data key="d7">The Enhanced Clock algorithm avoids evicting 3-class pages during a round and may retain them for another cycle.</data>
      <data key="d8">eviction priority,keep consideration</data>
      <data key="d9">chunk-e9724523b61c71a64ad927ea59b8337a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794399</data>
    </edge>
    <edge source="改进型时钟置换算法" target="4类页面">
      <data key="d6">1.0</data>
      <data key="d7">The Enhanced Clock algorithm avoids evicting 4-class pages, as they are recently accessed and modified, indicating high potential for reuse.</data>
      <data key="d8">avoid eviction,eviction priority</data>
      <data key="d9">chunk-e9724523b61c71a64ad927ea59b8337a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794399</data>
    </edge>
    <edge source="缺页率" target="页面大小">
      <data key="d6">1.0</data>
      <data key="d7">页面大小affects缺页率, with larger pages leading to lower缺页率due to better locality.</data>
      <data key="d8">influencing factor,memory management</data>
      <data key="d9">chunk-dd63fcc97211dcfcfa94d11eff1be6f8</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794761</data>
    </edge>
    <edge source="缺页率" target="物理块数">
      <data key="d6">1.0</data>
      <data key="d7">增加分配给进程的物理块数reduces缺页率by providing more room for active pages.</data>
      <data key="d8">influencing factor,memory allocation</data>
      <data key="d9">chunk-dd63fcc97211dcfcfa94d11eff1be6f8</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794762</data>
    </edge>
    <edge source="缺页率" target="程序编制方法">
      <data key="d6">1.0</data>
      <data key="d7">The locality of program code and data directly impacts缺页率, with higher locality reducing faults.</data>
      <data key="d8">influencing factor,programming locality</data>
      <data key="d9">chunk-dd63fcc97211dcfcfa94d11eff1be6f8</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794763</data>
    </edge>
    <edge source="缺页率" target="局部性原理">
      <data key="d6">1.0</data>
      <data key="d7">局部性原理underpins the relationship between program behavior and缺页率, explaining why access patterns affect memory efficiency.</data>
      <data key="d8">performance relationship,theoretical foundation</data>
      <data key="d9">chunk-dd63fcc97211dcfcfa94d11eff1be6f8</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794763</data>
    </edge>
    <edge source="物理块" target="段页式存储管理">
      <data key="d6">1.0</data>
      <data key="d7">内存被划分为与页面大小相同的物理块，分配以物理块为单位。</data>
      <data key="d8">memory allocation,physical unit</data>
      <data key="d9">chunk-c195ab08b96907e43c39705a88501db8</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794513</data>
    </edge>
    <edge source="物理块" target="抖动">
      <data key="d6">1.0</data>
      <data key="d7">Insufficient physical blocks allocated to a process causes抖动, as it leads to constant page swapping.</data>
      <data key="d8">memory allocation,system performance</data>
      <data key="d9">chunk-67ae509cb7f3a2cdf2694e125b8725c3</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794796</data>
    </edge>
    <edge source="Memory-Mapped Files" target="System Call">
      <data key="d6">1.0</data>
      <data key="d7">Memory-Mapped Files is implemented via a system call provided by the operating system.</data>
      <data key="d8">abstraction,operating system interface</data>
      <data key="d9">chunk-5a8929ecef7cbf8892a009420c53322d</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794442</data>
    </edge>
    <edge source="Memory-Mapped Files" target="Disk File">
      <data key="d6">1.0</data>
      <data key="d7">Memory-Mapped Files establish a mapping between a disk file and a process’s virtual address space for efficient data access.</data>
      <data key="d8">data access,file mapping</data>
      <data key="d9">chunk-5a8929ecef7cbf8892a009420c53322d</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794443</data>
    </edge>
    <edge source="Memory-Mapped Files" target="Process Virtual Address Space">
      <data key="d6">1.0</data>
      <data key="d7">Memory-Mapped Files map a disk file into a process’s virtual address space.</data>
      <data key="d8">memory mapping,virtual addressing</data>
      <data key="d9">chunk-5a8929ecef7cbf8892a009420c53322d</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794443</data>
    </edge>
    <edge source="Memory-Mapped Files" target="Page">
      <data key="d6">1.0</data>
      <data key="d7">Only when a page is accessed is it loaded from disk into memory, enabling lazy loading.</data>
      <data key="d8">on-demand loading,page-wise loading</data>
      <data key="d9">chunk-5a8929ecef7cbf8892a009420c53322d</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794444</data>
    </edge>
    <edge source="Memory-Mapped Files" target="File Content">
      <data key="d6">1.0</data>
      <data key="d7">File content is accessed as if it were memory, with read/write operations appearing to be direct memory access.</data>
      <data key="d8">memory-like operations,transparent access</data>
      <data key="d9">chunk-5a8929ecef7cbf8892a009420c53322d</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794444</data>
    </edge>
    <edge source="Memory-Mapped Files" target="Multiple Processes">
      <data key="d6">1.0</data>
      <data key="d7">Multiple processes can share the same memory-mapped file, enabling data sharing and coordination.</data>
      <data key="d8">inter-process communication,shared access</data>
      <data key="d9">chunk-5a8929ecef7cbf8892a009420c53322d</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794444</data>
    </edge>
    <edge source="Memory-Mapped Files" target="Shared Memory">
      <data key="d6">1.0</data>
      <data key="d7">Memory-Mapped Files facilitate shared memory across processes, allowing them to access and modify the same data.</data>
      <data key="d8">data sharing,memory efficiency</data>
      <data key="d9">chunk-5a8929ecef7cbf8892a009420c53322d</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794444</data>
    </edge>
    <edge source="Memory-Mapped Files" target="Performance Optimization">
      <data key="d6">1.0</data>
      <data key="d7">Memory-Mapped Files improve performance by reducing the need for explicit read/write system calls and enabling lazy loading.</data>
      <data key="d8">efficiency,reduced I/O overhead</data>
      <data key="d9">chunk-5a8929ecef7cbf8892a009420c53322d</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794445</data>
    </edge>
    <edge source="Memory-Mapped Files" target="Virtual Memory">
      <data key="d6">1.0</data>
      <data key="d7">Memory-Mapped Files share conceptual similarities with virtual memory by using address space abstraction and paging.</data>
      <data key="d8">address space management,similar abstraction</data>
      <data key="d9">chunk-5a8929ecef7cbf8892a009420c53322d</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794445</data>
    </edge>
    <edge source="Virtual Memory" target="Demand Paging">
      <data key="d6">1.0</data>
      <data key="d7">Demand paging is a fundamental component of virtual memory systems, enabling efficient memory usage.</data>
      <data key="d8">core technique,memory extension</data>
      <data key="d9">chunk-abb4ec292dd5335d76c0413487939cbe</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794661</data>
    </edge>
    <edge source="Virtual Memory" target="Request Paging System">
      <data key="d6">1.0</data>
      <data key="d7">The Request Paging System supports the functionality of virtual memory by providing demand paging and page replacement.</data>
      <data key="d8">enabling technology,functional integration</data>
      <data key="d9">chunk-28a7b83e6af7f15e967e78c26eccf799</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794682</data>
    </edge>
    <edge source="Page" target="Page Size">
      <data key="d6">1.0</data>
      <data key="d7">The size of a page is fixed and must be a power of 2, defining its boundaries within the logical address space.</data>
      <data key="d8">boundary definition,size specification</data>
      <data key="d9">chunk-46462724e0de563d009072de78fa1d68</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794642</data>
    </edge>
    <edge source="Page" target="Logical Address Space">
      <data key="d6">1.0</data>
      <data key="d7">The logical address space is divided into pages of equal size, each assigned a page number.</data>
      <data key="d8">logical division,page assignment</data>
      <data key="d9">chunk-46462724e0de563d009072de78fa1d68</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794643</data>
    </edge>
    <edge source="Page" target="Basic Page Storage Management">
      <data key="d6">1.0</data>
      <data key="d7">Basic page storage management logically divides a process's address space into pages for memory management.</data>
      <data key="d8">logical organization,memory division</data>
      <data key="d9">chunk-46462724e0de563d009072de78fa1d68</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794644</data>
    </edge>
    <edge source="动态分区分配" target="外部碎片">
      <data key="d6">1.0</data>
      <data key="d7">Dynamic partition allocation leads to the formation of external fragmentation over time due to frequent memory allocation and deallocation.</data>
      <data key="d8">allocation inefficiency,memory fragmentation</data>
      <data key="d9">chunk-f59ab8ff80e1533c966b7cb6b20563dc</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794477</data>
    </edge>
    <edge source="动态分区分配" target="紧凑技术">
      <data key="d6">1.0</data>
      <data key="d7">Compact technology is used to resolve external fragmentation in dynamic partition allocation by rearranging memory contents.</data>
      <data key="d8">fragmentation resolution,memory management</data>
      <data key="d9">chunk-f59ab8ff80e1533c966b7cb6b20563dc</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794478</data>
    </edge>
    <edge source="动态分区分配" target="空闲分区链">
      <data key="d6">1.0</data>
      <data key="d7">The free partition chain is a key data structure used in dynamic partition allocation for tracking available memory blocks.</data>
      <data key="d8">allocation tracking,data structure</data>
      <data key="d9">chunk-f59ab8ff80e1533c966b7cb6b20563dc</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794479</data>
    </edge>
    <edge source="动态分区分配" target="存储管理方式">
      <data key="d6">1.0</data>
      <data key="d7">存储管理方式developed into动态分区分配to better handle variable-sized programs.</data>
      <data key="d8">adaptive method,evolutionary progression</data>
      <data key="d9">chunk-fa7ddc38beb083a10e073654dee57a19</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794762</data>
    </edge>
    <edge source="外部碎片" target="内存利用率">
      <data key="d6">1.0</data>
      <data key="d7">External fragmentation negatively affects memory utilization by creating small, unusable memory blocks.</data>
      <data key="d8">performance impact,resource efficiency</data>
      <data key="d9">chunk-f59ab8ff80e1533c966b7cb6b20563dc</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794478</data>
    </edge>
    <edge source="空闲分区链" target="首次适应算法">
      <data key="d6">1.0</data>
      <data key="d7">First Fit algorithm searches the free partition chain in order of ascending address to find the first suitable partition.</data>
      <data key="d8">allocation strategy,search method</data>
      <data key="d9">chunk-f59ab8ff80e1533c966b7cb6b20563dc</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794477</data>
    </edge>
    <edge source="空闲分区链" target="最佳适应算法">
      <data key="d6">1.0</data>
      <data key="d7">Best Fit algorithm selects the smallest partition that fits the request from the free partition chain sorted by size.</data>
      <data key="d8">allocation strategy,size-based selection</data>
      <data key="d9">chunk-f59ab8ff80e1533c966b7cb6b20563dc</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794478</data>
    </edge>
    <edge source="空闲分区链" target="最坏适应算法">
      <data key="d6">1.0</data>
      <data key="d7">Worst Fit algorithm selects the largest available partition from the free partition chain ordered by size.</data>
      <data key="d8">allocation strategy,largest fit</data>
      <data key="d9">chunk-f59ab8ff80e1533c966b7cb6b20563dc</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794478</data>
    </edge>
    <edge source="空闲分区链" target="快速适应算法">
      <data key="d6">1.0</data>
      <data key="d7">Fast Fit algorithm organizes free partitions by common size classes, each with its own free partition chain for faster allocation.</data>
      <data key="d8">allocation strategy,size classification</data>
      <data key="d9">chunk-f59ab8ff80e1533c966b7cb6b20563dc</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794479</data>
    </edge>
    <edge source="首次适应算法" target="邻近适应算法">
      <data key="d6">1.0</data>
      <data key="d7">Next Fit is a variant of First Fit that continues the search from the last position, improving search efficiency.</data>
      <data key="d8">algorithm variant,search continuation</data>
      <data key="d9">chunk-f59ab8ff80e1533c966b7cb6b20563dc</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794478</data>
    </edge>
    <edge source="快速适应算法" target="伙伴系统">
      <data key="d6">1.0</data>
      <data key="d7">Fast Fit and the buddy system are both allocation methods that organize free partitions by size, though Fast Fit uses multiple chains while the buddy system enforces power-of-two sizes.</data>
      <data key="d8">classification,memory allocation method</data>
      <data key="d9">chunk-f59ab8ff80e1533c966b7cb6b20563dc</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794477</data>
    </edge>
    <edge source="哈希算法" target="空闲分区链表">
      <data key="d6">1.0</data>
      <data key="d7">Hash algorithm uses a hash table based on partition size to quickly locate the head of a corresponding free partition chain.</data>
      <data key="d8">data structure,fast lookup</data>
      <data key="d9">chunk-f59ab8ff80e1533c966b7cb6b20563dc</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794478</data>
    </edge>
    <edge source="段页式存储管理" target="分页存储管理">
      <data key="d6">1.0</data>
      <data key="d7">段页式存储管理结合了分页存储管理的物理内存分配方式。</data>
      <data key="d8">combined method,integration</data>
      <data key="d9">chunk-c195ab08b96907e43c39705a88501db8</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794511</data>
    </edge>
    <edge source="段页式存储管理" target="分段存储管理">
      <data key="d6">1.0</data>
      <data key="d7">段页式存储管理结合了分段存储管理的逻辑段划分方式。</data>
      <data key="d8">combined method,integration</data>
      <data key="d9">chunk-c195ab08b96907e43c39705a88501db8</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794511</data>
    </edge>
    <edge source="段页式存储管理" target="逻辑段">
      <data key="d6">1.0</data>
      <data key="d7">段页式存储管理中，进程的地址空间首先划分为多个逻辑段。</data>
      <data key="d8">address structure,segmentation</data>
      <data key="d9">chunk-c195ab08b96907e43c39705a88501db8</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794512</data>
    </edge>
    <edge source="段页式存储管理" target="页面">
      <data key="d6">1.0</data>
      <data key="d7">每个逻辑段进一步被划分为若干固定大小的页面。</data>
      <data key="d8">address structure,paging</data>
      <data key="d9">chunk-c195ab08b96907e43c39705a88501db8</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794512</data>
    </edge>
    <edge source="段页式存储管理" target="二维地址空间">
      <data key="d6">1.0</data>
      <data key="d7">段页式存储管理支持二维地址空间，由段和页构成。</data>
      <data key="d8">address model,structural</data>
      <data key="d9">chunk-c195ab08b96907e43c39705a88501db8</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794513</data>
    </edge>
    <edge source="分段存储管理" target="存储管理方式">
      <data key="d6">1.0</data>
      <data key="d7">分段存储管理is a specialized form of存储管理方式designed to meet user-level programming and access needs.</data>
      <data key="d8">method specialization,user requirement alignment</data>
      <data key="d9">chunk-fa7ddc38beb083a10e073654dee57a19</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794763</data>
    </edge>
    <edge source="段表" target="页表">
      <data key="d6">1.0</data>
      <data key="d7">每个段对应一张页表，段表中记录页表的起始地址。</data>
      <data key="d8">data structure dependency</data>
      <data key="d9">chunk-c195ab08b96907e43c39705a88501db8</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794511</data>
    </edge>
    <edge source="段表" target="段表寄存器">
      <data key="d6">2.0</data>
      <data key="d7">段表寄存器存储段表的起始地址，用于初始化段表查找。&lt;SEP&gt;段表寄存器存储段表的始址F和长度M，供地址变换机构使用。</data>
      <data key="d8">hardware support,register-reference,storage,system register</data>
      <data key="d9">chunk-14a72f660cb4c5e34ac9c9ddaed64956&lt;SEP&gt;chunk-c195ab08b96907e43c39705a88501db8</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794864</data>
    </edge>
    <edge source="段表" target="地址变换">
      <data key="d6">1.0</data>
      <data key="d7">地址变换过程首先通过段表查找页表的起始地址。</data>
      <data key="d8">address translation,lookup</data>
      <data key="d9">chunk-c195ab08b96907e43c39705a88501db8</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794512</data>
    </edge>
    <edge source="段表" target="地址变换机构">
      <data key="d6">1.0</data>
      <data key="d7">地址变换机构通过段表实现从逻辑地址到物理地址的转换。</data>
      <data key="d8">address translation,mapping mechanism</data>
      <data key="d9">chunk-14a72f660cb4c5e34ac9c9ddaed64956</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794865</data>
    </edge>
    <edge source="页表" target="地址变换">
      <data key="d6">1.0</data>
      <data key="d7">地址变换过程通过页表查找物理块号。</data>
      <data key="d8">address translation,lookup</data>
      <data key="d9">chunk-c195ab08b96907e43c39705a88501db8</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794513</data>
    </edge>
    <edge source="物理地址" target="地址变换">
      <data key="d6">1.0</data>
      <data key="d7">地址变换最终生成物理地址，用于内存访问。</data>
      <data key="d8">final address,result</data>
      <data key="d9">chunk-c195ab08b96907e43c39705a88501db8</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794513</data>
    </edge>
    <edge source="物理地址" target="逻辑地址">
      <data key="d6">1.0</data>
      <data key="d7">Logical addresses are translated into physical addresses via the address transformation mechanism.</data>
      <data key="d8">address mapping,translation</data>
      <data key="d9">chunk-00e431215b94639001c5095d3c4f8b1c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794568</data>
    </edge>
    <edge source="物理地址" target="地址变换机构">
      <data key="d6">1.0</data>
      <data key="d7">物理地址E通过计算b + W得出，用于访问内存。</data>
      <data key="d8">address calculation,translation output</data>
      <data key="d9">chunk-14a72f660cb4c5e34ac9c9ddaed64956</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794866</data>
    </edge>
    <edge source="逻辑地址" target="段号">
      <data key="d6">1.0</data>
      <data key="d7">逻辑地址包含段号，用于定位进程的逻辑段。</data>
      <data key="d8">address component,segmentation</data>
      <data key="d9">chunk-c195ab08b96907e43c39705a88501db8</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794511</data>
    </edge>
    <edge source="逻辑地址" target="页号">
      <data key="d6">1.0</data>
      <data key="d7">逻辑地址包含页号，用于定位段中的页面。</data>
      <data key="d8">address component,paging</data>
      <data key="d9">chunk-c195ab08b96907e43c39705a88501db8</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794512</data>
    </edge>
    <edge source="逻辑地址" target="页内偏移量">
      <data key="d6">1.0</data>
      <data key="d7">逻辑地址包含页内偏移量，用于定位页面内的具体位置。</data>
      <data key="d8">address component,offset</data>
      <data key="d9">chunk-c195ab08b96907e43c39705a88501db8</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794513</data>
    </edge>
    <edge source="逻辑地址" target="实际内存地址">
      <data key="d6">1.0</data>
      <data key="d7">Logical addresses are converted to actual memory addresses during loading or execution to enable correct program execution.</data>
      <data key="d8">address translation,memory mapping</data>
      <data key="d9">chunk-c09d18569a1b1c90198e18b0108e8c32</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794526</data>
    </edge>
    <edge source="逻辑地址" target="页表机制">
      <data key="d6">1.0</data>
      <data key="d7">The page table mechanism maps logical addresses to physical addresses in page-based systems.</data>
      <data key="d8">memory mapping,translation</data>
      <data key="d9">chunk-00e431215b94639001c5095d3c4f8b1c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794569</data>
    </edge>
    <edge source="逻辑地址" target="段表机制">
      <data key="d6">1.0</data>
      <data key="d7">The segment table mechanism maps logical segment addresses to physical memory.</data>
      <data key="d8">memory mapping,translation</data>
      <data key="d9">chunk-00e431215b94639001c5095d3c4f8b1c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794570</data>
    </edge>
    <edge source="程序的链接与装入" target="创建进程">
      <data key="d6">1.0</data>
      <data key="d7">Creating a process requires the steps of linking and loading to prepare a user program for execution in memory.</data>
      <data key="d8">process initiation,program preparation</data>
      <data key="d9">chunk-c09d18569a1b1c90198e18b0108e8c32</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794525</data>
    </edge>
    <edge source="用户源程序" target="编译">
      <data key="d6">1.0</data>
      <data key="d7">The user source program is processed by the compilation method to generate object code (target modules).</data>
      <data key="d8">code processing,source transformation</data>
      <data key="d9">chunk-c09d18569a1b1c90198e18b0108e8c32</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794525</data>
    </edge>
    <edge source="目标模块" target="编译">
      <data key="d6">1.0</data>
      <data key="d7">Compilation produces multiple target modules as output from the source code.</data>
      <data key="d8">intermediate file creation,output generation</data>
      <data key="d9">chunk-c09d18569a1b1c90198e18b0108e8c32</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794526</data>
    </edge>
    <edge source="目标模块" target="链接">
      <data key="d6">1.0</data>
      <data key="d7">Linking combines target modules and their required library functions into a single load module.</data>
      <data key="d8">input assembly,module integration</data>
      <data key="d9">chunk-c09d18569a1b1c90198e18b0108e8c32</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794527</data>
    </edge>
    <edge source="装入模块" target="链接">
      <data key="d6">1.0</data>
      <data key="d7">Linking produces a complete load module ready for execution.</data>
      <data key="d8">executable formation,integration output</data>
      <data key="d9">chunk-c09d18569a1b1c90198e18b0108e8c32</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794525</data>
    </edge>
    <edge source="装入模块" target="装入">
      <data key="d6">1.0</data>
      <data key="d7">The load module is moved into memory using the loading method for execution.</data>
      <data key="d8">execution preparation,memory loading</data>
      <data key="d9">chunk-c09d18569a1b1c90198e18b0108e8c32</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794525</data>
    </edge>
    <edge source="绝对装入" target="可重定位装入">
      <data key="d6">1.0</data>
      <data key="d7">Absolute loading and relocatable loading are different approaches to memory placement, with the former used in single-program environments and the latter allowing dynamic displacement.</data>
      <data key="d8">memory loading method comparison</data>
      <data key="d9">chunk-c09d18569a1b1c90198e18b0108e8c32</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794525</data>
    </edge>
    <edge source="可重定位装入" target="重定位">
      <data key="d6">1.0</data>
      <data key="d7">In relocatable loading, relocation is performed during the loading phase to convert logical addresses into physical addresses.</data>
      <data key="d8">address adjustment,loading phase</data>
      <data key="d9">chunk-c09d18569a1b1c90198e18b0108e8c32</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794526</data>
    </edge>
    <edge source="动态运行时装入" target="重定位">
      <data key="d6">1.0</data>
      <data key="d7">Dynamic runtime loading uses relocation during execution, enabled by the use of a relocation register.</data>
      <data key="d8">dynamic relocation support,runtime address conversion</data>
      <data key="d9">chunk-c09d18569a1b1c90198e18b0108e8c32</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794525</data>
    </edge>
    <edge source="动态运行时装入" target="重定位寄存器">
      <data key="d6">1.0</data>
      <data key="d7">Dynamic runtime loading requires a relocation register to store the base address of the loaded module.</data>
      <data key="d8">dynamic relocation,hardware support</data>
      <data key="d9">chunk-c09d18569a1b1c90198e18b0108e8c32</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794526</data>
    </edge>
    <edge source="动态运行时装入" target="不连续的存储区">
      <data key="d6">1.0</data>
      <data key="d7">Dynamic runtime loading supports placing programs in non-contiguous memory regions.</data>
      <data key="d8">dynamic allocation,memory flexibility</data>
      <data key="d9">chunk-c09d18569a1b1c90198e18b0108e8c32</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794527</data>
    </edge>
    <edge source="动态运行时装入" target="程序段的共享">
      <data key="d6">1.0</data>
      <data key="d7">Dynamic runtime loading enables sharing of program segments among multiple processes, reducing memory usage.</data>
      <data key="d8">code sharing,memory efficiency</data>
      <data key="d9">chunk-c09d18569a1b1c90198e18b0108e8c32</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794527</data>
    </edge>
    <edge source="静态链接" target="装入时动态链接">
      <data key="d6">1.0</data>
      <data key="d7">Static linking occurs before execution, while loading-time dynamic linking allows more flexibility and shared code usage.</data>
      <data key="d8">flexibility,linking time comparison</data>
      <data key="d9">chunk-c09d18569a1b1c90198e18b0108e8c32</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794526</data>
    </edge>
    <edge source="装入时动态链接" target="运行时动态链接">
      <data key="d6">1.0</data>
      <data key="d7">Loading-time dynamic linking links modules during load, while runtime dynamic linking links only when needed, saving memory space.</data>
      <data key="d8">linking timing,memory efficiency</data>
      <data key="d9">chunk-c09d18569a1b1c90198e18b0108e8c32</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794527</data>
    </edge>
    <edge source="虚拟内存" target="局部性原理">
      <data key="d6">1.0</data>
      <data key="d7">Virtual memory relies on the principle of locality to efficiently manage memory usage.</data>
      <data key="d8">memory optimization,technical foundation</data>
      <data key="d9">chunk-00e431215b94639001c5095d3c4f8b1c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794567</data>
    </edge>
    <edge source="虚拟内存" target="内存-外存两级存储器结构">
      <data key="d6">1.0</data>
      <data key="d7">Virtual memory is implemented using a two-level storage system of main memory and secondary storage.</data>
      <data key="d8">architecture foundation,system design</data>
      <data key="d9">chunk-00e431215b94639001c5095d3c4f8b1c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794568</data>
    </edge>
    <edge source="虚拟内存" target="请求分页存储管理">
      <data key="d6">1.0</data>
      <data key="d7">Virtual memory is implemented using request paging, where pages are loaded on demand.</data>
      <data key="d8">implementation method,memory management</data>
      <data key="d9">chunk-00e431215b94639001c5095d3c4f8b1c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794568</data>
    </edge>
    <edge source="虚拟内存" target="请求分段存储管理">
      <data key="d6">1.0</data>
      <data key="d7">Virtual memory can be implemented using request segmentation, where segments are loaded as needed.</data>
      <data key="d8">implementation method,memory management</data>
      <data key="d9">chunk-00e431215b94639001c5095d3c4f8b1c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794570</data>
    </edge>
    <edge source="虚拟内存" target="请求段页式存储管理">
      <data key="d6">1.0</data>
      <data key="d7">Virtual memory uses a hybrid approach combining segmentation and paging, loading segments and pages on demand.</data>
      <data key="d8">implementation method,memory management</data>
      <data key="d9">chunk-00e431215b94639001c5095d3c4f8b1c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794570</data>
    </edge>
    <edge source="虚拟存储器" target="多次性">
      <data key="d6">1.0</data>
      <data key="d7">Virtual storage supports loading programs in multiple stages rather than all at once.</data>
      <data key="d8">feature,memory loading flexibility</data>
      <data key="d9">chunk-00e431215b94639001c5095d3c4f8b1c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794568</data>
    </edge>
    <edge source="虚拟存储器" target="对换性">
      <data key="d6">1.0</data>
      <data key="d7">Virtual storage allows temporary removal of inactive data from memory to secondary storage.</data>
      <data key="d8">feature,memory swapping</data>
      <data key="d9">chunk-00e431215b94639001c5095d3c4f8b1c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794568</data>
    </edge>
    <edge source="虚拟存储器" target="虚拟性">
      <data key="d6">1.0</data>
      <data key="d7">Virtual storage creates the illusion of a larger memory space than physically available.</data>
      <data key="d8">feature,logical memory expansion</data>
      <data key="d9">chunk-00e431215b94639001c5095d3c4f8b1c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794569</data>
    </edge>
    <edge source="请求分页存储管理" target="页表机制">
      <data key="d6">1.0</data>
      <data key="d7">Page table mechanisms are essential for tracking logical-to-physical page mappings in request paging.</data>
      <data key="d8">data structure support,memory mapping</data>
      <data key="d9">chunk-00e431215b94639001c5095d3c4f8b1c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794567</data>
    </edge>
    <edge source="请求分页存储管理" target="中断机构">
      <data key="d6">1.0</data>
      <data key="d7">The interrupt mechanism triggers when a required page is not in memory during execution in request paging.</data>
      <data key="d8">error handling,operation trigger</data>
      <data key="d9">chunk-00e431215b94639001c5095d3c4f8b1c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794568</data>
    </edge>
    <edge source="请求分段存储管理" target="段表机制">
      <data key="d6">1.0</data>
      <data key="d7">Segment tables are used to manage the mapping of logical segments to physical memory.</data>
      <data key="d8">data structure support,memory mapping</data>
      <data key="d9">chunk-00e431215b94639001c5095d3c4f8b1c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794567</data>
    </edge>
    <edge source="请求分段存储管理" target="中断机构">
      <data key="d6">1.0</data>
      <data key="d7">The interrupt mechanism signals the OS when a required segment is not present in memory.</data>
      <data key="d8">error handling,operation trigger</data>
      <data key="d9">chunk-00e431215b94639001c5095d3c4f8b1c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794568</data>
    </edge>
    <edge source="Page Buffering Algorithm" target="Free Page List">
      <data key="d6">1.0</data>
      <data key="d7">The Page Buffering Algorithm utilizes the Free Page List to hold unmodified pages temporarily without immediate disk I/O, improving efficiency.</data>
      <data key="d8">memory management,page reuse</data>
      <data key="d9">chunk-3c9d6c4c9f8b1850281a50533371f77d</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794566</data>
    </edge>
    <edge source="Page Buffering Algorithm" target="Modified Page List">
      <data key="d6">1.0</data>
      <data key="d7">The Page Buffering Algorithm uses the Modified Page List to delay writing modified pages to disk until a sufficient number are collected, reducing I/O overhead.</data>
      <data key="d8">delayed eviction,memory management</data>
      <data key="d9">chunk-3c9d6c4c9f8b1850281a50533371f77d</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794567</data>
    </edge>
    <edge source="Page Frame Recycling" target="Kswapd">
      <data key="d6">1.0</data>
      <data key="d7">Kswapd is the system process that performs page frame recycling when memory pressure is detected.</data>
      <data key="d8">memory management,system daemon</data>
      <data key="d9">chunk-3c9d6c4c9f8b1850281a50533371f77d</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794566</data>
    </edge>
    <edge source="Page Frame Recycling" target="User-Process Page Frames">
      <data key="d6">1.0</data>
      <data key="d7">Page Frame Recycling primarily targets user-process page frames, as they are safe to reclaim.</data>
      <data key="d8">memory reclamation,process-level</data>
      <data key="d9">chunk-3c9d6c4c9f8b1850281a50533371f77d</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794567</data>
    </edge>
    <edge source="Page Frame Recycling" target="Kernel-Used Page Frames">
      <data key="d6">1.0</data>
      <data key="d7">Kernel-used page frames are generally not eligible for recycling to ensure system stability.</data>
      <data key="d8">memory protection,non-reclaimable</data>
      <data key="d9">chunk-3c9d6c4c9f8b1850281a50533371f77d</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794568</data>
    </edge>
    <edge source="Kswapd" target="Memory Usage Threshold">
      <data key="d6">1.0</data>
      <data key="d7">Kswapd checks memory usage and activates page frame recycling when free pages fall below the Memory Usage Threshold.</data>
      <data key="d8">monitoring,trigger condition</data>
      <data key="d9">chunk-3c9d6c4c9f8b1850281a50533371f77d</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794567</data>
    </edge>
    <edge source="地址变换机构" target="段号S">
      <data key="d6">1.0</data>
      <data key="d7">段号S用于在地址变换过程中进行越界判断。</data>
      <data key="d8">boundary check,input parameter</data>
      <data key="d9">chunk-14a72f660cb4c5e34ac9c9ddaed64956</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794866</data>
    </edge>
    <edge source="地址变换机构" target="段内偏移量W">
      <data key="d6">1.0</data>
      <data key="d7">段内偏移量W用于在地址变换过程中与段长比较以判断是否越界。</data>
      <data key="d8">boundary check,input parameter</data>
      <data key="d9">chunk-14a72f660cb4c5e34ac9c9ddaed64956</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794867</data>
    </edge>
    <edge source="内存" target="外存">
      <data key="d6">1.0</data>
      <data key="d7">Memory and external storage form the hierarchical storage system used in virtual memory.</data>
      <data key="d8">secondary storage,storage hierarchy</data>
      <data key="d9">chunk-00e431215b94639001c5095d3c4f8b1c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794568</data>
    </edge>
    <edge source="外存" target="对换区">
      <data key="d6">1.0</data>
      <data key="d7">The swap area is a region on secondary storage used for storing inactive memory pages.</data>
      <data key="d8">storage location,swap space</data>
      <data key="d9">chunk-00e431215b94639001c5095d3c4f8b1c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794570</data>
    </edge>
    <edge source="Single Continuous Allocation" target="System Area">
      <data key="d6">1.0</data>
      <data key="d7">In single continuous allocation, the memory is partitioned into a system area for operating system use and a user area for user programs.</data>
      <data key="d8">memory partitioning</data>
      <data key="d9">chunk-2fa1a754b848fd3412be2058c0482b68</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794617</data>
    </edge>
    <edge source="Single Continuous Allocation" target="User Area">
      <data key="d6">1.0</data>
      <data key="d7">The user area is dedicated to a single user program, with the entire space being allocated to it.</data>
      <data key="d8">memory partitioning</data>
      <data key="d9">chunk-2fa1a754b848fd3412be2058c0482b68</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794617</data>
    </edge>
    <edge source="Single Continuous Allocation" target="User Program">
      <data key="d6">1.0</data>
      <data key="d7">The user program is the sole occupant of the user area, requiring exclusive and contiguous memory allocation.</data>
      <data key="d8">containment,resource allocation</data>
      <data key="d9">chunk-2fa1a754b848fd3412be2058c0482b68</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794618</data>
    </edge>
    <edge source="Single Continuous Allocation" target="Internal Fragmentation">
      <data key="d6">1.0</data>
      <data key="d7">Internal fragmentation occurs because the allocated memory block may be larger than the actual program size, resulting in unutilized space.</data>
      <data key="d8">memory inefficiency,side effect</data>
      <data key="d9">chunk-2fa1a754b848fd3412be2058c0482b68</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794618</data>
    </edge>
    <edge source="Single Continuous Allocation" target="Memory Utilization">
      <data key="d6">1.0</data>
      <data key="d7">Memory utilization is extremely low because only one program runs at a time, leaving the majority of memory unused.</data>
      <data key="d8">drawback,performance limitation</data>
      <data key="d9">chunk-2fa1a754b848fd3412be2058c0482b68</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794618</data>
    </edge>
    <edge source="Single Continuous Allocation" target="External Fragmentation">
      <data key="d6">1.0</data>
      <data key="d7">This method avoids external fragmentation because only one program is loaded and memory is managed in one contiguous block.</data>
      <data key="d8">absence of fragmentation</data>
      <data key="d9">chunk-2fa1a754b848fd3412be2058c0482b68</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794618</data>
    </edge>
    <edge source="Single Continuous Allocation" target="Memory Protection">
      <data key="d6">1.0</data>
      <data key="d7">Memory protection is not needed because only one user program operates in the user area, eliminating risk of interference.</data>
      <data key="d8">lack of requirement</data>
      <data key="d9">chunk-2fa1a754b848fd3412be2058c0482b68</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794619</data>
    </edge>
    <edge source="Single Continuous Allocation" target="Continuous Allocation Method">
      <data key="d6">1.0</data>
      <data key="d7">Single continuous allocation is a type of continuous allocation method.</data>
      <data key="d8">category,method type</data>
      <data key="d9">chunk-5479cc3e41d3a11f68f2cb90f11aab62</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794785</data>
    </edge>
    <edge source="User Program" target="Memory Space">
      <data key="d6">1.0</data>
      <data key="d7">A user program requires a continuous memory space for execution.</data>
      <data key="d8">allocation target,resource requirement</data>
      <data key="d9">chunk-5479cc3e41d3a11f68f2cb90f11aab62</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794785</data>
    </edge>
    <edge source="User Program" target="Continuous Allocation Method">
      <data key="d6">1.0</data>
      <data key="d7">The continuous allocation method is used to assign a continuous memory space to a user program.</data>
      <data key="d8">memory assignment,process</data>
      <data key="d9">chunk-5479cc3e41d3a11f68f2cb90f11aab62</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794786</data>
    </edge>
    <edge source="External Fragmentation" target="Fixed Partition Allocation">
      <data key="d6">1.0</data>
      <data key="d7">Fixed partition allocation does not suffer from external fragmentation, as memory is allocated in fixed blocks and no dynamic allocation occurs.</data>
      <data key="d8">fragmentation type,memory characteristic</data>
      <data key="d9">chunk-f688f41802e3a8adfb553475e4ca265e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794722</data>
    </edge>
    <edge source="Internal Fragmentation" target="Fixed Partition Allocation">
      <data key="d6">1.0</data>
      <data key="d7">Internal fragmentation occurs in fixed partition allocation when a job is smaller than a partition, leading to unused space within the partition.</data>
      <data key="d8">memory inefficiency,resource waste</data>
      <data key="d9">chunk-f688f41802e3a8adfb553475e4ca265e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794722</data>
    </edge>
    <edge source="Memory Protection" target="CPU">
      <data key="d6">1.0</data>
      <data key="d7">Memory protection is enforced by the CPU through comparisons with upper and lower limit registers during memory access.</data>
      <data key="d8">hardware enforcement,memory safety</data>
      <data key="d9">chunk-6a91872eefca67b87c6a12b37faf30eb</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794814</data>
    </edge>
    <edge source="Memory Protection" target="Relocation Register">
      <data key="d6">1.0</data>
      <data key="d7">Memory protection uses the relocation register to determine the base physical address for mapping logical addresses.</data>
      <data key="d8">address translation,memory mapping</data>
      <data key="d9">chunk-6a91872eefca67b87c6a12b37faf30eb</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794815</data>
    </edge>
    <edge source="Memory Protection" target="Bound Address Register">
      <data key="d6">1.0</data>
      <data key="d7">Memory protection uses the bound address register to prevent processes from accessing memory beyond their allocated limit.</data>
      <data key="d8">access control,bounds checking</data>
      <data key="d9">chunk-6a91872eefca67b87c6a12b37faf30eb</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794815</data>
    </edge>
    <edge source="Basic Page Storage Management" target="Page Frame">
      <data key="d6">1.0</data>
      <data key="d7">Basic page storage management divides physical memory into page frames for the allocation of process pages.</data>
      <data key="d8">allocation,memory division</data>
      <data key="d9">chunk-46462724e0de563d009072de78fa1d68</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794642</data>
    </edge>
    <edge source="Page Frame" target="Physical Block">
      <data key="d6">1.0</data>
      <data key="d7">The terms page frame and physical block are interchangeable terms referring to the same physical memory unit.</data>
      <data key="d8">hardware abstraction,synonymous concept</data>
      <data key="d9">chunk-46462724e0de563d009072de78fa1d68</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794643</data>
    </edge>
    <edge source="Page Frame" target="Page Replacement Algorithm">
      <data key="d6">1.0</data>
      <data key="d7">The Page Replacement Algorithm selects which Page Frame to free when no free frames are available.</data>
      <data key="d8">management,selection</data>
      <data key="d9">chunk-28a7b83e6af7f15e967e78c26eccf799</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794683</data>
    </edge>
    <edge source="Page Frame" target="Page Fault Interrupt">
      <data key="d6">1.0</data>
      <data key="d7">The system assigns a Page Frame to the requested page during the page fault handling process.</data>
      <data key="d8">assignment,resource allocation</data>
      <data key="d9">chunk-28a7b83e6af7f15e967e78c26eccf799</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794684</data>
    </edge>
    <edge source="Page Number" target="Page Table">
      <data key="d6">1.0</data>
      <data key="d7">The page table uses page numbers as keys to locate corresponding physical block numbers.</data>
      <data key="d8">address mapping,lookup</data>
      <data key="d9">chunk-46462724e0de563d009072de78fa1d68</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794643</data>
    </edge>
    <edge source="Page Number" target="Page Table Length">
      <data key="d6">1.0</data>
      <data key="d7">The page table length is used to verify if a page number is within bounds, preventing memory access violations.</data>
      <data key="d8">access control,boundary check</data>
      <data key="d9">chunk-46462724e0de563d009072de78fa1d68</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794645</data>
    </edge>
    <edge source="Page Table" target="Page Table Entry">
      <data key="d6">2.0</data>
      <data key="d7">Each page table contains one page table entry per page, which maps a logical page number to a physical block number.&lt;SEP&gt;The Page Table consists of multiple Page Table Entries, each representing a virtual page.</data>
      <data key="d8">composition,mapping data,structure,table structure</data>
      <data key="d9">chunk-28a7b83e6af7f15e967e78c26eccf799&lt;SEP&gt;chunk-46462724e0de563d009072de78fa1d68</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794681</data>
    </edge>
    <edge source="Page Table" target="Page Table Register">
      <data key="d6">1.0</data>
      <data key="d7">The page table register holds the starting address and length of the page table in memory.</data>
      <data key="d8">register configuration,storage reference</data>
      <data key="d9">chunk-46462724e0de563d009072de78fa1d68</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794644</data>
    </edge>
    <edge source="Page Table" target="Basic Address Transformation Mechanism">
      <data key="d6">1.0</data>
      <data key="d7">The basic address transformation mechanism uses the page table to map logical addresses to physical addresses.</data>
      <data key="d8">address resolution,hardware implementation</data>
      <data key="d9">chunk-46462724e0de563d009072de78fa1d68</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794645</data>
    </edge>
    <edge source="Page Table" target="Translation Lookaside Buffer">
      <data key="d6">2.0</data>
      <data key="d7">The TLB caches frequently accessed page table entries to accelerate address translation, reducing memory access overhead.&lt;SEP&gt;When a page table entry is accessed, it may be copied into the Translation Lookaside Buffer to enhance speed.</data>
      <data key="d8">cache function,performance enhancement,synchronization,update</data>
      <data key="d9">chunk-28a7b83e6af7f15e967e78c26eccf799&lt;SEP&gt;chunk-46462724e0de563d009072de78fa1d68</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794684</data>
    </edge>
    <edge source="Page Table" target="Slow Table">
      <data key="d6">1.0</data>
      <data key="d7">The main memory page table is used as the slow table when the TLB does not contain a required mapping.</data>
      <data key="d8">fallback source,slow memory reference</data>
      <data key="d9">chunk-46462724e0de563d009072de78fa1d68</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794646</data>
    </edge>
    <edge source="Page Table" target="Address Translation Mechanism">
      <data key="d6">1.0</data>
      <data key="d7">The Address Translation Mechanism consults the Page Table when the TLB miss occurs to retrieve the physical block number.</data>
      <data key="d8">data source,lookup</data>
      <data key="d9">chunk-28a7b83e6af7f15e967e78c26eccf799</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794683</data>
    </edge>
    <edge source="Page Table" target="Memory Management Unit">
      <data key="d6">1.0</data>
      <data key="d7">The Memory Management Unit uses the page table to perform address translation from logical to physical.</data>
      <data key="d8">data reference,translation mechanism</data>
      <data key="d9">chunk-c8697590fab35afe994351ccfc05bbac</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794709</data>
    </edge>
    <edge source="Page Table Entry" target="Status Bit P">
      <data key="d6">1.0</data>
      <data key="d7">The Status Bit P is one of the four fields within a Page Table Entry that tracks in-memory status.</data>
      <data key="d8">attribute,metadata</data>
      <data key="d9">chunk-28a7b83e6af7f15e967e78c26eccf799</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794682</data>
    </edge>
    <edge source="Page Table Entry" target="Access Field A">
      <data key="d6">1.0</data>
      <data key="d7">The Access Field A is a field in the Page Table Entry used to monitor page usage frequency or recency.</data>
      <data key="d8">attribute,metadata</data>
      <data key="d9">chunk-28a7b83e6af7f15e967e78c26eccf799</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794683</data>
    </edge>
    <edge source="Page Table Entry" target="Modify Bit M">
      <data key="d6">1.0</data>
      <data key="d7">The Modify Bit M is a field in the Page Table Entry that indicates if the page has been modified in memory.</data>
      <data key="d8">attribute,metadata</data>
      <data key="d9">chunk-28a7b83e6af7f15e967e78c26eccf799</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794683</data>
    </edge>
    <edge source="Page Table Entry" target="External Storage Address">
      <data key="d6">1.0</data>
      <data key="d7">The External Storage Address is a field in the Page Table Entry specifying where the page resides on secondary storage.</data>
      <data key="d8">attribute,metadata</data>
      <data key="d9">chunk-28a7b83e6af7f15e967e78c26eccf799</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794684</data>
    </edge>
    <edge source="Page Table Entry" target="Paging System">
      <data key="d6">1.0</data>
      <data key="d7">In a paging system, page table entries are used to map virtual addresses to physical pages of shared code, enabling memory sharing.</data>
      <data key="d8">code sharing,memory management</data>
      <data key="d9">chunk-00b255b459e05b4695b33c9dceed4321</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794858</data>
    </edge>
    <edge source="Page Table Register" target="Basic Address Transformation Mechanism">
      <data key="d6">1.0</data>
      <data key="d7">The basic address transformation mechanism relies on the page table register to locate the page table in memory.</data>
      <data key="d8">hardware support,register access</data>
      <data key="d9">chunk-46462724e0de563d009072de78fa1d68</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794646</data>
    </edge>
    <edge source="Translation Lookaside Buffer" target="Fast Table">
      <data key="d6">1.0</data>
      <data key="d7">The TLB is also referred to as the fast table due to its high-speed lookup capability.</data>
      <data key="d8">alternative name,synonymy</data>
      <data key="d9">chunk-46462724e0de563d009072de78fa1d68</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794645</data>
    </edge>
    <edge source="Translation Lookaside Buffer" target="Address Translation Mechanism">
      <data key="d6">1.0</data>
      <data key="d7">The Address Translation Mechanism uses the Translation Lookaside Buffer to accelerate virtual-to-physical address translation.</data>
      <data key="d8">caching,performance optimization</data>
      <data key="d9">chunk-28a7b83e6af7f15e967e78c26eccf799</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794683</data>
    </edge>
    <edge source="Two-Level Page Table" target="Outer Page Table">
      <data key="d6">1.0</data>
      <data key="d7">The two-level page table uses an outer page table to store the base addresses of second-level page tables, reducing memory usage.</data>
      <data key="d8">hierarchical structure,memory optimization</data>
      <data key="d9">chunk-46462724e0de563d009072de78fa1d68</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794645</data>
    </edge>
    <edge source="Two-Level Page Table" target="Second-Level Page Number">
      <data key="d6">1.0</data>
      <data key="d7">The second-level page number is used to index into the second-level page table after accessing the outer page table.</data>
      <data key="d8">multi-level access,secondary indexing</data>
      <data key="d9">chunk-46462724e0de563d009072de78fa1d68</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794646</data>
    </edge>
    <edge source="Two-Level Page Table" target="Page Directory Register">
      <data key="d6">1.0</data>
      <data key="d7">The page directory register stores the base address of the outer page table for initializing the two-level page table lookup.</data>
      <data key="d8">base address access,register storage</data>
      <data key="d9">chunk-46462724e0de563d009072de78fa1d68</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794646</data>
    </edge>
    <edge source="Two-Level Page Table" target="Multi-Level Page Table">
      <data key="d6">1.0</data>
      <data key="d7">The multi-level page table is an extension of the two-level approach, designed to support larger address spaces.</data>
      <data key="d8">extension,scalability</data>
      <data key="d9">chunk-46462724e0de563d009072de78fa1d68</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794647</data>
    </edge>
    <edge source="Outer Page Table" target="Page Directory">
      <data key="d6">1.0</data>
      <data key="d7">The terms outer page table and page directory are used interchangeably to refer to the top-level table in a two-level page table system.</data>
      <data key="d8">synonym term,synonymy</data>
      <data key="d9">chunk-46462724e0de563d009072de78fa1d68</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794646</data>
    </edge>
    <edge source="Page Directory Register" target="Page Directory Base Address Register">
      <data key="d6">1.0</data>
      <data key="d7">The page directory register and the page directory base address register are synonymous terms referring to the same hardware register that holds the base address of the page directory.</data>
      <data key="d8">alternative name,synonymy</data>
      <data key="d9">chunk-46462724e0de563d009072de78fa1d68</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794647</data>
    </edge>
    <edge source="Physical Block Number" target="Address Translation Mechanism">
      <data key="d6">1.0</data>
      <data key="d7">The Address Translation Mechanism outputs the Physical Block Number as part of the final address calculation.</data>
      <data key="d8">mapping,output</data>
      <data key="d9">chunk-28a7b83e6af7f15e967e78c26eccf799</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794685</data>
    </edge>
    <edge source="Page Frame Allocation" target="Resident Set Size">
      <data key="d6">1.0</data>
      <data key="d7">Page frame allocation determines the size of the resident set for each process.</data>
      <data key="d8">process memory control,system-level assignment</data>
      <data key="d9">chunk-abb4ec292dd5335d76c0413487939cbe</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794662</data>
    </edge>
    <edge source="Resident Set Size" target="Page Fault Rate">
      <data key="d6">1.0</data>
      <data key="d7">A smaller resident set size increases the likelihood of page faults, leading to higher page fault rates.</data>
      <data key="d8">inverse relationship,memory efficiency</data>
      <data key="d9">chunk-abb4ec292dd5335d76c0413487939cbe</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794659</data>
    </edge>
    <edge source="Resident Set Size" target="Multiprogramming Degree">
      <data key="d6">1.0</data>
      <data key="d7">Smaller resident sets allow more processes to be loaded into memory, increasing multiprogramming degree.</data>
      <data key="d8">direct relationship,system concurrency</data>
      <data key="d9">chunk-abb4ec292dd5335d76c0413487939cbe</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794660</data>
    </edge>
    <edge source="Page Fault Rate" target="Preloading Page Strategy">
      <data key="d6">1.0</data>
      <data key="d7">Preloading pages reduces future page faults by anticipating access patterns.</data>
      <data key="d8">performance improvement,proactive optimization</data>
      <data key="d9">chunk-abb4ec292dd5335d76c0413487939cbe</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794660</data>
    </edge>
    <edge source="Fixed Allocation" target="Local Replacement">
      <data key="d6">1.0</data>
      <data key="d7">Fixed allocation with local replacement ensures stable memory assignment and replacement within the same process.</data>
      <data key="d8">combined strategy,memory stability</data>
      <data key="d9">chunk-abb4ec292dd5335d76c0413487939cbe</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794659</data>
    </edge>
    <edge source="Fixed Allocation" target="Variable Allocation">
      <data key="d6">1.0</data>
      <data key="d7">Fixed and variable allocation are mutually exclusive strategies for assigning physical page frames to processes.</data>
      <data key="d8">allocation model contrast,mutual exclusivity</data>
      <data key="d9">chunk-abb4ec292dd5335d76c0413487939cbe</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794662</data>
    </edge>
    <edge source="Variable Allocation" target="Global Replacement">
      <data key="d6">1.0</data>
      <data key="d7">Variable allocation with global replacement enables efficient memory reallocation across processes based on current needs.</data>
      <data key="d8">combined strategy,dynamic overload management</data>
      <data key="d9">chunk-abb4ec292dd5335d76c0413487939cbe</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794659</data>
    </edge>
    <edge source="Variable Allocation" target="Local Replacement">
      <data key="d6">1.0</data>
      <data key="d7">Variable allocation with local replacement dynamically adjusts memory based on process behavior while preventing interference between processes.</data>
      <data key="d8">adaptive process management,combined strategy</data>
      <data key="d9">chunk-abb4ec292dd5335d76c0413487939cbe</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794660</data>
    </edge>
    <edge source="Global Replacement" target="Local Replacement">
      <data key="d6">1.0</data>
      <data key="d7">Global and local replacement are mutually exclusive page replacement strategies.</data>
      <data key="d8">mutual exclusivity,replacement model contrast</data>
      <data key="d9">chunk-abb4ec292dd5335d76c0413487939cbe</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794662</data>
    </edge>
    <edge source="Average Allocation Algorithm" target="Physical Page Frame">
      <data key="d6">1.0</data>
      <data key="d7">The average allocation algorithm ensures fair distribution of physical page frames among processes.</data>
      <data key="d8">distributional strategy,equitable sharing</data>
      <data key="d9">chunk-abb4ec292dd5335d76c0413487939cbe</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794659</data>
    </edge>
    <edge source="Proportional Allocation Algorithm" target="Physical Page Frame">
      <data key="d6">1.0</data>
      <data key="d7">The proportional allocation algorithm assigns more page frames to larger processes based on their size.</data>
      <data key="d8">proportional distribution,size-based assignment</data>
      <data key="d9">chunk-abb4ec292dd5335d76c0413487939cbe</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794660</data>
    </edge>
    <edge source="Priority Allocation Algorithm" target="Physical Page Frame">
      <data key="d6">1.0</data>
      <data key="d7">The priority allocation algorithm allocates more page frames to high-priority processes to ensure timely execution.</data>
      <data key="d8">priority-based assignment,resource prioritization</data>
      <data key="d9">chunk-abb4ec292dd5335d76c0413487939cbe</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794662</data>
    </edge>
    <edge source="Demand Page Strategy" target="Page Fault">
      <data key="d6">1.0</data>
      <data key="d7">Demand paging triggers a page fault when a page is accessed and not in memory.</data>
      <data key="d8">initiating event,on-demand loading</data>
      <data key="d9">chunk-abb4ec292dd5335d76c0413487939cbe</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794660</data>
    </edge>
    <edge source="Demand Page Strategy" target="Request-Paging System">
      <data key="d6">1.0</data>
      <data key="d7">The request-paging system implements the demand page strategy to load pages only when requested during process execution.</data>
      <data key="d8">core implementation,memory loading mechanism</data>
      <data key="d9">chunk-abb4ec292dd5335d76c0413487939cbe</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794662</data>
    </edge>
    <edge source="Swap Area" target="Disk I/O Speed">
      <data key="d6">1.0</data>
      <data key="d7">The swap area provides faster disk I/O for page swapping compared to the file area.</data>
      <data key="d8">storage performance,swap efficiency</data>
      <data key="d9">chunk-abb4ec292dd5335d76c0413487939cbe</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794660</data>
    </edge>
    <edge source="Swap Area" target="File Area">
      <data key="d6">1.0</data>
      <data key="d7">The secondary storage is divided into file area and swap area for different types of data handling.</data>
      <data key="d8">memory management,storage division</data>
      <data key="d9">chunk-abb4ec292dd5335d76c0413487939cbe</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794661</data>
    </edge>
    <edge source="Swap Area" target="UNIX Method">
      <data key="d6">1.0</data>
      <data key="d7">The UNIX method retrieves previously run pages from the swap area to restore execution state.</data>
      <data key="d8">page retrieval,runtime state recovery</data>
      <data key="d9">chunk-abb4ec292dd5335d76c0413487939cbe</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794662</data>
    </edge>
    <edge source="Swap Area" target="Request-Paging System">
      <data key="d6">1.0</data>
      <data key="d7">The request-paging system uses the swap area for storing pages that have been swapped out from physical memory.</data>
      <data key="d8">page replacement,storage dependency</data>
      <data key="d9">chunk-abb4ec292dd5335d76c0413487939cbe</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794663</data>
    </edge>
    <edge source="File Area" target="UNIX Method">
      <data key="d6">1.0</data>
      <data key="d7">The UNIX method loads unexecuted pages from the file area at the start of process execution.</data>
      <data key="d8">initial load,page retrieval</data>
      <data key="d9">chunk-abb4ec292dd5335d76c0413487939cbe</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794663</data>
    </edge>
    <edge source="File Area" target="Request-Paging System">
      <data key="d6">1.0</data>
      <data key="d7">The request-paging system uses the file area to store program images and files not currently in memory.</data>
      <data key="d8">image management,storage dependency</data>
      <data key="d9">chunk-abb4ec292dd5335d76c0413487939cbe</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794663</data>
    </edge>
    <edge source="Request Paging System" target="Basic Paging System">
      <data key="d6">1.0</data>
      <data key="d7">The Request Paging System is built upon the Basic Paging System to support virtual memory.</data>
      <data key="d8">enhancement,foundation</data>
      <data key="d9">chunk-28a7b83e6af7f15e967e78c26eccf799</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794681</data>
    </edge>
    <edge source="Modify Bit M" target="Page Replacement Algorithm">
      <data key="d6">1.0</data>
      <data key="d7">The decision to write a page back to external storage depends on whether the Modify Bit M is set.</data>
      <data key="d8">condition,decision criterion</data>
      <data key="d9">chunk-28a7b83e6af7f15e967e78c26eccf799</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794684</data>
    </edge>
    <edge source="Modify Bit M" target="Page Fault Handler">
      <data key="d6">1.0</data>
      <data key="d7">The Page Fault Handler checks the Modify Bit M to determine whether the page needs to be written back to external storage before replacing it.</data>
      <data key="d8">action decision,condition check</data>
      <data key="d9">chunk-28a7b83e6af7f15e967e78c26eccf799</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794685</data>
    </edge>
    <edge source="External Storage Address" target="Page Fault Handler">
      <data key="d6">1.0</data>
      <data key="d7">The Page Fault Handler uses the External Storage Address to locate and load the requested page.</data>
      <data key="d8">load target,lookup</data>
      <data key="d9">chunk-28a7b83e6af7f15e967e78c26eccf799</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794684</data>
    </edge>
    <edge source="Page Fault Handler" target="Page Fault Interrupt">
      <data key="d6">1.0</data>
      <data key="d7">The Page Fault Interrupt activates the Page Fault Handler to manage the process of loading the missing page.</data>
      <data key="d8">response,trigger</data>
      <data key="d9">chunk-28a7b83e6af7f15e967e78c26eccf799</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794681</data>
    </edge>
    <edge source="Page Fault Interrupt" target="Blocking Queue">
      <data key="d6">1.0</data>
      <data key="d7">When a page fault occurs, the process is moved from the ready state to the blocking queue.</data>
      <data key="d8">process state transition,timing</data>
      <data key="d9">chunk-28a7b83e6af7f15e967e78c26eccf799</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794682</data>
    </edge>
    <edge source="Page Fault Interrupt" target="Ready Queue">
      <data key="d6">1.0</data>
      <data key="d7">After page loading completes, the process is resumed and moved back to the ready queue.</data>
      <data key="d8">process state transition,timing</data>
      <data key="d9">chunk-28a7b83e6af7f15e967e78c26eccf799</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794683</data>
    </edge>
    <edge source="Address Translation Mechanism" target="Virtual Address">
      <data key="d6">1.0</data>
      <data key="d7">The Address Translation Mechanism takes the Virtual Address as input to generate a physical address.</data>
      <data key="d8">input,transformation</data>
      <data key="d9">chunk-28a7b83e6af7f15e967e78c26eccf799</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794685</data>
    </edge>
    <edge source="Address Relocation" target="Linker">
      <data key="d6">1.0</data>
      <data key="d7">The linker performs the initial setup of logical addresses during program linkage, forming the basis of address relocation.</data>
      <data key="d8">address assignment,program linking</data>
      <data key="d9">chunk-c8697590fab35afe994351ccfc05bbac</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794709</data>
    </edge>
    <edge source="Address Relocation" target="Memory Management Unit">
      <data key="d6">1.0</data>
      <data key="d7">The Memory Management Unit supports address relocation by translating logical addresses to physical addresses at runtime.</data>
      <data key="d8">hardware assistance,runtime translation</data>
      <data key="d9">chunk-c8697590fab35afe994351ccfc05bbac</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794710</data>
    </edge>
    <edge source="Memory Management Unit" target="Relocation Register">
      <data key="d6">1.0</data>
      <data key="d7">The memory management unit uses the relocation register to map logical addresses to physical addresses.</data>
      <data key="d8">address translation,memory control</data>
      <data key="d9">chunk-6a91872eefca67b87c6a12b37faf30eb</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794814</data>
    </edge>
    <edge source="Memory Management Unit" target="Bound Address Register">
      <data key="d6">1.0</data>
      <data key="d7">The memory management unit compares logical addresses with the bound address register to detect potential violations.</data>
      <data key="d8">bounds checking,memory safety</data>
      <data key="d9">chunk-6a91872eefca67b87c6a12b37faf30eb</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794816</data>
    </edge>
    <edge source="Process" target="Private Data Area">
      <data key="d6">1.0</data>
      <data key="d7">Each process is allocated a private data area to store local variables and state during execution, ensuring data isolation.</data>
      <data key="d8">data allocation,runtime isolation</data>
      <data key="d9">chunk-00b255b459e05b4695b33c9dceed4321</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794860</data>
    </edge>
    <edge source="Process" target="Shared Code Area">
      <data key="d6">1.0</data>
      <data key="d7">Each process accesses the shared code area for executing common logic, without altering the original code.</data>
      <data key="d8">execution context,memory access</data>
      <data key="d9">chunk-00b255b459e05b4695b33c9dceed4321</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794864</data>
    </edge>
    <edge source="Fixed Partition Allocation" target="User Memory Space">
      <data key="d6">1.0</data>
      <data key="d7">Fixed partition allocation divides the user memory space into fixed-size segments for job management.</data>
      <data key="d8">memory division,resource allocation</data>
      <data key="d9">chunk-f688f41802e3a8adfb553475e4ca265e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794721</data>
    </edge>
    <edge source="Fixed Partition Allocation" target="Partition Size Equal">
      <data key="d6">1.0</data>
      <data key="d7">Partition size equal is one of the two methods used in defining partitions for fixed partition allocation.</data>
      <data key="d8">memory allocation,partitioning strategy</data>
      <data key="d9">chunk-f688f41802e3a8adfb553475e4ca265e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794721</data>
    </edge>
    <edge source="Fixed Partition Allocation" target="Partition Size Unequal">
      <data key="d6">1.0</data>
      <data key="d7">Partition size unequal is the alternative method for defining partitions within fixed partition allocation.</data>
      <data key="d8">memory allocation,partitioning strategy</data>
      <data key="d9">chunk-f688f41802e3a8adfb553475e4ca265e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794721</data>
    </edge>
    <edge source="Fixed Partition Allocation" target="Partition Usage Table">
      <data key="d6">1.0</data>
      <data key="d7">The partition usage table is used to manage and monitor the allocation status of memory partitions in fixed partition allocation.</data>
      <data key="d8">management tool,memory tracking</data>
      <data key="d9">chunk-f688f41802e3a8adfb553475e4ca265e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794722</data>
    </edge>
    <edge source="Fixed Partition Allocation" target="Continuous Allocation Method">
      <data key="d6">1.0</data>
      <data key="d7">Fixed partition allocation is a type of continuous allocation method.</data>
      <data key="d8">category,method type</data>
      <data key="d9">chunk-5479cc3e41d3a11f68f2cb90f11aab62</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794786</data>
    </edge>
    <edge source="Memory Partition" target="Job">
      <data key="d6">1.0</data>
      <data key="d7">Each job is assigned to a single memory partition in fixed partition allocation.</data>
      <data key="d8">assignment,execution</data>
      <data key="d9">chunk-f688f41802e3a8adfb553475e4ca265e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794721</data>
    </edge>
    <edge source="存储管理方式" target="单一连续分配">
      <data key="d6">1.0</data>
      <data key="d7">存储管理方式evolved from单一连续分配as the first basic method in early operating systems.</data>
      <data key="d8">evolutionary progression,foundational method</data>
      <data key="d9">chunk-fa7ddc38beb083a10e073654dee57a19</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794760</data>
    </edge>
    <edge source="存储管理方式" target="固定分区分配">
      <data key="d6">1.0</data>
      <data key="d7">存储管理方式advanced to固定分区分配to support multi-programming through predefined partitions.</data>
      <data key="d8">evolutionary progression,transitional method</data>
      <data key="d9">chunk-fa7ddc38beb083a10e073654dee57a19</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794761</data>
    </edge>
    <edge source="存储管理方式" target="离散分配方式">
      <data key="d6">1.0</data>
      <data key="d7">存储管理方式evolved into离散分配方式to improve memory utilization through non-contiguous allocation.</data>
      <data key="d8">advanced technique,evolutionary progression</data>
      <data key="d9">chunk-fa7ddc38beb083a10e073654dee57a19</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794762</data>
    </edge>
    <edge source="存储管理方式" target="操作系统">
      <data key="d6">1.0</data>
      <data key="d7">The development of操作系统has driven the evolution of存储管理方式from simple to complex techniques.</data>
      <data key="d8">functional advancement,system evolution</data>
      <data key="d9">chunk-fa7ddc38beb083a10e073654dee57a19</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794763</data>
    </edge>
    <edge source="离散分配方式" target="页式存储管理">
      <data key="d6">1.0</data>
      <data key="d7">页式存储管理is a specific implementation of离散分配方式that uses fixed-size pages.</data>
      <data key="d8">specific implementation,technique adoption</data>
      <data key="d9">chunk-fa7ddc38beb083a10e073654dee57a19</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794760</data>
    </edge>
    <edge source="已修改换出页面的链表" target="磁盘I/O次数">
      <data key="d6">1.0</data>
      <data key="d7">Maintaining a list of modified evicted pages reduces redundant disk writes, thereby lowering磁盘I/O次数.</data>
      <data key="d8">I/O reduction,performance optimization</data>
      <data key="d9">chunk-dd63fcc97211dcfcfa94d11eff1be6f8</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794761</data>
    </edge>
    <edge source="磁盘I/O次数" target="写回磁盘的频率">
      <data key="d6">1.0</data>
      <data key="d7">The frequency of writing pages back to disk directly correlates with the total磁盘I/O次数.</data>
      <data key="d8">direct relationship,system overhead</data>
      <data key="d9">chunk-dd63fcc97211dcfcfa94d11eff1be6f8</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794762</data>
    </edge>
    <edge source="Continuous Allocation Method" target="Dynamic Partition Allocation">
      <data key="d6">1.0</data>
      <data key="d7">Dynamic partition allocation is a type of continuous allocation method.</data>
      <data key="d8">category,method type</data>
      <data key="d9">chunk-5479cc3e41d3a11f68f2cb90f11aab62</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794786</data>
    </edge>
    <edge source="抖动" target="页面置换">
      <data key="d6">1.0</data>
      <data key="d7">The频繁页面置换caused by inadequate memory resources leads to抖动in the system.</data>
      <data key="d8">causal relationship,system instability</data>
      <data key="d9">chunk-67ae509cb7f3a2cdf2694e125b8725c3</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794797</data>
    </edge>
    <edge source="工作集" target="驻留集">
      <data key="d6">1.0</data>
      <data key="d7">The驻留集must be at least as large as the工作集to prevent frequent缺页and maintain optimal process performance.</data>
      <data key="d8">memory management,process efficiency</data>
      <data key="d9">chunk-67ae509cb7f3a2cdf2694e125b8725c3</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794796</data>
    </edge>
    <edge source="工作集" target="缺页">
      <data key="d6">1.0</data>
      <data key="d7">If the驻留集is smaller than the工作集, the process will experience frequent缺页during execution.</data>
      <data key="d8">memory behavior,page fault prevention</data>
      <data key="d9">chunk-67ae509cb7f3a2cdf2694e125b8725c3</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794796</data>
    </edge>
    <edge source="Privileged Instruction" target="Operating System Kernel">
      <data key="d6">1.0</data>
      <data key="d7">Only the operating system kernel is allowed to execute privileged instructions, which are used to load relocation and bound address registers.</data>
      <data key="d8">privileged access,system control</data>
      <data key="d9">chunk-6a91872eefca67b87c6a12b37faf30eb</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794814</data>
    </edge>
    <edge source="Read-Only Regions" target="Reentrant Code">
      <data key="d6">1.0</data>
      <data key="d7">Reentrant code is designed to be shared in read-only regions to ensure consistent and safe execution across multiple processes.</data>
      <data key="d8">code integrity,shared execution</data>
      <data key="d9">chunk-00b255b459e05b4695b33c9dceed4321</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794863</data>
    </edge>
    <edge source="Reentrant Code" target="Shared Code Area">
      <data key="d6">1.0</data>
      <data key="d7">Reentrant code is stored in the shared code area so multiple processes can execute it concurrently.</data>
      <data key="d8">code sharing,multi-process execution</data>
      <data key="d9">chunk-00b255b459e05b4695b33c9dceed4321</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794858</data>
    </edge>
    <edge source="Reentrant Code" target="Private Data Area">
      <data key="d6">1.0</data>
      <data key="d7">Each process uses a private data area to hold mutable data, ensuring that changes do not affect the shared reentrant code.</data>
      <data key="d8">data isolation,execution safety</data>
      <data key="d9">chunk-00b255b459e05b4695b33c9dceed4321</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794859</data>
    </edge>
    <edge source="Reentrant Code" target="Execution Time">
      <data key="d6">1.0</data>
      <data key="d7">During execution time, reentrant code is accessed by multiple processes, and modifications are limited to private data areas.</data>
      <data key="d8">code execution,runtime behavior</data>
      <data key="d9">chunk-00b255b459e05b4695b33c9dceed4321</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794860</data>
    </edge>
    <edge source="Shared Code Area" target="Paging System">
      <data key="d6">1.0</data>
      <data key="d7">The paging system supports sharing the shared code area by having each process's page table reference the same physical page numbers.</data>
      <data key="d8">page-level sharing,virtual memory</data>
      <data key="d9">chunk-00b255b459e05b4695b33c9dceed4321</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794861</data>
    </edge>
    <edge source="Physical Page Number" target="Paging System">
      <data key="d6">1.0</data>
      <data key="d7">The paging system uses physical page numbers to locate the actual location of shared code in physical memory.</data>
      <data key="d8">hardware addressing,memory mapping</data>
      <data key="d9">chunk-00b255b459e05b4695b33c9dceed4321</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794860</data>
    </edge>
    <edge source="Segment Table Entry" target="Segmentation System">
      <data key="d6">1.0</data>
      <data key="d7">In a segmentation system, a single segment table entry is used to point to the shared code segment, simplifying sharing.</data>
      <data key="d8">memory sharing,segment management</data>
      <data key="d9">chunk-00b255b459e05b4695b33c9dceed4321</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794858</data>
    </edge>
    <edge source="Shared Code Segment" target="Segmentation System">
      <data key="d6">1.0</data>
      <data key="d7">The segmentation system enables sharing of the shared code segment by referencing its starting address through a segment table entry.</data>
      <data key="d8">memory access,segment-level sharing</data>
      <data key="d9">chunk-00b255b459e05b4695b33c9dceed4321</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794860</data>
    </edge>
    <edge source="Paging System" target="Code Sharing">
      <data key="d6">1.0</data>
      <data key="d7">The paging system implements code sharing by assigning the same physical page numbers to shared code across multiple process page tables.</data>
      <data key="d8">implementation,memory management technique</data>
      <data key="d9">chunk-00b255b459e05b4695b33c9dceed4321</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794864</data>
    </edge>
    <edge source="Segmentation System" target="Code Sharing">
      <data key="d6">1.0</data>
      <data key="d7">The segmentation system implements code sharing by using a single segment table entry to reference the shared code segment.</data>
      <data key="d8">implementation,memory management technique</data>
      <data key="d9">chunk-00b255b459e05b4695b33c9dceed4321</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794865</data>
    </edge>
    <edge source="分段管理方式" target="逻辑地址空间">
      <data key="d6">1.0</data>
      <data key="d7">分段管理方式将逻辑地址空间划分为大小不等的段，每段从0开始编址。</data>
      <data key="d8">address space division,logical segmentation</data>
      <data key="d9">chunk-14a72f660cb4c5e34ac9c9ddaed64956</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794864</data>
    </edge>
    <edge source="分段管理方式" target="段">
      <data key="d6">1.0</data>
      <data key="d7">每个段是逻辑地址空间的划分单元，并分配连续的地址空间。</data>
      <data key="d8">memory organization,segmentation</data>
      <data key="d9">chunk-14a72f660cb4c5e34ac9c9ddaed64956</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794865</data>
    </edge>
    <edge source="分段管理方式" target="虚拟地址空间">
      <data key="d6">1.0</data>
      <data key="d7">分段管理方式以用户和程序员需求为核心，构建二维的虚拟地址空间。</data>
      <data key="d8">memory model,user perspective</data>
      <data key="d9">chunk-14a72f660cb4c5e34ac9c9ddaed64956</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794866</data>
    </edge>
    <edge source="分段管理方式" target="地址越界保护">
      <data key="d6">1.0</data>
      <data key="d7">分段管理通过地址越界保护防止非法内存访问。</data>
      <data key="d8">memory safety,protection mechanism</data>
      <data key="d9">chunk-14a72f660cb4c5e34ac9c9ddaed64956</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794867</data>
    </edge>
    <edge source="分段管理方式" target="存取控制保护">
      <data key="d6">1.0</data>
      <data key="d7">分段管理使用存取控制保护机制限制对段的访问权限。</data>
      <data key="d8">access control,security mechanism</data>
      <data key="d9">chunk-14a72f660cb4c5e34ac9c9ddaed64956</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794867</data>
    </edge>
    <edge source="逻辑地址结构" target="段号S">
      <data key="d6">1.0</data>
      <data key="d7">逻辑地址结构由段号S与段内偏移量W组成，由用户显式提供。</data>
      <data key="d8">address composition,segmentation</data>
      <data key="d9">chunk-14a72f660cb4c5e34ac9c9ddaed64956</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794864</data>
    </edge>
    <edge source="逻辑地址结构" target="段内偏移量W">
      <data key="d6">1.0</data>
      <data key="d7">逻辑地址结构由段号S与段内偏移量W组成，由用户显式提供。</data>
      <data key="d8">address composition,segmentation</data>
      <data key="d9">chunk-14a72f660cb4c5e34ac9c9ddaed64956</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794865</data>
    </edge>
    <edge source="共享段表" target="可重入代码">
      <data key="d6">1.0</data>
      <data key="d7">共享段表支持可重入代码的多进程共享与并发访问。</data>
      <data key="d8">execution safety,shared code access</data>
      <data key="d9">chunk-14a72f660cb4c5e34ac9c9ddaed64956</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794865</data>
    </edge>
    <edge source="Process Memory Image" target="Executable Program File">
      <data key="d6">1.0</data>
      <data key="d7">The process memory image is formed when an executable program file is loaded into memory.</data>
      <data key="d8">derived from,in-memory representation</data>
      <data key="d9">chunk-595c1a74214288cf8d47eda3bbc75afe</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794884</data>
    </edge>
    <edge source="Process Memory Image" target="Code Segment">
      <data key="d6">1.0</data>
      <data key="d7">The process memory image includes the code segment as a core part.</data>
      <data key="d8">contains,structural component</data>
      <data key="d9">chunk-595c1a74214288cf8d47eda3bbc75afe</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794884</data>
    </edge>
    <edge source="Process Memory Image" target="Data Segment">
      <data key="d6">1.0</data>
      <data key="d7">The process memory image includes the data segment as a core part.</data>
      <data key="d8">contains,structural component</data>
      <data key="d9">chunk-595c1a74214288cf8d47eda3bbc75afe</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794885</data>
    </edge>
    <edge source="Process Memory Image" target="Process Control Block">
      <data key="d6">1.0</data>
      <data key="d7">The process memory image includes the process control block, which resides in system memory and enables OS control.</data>
      <data key="d8">contains,system management</data>
      <data key="d9">chunk-595c1a74214288cf8d47eda3bbc75afe</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794885</data>
    </edge>
    <edge source="Process Memory Image" target="Heap">
      <data key="d6">1.0</data>
      <data key="d7">The process memory image includes the heap for runtime dynamic memory allocation.</data>
      <data key="d8">contains,dynamic memory</data>
      <data key="d9">chunk-595c1a74214288cf8d47eda3bbc75afe</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794885</data>
    </edge>
    <edge source="Process Memory Image" target="Stack">
      <data key="d6">1.0</data>
      <data key="d7">The process memory image includes the stack to support function calls.</data>
      <data key="d8">contains,function execution</data>
      <data key="d9">chunk-595c1a74214288cf8d47eda3bbc75afe</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794886</data>
    </edge>
    <edge source="Heap" target="Malloc Function">
      <data key="d6">1.0</data>
      <data key="d7">The heap is dynamically expanded and contracted using the malloc and free functions.</data>
      <data key="d8">dynamic allocation,manipulated by</data>
      <data key="d9">chunk-595c1a74214288cf8d47eda3bbc75afe</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794886</data>
    </edge>
    <edge source="Heap" target="Free Function">
      <data key="d6">1.0</data>
      <data key="d7">The free function is used to release memory from the heap.</data>
      <data key="d8">manipulated by,memory deallocation</data>
      <data key="d9">chunk-595c1a74214288cf8d47eda3bbc75afe</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794886</data>
    </edge>
    <edge source="Stack" target="Malloc Function">
      <data key="d6">1.0</data>
      <data key="d7">The stack and malloc function serve different purposes; the stack manages function calls, while malloc manages heap memory.</data>
      <data key="d8">distinct purpose,separate functionality</data>
      <data key="d9">chunk-595c1a74214288cf8d47eda3bbc75afe</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761794884</data>
    </edge>
  </graph>
</graphml>
