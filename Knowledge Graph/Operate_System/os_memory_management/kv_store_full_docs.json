{
  "doc-e9724523b61c71a64ad927ea59b8337a": {
    "content": "18. 页面置换算法 进程运行时, 若其访问的页面不在内存而需将其调入, 但内存已无空闲空间时, 就需要从内存中调出一页, 换出到外存。选择调出哪个页面的算法就称为页面置换算法。 最佳(OPT)置换算法 最佳置换算法选择淘汰的页面是以后永不使用的页面, 或是在最长时间内不再被访问的页面, 以便保证获得最低的缺页率。该算法无法实现。 先进先出(FIFO)页面置换算法 FIFO 算法选择淘汰的页面是最早进入内存的页面。该算法实现简单, 但与进程实际运行的规律不相适应, 性能较差。 FIFO 算法还会产生当为进程分配的物理块增多, 缺页次数不减反增的异常现象, 称为 Belady异常。 最近最久未使用(LRU)置换算法 LRU 算法选择淘汰的页面是最近最长时间未使用的页面, 它认为过去一段时间内未访问过的页面, 在最近的将来可能也不会被访问。 LRU 算法性能较好, 但实现起来需要寄存器和栈的硬件支持, 开销较大。 时钟(CLOCK) 置换算法 (1) 简单的CLOCK 置换算法 为每个页面设置一个访问位, 当某页首次被装入或被访问时, 其访问位被置为1。算法将内存中的页面链接成一个循环队列, 并有一个替换指针与之相关联。在选择淘汰一页时, 只需检查页面的访问位:若为0, 就选择该页换出:若为1, 则将它置为0, 暂不换出, 给予该页第二次驻留内存的机会, 再依次顺序检查下一个页面。 (2) 改进型 CLOCK 置换算法 在改进型 CLOCK算法中, 除考虑页面使用情况外, 还增加了置换代价——修改位。在选择页面换出时, 优先考虑既未使用过又未修改过的页面。由访问位A和修改位M可以组合成下面四种类型的页面: 1类(A=0, M=0): 最近未被访问, 且未被修改, 是最佳的淘汰页。 2类(A=0, M=1): 最近未被访问, 但已被修改, 是次佳的淘汰页。 3类(A=1, M=0): 最近已被访问, 但未被修改, 可能再被访问。 4类(A=1, M=1): 最近已被访问, 且已被修改, 可能再被访问。 算法执行时, 按1->2->3->4的顺序分轮扫描, 寻找并淘汰相应类别的页面。",
    "create_time": 1761794316,
    "update_time": 1761794316,
    "_id": "doc-e9724523b61c71a64ad927ea59b8337a"
  },
  "doc-c6de281f0215ff49a87e3727a7c2bb2a": {
    "content": "1. 内存管理的基本原理和要求 内存管理(Memory Management)是操作系统设计中最重要和最复杂的内容之一。虽然计算机硬件技术一直在飞速发展, 内存容量也在不断增大, 但仍然不可能将所有用户进程和系统所需要的全部程序与数据放入主存, 因此操作系统必须对内存空间进行合理的划分和有效的动态分配。操作系统对内存的划分和动态分配, 就是内存管理的概念。 有效的内存管理在多道程序设计中非常重要, 它不仅可以方便用户使用存储器、提高内存利用率, 还可以通过虚拟技术从逻辑上扩充存储器。内存管理的主要功能有: 内存空间的分配与回收。由操作系统负责内存空间的分配和管理, 记录内存的空闲空间、内存的分配情况, 并回收已结束进程所占用的内存空间。 地址转换。程序的逻辑地址与内存中的物理地址不可能一致, 因此存储管理必须提供地址变换功能, 将逻辑地址转换成相应的物理地址。 内存空间的扩充。利用虚拟存储技术从逻辑上扩充内存。 内存共享。指允许多个进程访问内存的同一部分。例如, 多个合作进程可能需要访问同一块数据, 因此必须支持对内存共享区域进行受控访问。 存储保护。保证各个进程在各自的存储空间内运行, 互不干扰。 在进行具体的内存管理之前, 需要了解进程运行的基本原理和要求。",
    "create_time": 1761794316,
    "update_time": 1761794316,
    "_id": "doc-c6de281f0215ff49a87e3727a7c2bb2a"
  },
  "doc-5a8929ecef7cbf8892a009420c53322d": {
    "content": "21. 内存映射文件 内存映射文件(Memory-Mapped Files)是操作系统向应用程序提供的一个系统调用, 它与虚拟内存有些相似, 在磁盘文件与进程的虚拟地址空间之间建立映射关系。 进程通过该系统调用, 将一个文件映射到其虚拟地址空间的某个区域, 之后就能用访问内存的方式来读/写文件。磁盘文件的读/写由操作系统负责完成, 对进程而言是透明的。在映射进程的页面时, 不会实际读入文件的内容, 而只在访问页面时才被每次一页地读入。当进程退出或关闭文件映射时, 所有被改动的页面才被写回磁盘文件。 内存映射文件带来的好处主要是: ①使程序员的编程更简单; ②方便多个进程共享同一个磁盘文件。",
    "create_time": 1761794316,
    "update_time": 1761794316,
    "_id": "doc-5a8929ecef7cbf8892a009420c53322d"
  },
  "doc-f59ab8ff80e1533c966b7cb6b20563dc": {
    "content": "11. 动态分区分配 (1) 动态分区分配的基本原理 动态分区分配也称可变分区分配, 是指在进程装入内存时, 根据进程的实际需要, 动态地为之分配内存, 并使分区的大小正好适合进程的需要。 随着时间的推移, 内存中会产生越来越多的小内存块, 内存的利用率也随之下降。这些小内存块被称为外部碎片。外部碎片可通过紧凑技术来克服, 即操作系统不时地对进程进行移动和整理。 在动态分区分配中, 设置一张空闲分区链(表)。分配内存时, 检索空闲分区链, 找到所需的分区。回收内存时, 系统根据回收分区的始址, 从空闲分区链中找到相应的插入点, 此时可能出现四种情况: ①与前一空闲分区相邻, 则合并; ②与后一空闲分区相邻, 则合并; ③同时与前、后两个分区相邻, 则三者合并; ④没有相邻的空闲分区, 则为回收区新建一个表项。 (2) 基于顺序搜索的分配算法 首次适应(First Fit)算法。空闲分区按地址递增的次序排列。每次分配内存时, 顺序查找到第一个能满足大小的空闲分区, 分配给作业。 邻近适应(Next Fit)算法。也称循环首次适应算法, 分配内存时从上次查找结束的位置开始继续查找。 最佳适应(Best Fit)算法。空闲分区按容量递增的次序排列。每次分配内存时, 顺序查找到第一个能满足大小的空闲分区, 即最小的空闲分区, 分配给作业。 最坏适应(Worst Fit)算法。空闲分区按容量递减的次序排列。每次分配内存时, 查找到最大的空闲分区, 从中分割一部分空间给作业。 综合来看, 首次适应算法的开销小, 性能最好。 (3) 基于索引搜索的分配算法 快速适应算法。空闲分区的分类根据进程常用的空间大小进行划分。为每类(大小相同)空闲分区, 单独设立一个空闲分区链。 伙伴系统。规定所有分区的大小均为2的k次幂(k为正整数)。 哈希算法。根据空闲分区链表的分布规律, 建立哈希函数, 构建一张以空闲分区大小为关键字的哈希表, 每个表项记录一个对应空闲分区链的头指针。",
    "create_time": 1761794316,
    "update_time": 1761794316,
    "_id": "doc-f59ab8ff80e1533c966b7cb6b20563dc"
  },
  "doc-c195ab08b96907e43c39705a88501db8": {
    "content": "14. 段页式存储管理 将分页存储管理和分段存储管理这两种方法结合起来, 便形成了段页式存储管理方式。 在段页式系统中, 进程的地址空间首先被分成若干逻辑段, 每段都有自己的段号, 然后将各段分成若干大小固定的页。对内存空间的管理仍然和分页存储管理一样, 将其分成若干和页面大小相同的物理块, 对内存的分配以物理块为单位。 在段页式系统中, 进程的逻辑地址分为三部分:段号、页号和页内偏移量。 为了实现地址变换, 系统为每个进程建立一张段表, 每个段对应一个段表项, 每个段有一张页表。系统中还应有一个段表寄存器。 在进行地址变换时, 首先通过段表查到页表始址, 然后通过页表找到物理块号, 最后形成物理地址。进行一次访问实际需要三次访问主存。段页式管理的地址空间是二维的。",
    "create_time": 1761794316,
    "update_time": 1761794316,
    "_id": "doc-c195ab08b96907e43c39705a88501db8"
  },
  "doc-c09d18569a1b1c90198e18b0108e8c32": {
    "content": "3. 程序的链接与装入 创建进程首先要将程序和数据装入内存。将用户源程序变为可在内存中执行的程序, 通常需要以下几个步骤: 编译。由编译程序将用户源代码编译成若干目标模块。 链接。由链接程序将编译后形成的一组目标模块, 以及它们所需的库函数链接在一起, 形成一个完整的装入模块。 装入。由装入程序将装入模块装入内存运行。 将一个装入模块装入内存时, 有以下三种装入方式。 (1) 绝对装入 绝对装入方式只适用于单道程序环境。在编译时, 若知道程序将放到内存的哪个位置, 则编译程序将产生绝对地址的目标代码。装入程序按照装入模块的地址, 将程序和数据装入内存。程序中的逻辑地址与实际内存地址完全相同, 因此不需对程序和数据的地址进行修改。 (2) 可重定位装入 可重定位装入也称静态重定位。经过编译、链接后的装入模块的始址(起始地址)通常都是从0开始的, 程序中使用的指令和数据的地址都是相对于始址而言的逻辑地址。可根据内存的当前情况, 将装入模块装入内存的适当位置。在装入时对目标程序中的相对地址的修改过程称为重定位, 地址转换通常是在进程装入时一次完成的。 当一个作业装入内存时, 必须给它分配要求的全部内存空间, 若没有足够的内存, 则无法装入。作业一旦进入内存, 整个运行期间就不能在内存中移动, 也不能再申请内存空间。 (3) 动态运行时装入 动态运行时装入也称动态重定位。程序若要在内存中发生移动, 则要采用动态的装入方式。装入程序将装入模块装入内存后, 并不会立即将装入模块中的相对地址转换为绝对地址, 而是将这种地址转换推迟到程序真正要执行时才进行。因此, 装入内存后的所有地址均为相对地址。这种方式需要一个重定位寄存器(存放装入模块的起始位置)的支持。 动态重定位的优点:可以将程序分配到不连续的存储区;在程序运行前只需装入它的部分代码即可投入运行, 然后在程序运行期间, 根据需要动态申请分配内存;便于程序段的共享。 对目标模块进行链接时, 根据链接的时间不同, 分为以下三种链接方式。 (1) 静态链接 在程序运行之前, 先将各目标模块及它们所需的库函数链接成一个完整的装入模块, 以后不再拆开。 (2) 装入时动态链接 将用户源程序编译后所得到的一组目标模块, 在装入内存时, 采用边装入边链接的方式。其优点是便于修改和更新, 便于实现对目标模块的共享。 (3) 运行时动态链接 在程序执行中需要某目标模块时, 才对它进行链接。凡在程序执行中未用到的目标模块, 都不会被调入内存和链接到装入模块上。其优点是能加快程序的装入过程, 还可节省内存空间。",
    "create_time": 1761794316,
    "update_time": 1761794316,
    "_id": "doc-c09d18569a1b1c90198e18b0108e8c32"
  },
  "doc-00e431215b94639001c5095d3c4f8b1c": {
    "content": "15. 虚拟内存的基本概念 传统存储管理方式的特征 它们都具有以下两个共同的特征: 一次性。作业必须一次性全部装入内存后, 才能开始运行。 驻留性。作业被装入内存后, 就一直驻留在内存中, 其任何部分都不会被换出, 直至作业运行结束。 局部性原理 时间局部性。程序中的某条指令一旦执行, 不久后该指令可能再次执行; 某数据被访问过, 不久后该数据可能再次被访问。 空间局部性。一旦程序访问了某个存储单元, 在不久后, 其附近的存储单元也将被访问。 虚拟内存技术实际上建立了“内存-外存”的两级存储器结构, 利用局部性原理实现高速缓存。 虚拟存储器的定义和特征 基于局部性原理, 在程序装入时, 仅需将程序当前运行要用到的少数页面(或段)装入内存, 而将其余部分暂留在外存, 便可启动程序执行。在程序执行过程中, 当所访问的信息不在内存时, 由操作系统负责将所需信息从外存调入内存, 然后继续执行程序, 这个过程就是请求调页(或请求调段)功能。当内存空间不够时, 由操作系统负责将内存中暂时用不到的信息换出到外存, 从而腾出空间存放将要调入内存的信息, 这个过程就是页面置换(或段置換)功能。这样, 系统好像为用户提供了一个比实际内存容量大得多的存储器, 称为虚拟存储器。 虚拟存储器有以下三个主要特征: 多次性。无须在作业运行时一次性全部装入内存, 而是允许被分成多次调入内存。 对换性。在作业运行时无须一直常驻内存, 而是允许在作业运行过程中, 将那些暂不使用的程序和数据从内存调至外存的对换区(换出), 待以后需要时再将它们从外存调至内存(换进)。 虚拟性。从逻辑上扩充了内存的容量, 使用户看到的内存容量, 远大于实际容量。 虚拟内存技术的实现 虚拟内存的实现需要建立在离散分配的内存管理方式的基础上。 虚拟内存的实现有以下三种方式: 请求分页存储管理。 请求分段存储管理。 请求段页式存储管理。 一般需要的硬件支持有以下几个方面: 一定容量的内存和外存。 页表机制(或段表机制), 作为主要的数据结构。 中断机构, 当用户程序要访问的部分尚未调入内存时, 则产生中断。 地址变换机构, 逻辑地址到物理地址的变换。",
    "create_time": 1761794316,
    "update_time": 1761794316,
    "_id": "doc-00e431215b94639001c5095d3c4f8b1c"
  },
  "doc-3c9d6c4c9f8b1850281a50533371f77d": {
    "content": "20. 页框回收 页面缓冲算法 页面缓冲算法在原页面置换算法的基础上增设已修改页面链表, 保存已修改且需要被换出的页面, 等被换出的页面数量达到一定值时, 再一起换出到磁盘, 以减少页面换出的开销。 为了显著降低页面换入/换出的频率, 在内存中设置了如下两个链表: 空闲页面链表。当有一个未被修改的页面要换出时, 实际上并不将它换出到磁盘, 而将它所在的页框挂在空闲链表的链尾。 修改页面链表。当进程需要将一个已修改的页面换出时, 系统并不立即将它换出到磁盘, 而将它所在的页框挂在修改页面链表的末尾。 页框回收 当系统可分配的内存不足时, 就必须回收一些页框。属于内核的大部分页框都是不能回收的, 而由进程使用的页框大部分是可以回收的。 在Linux内核中, 设置了一个负责页面换出的守护进程kswapd, 它定期检查内存的使用情况, 当空闲页框数量少于特定的阈值时, 便发起页框回收操作。",
    "create_time": 1761794316,
    "update_time": 1761794316,
    "_id": "doc-3c9d6c4c9f8b1850281a50533371f77d"
  },
  "doc-46462724e0de563d009072de78fa1d68": {
    "content": "12. 基本分页存储管理 将内存空间分为若干固定大小的分区, 称为页框、页帧或物理块。进程的逻辑地址空间也分为与块大小相等的若干区域, 称为页或页面。操作系统以页框为单位为各个进程分配内存空间。 分页管理不产生外部碎片。但会产生内部碎片(页内碎片)。 分页存储的几个基本概念 (1) 页面和页面大小 进程的逻辑地址空间中的每个页面有一个编号, 称为页号, 从0开始:内存空间中的每个页框也有一个编号, 称为页框号(或物理块号), 也从0开始。 为方便地址转换, 页面大小应是2的整数次幂。 (2) 地址结构 分页存储管理的逻辑地址结构包含两部分:前一部分为页号P, 后一部分为页内偏移量W。 (3) 页表 为了便于找到进程的每个页面在内存中存放的位置, 系统为每个进程建立一张页面映射表, 简称页表。进程的每个页面对应一个页表项, 每个页表项由页号和块号组成, 它记录了页面在内存中对应的物理块号。页表的作用是实现从页号到物理块号的地址映射。 基本地址变换机构 地址变换机构的任务是将逻辑地址转换为内存中的物理地址。地址变换是借助于页表实现的。 在系统中设置一个页表寄存器(PTR), 存放页表在内存的始址F和页表长度 M。设页面大小为L, 逻辑地址A到物理地址E的变换过程如下: ① 根据逻辑地址计算出页号 P=A/L、页内偏移量 W=A%L。 ② 判断页号是否越界, 若页号P≥页表长度M, 则产生越界中断, 否则继续执行。 ③ 在页表中查询页号对应的页表项, 确定页面存放的物理块号b。 ④ 计算物理地址 E=b*L+W, 用物理地址去访存。 具有快表的地址变换机构 在地址变换机构中增设一个具有并行查找能力的高速缓冲存储器——快表(TLB), 也称相联存储器, 用来存放当前访问的若干页表项, 以加速地址变换的过程。与此对应, 主存中的页表常称为慢表。 在具有快表的分页机制中, 地址的变换过程如下: ① CPU给出逻辑地址后, 由硬件进行地址转换, 将页号与快表中的所有页号进行比较。 ② 若找到匹配的页号, 说明要访问的页表项在快表中有副本, 则直接从中取出该页对应的物理块号, 与页内偏移量拼接形成物理地址。 ③ 若未找到匹配的页号, 则需要访问内存中的页表, 读出页表项后, 就能得到该页的物理块号, 再与页内偏移量拼接形成物理地址。找到页表项后, 应同时将其存入快表, 以便后面的再次访问。 两级页表 为解决页表占用过多连续内存空间的问题, 可采用离散分配方式, 为离散分配的页表再建立一张页表, 称为外层页表(或页目录)。 当采用两级分页时, 逻辑地址空间被划分为一级页号(页目录号)、二级页号和页内偏移量。 在页表的每个表项中, 存放的是进程的某页对应的物理块号。在外层页表的每个表项中, 存放的是某个页表分页的始址。 为了方便实现地址变换, 需要在系统中增设一个外层页表寄存器(也称页目录基址寄存器), 用于存放页目录始址。将逻辑地址中的页目录号作为页目录的索引, 从中找到对应页表的始址; 再用二级页号作为页表分页的索引, 从中找到对应的页表项; 将页表项中的物理块号和页内偏移拼接形成物理地址。共进行了三次访存。 对于更大的逻辑地址空间, 必须采用多级页表, 再对外层页表分页。",
    "create_time": 1761794316,
    "update_time": 1761794316,
    "_id": "doc-46462724e0de563d009072de78fa1d68"
  },
  "doc-2fa1a754b848fd3412be2058c0482b68": {
    "content": "9. 单一连续分配 在单一连续分配方式中, 内存被分为系统区和用户区, 系统区仅供操作系统使用, 通常在低地址部分; 用户区内存中仅有一道用户程序, 即用户程序独占整个用户区。 这种方式的优点是简单、无外部碎片; 不需要进行内存保护。缺点是只能用于单用户、单任务的操作系统中; 有内部碎片; 内存的利用率极低。",
    "create_time": 1761794316,
    "update_time": 1761794316,
    "_id": "doc-2fa1a754b848fd3412be2058c0482b68"
  },
  "doc-abb4ec292dd5335d76c0413487939cbe": {
    "content": "17. 页框分配 驻留集大小 对于分页式的虚拟内存, 操作系统必须决定给特定的进程分配几个页框。给一个进程分配的页框的集合就是这个进程的驻留集。 驻留集越小, 驻留在内存中的进程就越多, 可以提高多道程序的并发度, 但分配给每个进程的页框太少, 会导致缺页率较高。 驻留集越大, 当分配给进程的页框超过某个数量时, 再为进程增加页框对缺页率的改善是不明显的, 反而只能是浪费内存空间。 内存分配策略 在请求分页系统中, 可采取两种内存分配策略, 即固定和可变分配策略。在进行置换时, 也可采取两种策略, 即全局和局部置换。于是可组合出下面三种适用的策略。 (1) 固定分配局部置换 为每个进程分配固定数量的物理块, 在进程运行期间都不改变。若进程在运行中发生缺页, 则只能从分配给该进程在内存的页面中选出一页换出。 (2) 可变分配全局置换 先为每个进程分配一定数量的物理块, 在进程运行期间可根据情况适当地增加或减少。若进程在运行中发生缺页, 则系统从空闲物理块队列中取出一块分配给该进程。 (3) 可变分配局部置换 为每个进程分配一定数量的物理块, 当某进程发生缺页时, 只允许从该进程在内存的页面中选出一页换出。若进程在运行中频繁地发生缺页中断, 则系统再为该进程分配若干物理块;反之, 若进程在运行中的缺页率特别低, 则可适当减少分配给该进程的物理块。 物理块调入算法 采用固定分配策略时, 可采用下述几种算法。 平均分配算法, 将系统中所有可供分配的物理块平均分配给各个进程。 按比例分配算法, 根据进程的大小按比例分配物理块。 优先权分配算法, 为重要和紧迫的进程分配较多的物理块。 调入页面的时机 预调页策略。可以预测不久之后可能被访问的页面, 将它们预先调入内存。 请求调页策略。进程在运行中需要访问的页面不在内存, 便提出请求, 由系统将其所需页面调入内存。 从何处调入页面 请求分页系统中的外存分为两部分: 用于存放文件的文件区和用于存放对换页面的对换区。对换区的磁盘I/O速度比文件区的更快。 系统拥有足够的对换区空间。可以全部从对换区调入所需页面, 以提高调页速度。 系统缺少足够的对换区空间。凡是不会被修改的文件都直接从文件区调入; 对于那些可能被修改的部分, 在将它们换出时必须放在对换区。 UNIX方式。与进程有关的文件都放在文件区, 因此未运行过的页面都应从文件区调入。曾经运行过但又被换出的页面, 应从对换区调入。",
    "create_time": 1761794316,
    "update_time": 1761794316,
    "_id": "doc-abb4ec292dd5335d76c0413487939cbe"
  },
  "doc-28a7b83e6af7f15e967e78c26eccf799": {
    "content": "16. 请求分页管理方式 请求分页系统建立在基本分页系统的基础之上, 为支持虚拟存储器功能而增加了请求调页和页面置换功能。 页表机制 在请求页表项中增加了4个字段。 状态位P。标记该页是否已调入内存。 访问字段A。记录本页在一段时间内被访问的次数, 或记录本页最近已有多长时间未被访问。 修改位M。标记该页在调入内存后是否被修改过。 外存地址。记录该页在外存的存放地址。 缺页中断机构 在请求分页系统中, 每当要访问的页面不在内存时, 便产生一个缺页中断, 请求操作系统的缺页中断处理程序处理。此时缺页的进程阻塞, 放入阻塞队列, 调页完成后再将其唤醒, 放回就绪队列。若内存中有空闲页框, 则为进程分配一个页框, 将所缺页面从外存装入该页框, 并修改页表中相应的表项。若内存中没有空闲页框, 则由页面置换算法选择一个页面淘汰, 若该页在内存期间被修改过, 则还要将其写回外存。 与一般的中断相比, 它有以下两个明显的区别: 在指令执行期间而非一条指令执行完后产生和处理中断, 属于内部异常。 一条指令在执行期间, 可能产生多次缺页中断。 地址变换机构 在基本分页系统地址变换机构的基础上, 为实现虚拟内存, 增加了产生和处理缺页中断, 及从内存中换出一页的功能。 请求分页系统的地址变换过程如下: ① 先检索快表, 若命中, 则从相应表项中取出该页的物理块号, 并修改页表项中的访问位。 ② 若快表未命中, 则要到页表中查找, 若找到, 则从相应表项中取出物理块号, 并将该页表项写入快表。 ③ 若在页表中未找到, 则需要进行缺页中断处理, 请求系统将该页从外存换入内存, 页面被调入内存后, 由操作系统负责更新页表和快表, 并获得物理块号。 ④ 利用得到的物理块号和页内地址拼接形成物理地址, 用该地址去访存。",
    "create_time": 1761794316,
    "update_time": 1761794316,
    "_id": "doc-28a7b83e6af7f15e967e78c26eccf799"
  },
  "doc-c8697590fab35afe994351ccfc05bbac": {
    "content": "2. 逻辑地址与物理地址 编译后, 每个目标模块都从0号单元开始编址, 这称为该目标模块的相对地址(或逻辑地址)。当链接程序将各个模块链接成一个完整的可执行目标程序时, 链接程序顺序依次按各个模块的相对地址构成统一的从0号单元开始编址的逻辑地址空间(或虚拟地址空间)。进程在运行时, 看到和使用的地址都是逻辑地址。用户程序和程序员只需知道逻辑地址, 而内存管理的具体机制则是完全透明的。不同进程可以有相同的逻辑地址, 因为这些相同的逻辑地址可以映射到主存的不同位置。 物理地址空间是指内存中物理单元的集合, 它是地址转换的最终地址, 进程在运行时执行指令和访问数据, 最后都要通过物理地址从主存中存取。当装入程序将可执行代码装入内存时, 必须通过地址转换将逻辑地址转换成物理地址, 这个过程称为地址重定位。 操作系统通过内存管理部件(MMU)将进程使用的逻辑地址转换为物理地址。进程使用虚拟内存空间中的地址, 操作系统在相关硬件的协助下, 将它“转换”成真正的物理地址。逻辑地址通过页表映射到物理内存, 页表由操作系统维护并被处理器引用。",
    "create_time": 1761794316,
    "update_time": 1761794316,
    "_id": "doc-c8697590fab35afe994351ccfc05bbac"
  },
  "doc-f688f41802e3a8adfb553475e4ca265e": {
    "content": "10. 固定分区分配 固定分区分配是最简单的一种多道程序存储管理方式, 它将用户内存空间划分为若干固定大小的分区, 每个分区只装入一道作业。 在划分分区时有两种不同的方法。 分区大小相等。 分区大小不等。 为了便于分配和回收, 建立一张分区使用表。 这种方式存在两个问题: ①程序太大而放不进任何一个分区; ②当程序小于固定分区大小时, 也要占用一个完整的内存分区, 这样分区内部就存在空间浪费, 这种现象称为内部碎片。固定分区方式无外部碎片。",
    "create_time": 1761794316,
    "update_time": 1761794316,
    "_id": "doc-f688f41802e3a8adfb553475e4ca265e"
  },
  "doc-dd63fcc97211dcfcfa94d11eff1be6f8": {
    "content": "22. 虚拟存储器性能影响因素 缺页率是影响虚拟存储器性能的主要因素, 而缺页率又受到页面大小、分配给进程的物理块数、页面置换算法以及程序的编制方法的影响。 根据局部性原理, 页面较大则缺页率较低, 页面较小则缺页率较高。 分配给进程的物理块数越多, 缺页率就越低。 好的页面置换算法可使进程在运行过程中具有较低的缺页率。 写回磁盘的频率。在系统中建立一个已修改换出页面的链表, 可显著减少磁盘I/O的次数。 编写程序的局部化程度越高, 执行时的缺页率就越低。",
    "create_time": 1761794316,
    "update_time": 1761794316,
    "_id": "doc-dd63fcc97211dcfcfa94d11eff1be6f8"
  },
  "doc-fa7ddc38beb083a10e073654dee57a19": {
    "content": "7. 内存分配与回收 存储管理方式随着操作系统的发展而发展。在操作系统由单道向多道发展时, 存储管理方式便由单一连续分配发展为固定分区分配。为了能更好地适应不同大小的程序要求, 又从固定分区分配发展到动态分区分配。为了更好地提高内存的利用率, 进而从连续分配方式发展到离散分配方式——页式存储管理。引入分段存储管理的目的, 主要是满足用户在编程和使用方面的要求。",
    "create_time": 1761794316,
    "update_time": 1761794316,
    "_id": "doc-fa7ddc38beb083a10e073654dee57a19"
  },
  "doc-5479cc3e41d3a11f68f2cb90f11aab62": {
    "content": "8. 连续分配管理方式 连续分配方式是指为一个用户程序分配一个连续的内存空间。连续分配方式主要包括单一连续分配、固定分区分配和动态分区分配。",
    "create_time": 1761794316,
    "update_time": 1761794316,
    "_id": "doc-5479cc3e41d3a11f68f2cb90f11aab62"
  },
  "doc-67ae509cb7f3a2cdf2694e125b8725c3": {
    "content": "19. 抖动和工作集 抖动 在页面置换过程中, 刚刚换出的页面马上又要换入内存, 刚刚换入的页面马上又要换出内存, 这种频繁的页面调度行为称为抖动或颠簸。 系统发生抖动的根本原因是, 分配给每个进程的物理块太少, 不能满足进程正常运行的基本要求。 工作集 工作集是指在某段时间间隔内, 进程要访问的页面集合。工作集反映了进程在接下来的一段时间内很有可能频繁访问的页面集合, 因此驻留集大小不能小于工作集大小, 否则进程在运行过程中会频繁缺页。",
    "create_time": 1761794316,
    "update_time": 1761794316,
    "_id": "doc-67ae509cb7f3a2cdf2694e125b8725c3"
  },
  "doc-14a72f660cb4c5e34ac9c9ddaed64956": {
    "content": "13. 基本分段存储管理 分页管理方式是从计算机的角度考虑设计的, 分段管理方式的提出则考虑了用户和程序员, 以满足方便编程、信息保护和共享、动态增长及动态链接等多方面的需要。 分段 分段系统将用户进程的逻辑地址空间划分为大小不等的段。每段从0开始编址, 并分配一段连续的地址空间(段内要求连续, 段间不要求连续, 进程的地址空间是二维的)。 分段存储管理的逻辑地址结构由段号S与段内偏移量W两部分组成。 在分段系统中, 段号和段内偏移量必须由用户显式提供。 段表 每个进程都有一张逻辑空间与内存空间映射的段表, 进程的每个段对应一个段表项, 段表项记录了该段在内存中的始址和段的长度。 地址变换机构 在系统中设置了一个段表寄存器, 用于存放段表始址F和段表长度M。从逻辑地址到物理地址E之间的地址变换过程如下: ① 从逻辑地址A中取出前几位为段号S, 后几位为段内偏移量W。 ② 判断段号是否越界, 若段号S≥段表长度M, 则产生越界中断, 否则继续执行。 ③ 在段表中查询段号对应的段表项。取出段表项中该段的段长C, 若W≥C, 则产生越界中断, 否则继续执行。 ④ 取出段表项中该段的始址b, 计算物理地址 E=b+W, 用物理地址E去访存。 分页和分段的对比 页是信息的物理单位, 分页的主要目的是提高内存利用率, 对用户是不可见的。段是信息的逻辑单位, 分段的主要目的是更好地满足用户需求, 对用户是可见的。 页的大小固定且由系统决定。段的长度不固定, 具体取决于用户所编写的程序。 分页管理的地址空间是一维的。分段管理的地址空间是二维的。 段的共享与保护 在分段系统中, 为实现段共享, 在系统中配置一张共享段表, 所有共享的段都在共享段表中占一个表项。 可重入代码或纯代码是一种允许多个进程同时访问的代码。 与分页管理类似, 分段管理的保护方法主要有两种: 一种是存取控制保护, 另一种是地址越界保护。",
    "create_time": 1761794316,
    "update_time": 1761794316,
    "_id": "doc-14a72f660cb4c5e34ac9c9ddaed64956"
  },
  "doc-6a91872eefca67b87c6a12b37faf30eb": {
    "content": "5. 内存保护 确保每个进程都有一个单独的内存空间。内存分配前, 需要保护操作系统不受用户进程的影响, 同时保护用户进程不受其他用户进程的影响。内存保护可采取两种方法: 在CPU中设置一对上、下限寄存器, 存放用户进程在主存中的下限和上限地址, 每当CPU要访问一个地址时, 分别和两个寄存器的值相比, 判断有无越界。 采用重定位寄存器(也称基地址寄存器)和界地址寄存器(也称限长寄存器)进行越界检查。重定位寄存器中存放的是进程的起始物理地址, 界地址寄存器中存放的是进程的最大逻辑地址。内存管理部件将逻辑地址与界地址寄存器进行比较, 若未发生地址越界, 则加上重定位寄存器的值后映射成物理地址, 再送交内存单元。 加载重定位寄存器和界地址寄存器时必须使用特权指令, 只有操作系统内核才可以加载这两个存储器。",
    "create_time": 1761794316,
    "update_time": 1761794316,
    "_id": "doc-6a91872eefca67b87c6a12b37faf30eb"
  },
  "doc-00b255b459e05b4695b33c9dceed4321": {
    "content": "6. 内存共享 并不是所有的进程内存空间都适合共享, 只有那些只读的区域才可以共享。可重入代码也称纯代码, 是一种允许多个进程同时访问但不允许被任何进程修改的代码。但在实际执行时, 也可以为每个进程配以局部数据区, 将在执行中可能改变的部分复制到该数据区, 这样, 程序在执行时只需对该私有数据区中的内存进行修改, 并不去改变共享的代码。 在分页系统中, 为实现代码共享, 应在每个进程的页表中都建立页表项, 它们都指向共享代码区的物理页号。对于分段系统, 不管该段有多大, 都只需为该段设置一个段表项, 指向共享代码段始址。",
    "create_time": 1761794316,
    "update_time": 1761794316,
    "_id": "doc-00b255b459e05b4695b33c9dceed4321"
  },
  "doc-595c1a74214288cf8d47eda3bbc75afe": {
    "content": "4. 进程的内存映像 不同于存放在硬盘上的可执行程序文件, 当一个程序调入内存运行时, 就构成了进程的内存映像。一个进程的内存映像一般有几个要素: 代码段:即程序的二进制代码, 代码段是只读的, 可以被多个进程共享。 数据段:即程序运行时加工处理的对象, 包括全局变量和静态变量。 进程控制块(PCB):存放在系统区。操作系统通过PCB来控制和管理进程。 堆:用来存放动态分配的变量。通过调用malloc函数动态地向高地址分配空间。 栈:用来实现函数调用。从用户空间的最大地址往低地址方向增长。 代码段和数据段在程序调入内存时就指定了大小, 而堆和栈不一样。当调用像 malloc 和 free这样的C标准库函数时, 堆可以在运行时动态地扩展和收缩。用户栈在程序运行期间也可以动态地扩展和收缩。",
    "create_time": 1761794316,
    "update_time": 1761794316,
    "_id": "doc-595c1a74214288cf8d47eda3bbc75afe"
  }
}