{
  "doc-e9724523b61c71a64ad927ea59b8337a": {
    "status": "processed",
    "chunks_count": 1,
    "chunks_list": [
      "chunk-e9724523b61c71a64ad927ea59b8337a"
    ],
    "content_summary": "18. 页面置换算法 进程运行时, 若其访问的页面不在内存而需将其调入, 但内存已无空闲空间时, 就需要从内存中调出一页, 换出到外存。选择调出哪个页面的算法就称为页面置换算法。 最佳(OPT)置换算法 最佳置换算法选择淘汰的页面是以后永不使用的页面, 或是在最长时间内不再被访问的页面, 以便保证获得最低的缺页率。该算法无法实现。 先进先出(FIFO)页面置换算法 FIFO 算法选择淘汰的页面是最早进入内存的页面。该算法实现简单, 但与进程实际运行的规律不相适应, 性能较差。 FIFO 算法还会...",
    "content_length": 903,
    "created_at": "2025-10-30T03:18:36.776119+00:00",
    "updated_at": "2025-10-30T03:20:00.094660+00:00",
    "file_path": "unknown_source",
    "track_id": "insert_20251030_111836_47260344",
    "metadata": {
      "processing_start_time": 1761794316,
      "processing_end_time": 1761794400
    }
  },
  "doc-c6de281f0215ff49a87e3727a7c2bb2a": {
    "status": "processed",
    "chunks_count": 1,
    "chunks_list": [
      "chunk-c6de281f0215ff49a87e3727a7c2bb2a"
    ],
    "content_summary": "1. 内存管理的基本原理和要求 内存管理(Memory Management)是操作系统设计中最重要和最复杂的内容之一。虽然计算机硬件技术一直在飞速发展, 内存容量也在不断增大, 但仍然不可能将所有用户进程和系统所需要的全部程序与数据放入主存, 因此操作系统必须对内存空间进行合理的划分和有效的动态分配。操作系统对内存的划分和动态分配, 就是内存管理的概念。 有效的内存管理在多道程序设计中非常重要, 它不仅可以方便用户使用存储器、提高内存利用率, 还可以通过虚拟技术从逻辑上扩充存储器。内存管理的主...",
    "content_length": 539,
    "created_at": "2025-10-30T03:18:36.776056+00:00",
    "updated_at": "2025-10-30T03:19:42.775725+00:00",
    "file_path": "unknown_source",
    "track_id": "insert_20251030_111836_47260344",
    "metadata": {
      "processing_start_time": 1761794316,
      "processing_end_time": 1761794382
    }
  },
  "doc-5a8929ecef7cbf8892a009420c53322d": {
    "status": "processed",
    "chunks_count": 1,
    "chunks_list": [
      "chunk-5a8929ecef7cbf8892a009420c53322d"
    ],
    "content_summary": "21. 内存映射文件 内存映射文件(Memory-Mapped Files)是操作系统向应用程序提供的一个系统调用, 它与虚拟内存有些相似, 在磁盘文件与进程的虚拟地址空间之间建立映射关系。 进程通过该系统调用, 将一个文件映射到其虚拟地址空间的某个区域, 之后就能用访问内存的方式来读/写文件。磁盘文件的读/写由操作系统负责完成, 对进程而言是透明的。在映射进程的页面时, 不会实际读入文件的内容, 而只在访问页面时才被每次一页地读入。当进程退出或关闭文件映射时, 所有被改动的页面才被写回磁盘文件...",
    "content_length": 298,
    "created_at": "2025-10-30T03:18:36.776127+00:00",
    "updated_at": "2025-10-30T03:20:45.793123+00:00",
    "file_path": "unknown_source",
    "track_id": "insert_20251030_111836_47260344",
    "metadata": {
      "processing_start_time": 1761794382,
      "processing_end_time": 1761794445
    }
  },
  "doc-f59ab8ff80e1533c966b7cb6b20563dc": {
    "status": "processed",
    "chunks_count": 1,
    "chunks_list": [
      "chunk-f59ab8ff80e1533c966b7cb6b20563dc"
    ],
    "content_summary": "11. 动态分区分配 (1) 动态分区分配的基本原理 动态分区分配也称可变分区分配, 是指在进程装入内存时, 根据进程的实际需要, 动态地为之分配内存, 并使分区的大小正好适合进程的需要。 随着时间的推移, 内存中会产生越来越多的小内存块, 内存的利用率也随之下降。这些小内存块被称为外部碎片。外部碎片可通过紧凑技术来克服, 即操作系统不时地对进程进行移动和整理。 在动态分区分配中, 设置一张空闲分区链(表)。分配内存时, 检索空闲分区链, 找到所需的分区。回收内存时, 系统根据回收分区的始址, ...",
    "content_length": 840,
    "created_at": "2025-10-30T03:18:36.776099+00:00",
    "updated_at": "2025-10-30T03:21:19.866258+00:00",
    "file_path": "unknown_source",
    "track_id": "insert_20251030_111836_47260344",
    "metadata": {
      "processing_start_time": 1761794400,
      "processing_end_time": 1761794479
    }
  },
  "doc-c195ab08b96907e43c39705a88501db8": {
    "status": "processed",
    "chunks_count": 1,
    "chunks_list": [
      "chunk-c195ab08b96907e43c39705a88501db8"
    ],
    "content_summary": "14. 段页式存储管理 将分页存储管理和分段存储管理这两种方法结合起来, 便形成了段页式存储管理方式。 在段页式系统中, 进程的地址空间首先被分成若干逻辑段, 每段都有自己的段号, 然后将各段分成若干大小固定的页。对内存空间的管理仍然和分页存储管理一样, 将其分成若干和页面大小相同的物理块, 对内存的分配以物理块为单位。 在段页式系统中, 进程的逻辑地址分为三部分:段号、页号和页内偏移量。 为了实现地址变换, 系统为每个进程建立一张段表, 每个段对应一个段表项, 每个段有一张页表。系统中还应有一...",
    "content_length": 337,
    "created_at": "2025-10-30T03:18:36.776108+00:00",
    "updated_at": "2025-10-30T03:21:54.022791+00:00",
    "file_path": "unknown_source",
    "track_id": "insert_20251030_111836_47260344",
    "metadata": {
      "processing_start_time": 1761794445,
      "processing_end_time": 1761794514
    }
  },
  "doc-c09d18569a1b1c90198e18b0108e8c32": {
    "status": "processed",
    "chunks_count": 1,
    "chunks_list": [
      "chunk-c09d18569a1b1c90198e18b0108e8c32"
    ],
    "content_summary": "3. 程序的链接与装入 创建进程首先要将程序和数据装入内存。将用户源程序变为可在内存中执行的程序, 通常需要以下几个步骤: 编译。由编译程序将用户源代码编译成若干目标模块。 链接。由链接程序将编译后形成的一组目标模块, 以及它们所需的库函数链接在一起, 形成一个完整的装入模块。 装入。由装入程序将装入模块装入内存运行。 将一个装入模块装入内存时, 有以下三种装入方式。 (1) 绝对装入 绝对装入方式只适用于单道程序环境。在编译时, 若知道程序将放到内存的哪个位置, 则编译程序将产生绝对地址的目标...",
    "content_length": 1085,
    "created_at": "2025-10-30T03:18:36.776073+00:00",
    "updated_at": "2025-10-30T03:22:08.143954+00:00",
    "file_path": "unknown_source",
    "track_id": "insert_20251030_111836_47260344",
    "metadata": {
      "processing_start_time": 1761794479,
      "processing_end_time": 1761794528
    }
  },
  "doc-00e431215b94639001c5095d3c4f8b1c": {
    "status": "processed",
    "chunks_count": 1,
    "chunks_list": [
      "chunk-00e431215b94639001c5095d3c4f8b1c"
    ],
    "content_summary": "15. 虚拟内存的基本概念 传统存储管理方式的特征 它们都具有以下两个共同的特征: 一次性。作业必须一次性全部装入内存后, 才能开始运行。 驻留性。作业被装入内存后, 就一直驻留在内存中, 其任何部分都不会被换出, 直至作业运行结束。 局部性原理 时间局部性。程序中的某条指令一旦执行, 不久后该指令可能再次执行; 某数据被访问过, 不久后该数据可能再次被访问。 空间局部性。一旦程序访问了某个存储单元, 在不久后, 其附近的存储单元也将被访问。 虚拟内存技术实际上建立了“内存-外存”的两级存储器结...",
    "content_length": 910,
    "created_at": "2025-10-30T03:18:36.776111+00:00",
    "updated_at": "2025-10-30T03:22:51.088602+00:00",
    "file_path": "unknown_source",
    "track_id": "insert_20251030_111836_47260344",
    "metadata": {
      "processing_start_time": 1761794514,
      "processing_end_time": 1761794571
    }
  },
  "doc-3c9d6c4c9f8b1850281a50533371f77d": {
    "status": "processed",
    "chunks_count": 1,
    "chunks_list": [
      "chunk-3c9d6c4c9f8b1850281a50533371f77d"
    ],
    "content_summary": "20. 页框回收 页面缓冲算法 页面缓冲算法在原页面置换算法的基础上增设已修改页面链表, 保存已修改且需要被换出的页面, 等被换出的页面数量达到一定值时, 再一起换出到磁盘, 以减少页面换出的开销。 为了显著降低页面换入/换出的频率, 在内存中设置了如下两个链表: 空闲页面链表。当有一个未被修改的页面要换出时, 实际上并不将它换出到磁盘, 而将它所在的页框挂在空闲链表的链尾。 修改页面链表。当进程需要将一个已修改的页面换出时, 系统并不立即将它换出到磁盘, 而将它所在的页框挂在修改页面链表的末尾...",
    "content_length": 396,
    "created_at": "2025-10-30T03:18:36.776124+00:00",
    "updated_at": "2025-10-30T03:22:48.894258+00:00",
    "file_path": "unknown_source",
    "track_id": "insert_20251030_111836_47260344",
    "metadata": {
      "processing_start_time": 1761794528,
      "processing_end_time": 1761794568
    }
  },
  "doc-46462724e0de563d009072de78fa1d68": {
    "status": "processed",
    "chunks_count": 1,
    "chunks_list": [
      "chunk-46462724e0de563d009072de78fa1d68"
    ],
    "content_summary": "12. 基本分页存储管理 将内存空间分为若干固定大小的分区, 称为页框、页帧或物理块。进程的逻辑地址空间也分为与块大小相等的若干区域, 称为页或页面。操作系统以页框为单位为各个进程分配内存空间。 分页管理不产生外部碎片。但会产生内部碎片(页内碎片)。 分页存储的几个基本概念 (1) 页面和页面大小 进程的逻辑地址空间中的每个页面有一个编号, 称为页号, 从0开始:内存空间中的每个页框也有一个编号, 称为页框号(或物理块号), 也从0开始。 为方便地址转换, 页面大小应是2的整数次幂。 (2) 地...",
    "content_length": 1353,
    "created_at": "2025-10-30T03:18:36.776102+00:00",
    "updated_at": "2025-10-30T03:24:07.658808+00:00",
    "file_path": "unknown_source",
    "track_id": "insert_20251030_111836_47260344",
    "metadata": {
      "processing_start_time": 1761794569,
      "processing_end_time": 1761794647
    }
  },
  "doc-2fa1a754b848fd3412be2058c0482b68": {
    "status": "processed",
    "chunks_count": 1,
    "chunks_list": [
      "chunk-2fa1a754b848fd3412be2058c0482b68"
    ],
    "content_summary": "9. 单一连续分配 在单一连续分配方式中, 内存被分为系统区和用户区, 系统区仅供操作系统使用, 通常在低地址部分; 用户区内存中仅有一道用户程序, 即用户程序独占整个用户区。 这种方式的优点是简单、无外部碎片; 不需要进行内存保护。缺点是只能用于单用户、单任务的操作系统中; 有内部碎片; 内存的利用率极低。",
    "content_length": 155,
    "created_at": "2025-10-30T03:18:36.776092+00:00",
    "updated_at": "2025-10-30T03:23:39.493130+00:00",
    "file_path": "unknown_source",
    "track_id": "insert_20251030_111836_47260344",
    "metadata": {
      "processing_start_time": 1761794571,
      "processing_end_time": 1761794619
    }
  },
  "doc-abb4ec292dd5335d76c0413487939cbe": {
    "status": "processed",
    "chunks_count": 1,
    "chunks_list": [
      "chunk-abb4ec292dd5335d76c0413487939cbe"
    ],
    "content_summary": "17. 页框分配 驻留集大小 对于分页式的虚拟内存, 操作系统必须决定给特定的进程分配几个页框。给一个进程分配的页框的集合就是这个进程的驻留集。 驻留集越小, 驻留在内存中的进程就越多, 可以提高多道程序的并发度, 但分配给每个进程的页框太少, 会导致缺页率较高。 驻留集越大, 当分配给进程的页框超过某个数量时, 再为进程增加页框对缺页率的改善是不明显的, 反而只能是浪费内存空间。 内存分配策略 在请求分页系统中, 可采取两种内存分配策略, 即固定和可变分配策略。在进行置换时, 也可采取两种策略...",
    "content_length": 1024,
    "created_at": "2025-10-30T03:18:36.776116+00:00",
    "updated_at": "2025-10-30T03:24:23.884716+00:00",
    "file_path": "unknown_source",
    "track_id": "insert_20251030_111836_47260344",
    "metadata": {
      "processing_start_time": 1761794619,
      "processing_end_time": 1761794663
    }
  },
  "doc-28a7b83e6af7f15e967e78c26eccf799": {
    "status": "processed",
    "chunks_count": 1,
    "chunks_list": [
      "chunk-28a7b83e6af7f15e967e78c26eccf799"
    ],
    "content_summary": "16. 请求分页管理方式 请求分页系统建立在基本分页系统的基础之上, 为支持虚拟存储器功能而增加了请求调页和页面置换功能。 页表机制 在请求页表项中增加了4个字段。 状态位P。标记该页是否已调入内存。 访问字段A。记录本页在一段时间内被访问的次数, 或记录本页最近已有多长时间未被访问。 修改位M。标记该页在调入内存后是否被修改过。 外存地址。记录该页在外存的存放地址。 缺页中断机构 在请求分页系统中, 每当要访问的页面不在内存时, 便产生一个缺页中断, 请求操作系统的缺页中断处理程序处理。此时缺...",
    "content_length": 757,
    "created_at": "2025-10-30T03:18:36.776113+00:00",
    "updated_at": "2025-10-30T03:24:45.961540+00:00",
    "file_path": "unknown_source",
    "track_id": "insert_20251030_111836_47260344",
    "metadata": {
      "processing_start_time": 1761794647,
      "processing_end_time": 1761794685
    }
  },
  "doc-c8697590fab35afe994351ccfc05bbac": {
    "status": "processed",
    "chunks_count": 1,
    "chunks_list": [
      "chunk-c8697590fab35afe994351ccfc05bbac"
    ],
    "content_summary": "2. 逻辑地址与物理地址 编译后, 每个目标模块都从0号单元开始编址, 这称为该目标模块的相对地址(或逻辑地址)。当链接程序将各个模块链接成一个完整的可执行目标程序时, 链接程序顺序依次按各个模块的相对地址构成统一的从0号单元开始编址的逻辑地址空间(或虚拟地址空间)。进程在运行时, 看到和使用的地址都是逻辑地址。用户程序和程序员只需知道逻辑地址, 而内存管理的具体机制则是完全透明的。不同进程可以有相同的逻辑地址, 因为这些相同的逻辑地址可以映射到主存的不同位置。 物理地址空间是指内存中物理单元的...",
    "content_length": 469,
    "created_at": "2025-10-30T03:18:36.776069+00:00",
    "updated_at": "2025-10-30T03:25:10.969981+00:00",
    "file_path": "unknown_source",
    "track_id": "insert_20251030_111836_47260344",
    "metadata": {
      "processing_start_time": 1761794663,
      "processing_end_time": 1761794710
    }
  },
  "doc-f688f41802e3a8adfb553475e4ca265e": {
    "status": "processed",
    "chunks_count": 1,
    "chunks_list": [
      "chunk-f688f41802e3a8adfb553475e4ca265e"
    ],
    "content_summary": "10. 固定分区分配 固定分区分配是最简单的一种多道程序存储管理方式, 它将用户内存空间划分为若干固定大小的分区, 每个分区只装入一道作业。 在划分分区时有两种不同的方法。 分区大小相等。 分区大小不等。 为了便于分配和回收, 建立一张分区使用表。 这种方式存在两个问题: ①程序太大而放不进任何一个分区; ②当程序小于固定分区大小时, 也要占用一个完整的内存分区, 这样分区内部就存在空间浪费, 这种现象称为内部碎片。固定分区方式无外部碎片。",
    "content_length": 222,
    "created_at": "2025-10-30T03:18:36.776095+00:00",
    "updated_at": "2025-10-30T03:25:23.073462+00:00",
    "file_path": "unknown_source",
    "track_id": "insert_20251030_111836_47260344",
    "metadata": {
      "processing_start_time": 1761794685,
      "processing_end_time": 1761794723
    }
  },
  "doc-dd63fcc97211dcfcfa94d11eff1be6f8": {
    "status": "processed",
    "chunks_count": 1,
    "chunks_list": [
      "chunk-dd63fcc97211dcfcfa94d11eff1be6f8"
    ],
    "content_summary": "22. 虚拟存储器性能影响因素 缺页率是影响虚拟存储器性能的主要因素, 而缺页率又受到页面大小、分配给进程的物理块数、页面置换算法以及程序的编制方法的影响。 根据局部性原理, 页面较大则缺页率较低, 页面较小则缺页率较高。 分配给进程的物理块数越多, 缺页率就越低。 好的页面置换算法可使进程在运行过程中具有较低的缺页率。 写回磁盘的频率。在系统中建立一个已修改换出页面的链表, 可显著减少磁盘I/O的次数。 编写程序的局部化程度越高, 执行时的缺页率就越低。",
    "content_length": 230,
    "created_at": "2025-10-30T03:18:36.776129+00:00",
    "updated_at": "2025-10-30T03:26:03.977907+00:00",
    "file_path": "unknown_source",
    "track_id": "insert_20251030_111836_47260344",
    "metadata": {
      "processing_start_time": 1761794711,
      "processing_end_time": 1761794763
    }
  },
  "doc-fa7ddc38beb083a10e073654dee57a19": {
    "status": "processed",
    "chunks_count": 1,
    "chunks_list": [
      "chunk-fa7ddc38beb083a10e073654dee57a19"
    ],
    "content_summary": "7. 内存分配与回收 存储管理方式随着操作系统的发展而发展。在操作系统由单道向多道发展时, 存储管理方式便由单一连续分配发展为固定分区分配。为了能更好地适应不同大小的程序要求, 又从固定分区分配发展到动态分区分配。为了更好地提高内存的利用率, 进而从连续分配方式发展到离散分配方式——页式存储管理。引入分段存储管理的目的, 主要是满足用户在编程和使用方面的要求。",
    "content_length": 181,
    "created_at": "2025-10-30T03:18:36.776086+00:00",
    "updated_at": "2025-10-30T03:26:03.763991+00:00",
    "file_path": "unknown_source",
    "track_id": "insert_20251030_111836_47260344",
    "metadata": {
      "processing_start_time": 1761794723,
      "processing_end_time": 1761794763
    }
  },
  "doc-5479cc3e41d3a11f68f2cb90f11aab62": {
    "status": "processed",
    "chunks_count": 1,
    "chunks_list": [
      "chunk-5479cc3e41d3a11f68f2cb90f11aab62"
    ],
    "content_summary": "8. 连续分配管理方式 连续分配方式是指为一个用户程序分配一个连续的内存空间。连续分配方式主要包括单一连续分配、固定分区分配和动态分区分配。",
    "content_length": 70,
    "created_at": "2025-10-30T03:18:36.776089+00:00",
    "updated_at": "2025-10-30T03:26:27.066123+00:00",
    "file_path": "unknown_source",
    "track_id": "insert_20251030_111836_47260344",
    "metadata": {
      "processing_start_time": 1761794763,
      "processing_end_time": 1761794787
    }
  },
  "doc-67ae509cb7f3a2cdf2694e125b8725c3": {
    "status": "processed",
    "chunks_count": 1,
    "chunks_list": [
      "chunk-67ae509cb7f3a2cdf2694e125b8725c3"
    ],
    "content_summary": "19. 抖动和工作集 抖动 在页面置换过程中, 刚刚换出的页面马上又要换入内存, 刚刚换入的页面马上又要换出内存, 这种频繁的页面调度行为称为抖动或颠簸。 系统发生抖动的根本原因是, 分配给每个进程的物理块太少, 不能满足进程正常运行的基本要求。 工作集 工作集是指在某段时间间隔内, 进程要访问的页面集合。工作集反映了进程在接下来的一段时间内很有可能频繁访问的页面集合, 因此驻留集大小不能小于工作集大小, 否则进程在运行过程中会频繁缺页。",
    "content_length": 221,
    "created_at": "2025-10-30T03:18:36.776122+00:00",
    "updated_at": "2025-10-30T03:26:37.363027+00:00",
    "file_path": "unknown_source",
    "track_id": "insert_20251030_111836_47260344",
    "metadata": {
      "processing_start_time": 1761794764,
      "processing_end_time": 1761794797
    }
  },
  "doc-14a72f660cb4c5e34ac9c9ddaed64956": {
    "status": "processed",
    "chunks_count": 1,
    "chunks_list": [
      "chunk-14a72f660cb4c5e34ac9c9ddaed64956"
    ],
    "content_summary": "13. 基本分段存储管理 分页管理方式是从计算机的角度考虑设计的, 分段管理方式的提出则考虑了用户和程序员, 以满足方便编程、信息保护和共享、动态增长及动态链接等多方面的需要。 分段 分段系统将用户进程的逻辑地址空间划分为大小不等的段。每段从0开始编址, 并分配一段连续的地址空间(段内要求连续, 段间不要求连续, 进程的地址空间是二维的)。 分段存储管理的逻辑地址结构由段号S与段内偏移量W两部分组成。 在分段系统中, 段号和段内偏移量必须由用户显式提供。 段表 每个进程都有一张逻辑空间与内存空间...",
    "content_length": 808,
    "created_at": "2025-10-30T03:18:36.776104+00:00",
    "updated_at": "2025-10-30T03:27:47.888738+00:00",
    "file_path": "unknown_source",
    "track_id": "insert_20251030_111836_47260344",
    "metadata": {
      "processing_start_time": 1761794787,
      "processing_end_time": 1761794867
    }
  },
  "doc-6a91872eefca67b87c6a12b37faf30eb": {
    "status": "processed",
    "chunks_count": 1,
    "chunks_list": [
      "chunk-6a91872eefca67b87c6a12b37faf30eb"
    ],
    "content_summary": "5. 内存保护 确保每个进程都有一个单独的内存空间。内存分配前, 需要保护操作系统不受用户进程的影响, 同时保护用户进程不受其他用户进程的影响。内存保护可采取两种方法: 在CPU中设置一对上、下限寄存器, 存放用户进程在主存中的下限和上限地址, 每当CPU要访问一个地址时, 分别和两个寄存器的值相比, 判断有无越界。 采用重定位寄存器(也称基地址寄存器)和界地址寄存器(也称限长寄存器)进行越界检查。重定位寄存器中存放的是进程的起始物理地址, 界地址寄存器中存放的是进程的最大逻辑地址。内存管理部件...",
    "content_length": 354,
    "created_at": "2025-10-30T03:18:36.776080+00:00",
    "updated_at": "2025-10-30T03:26:56.471000+00:00",
    "file_path": "unknown_source",
    "track_id": "insert_20251030_111836_47260344",
    "metadata": {
      "processing_start_time": 1761794797,
      "processing_end_time": 1761794816
    }
  },
  "doc-00b255b459e05b4695b33c9dceed4321": {
    "status": "processed",
    "chunks_count": 1,
    "chunks_list": [
      "chunk-00b255b459e05b4695b33c9dceed4321"
    ],
    "content_summary": "6. 内存共享 并不是所有的进程内存空间都适合共享, 只有那些只读的区域才可以共享。可重入代码也称纯代码, 是一种允许多个进程同时访问但不允许被任何进程修改的代码。但在实际执行时, 也可以为每个进程配以局部数据区, 将在执行中可能改变的部分复制到该数据区, 这样, 程序在执行时只需对该私有数据区中的内存进行修改, 并不去改变共享的代码。 在分页系统中, 为实现代码共享, 应在每个进程的页表中都建立页表项, 它们都指向共享代码区的物理页号。对于分段系统, 不管该段有多大, 都只需为该段设置一个段表...",
    "content_length": 263,
    "created_at": "2025-10-30T03:18:36.776083+00:00",
    "updated_at": "2025-10-30T03:27:45.382238+00:00",
    "file_path": "unknown_source",
    "track_id": "insert_20251030_111836_47260344",
    "metadata": {
      "processing_start_time": 1761794816,
      "processing_end_time": 1761794865
    }
  },
  "doc-595c1a74214288cf8d47eda3bbc75afe": {
    "status": "processed",
    "chunks_count": 1,
    "chunks_list": [
      "chunk-595c1a74214288cf8d47eda3bbc75afe"
    ],
    "content_summary": "4. 进程的内存映像 不同于存放在硬盘上的可执行程序文件, 当一个程序调入内存运行时, 就构成了进程的内存映像。一个进程的内存映像一般有几个要素: 代码段:即程序的二进制代码, 代码段是只读的, 可以被多个进程共享。 数据段:即程序运行时加工处理的对象, 包括全局变量和静态变量。 进程控制块(PCB):存放在系统区。操作系统通过PCB来控制和管理进程。 堆:用来存放动态分配的变量。通过调用malloc函数动态地向高地址分配空间。 栈:用来实现函数调用。从用户空间的最大地址往低地址方向增长。 代码...",
    "content_length": 347,
    "created_at": "2025-10-30T03:18:36.776076+00:00",
    "updated_at": "2025-10-30T03:28:07.283188+00:00",
    "file_path": "unknown_source",
    "track_id": "insert_20251030_111836_47260344",
    "metadata": {
      "processing_start_time": 1761794865,
      "processing_end_time": 1761794887
    }
  }
}