{
  "doc-5f130d8e8cad5fdb4c75e49961444322": {
    "status": "processed",
    "chunks_count": 1,
    "chunks_list": [
      "chunk-5f130d8e8cad5fdb4c75e49961444322"
    ],
    "content_summary": "16. 信号量 信号量机制是一种功能较强的机制, 可用来解决互斥与同步问题, 它只能被两个标准的原语wait()和 signal()访问, 也可简写为P()和V()。 原语是指完成某种功能且不被分割、不被中断执行的操作序列, 通常可由硬件来实现。 整型信号量 整型信号量被定义为一个用于表示资源数量的整型量S。在整型信号量机制中的wait 操作, 只要信号量S≤0, 就会不断循环测试。因此, 该机制并未遵循“让权等待”的准则, 而是使进程处于“忙等”的状态。 记录型信号量 记录型信号量机制是一种不...",
    "content_length": 778,
    "created_at": "2025-10-30T03:02:25.469474+00:00",
    "updated_at": "2025-10-30T03:04:08.547874+00:00",
    "file_path": "unknown_source",
    "track_id": "insert_20251030_110225_46621544",
    "metadata": {
      "processing_start_time": 1761793345,
      "processing_end_time": 1761793448
    }
  },
  "doc-c98a5fa2e2c907903ada408db717755c": {
    "status": "processed",
    "chunks_count": 2,
    "chunks_list": [
      "chunk-1b524b2458aae3cb2440c44f7981f746",
      "chunk-361e96af48cd5d95ba6650e6d3810455"
    ],
    "content_summary": "11. CPU 调度算法 先来先服务(FCFS)调度算法 FCFS 调度算法是一种最简单的调度算法, 它既可用于作业调度, 又可用于进程调度。 在作业调度中, FCFS调度算法每次从后备作业队列中选择最先进入该队列的一个或几个作业, 将它们调入内存, 分配必要的资源, 创建进程并放入就绪队列。 在进程调度中, FCFS调度算法每次从就绪队列中选择最先进入该队列的进程, 将CPU分配给它, 使之投入运行, 直到运行完成或因某种原因此阻塞时才释放CPU。 FCFS 调度算法属于不可剥夺算法。若一个长...",
    "content_length": 2454,
    "created_at": "2025-10-30T03:02:25.469461+00:00",
    "updated_at": "2025-10-30T03:04:40.015769+00:00",
    "file_path": "unknown_source",
    "track_id": "insert_20251030_110225_46621544",
    "metadata": {
      "processing_start_time": 1761793345,
      "processing_end_time": 1761793480
    }
  },
  "doc-d9ae7922752a96dfde647be32905f641": {
    "status": "processed",
    "chunks_count": 1,
    "chunks_list": [
      "chunk-d9ae7922752a96dfde647be32905f641"
    ],
    "content_summary": "14. 实现临界区互斥的基本方法 软件实现方法 在进入区设置并检查一些标志来标明是否有进程在临界区中, 若已有进程在临界区, 则在进入区通过循环检查进行等待, 进程离开临界区后则在退出区修改标志。 (1) 算法一:单标志法 该算法设置一个公用整型变量 turn, 指示允许进入临界区的进程编号。该算法可以实现每次只允许一个进程进入临界区。但两个进程必须交替进入临界区, 若某个进程不再进入临界区, 则另一个进程也将无法进入临界区(违背“空闲让进”准则)。 (2) 算法二:双标志先检查法 该算法设置一...",
    "content_length": 1100,
    "created_at": "2025-10-30T03:02:25.469469+00:00",
    "updated_at": "2025-10-30T03:05:56.800603+00:00",
    "file_path": "unknown_source",
    "track_id": "insert_20251030_110225_46621544",
    "metadata": {
      "processing_start_time": 1761793448,
      "processing_end_time": 1761793556
    }
  },
  "doc-77d7b8e6f06999efb089a2a4176d1434": {
    "status": "processed",
    "chunks_count": 1,
    "chunks_list": [
      "chunk-77d7b8e6f06999efb089a2a4176d1434"
    ],
    "content_summary": "18. 管程 在信号量机制中, 每个要访问临界资源的进程都必须自备同步的PV操作, 大量分散的同步操作给系统管理带来了麻烦, 且容易因同步操作不当而导致系统死锁。于是, 便产生了一种新的进程同步工具——————管程。 管程的定义 利用共享数据结构抽象地表示系统中的共享资源, 而将对该数据结构实施的操作定义为一组过程。这个代表共享资源的数据结构, 以及由对该共享数据结构实施操作的一组过程所组成的资源管理程序, 称为管程(monitor)。 管程由4部分组成:①管程的名称;②局部于管程内部的共享数据...",
    "content_length": 613,
    "created_at": "2025-10-30T03:02:25.469479+00:00",
    "updated_at": "2025-10-30T03:05:41.578179+00:00",
    "file_path": "unknown_source",
    "track_id": "insert_20251030_110225_46621544",
    "metadata": {
      "processing_start_time": 1761793480,
      "processing_end_time": 1761793541
    }
  },
  "doc-156e9bc4a555d2a7cb0d3724273d5ea6": {
    "status": "processed",
    "chunks_count": 1,
    "chunks_list": [
      "chunk-156e9bc4a555d2a7cb0d3724273d5ea6"
    ],
    "content_summary": "3. 进程的状态与转换 进程在其生命周期内, 由于系统中各个进程之间的相互制约及系统的运行环境的变化, 使得进程的状态也在不断地发生变化。通常进程有以下5种状态, 前3种是进程的基本状态。 运行态。进程正在CPU上运行。在单CPU中, 每个时刻只有一个进程处于运行态。 就绪态。进程获得了除CPU外的一切所需资源, 一旦得到CPU, 便可立即运行。系统中处于就绪态的进程可能有多个, 通常将它们排成一个队列, 称为就绪队列。 阻塞态, 也称等待态。进程正在等待某一事件而暂停运行, 如等待某个资源可用...",
    "content_length": 1063,
    "created_at": "2025-10-30T03:02:25.469437+00:00",
    "updated_at": "2025-10-30T03:06:57.024212+00:00",
    "file_path": "unknown_source",
    "track_id": "insert_20251030_110225_46621544",
    "metadata": {
      "processing_start_time": 1761793541,
      "processing_end_time": 1761793617
    }
  },
  "doc-d3e84198ebbd072f7382ef600186508e": {
    "status": "processed",
    "chunks_count": 1,
    "chunks_list": [
      "chunk-d3e84198ebbd072f7382ef600186508e"
    ],
    "content_summary": "17. 经典同步问题 生产者-消费者问题 问题描述:系统中有一组生产者进程和一组消费者进程, 生产者每次生产一个产品并放入缓冲区, 消费者每次从缓冲区中取出一个产品并消费。生产者和消费者共享一个初始为空、大小为n的缓冲区。只有当缓冲区不满时, 生产者才能将产品放入缓冲区;只有当缓冲区不空时, 消费者才能从中取出产品。缓冲区是临界资源, 各进程必须互斥访问。 问题分析:生产者和消费者对缓冲区的访问是互斥关系, 同时生产者和消费者又是一个相互协作的关系, 只有生产者生产之后, 消费者才能消费, 它们...",
    "content_length": 769,
    "created_at": "2025-10-30T03:02:25.469476+00:00",
    "updated_at": "2025-10-30T03:07:19.940563+00:00",
    "file_path": "unknown_source",
    "track_id": "insert_20251030_110225_46621544",
    "metadata": {
      "processing_start_time": 1761793556,
      "processing_end_time": 1761793639
    }
  },
  "doc-f326031f0d80f48ea7bc3e6da1a5f8a4": {
    "status": "processed",
    "chunks_count": 1,
    "chunks_list": [
      "chunk-f326031f0d80f48ea7bc3e6da1a5f8a4"
    ],
    "content_summary": "12. 多处理机调度 多处理机系统的调度较单处理机系统复杂, 它与系统结构有关。 非对称多处理机(Asymmetric MultiProcessing, AMP)大多采用主从式操作系统, 内核驻留在主机上, 而从机上只运行用户程序, 进程调度由主机负责。 对称多处理机(Symmetric MultiProcessing,SMP)的所有处理机都是相同的, 因此由调度程序将任何一个进程分配给任何一个CPU。 亲和性和负载平衡 当一个进程从一个CPU移到其他CPU上时, 应将第一个CPU的缓存设置为无...",
    "content_length": 540,
    "created_at": "2025-10-30T03:02:25.469463+00:00",
    "updated_at": "2025-10-30T03:07:55.672649+00:00",
    "file_path": "unknown_source",
    "track_id": "insert_20251030_110225_46621544",
    "metadata": {
      "processing_start_time": 1761793617,
      "processing_end_time": 1761793675
    }
  },
  "doc-e16dceff2fc93c138aa86eb65cacc6c7": {
    "status": "processed",
    "chunks_count": 1,
    "chunks_list": [
      "chunk-e16dceff2fc93c138aa86eb65cacc6c7"
    ],
    "content_summary": "15. 互斥锁 解决临界区最简单的工具就是互斥锁(mutexlock)。一个进程在进入临界区时调用 acquire()函数, 以获得锁;在退出临界区时调用 release()函数, 以释放锁。每个互斥锁有一个布尔变量 available, 表示锁是否可用。 acquire()或 release()的执行必须是原子操作, 因此互斥锁通常采用硬件机制来实现。 上面描述的互斥锁也称自旋锁, 其主要缺点是忙等待。互斥锁通常用于多处理器系统。",
    "content_length": 218,
    "created_at": "2025-10-30T03:02:25.469472+00:00",
    "updated_at": "2025-10-30T03:08:04.798562+00:00",
    "file_path": "unknown_source",
    "track_id": "insert_20251030_110225_46621544",
    "metadata": {
      "processing_start_time": 1761793639,
      "processing_end_time": 1761793684
    }
  },
  "doc-c39617d7522bbe85482a3d992382cd4b": {
    "status": "processed",
    "chunks_count": 1,
    "chunks_list": [
      "chunk-c39617d7522bbe85482a3d992382cd4b"
    ],
    "content_summary": "7. 调度的概念 调度的基本概念 在多道程序系统中, 进程的数量往往多于CPU的个数, 因此进程争用CPU的情况在所难免。 CPU 调度是对CPU进行分配, 即从就绪队列中按照一定的算法(公平、高效的原则)选择一个进程并将CPU分配给它运行, 以实现进程并发地执行。 CPU 调度是多道程序操作系统的基础, 是操作系统设计的核心问题。 调度的层次 一个作业从提交开始直到完成, 往往要经历以下三级调度。 (1) 高级调度(作业调度) 按照某种规则从外存上处于后备队列的作业中挑选一个(或多个), 给它...",
    "content_length": 890,
    "created_at": "2025-10-30T03:02:25.469451+00:00",
    "updated_at": "2025-10-30T03:09:50.241008+00:00",
    "file_path": "unknown_source",
    "track_id": "insert_20251030_110225_46621544",
    "metadata": {
      "processing_start_time": 1761793675,
      "processing_end_time": 1761793790
    }
  },
  "doc-96612cb99be5ccc8684e38f3d50f77f5": {
    "status": "processed",
    "chunks_count": 1,
    "chunks_list": [
      "chunk-96612cb99be5ccc8684e38f3d50f77f5"
    ],
    "content_summary": "13. 同步与互斥的基本概念 在多道程序环境下, 进程是并发执行的, 不同进程之间存在着不同的相互制约关系。为了协调进程之间的相互制约关系, 引入了进程同步的概念。 临界资源 虽然多个进程可以共享系统中的各种资源, 但其中许多资源一次只能为一个进程所用, 我们将一次仅允许一个进程使用的资源称为临界资源。 对临界资源的访问, 必须互斥地进行, 在每个进程中, 访问临界资源的那段代码称为临界区。 为了保证临界资源的正确使用, 可将临界资源的访问过程分成4个部分: 进入区。为了进入临界区使用临界资源,...",
    "content_length": 731,
    "created_at": "2025-10-30T03:02:25.469466+00:00",
    "updated_at": "2025-10-30T03:09:10.878167+00:00",
    "file_path": "unknown_source",
    "track_id": "insert_20251030_110225_46621544",
    "metadata": {
      "processing_start_time": 1761793684,
      "processing_end_time": 1761793750
    }
  },
  "doc-b5aa6485f08fa52f1ae6912e99884079": {
    "status": "processed",
    "chunks_count": 1,
    "chunks_list": [
      "chunk-b5aa6485f08fa52f1ae6912e99884079"
    ],
    "content_summary": "22. 死锁检测和解除 死锁检测 死锁检测和解除是指系统在运行过程中, 能发现死锁的存在, 并能解除死锁。 为了能对系统是否已发生了死锁进行检测, 必须: 保存有关资源的请求和分配信息。 提供一种能利用这些信息去检测系统是否已进入死锁状态的算法。 死锁解除 死锁解除的主要方法有: 剥夺资源。从其他进程剥夺足够数量的资源给死锁进程, 以解除死锁状态。 撤销进程。最简单的方法是撤销全部死锁进程, 但代价太大。另一种方法是逐个撤销死锁进程, 直至死锁状态消除。 进程回退。让一个或多个进程回退到足以避免...",
    "content_length": 296,
    "created_at": "2025-10-30T03:02:25.469488+00:00",
    "updated_at": "2025-10-30T03:09:45.944981+00:00",
    "file_path": "unknown_source",
    "track_id": "insert_20251030_110225_46621544",
    "metadata": {
      "processing_start_time": 1761793750,
      "processing_end_time": 1761793785
    }
  },
  "doc-fd78a6e2f6ac315b1d1c2a02efb03591": {
    "status": "processed",
    "chunks_count": 1,
    "chunks_list": [
      "chunk-fd78a6e2f6ac315b1d1c2a02efb03591"
    ],
    "content_summary": "21. 死锁避免 避免死锁同样是事先预防策略, 但它并不像死锁预防策略那样严格地限制进程对资源的访问, 而是在每次资源分配前, 先分析此次分配是否会使系统进入不安全状态, 若不会, 才将资源分配给它。 系统安全状态 所谓系统安全状态, 是指系统能按某种进程推进顺序, 为每个进程分配其所需资源, 直至满足每个进程对资源的最大需求, 使每个进程都可顺利地完成。 若系统无法找到这样一个安全序列, 则称系统处于不安全状态。 银行家算法 银行家算法是著名的死锁避免算法, 其思想是:操作系统视为银行家, 操...",
    "content_length": 290,
    "created_at": "2025-10-30T03:02:25.469485+00:00",
    "updated_at": "2025-10-30T03:10:26.664421+00:00",
    "file_path": "unknown_source",
    "track_id": "insert_20251030_110225_46621544",
    "metadata": {
      "processing_start_time": 1761793785,
      "processing_end_time": 1761793826
    }
  },
  "doc-3cb253a00dc29a6f3e799f512507d052": {
    "status": "processed",
    "chunks_count": 2,
    "chunks_list": [
      "chunk-d75ea791c964266b65c0ee55b3a8e15f",
      "chunk-c214e070db9e1fbcd76d28e9e144db30"
    ],
    "content_summary": "5. 进程的通信 进程通信是指进程之间的信息交换。PV操作(见2.3节)是低级通信方式, 高级通信方式是指以较高的效率传输大量数据的通信方式。高级通信方法主要有以下三类。 共享存储 在通信的进程之间存在一块可直接访问的共享空间, 通过对这片共享空间进行读/写操作实现进程之间的信息交换。在对共享空间进行读/写操作时, 需要使用同步互斥工具(如P操作、V操作)对共享空间的读/写进行控制。共享存储又分为两种:低级方式的共享是基于数据结构的共享:高级方式的共享则是基于存储区的共享。操作系统只负责为通信进...",
    "content_length": 1859,
    "created_at": "2025-10-30T03:02:25.469446+00:00",
    "updated_at": "2025-10-30T03:11:10.761866+00:00",
    "file_path": "unknown_source",
    "track_id": "insert_20251030_110225_46621544",
    "metadata": {
      "processing_start_time": 1761793790,
      "processing_end_time": 1761793870
    }
  },
  "doc-487071d7bc0418a368cd03f9a4b87b27": {
    "status": "processed",
    "chunks_count": 3,
    "chunks_list": [
      "chunk-e2c5907dce4f167e0b11853c616e448f",
      "chunk-34425c38108ef3730cc0889df3f8434a",
      "chunk-f910452b3163456182b06ef94a84992f"
    ],
    "content_summary": "6. 线程和多线程模型 线程的基本概念 引入进程的目的是更好地使多道程序并发执行, 提高资源利用率和系统吞吐量; 而引入线程(Threads)的目的则是减小程序在并发执行时所付出的时空开销, 提高操作系统的并发性能。 线程最直接的理解就是轻量级进程, 它是一个基本的CPU执行单元, 也是程序执行流的最小单元, 由线程ID、程序计数器、寄存器集合和堆栈组成。线程是进程中的一个实体, 是被系统独立调度和分派的基本单位, 线程自己不拥有系统资源, 只拥有一点儿在运行中必不可少的资源, 但它可与同属一个...",
    "content_length": 3749,
    "created_at": "2025-10-30T03:02:25.469448+00:00",
    "updated_at": "2025-10-30T03:12:19.727039+00:00",
    "file_path": "unknown_source",
    "track_id": "insert_20251030_110225_46621544",
    "metadata": {
      "processing_start_time": 1761793826,
      "processing_end_time": 1761793939
    }
  },
  "doc-9aabe855c161e30442ff85ca7a64312e": {
    "status": "processed",
    "chunks_count": 1,
    "chunks_list": [
      "chunk-9aabe855c161e30442ff85ca7a64312e"
    ],
    "content_summary": "19. 死锁的概念 死锁的定义 在多道程序系统中, 由于进程的并发执行, 极大地提升了系统效率。然而, 多个进程的并发执行也带来了新的问题——死锁。死锁, 是指多个进程因竞争资源而造成的一种僵局(互相等待), 若无外力干涉, 这些进程都将无法向前推进。 死锁和饥饿的共同点是进程无法顺利执行下去。 死锁和饥饿的主要差别:①死锁进程的集合中的每一个进程都在等待被该集合中的其他进程所占有的资源, 而饥饿的进程仅在等待被其他进程所占有的资源。②若有死锁现象, 则发生死锁的进程必然处于等待态, 也可能处于...",
    "content_length": 647,
    "created_at": "2025-10-30T03:02:25.469481+00:00",
    "updated_at": "2025-10-30T03:12:52.062345+00:00",
    "file_path": "unknown_source",
    "track_id": "insert_20251030_110225_46621544",
    "metadata": {
      "processing_start_time": 1761793870,
      "processing_end_time": 1761793972
    }
  },
  "doc-491042f5eab097ef962a4657a4b61650": {
    "status": "processed",
    "chunks_count": 2,
    "chunks_list": [
      "chunk-491042f5eab097ef962a4657a4b61650",
      "chunk-78245f9f1818877740dc30da5ae2c6e1"
    ],
    "content_summary": "8. 调度的实现 调度程序(调度器) 用于调度和分派CPU的组件称为调度程序, 它通常由三部分组成。 排队器。将系统中的所有就绪进程按照一定的策略排成一个或多个队列, 以便于调度程序选择。 分派器。依据调度程序所选的进程, 将其从就绪队列中取出, 将CPU分配给新进程。 上下文切换器。在对CPU进行切换时, 会发生两对上下文的切换操作:第一对, 将当前进程的上下文保存到其PCB中, 再装入分派程序的上下文, 以便分派程序运行;第二对, 移出分派程序的上下文, 将新选进程的CPU现场信息装入CPU...",
    "content_length": 1439,
    "created_at": "2025-10-30T03:02:25.469453+00:00",
    "updated_at": "2025-10-30T03:13:56.217126+00:00",
    "file_path": "unknown_source",
    "track_id": "insert_20251030_110225_46621544",
    "metadata": {
      "processing_start_time": 1761793939,
      "processing_end_time": 1761794036
    }
  },
  "doc-7ca51faf7f3faf56c56ab18dd6458c7e": {
    "status": "processed",
    "chunks_count": 2,
    "chunks_list": [
      "chunk-7ca51faf7f3faf56c56ab18dd6458c7e",
      "chunk-62e7a5a2dcc4d8e5b08d9447994638c2"
    ],
    "content_summary": "4. 进程控制 进程控制的主要功能是对系统中的所有进程实施有效的管理, 它具有创建新进程、撤销已有进程、实现进程状态转换等功能。在操作系统中, 一般将进程控制用的程序段称为原语, 原语的特点是执行期间不允许中断, 它是一个不可分割的基本单位。 进程的创建 允许一个进程创建另一个进程, 此时创建者称为父进程, 被创建的进程称为子进程。子进程可以继承父进程所拥有的资源。当子进程终止时, 应将其从父进程那里获得的资源还给父进程。 在操作系统中, 终端用户登录系统、作业调度、系统提供服务、用户程序的应用...",
    "content_length": 1574,
    "created_at": "2025-10-30T03:02:25.469440+00:00",
    "updated_at": "2025-10-30T03:14:10.827620+00:00",
    "file_path": "unknown_source",
    "track_id": "insert_20251030_110225_46621544",
    "metadata": {
      "processing_start_time": 1761793972,
      "processing_end_time": 1761794050
    }
  },
  "doc-2da376f0975743dcb0cc169c929cbe5c": {
    "status": "processed",
    "chunks_count": 1,
    "chunks_list": [
      "chunk-2da376f0975743dcb0cc169c929cbe5c"
    ],
    "content_summary": "2. 进程的组成 进程是一个独立的运行单位, 也是操作系统进行资源分配和调度的基本单位。它由以下三部分组成, 其中最核心的是进程控制块(PCB)。 进程控制块 进程创建时, 操作系统为它新建一个PCB, 该结构之后常驻内存, 任意时刻都可以存取, 并在进程结束时删除。PCB是进程实体的一部分, 是进程存在的唯一标志。 进程执行时, 系统通过其PCB 了解进程的现行状态信息, 以便操作系统对其进行控制和管理; 进程结束时, 系统收回其PCB, 该进程随之消亡。 当操作系统希望调度某个进程运行时, ...",
    "content_length": 1239,
    "created_at": "2025-10-30T03:02:25.469433+00:00",
    "updated_at": "2025-10-30T03:16:05.631843+00:00",
    "file_path": "unknown_source",
    "track_id": "insert_20251030_110225_46621544",
    "metadata": {
      "processing_start_time": 1761794036,
      "processing_end_time": 1761794165
    }
  },
  "doc-6de1df73d142ee13cb1e9512464e4e80": {
    "status": "processed",
    "chunks_count": 1,
    "chunks_list": [
      "chunk-6de1df73d142ee13cb1e9512464e4e80"
    ],
    "content_summary": "20. 死锁预防 死锁预防的方法是使4个必要条件中的至少一个不能成立, 来预防死锁的发生。 破坏互斥条件 若允许系统资源都能共享使用, 则系统不会进入死锁状态。但有些资源根本不能同时共享, 故破坏互斥条件而预防死锁的方法不太可行。 破坏请求和保持条件 为了不致发生死锁, 必须保证当一个进程已保持了某些不可剥夺资源时, 便不能再请求其他任何资源。要做到这一点, 可采用两种协议: 第一种协议。所有进程在开始运行之前, 必须一次性地申请其在整个运行过程中所需的全部资源。 第二种协议。允许一个进程只获得...",
    "content_length": 460,
    "created_at": "2025-10-30T03:02:25.469483+00:00",
    "updated_at": "2025-10-30T03:15:05.351180+00:00",
    "file_path": "unknown_source",
    "track_id": "insert_20251030_110225_46621544",
    "metadata": {
      "processing_start_time": 1761794050,
      "processing_end_time": 1761794105
    }
  },
  "doc-fd195ae7c40727c5b83fa7b77d72095e": {
    "status": "processed",
    "chunks_count": 1,
    "chunks_list": [
      "chunk-fd195ae7c40727c5b83fa7b77d72095e"
    ],
    "content_summary": "1. 进程的概念和特征 进程的概念 在多道程序环境下, 允许多个程序并发执行, 此时它们将失去封闭性, 并具有间断性及不可再现性的特征。为此引入了进程(Process)的概念, 以便更好地描述和控制程序的并发执行, 实现操作系统的并发性和共享性(最基本的两个特性)。 为了使参与并发执行的每个程序(含数据)都能独立地运行, 必须为之配置一个专门的数据结构, 称为进程控制块(Process Control Block,PCB)。系统利用PCB来描述进程的基本情况和运行状态, 进而控制和管理进程。相应...",
    "content_length": 1005,
    "created_at": "2025-10-30T03:02:25.469421+00:00",
    "updated_at": "2025-10-30T03:16:57.778387+00:00",
    "file_path": "unknown_source",
    "track_id": "insert_20251030_110225_46621544",
    "metadata": {
      "processing_start_time": 1761794105,
      "processing_end_time": 1761794217
    }
  },
  "doc-b7f639a9301d2ec0568bcbcad2dc3725": {
    "status": "processed",
    "chunks_count": 1,
    "chunks_list": [
      "chunk-b7f639a9301d2ec0568bcbcad2dc3725"
    ],
    "content_summary": "10. 进程切换 对通常的进程而言, 其创建、撤销及要求由系统设备完成的I/O操作, 都是利用系统调用而进入内核, 再由内核中的相应处理程序予以完成的。进程切换同样是在内核的支持下实现的, 因此可以说, 任何进程都是在操作系统内核的支持下运行的, 是与内核紧密相关的。 (1) 上下文切换 切换 CPU到另一个进程需要保存当前进程状态并恢复另一个进程的状态, 这个任务称为上下文切换。进程上下文采用进程PCB表示, 包括CPU寄存器的值、进程状态和内存管理信息等。上下文切换的流程如下: 挂起一个进程...",
    "content_length": 658,
    "created_at": "2025-10-30T03:02:25.469458+00:00",
    "updated_at": "2025-10-30T03:17:27.766510+00:00",
    "file_path": "unknown_source",
    "track_id": "insert_20251030_110225_46621544",
    "metadata": {
      "processing_start_time": 1761794165,
      "processing_end_time": 1761794247
    }
  },
  "doc-76ab4199a2aae3d8b4b3b6c270c34a12": {
    "status": "processed",
    "chunks_count": 1,
    "chunks_list": [
      "chunk-76ab4199a2aae3d8b4b3b6c270c34a12"
    ],
    "content_summary": "9. 调度的目标 为了比较CPU调度算法的性能, 人们提出了很多评价标准, 下面介绍其中主要的几种: CPU利用率。CPU是计算机系统中最重要和昂贵的资源之一, 所以应尽可能使CPU保持“忙”状态, 使这一资源利用率最高。 系统吞吐量。表示单位时间内CPU完成作业的数量。长作业需要消耗较长的CPU时间, 因此会降低系统的吞吐量。而对于短作业, 需要消耗的CPU时间较短, 因此能提高系统的吞吐量。 周转时间。指从作业提交到作业完成所经历的时间, 是作业等待、在就绪队列中排队、在CPU上运行及I/O...",
    "content_length": 460,
    "created_at": "2025-10-30T03:02:25.469455+00:00",
    "updated_at": "2025-10-30T03:18:23.540126+00:00",
    "file_path": "unknown_source",
    "track_id": "insert_20251030_110225_46621544",
    "metadata": {
      "processing_start_time": 1761794217,
      "processing_end_time": 1761794303
    }
  }
}