{
  "doc-c22f61a22dddcf7887de6d879988c291": {
    "content": "21. 浮点数的规格化 为了在浮点数运算过程中尽可能多地保留有效数字的位数，使有效数字尽量占满尾数数位， 必须在运算过程中对浮点数进行规格化操作。所谓规格化操作，是指通过调整一个非规格化浮点数的尾数和阶码的大小，使非零浮点数在尾数的最高数位上保证是一个有效值。 左规：当运算结果的尾数的最高数位不是有效位时，需要进行左规。左规时，尾数每左移一位、阶码减1(基数为2时)。左规可能要进行多次。 右规：当运算结果的尾数的有效位进到小数点前面时，需要进行右规，右规只需进行一次。 将尾数右移一位、阶码加1(基数为2时)。右规时，阶码增加可能导致溢出。",
    "create_time": 1761467354,
    "update_time": 1761467354,
    "_id": "doc-c22f61a22dddcf7887de6d879988c291"
  },
  "doc-224035519c723875f8ee06a75cc06f38": {
    "content": "6. 无符号整数的表示 当一个编码的全部二进制位均为数值位而没有符号位时，该编码表示就是无符号整数， 简称无符号数。此时，默认数的符号为正。因为无符号整数省略了一位符号位，所以在字长 相同的情况下，它能表示的最大数比有符号整数能表示的大。 一般在全部是正数运算且不出 现负值结果的场合下，使用无符号整数表示。例如，可用无符号整数进行地址运算，或用它 来表示指针。 例如，对8位无符号整数，最小数为00000000(值为0),最大数为11111111(值为255), 即表示范围为0～255;而对于8位有符号整数(补码表示),最小数为10000000(值为-128), 最大数为01111111(值为2⁷-1=127), 即表示范围为-128～127。",
    "create_time": 1761467354,
    "update_time": 1761467354,
    "_id": "doc-224035519c723875f8ee06a75cc06f38"
  },
  "doc-fe930da67280065a9ab94641ffc7e10e": {
    "content": "4. 真值和机器数 在日常生活中，通常用正号、负号来分别表示正数(正号可省略)和负数，如+15、 -8等。 这种带“+”或“-”符号的数称为真值。真值是机器数所代表的实际值。 在计算机中，通常将数的符号和数值部分一起编码，将数据的符号数字化，通常用“0”表 示“正”,用“1”表示“负”。这种把符号“数字化”的数称为机器数。常用的有原码、补码 和反码表示法。如0,101(这里的逗号“,”仅用于区分符号位与数值位)表示+5。",
    "create_time": 1761467354,
    "update_time": 1761467354,
    "_id": "doc-fe930da67280065a9ab94641ffc7e10e"
  },
  "doc-7f2cde5c650ea54bac6265e49d30e485": {
    "content": "C语言中的整型数据类型 C 语言中，有符号整数根据位数的不同，可分为短整型(short或short int,16 位)、整型(int, 32位)、长整型 (long或 long int, 在32位机器中为32位，在64位机器中为64位)。要定义 无符号整数，只需在short/int/long之前加上关键字unsigned,如无符号短整型 (unsigned short 或 unsigned short int)、无符号整型(unsigned int)、无符号长整型(unsigned long或 unsigned long int)。 若不指定signed/unsigned 时，则默认为有符号整数。 字符型 (char,8位) 是C语言中的一个特殊类型，默认按无符号整数解释。 上述类型都是按补码形式存储的，只是有符号整数的最高位代表符号，而无符号整数的全部 二进制位都表示数值，没有符号位，相当于数的绝对值，因此两者所表示的数据范围有所不同。",
    "create_time": 1761467354,
    "update_time": 1761467354,
    "_id": "doc-7f2cde5c650ea54bac6265e49d30e485"
  },
  "doc-ca423326f2f43c01238f9b5f5a0e0862": {
    "content": "2. 进位计数制 常用的进位计数制有十进制、二进制、八进制、十六进制等。十进制数是日常生活中最常 使用的，而计算机中通常使用二进制数、八进制数和十六进制数。 在进位计数制中，每个数位所用到的不同数码的个数称为基数。十进制的基数为10(0～9), 每个数位计满10就向高位进位，即“逢十进一”。十进制数101,其个位的1显然与百位的1所 表示的数值是不同的。每个数码所表示的数值等于该数码本身乘以一个与它所在数位有关的常数，这个常数称为位权。一个进位数的数值大小就是它的各位数码按权相加。 1)二进制。 计算机中用得最多的是基数为2的计数制，即二进制。二进制只有0和1两种 数码，计数“逢二进一”。 2)八进制。 基数为8,有0～7共8个不同的数码。计数逢八进一。因为r=8=2³, 所以把二进制中的3位数码编为一组就是1位八进制数码，两者之间的转换极为方便。 3)十六进制。 基数为16,有0～9、 A～F 共16个不同的数码，其中A～F 分别表示10～15。 计数逢十六进一。因为r=16=2⁴,所以4位二进制数码与1位十六进制数码相对应。 可以用后缀字母标识一个数的进位计数制，用B 表示二进制数，用O 表示八进制数，用D 表 示十进制数(通常直接省略),用H 表示十六进制数，有时也用前缀0x 表示十六进制数。",
    "create_time": 1761467354,
    "update_time": 1761467354,
    "_id": "doc-ca423326f2f43c01238f9b5f5a0e0862"
  },
  "doc-ea5d582d57c5196325119e4d99f578d2": {
    "content": "7. 有符号整数的表示 将符号数值化，并将符号位放在有效数字的前面，就组成了有符号整数。虽然前面介绍的原 码、补码、反码和移码都可以用来表示有符号整数，但补码表示有其明显的优势： ①与原码和反码相比，0的补码表示唯一。 ②与原码和移码相比，补码运算规则比较简单，且符号位可以和数值位一起参加运算。 ③与原码和反码相比，补码比原码和反码多表示一个最小负数。 计算机中的有符号整数都用补码表示，所以n 位有符号整数的表示范围是-2”-¹~2”-1-1。",
    "create_time": 1761467354,
    "update_time": 1761467354,
    "_id": "doc-ea5d582d57c5196325119e4d99f578d2"
  },
  "doc-6151c8c091207072ad8e5a4c89b6cd43": {
    "content": "10. 基本运算部件 在计算机中，运算器由算术逻辑单元( Arithmetic Logic Unit,ALU)、 移位器、状态寄存器 (PSW) 和通用寄存器组等组成。运算器的基本功能包括加、减、乘、除四则运算，与、或、非、 异或等逻辑运算，以及移位、求补等操作。ALU 的核心部件是加法器。 （1） 一位全加器 全加器 (FA) 是最基本的加法单元，有加数A 、加数B,与低位传来的进位 C₁共三个输入， 有本位和S, 及向高位的进位 C 共两个输出。 （2）串行进位加法器 将 n 个全加器相连可得到n 位加法器，称为串行进位加法器。串行进位也称行波进位，每级进位直接依赖于前一级的进位，即进位信号是逐级形成的。在串行进位加法器中，低位运算产生进位所需的时间将影响高位运算的时间。因此，串行进 位加法器的最长运算时间主要是由进位信号的传递时间决定的，位数越多，延迟时间就越长，所 以加快进位产生和提高传递的速度是关键。 （3）并行进位加法器 并行进位(也称先行进位)加法器可以加快进位产生的速度，进而提升加法运算产生结果的 速度。构造一个 n 位并行进位加法器，需要将n 个一位全加器连接上n 位先行进位部分(简称CLA 部件),其作用是“并行产生进位”,即n 位进位信息几乎是同时产生的。因此，相比于串行进 位加法器，并行进位加法器提升了加法运算产生结果的速度。图2.5所示是一个4位全先行进位 加法器。随着加法器位数的增加，电路结构会变得更复杂，这里不再深入讨论。 （4）n位全先行进位加法器 对于n 位加法器，除了需要得到运算结果，还要关注加法运算是否发生溢出、运算结果的正 负性、运算结果是否为0等，这些信息对于程序的执行控制至关重要。因此，需要在n 位加法器 的基础上增加一些逻辑电路，使其不仅能计算和/差，还能生成相应的标志信息：分别是OF 、CF、 SF 和ZF, 每个标志信息占1位。 （5）算术逻辑单元 (ALU) ALU 是一种功能较强的组合逻辑电路，它能进行多种算术运算和逻辑运算。加、减、乘、除 运算最终都能归结为加法运算，因此 ALU 的核心是带标志加法器，同时也能执行“与”“或”“非”等逻辑运算。ALU 的基本结构中A 和 B 是两个n 位操作数输入端，Cin 是进位输入端，ALUop 是操作控制端(发出控制信号),用来决定 ALU 所执行的处理功能。例 如，ALUop 选择Add 运算，ALU 就执行加法运算，输出的结果就是A 加 B 之和。ALUop 的位数 决定了操作的种类。例如，当位数为3时， ALU 最多只有8种操作。",
    "create_time": 1761467354,
    "update_time": 1761467354,
    "_id": "doc-6151c8c091207072ad8e5a4c89b6cd43"
  },
  "doc-fe285d304d7559e78510976eea6cc1c1": {
    "content": "22. 定点、浮点表示的区别 (1)数值的表示范围 若定点数和浮点数的字长相同，则浮点表示法所能表示的数值范围远大于定点表示法。 (2)精度 对于字长相同的定点数和浮点数来说，浮点数虽然扩大了数的表示范围，但精度降低了。 (3)数的运算 浮点数包括阶码和尾数两部分，运算时不仅要做尾数的运算，还要做阶码的运算，而且运算 结果要求规格化，所以浮点运算比定点运算复杂。 (4)溢出问题 在定点运算中，当运算结果超出数的表示范围时，发生溢出；在浮点运算中，运算结果超出 尾数表示范围却不一定溢出，只有规格化后阶码超出所能表示的范围时，才发生溢出。",
    "create_time": 1761467354,
    "update_time": 1761467354,
    "_id": "doc-fe285d304d7559e78510976eea6cc1c1"
  },
  "doc-d6401acae9e97b990cd8ff7387370e66": {
    "content": "12. 补码的加减法运算 补码运算的特点如下。 1)按二进制运算规则运算，逢二进一。 2)若做加法，两个数的补码直接相加；若做减法，则将被减数与减数的负数补码相加。 3)符号位与数值位一起参与运算，加、减运算结果的符号位也在运算中直接得出。 4)最终运算结果的高位丢弃，保留n+1位，运算结果亦为补码。",
    "create_time": 1761467354,
    "update_time": 1761467354,
    "_id": "doc-d6401acae9e97b990cd8ff7387370e66"
  },
  "doc-3878dd58bdab1629f78e313f678153cc": {
    "content": "二进制 在计算机系统内部，所有信息都是用二进制进行编码的，这样做的原因有以下几点。 1)二进制只有两种状态，使用有两个稳定状态的物理器件就可以表示二进制数的每一位， 制造成本比较低，例如用高、低电平或电荷的正、负极性都可以很方便地表示0和1。 2)二进制位1 和0正好与逻辑值“真”和“假”相对应，为计算机实现逻辑运算和程序中 的逻辑判断提供了便利条件。 3)二进制的编码和运算规则都很简单，通过逻辑门电路能方便地实现算术运算。",
    "create_time": 1761467354,
    "update_time": 1761467354,
    "_id": "doc-3878dd58bdab1629f78e313f678153cc"
  },
  "doc-bc20958ae5e844428623c62227b67c7b": {
    "content": "13. 溢出判别方法 仅当两个符号相同的数相加或两个符号相异的数相减才可能产生溢出，如两个正数相加，而结果的符号位却为1(结果为负);一个负数减去一个正数，结果的符号位却为0(结果为正)。 补码定点数加减运算溢出判断的方法有3种。 (1)采用一位符号位 减法运算在机器中是用加法器实现的，因此无论是加法还是减法，只要参加操作的两个数的 符号相同，结果又与原操作数的符号不同，则表示结果溢出。 (2)采用双符号位 双符号位法也称模4补码。运算结果的两个符号位相同，表示未溢出；运算结果的两个符号位不同，表示溢出，此时最高位符号位代表真正的符号。 (3)采用一位符号位根据数值位的进位情况判断溢出 若符号位(最高位)的进位Cn与最高数位(次高位)的进位Cn1 相同，说明无溢出，否则说明有溢出。",
    "create_time": 1761467354,
    "update_time": 1761467354,
    "_id": "doc-bc20958ae5e844428623c62227b67c7b"
  },
  "doc-eb70606fa9ba73ffc22231992979ee26": {
    "content": "C语言的符号转换和字长转换 C 语言允许在不同的数据类型间做类型转换。强制类型转换的代码格式为“TYPEb=(TYPE)a”, 强制类型转换后，返回一个具有 TYPE 类型的数值。 另一种常见的运算是在不同字长的整数之间进行类型转换。 从小字长转换为大字长时，要对高位部分进行扩展。若原数字是无符号整数，则进行零扩展，扩展后 的高位部分用0填充(例如，当16位无符号整数 u 强制转换为32位无符号整数v 时，高16位 用0填充)。若原数字是有符号整数，则进行符号扩展，扩展后的高位部分用原数字符号位填 充(例如，当16位有符号整数x 强制转换为32位有符号整数y 时，因为x 的符号位是1,所 以高16位用1填充)。注意， char 型为8位无符号整数，其在转换为int 型时高位补0即可。 在有符号数和无符号数的转换中，若两个变量的字长不同，则分两种情况进行讨论：①若 从小字长转换到大字长，则要先对原数字的高位部分进行扩展，若原数字是无符号整数，则进 行零扩展；若原数字是有符号整数，则进行符号扩展。②若从大字长转换到小字长，则直接截 取低位部分。也就是说，先进行字长的转换，再进行符号的转换。",
    "create_time": 1761467354,
    "update_time": 1761467354,
    "_id": "doc-eb70606fa9ba73ffc22231992979ee26"
  },
  "doc-b661f934d6911328f3c940a7306bdabc": {
    "content": "22. 浮点数的加减运算 浮点数运算的特点是阶码运算和尾数运算分开进行，浮点数加减运算分为以下几步。 （1）对阶 对阶的目的是使两个操作数的小数点位置对齐，即使得两个数的阶码相等。为此，先求阶码 差，然后以小阶码向大阶码看齐的原则，将阶码小的尾数右移一位(基数为2),阶码加1,直 到两个数的阶码相等为止。尾数右移时，若舍弃有效位会产生误差，影响精度。为了保证运算的 精度，尾数右移时，低位移出的位不要丢掉，应保留并参加尾数部分的运算。 若采用大阶码向小阶码看齐的原则，则尾数需要左移，最高有效位被移出，导致结果出错。 （2）尾数加减 将对阶后的尾数按定点原码小数的加(减)运算规则进行运算。因为IEEE 754 浮点数尾数 中有一个隐藏位，因此在进行尾数加减时，必须将隐藏位还原到尾数部分。运算后的尾数不一定 是规格化的，因此，浮点数的加减运算需要进一步进行规格化处理。 （3）尾数规格化 （4）舍入 在对阶和尾数右规时，可能对尾数进行右移，为保证运算精度，一般将移出的部分低位保留 下来，参加中间过程的运算，最后再将运算结果进行舍入，还原表示成IEEE 754格式。 IEEE 754 提供了以下4种可选的舍入模式。 就近舍入：舍入为最近的可表示数。当运算结果是两个可表示数的非中间值时，实际上是 “0舍1入”方式(类似于十进制的“四舍五入”法);当运算结果正好在两个可表示数的 中间时，则选择结果为偶数。 2)正向舍入：朝数轴+∞方向舍入，即取右边最近的可表示数。 3)负向舍入：朝数轴-∞方向舍入，即取左边最近的可表示数。 4)截断法：直接截取所需位数，丢弃后面的所有位，这种舍入处理最简单。对正数或负数 来说，都是取更接近原点的那个可表示数，是一种趋向原点的舍入。 （5）溢出判断 在尾数规格化和尾数舍入时，可能对结果的阶码执行加/减运算。因此，必须考虑指数溢出问 题。若一个正指数超过了最大允许值(127或1023),则发生指数上溢，产生异常。若一个负指 数超过了最小允许值(-149或-1074)①,则发生指数下溢，通常把结果按机器零处理。",
    "create_time": 1761467354,
    "update_time": 1761467354,
    "_id": "doc-b661f934d6911328f3c940a7306bdabc"
  },
  "doc-ac11d99928fbdb7cf8188b4d1e45043f": {
    "content": "19. 除法运算 原码的除法运算与乘法运算很相似，都是一种移位和加减运算迭代的过程，但比乘法运算更 复杂 。n位定点数的除法运算，需统一为：一个2n 位的数除以一个n位的数，得到一个n 位的商，因此需要对被除数进行扩展。对于定点正小数(原码小数),只需在被除数低位添 n 个0即可。 对于定点正整数(无符号数),只需在被除数高位添 n 个0即可。做整数除法时，若除数为0, 则发生“除数为0”异常，此时需调出操作系统相应的异常处理程序进行处理。 下面以两个无符号数为例说明手算除法步骤。 上述除法运算的过程可归纳如下： ①被除数与除数相减，够减则上商为1,不够减则上商为0。 ②每次得到的差为中间余数，将除数右移后与上次的中间余数比较。用中间余数减除数， 够减则上商为1,不够减则上商为0。如此重复，直到商的位数满足要求为止。",
    "create_time": 1761467354,
    "update_time": 1761467354,
    "_id": "doc-ac11d99928fbdb7cf8188b4d1e45043f"
  },
  "doc-1bf253441ffd1d27c8127187db5ecb32": {
    "content": "有符号数大小的比较 对于有符号数的运算，零标志ZF 、溢出标志OF 、符号标志SF 才有意义。假设两个有符号 数A 和 B, 用补码表示，以执行[A]-[B] 为例来说明ZF、OF、SF 标志的几种可能情况。 当 ZF=1时，说明A=B 。 当 ZF=0且未发生溢出时，即OF=0时，若 SF=0, 则表示结果非负，说明A>B; 当发生溢出时，即OF=1时，若SF=1, 则必然是正数减去负数发生溢出导致结果为负，因此，当OF=SF且ZF=0时，说明A>B。 当 ZF=0且未发生溢出时，即OF=0时，若SF=1, 则表示结果为负，说明A<B; 当发生溢出时，即OF=1 时，若 SF=0, 则必然是负数减去正数发生溢出导致结果为正，因此， 当OF≠SF且ZF=0时 ，说明A<B。",
    "create_time": 1761467354,
    "update_time": 1761467354,
    "_id": "doc-1bf253441ffd1d27c8127187db5ecb32"
  },
  "doc-8b64d30374af75767b82b53c5d492c80": {
    "content": "18. 定点乘法运算 原码乘法的特点是符号位与数值位是分开求的，原码乘法运算分为两步： ①乘积的符号位由 两个乘数的符号位“异或”得到； ②乘积的数值位是两个乘数的绝对值之积。两个定点数的数值部分之积可视为两个无符号数的乘积。 乘法运算可用加法和移位运算来实现,两个n位无符号数相乘共需进行n次加法和n次移位运算。原码乘法运算的过程可归纳如下： ①被乘数和乘数均取绝对值参加运算，视为无符号数， ② 部分积 P, 是乘法运算的中间结果，初值P₀=0 。从乘数的最低位yn开始，将前面所得的部分积P; 加上X×y-i,然后右移一位，此步骤重复 n 次 。 参与运算的是两个数的数值位，因此运算过程中的右移操作均为逻辑右移。",
    "create_time": 1761467354,
    "update_time": 1761467354,
    "_id": "doc-8b64d30374af75767b82b53c5d492c80"
  },
  "doc-9a74c12334c1c89b7dc2a0d69025220d": {
    "content": "3. 不同进制数之间的相互转换 (1)二进制数转换为八进制数和十六进制数 对于一个二进制小数(既包含整数部分，又包含小数部分),在转换时应以小数点为界。其 整数部分，从小数点开始往左数，将一串二进制数分为3位(八进制)一组或4位(十六进制) 一组，在数的最左边可根据需要加“0”补齐；对于小数部分，从小数点开始往右数，也将一串 二进制数分为3位一组或4位一组，在数的最右边也可根据需要加“0”补齐。最终使总的位数 为3或4的整数倍，然后分别用对应的八进制数或十六进制数取代。 (2)任意进制数转换为十进制数 将任意进制数的各位数码与它们的权值相乘，再把乘积相加，就得到了一个十进制数。这种 方法称为按权展开相加法。 (3)十进制数转换为任意进制数 一个十进制数转换为任意进制数，通常采用基数乘除法 (注意，基数的值与进制相关)。这 种转换方法对十进制数的整数部分和小数部分将分别进行处理，对整数部分采用除基取余法，对 小数部分采用乘基取整法，最后将整数部分与小数部分的转换结果拼接起来。",
    "create_time": 1761467354,
    "update_time": 1761467354,
    "_id": "doc-9a74c12334c1c89b7dc2a0d69025220d"
  },
  "doc-5ea05d0aadedcb24741fd320a2b9543c": {
    "content": "20. 浮点数的表示 浮点数表示法是指以适当的形式将比例因子表示在数据中，让小数点的位置根据需要而浮 动。这样，在位数有限的情况下，既扩大了数的表示范围，又保持了数的有效精度。例如，用定点数表示电子的质量(9×10⁻²8g)或太阳的质量(2×10³g)是非常不方便的。 浮点数由符号、尾数和阶码三部分组成。 阶码的值反映浮点数的小数点的实际位置；阶码的位数反映浮点数的表示范围；尾数的位数反映浮点数的精度。 原码是关于原点对称的，所以浮点数的范围也是关于原点对称的。 运算结果大于最大正数时称为正上溢，小于绝对值最大负数时称为负上溢，正上溢和负上溢 统称上溢。数据一旦产生上溢，计算机必须中断运算操作，进行溢出处理。当运算结果在0至最小正数之间时称为正下溢，在0至绝对值最小负数之间时称为负下溢，正下溢和负下溢统称下溢。 数据下溢时，浮点数值趋于零，计算机将其当作机器零处理。",
    "create_time": 1761467354,
    "update_time": 1761467354,
    "_id": "doc-5ea05d0aadedcb24741fd320a2b9543c"
  },
  "doc-ba5ba3047ff33c33c3e78b969b12b98e": {
    "content": "无符号数大小的比较 对于无符号数的运算，零标志ZF 、进/借位标志CF才有意义。假设有两个无符号数A 和B, 下面以执行A-B为例来说明ZF 、CF 标志的几种可能情况。 若A=B, 如 A-B=011-011=000, 此时结果为零ZF=1, 无借位CF=0。 若A>B, 如 A-B=010-001=001, 此时结果非零ZF=0, 无借位CF=0。 若A<B, 如 A-B=000-001=(1)000-001=111, 此时ZF=0,有借位CF=1。 当Z F=1时，说明A=B 。 当ZF=0且CF=0时，说明A>B。 当CF=1时，说明A<B 。",
    "create_time": 1761467354,
    "update_time": 1761467354,
    "_id": "doc-ba5ba3047ff33c33c3e78b969b12b98e"
  },
  "doc-09b53b0df067c5056104774d13e5e395": {
    "content": "24. 数据的大小端和对齐存储 在存储数据时，数据从低位到高位可以按从左到右排列，也可以按从右到左排列。因此，无 法用最左或最右来表征数据的最高位或最低位，通常用最低有效字节 (LSB)和最高有效字节 (MSB)来分别表示数据的低位和高位。例如，在32位计算机中， 一个 int型变量i的机器数为 01234567H, 其最高有效字节MSB=01H, 最低有效字节LSB=67H。 现代计算机基本都采用字节编址，即每个地址编号中存放1字节。不同类型的数据占用的字 节数不同，如 int 型和 float 型占4字节， double 型占8字节等，而程序中对每个数据只给定一个地址。假设变量 i 的地址为0800H, 字节 01H 、23H 、45H 、67H 应各有一个内存地址，那么4字节在内存中应如何排列呢?根据数据中各字节在连续字节序列中的排列顺序不同，可以采用两种 排列方式：大端方式 (big endian)和小端方式(little endian) 1)大端方式：先存储高位字节，后存储低位字节。字中的字节顺序和原序列的相同。 2)小端方式：先存储低位字节，后存储高位字节。字中的字节顺序和原序列的相反。 在检查底层机器级代码时，需要分清各类型数据字节序列的顺序。 现代计算机都是按字节编址的，假设字长为32位，数据按边界对齐方式存放要求其存储地 址是自身大小的整数倍，半字地址一定是2的整数倍，字地址一定是4的整数倍，这样无论所取 的数据是字节、半字还是字，均可一次访存取出。当所存数据不满足上述要求时，可通过填充空 白字节使其符合要求。这样做虽然会浪费一些存储空间，但可以提高存取数据的速度。当数据不 按边界对齐方式存储时，半字长或字长的数据可能在两个存储字中，此时需要两次访存，并对高 低字节的位置进行调整后才能得到所需数据，从而影响了系统的效率。 在C 语言的struct 类型中，边界对齐有两个重要要求： ①每个成员按其类型的大小对齐，char 型的对齐值为1,short 型的对齐值为2,int 型的对齐值为4,单位为字节； ②struct 的长度必须 是成员中最大对齐值的整数倍(不够就补空字节)。这样就能保证 struct 数组的每项都满足边界 对齐的条件。 边界对齐方式相对边界不对齐方式是一种空间换时间的思想。精简指令系统计算机 RISC 通常采用边界对齐方式，因为边界对齐方式取指令时间相同，因此能适应指令流水。",
    "create_time": 1761467354,
    "update_time": 1761467354,
    "_id": "doc-09b53b0df067c5056104774d13e5e395"
  },
  "doc-ee63e6f80ae58c99375bb442c346b8a6": {
    "content": "11. 定点数的移位运算 当计算机中没有乘/除法运算电路时，可以通过加法和移位相结合的方法来实现乘/除法运算。 对于任意二进制整数，左移一位，若不产生溢出，相当于乘以2(与十进制数的左移一位相当于乘以10类似);右移一位，若不考虑因移出而舍去的末位尾数，相当于除以2。 根据操作数的类型不同，移位运算可以分为逻辑移位和算术移位。 （1）逻辑移位 逻辑移位将操作数视为无符号整数。逻辑移位的规则：左移时，高位移出，低位补0;右移 时，低位移出，高位补0。对于无符号整数的逻辑左移，若高位的1移出，则发生溢出。 （2）算术移位 算术移位需要考虑符号位的问题，即将操作数视为有符号整数。 计算机中的有符号整数都是用补码表示的，因此对于有符号整数的移位操作应采用补码算术 移位方式。算术移位的规则：左移时，高位移出，低位补0,若移出的高位不同于移位后的符号 位，即左移前后的符号位不同，则发生溢出；右移时，低位移出，高位补符号位，若低位的1移 出，则影响精度。例如，补码1001和0101左移时会发生溢出，右移时会丢失精度。",
    "create_time": 1761467354,
    "update_time": 1761467354,
    "_id": "doc-ee63e6f80ae58c99375bb442c346b8a6"
  },
  "doc-278906376b45ec28050699d283cb1aeb": {
    "content": "14. 加减运算电路 已知一个数的补码表示为 Y, 则这个数的负数的补码为Y+1, 因此，只要在原加法器的 Y 输入端加n 个反向器以实现各位取反的功能，然后加一个2选1多路选择器，用一个控制端 Sub 来控制，以选择是将Y输入加法器还是将Y 输入加法器，并将Sub 同时作为低位进位送到加法器 (做减法时实现末位加1), 无符号整数相当于正整数的补码表示，因此图2.9的电路同时也能实现无符号数的加/减运 算，对于有符号数x 和y, 图中的X 和 Y分别是x 和y 的补码表示；对于无符号数x 和y, 图中的 X 和 Y分别是x 和y 的二进制表示。不论是补码减法还是无符号数减法，都是用被减数加上减数 的负数的补码 (Y+1) 来实现的。 运算器本身无法识别所处理的二进制串是有符号数还是无符号数。可通过标志信息来区分有符号整数运算结果和无符号整数运算结果。 零标志ZF:ZF=1表示结果为0。对于无符号数和有符号数的运算，ZF都有意义。 溢出标志OF: 判断有符号数运算是否溢出，它是符号位进位与最高数位进位的异或结果。对于无符号数运算，OF 没有意义，通俗地说，就是根据OF 无法判断无符号数运算是否溢出。 符号标志SF:表示结果的符号，即F的最高位。对于无符号数运算SF 没有意义。 进/借位标志CF: 表示无符号数运算时的进位/借位，判断是否发生溢出。加法时，CF=1 表 示结果溢出，因此CF 等于进位输出Cout。减法时，CF=1表示有借位，即不够减，所以CF 等于 位输出Cout取反。对于有符号数运算，CF 没有意义，也就是说，根据CF 无法判断有符号数运算是否溢出。",
    "create_time": 1761467354,
    "update_time": 1761467354,
    "_id": "doc-278906376b45ec28050699d283cb1aeb"
  },
  "doc-7661b58ae4a51d1ee96186ef15ec5292": {
    "content": "C语言中的浮点数类型 C 语言中的float型和double型分别对应于IEEE754单精度浮点数和双精度浮点数。 long double型对应于扩展双精度浮点数，但long double型的长度和格式随编译器和处理器类型的不同 而有所不同。在 C 程序中，等式的赋值和判断会导致强制类型转换，以char→int→long→double和float→double 最为常见，从前到后范围和精度都从小到大，转换过程没有损失。 不同类型数的混合运算时，遵循的原则是类型提升，即较低类型转换为较高类型。如 long 型 与 int 型一起运算时，需先将int 型转换为long 型，然后进行运算，结果为long 型。若float 型和 double 型一起运算，虽然两者同为浮点型，但精度不同，则仍需先将 float 型转换为double 型后再进行运 算，结果亦为double 型。所有这些转换都是系统自动进行的，这种转换称为隐式类型转换。 1)int型转换为 float 型时，虽然不会发生溢出，但 float 型尾数连隐藏位共24位，int 型为 32位，当int 型数转换成浮点数的尾数的有效位大于24位时，需舍入处理，影响精度。 2)int 型或float 型转换为double 型时，因double 型的有效位数更多，因此能保留精确值。 3)double型转换为float 型时，因float 型的表示范围更小，因此大数转换时可能发生溢出。 此外，尾数有效位数变少，因此高精度数转换时会发生舍入。 4)float型或double 型转换为int 型时，因int 型没有小数部分，因此数据会向0方向截断(仅保留整数部分),发生舍入。另外，因int 型的表示范围更小，因此大数转换时可能溢出。",
    "create_time": 1761467354,
    "update_time": 1761467354,
    "_id": "doc-7661b58ae4a51d1ee96186ef15ec5292"
  },
  "doc-ea2c16caf28ea549ed420e26afbca237": {
    "content": "17. 原码的加减法运算 在原码加减运算中，将符号位和数值位分开处理，具体的规则如下。 加法规则：遵循“同号求和，异号求差”的原则，先判断两个操作数的符号位。具体来说， 符号位相同，则数值位相加，结果符号位不变，若最高数值位相加产生进位，则发生溢出；符号位不同，则做减法，绝对值大的数减去绝对值小的数，结果符号位与绝对值大的数相同。 减法规则：先将减数的符号取反，然后将被减数与符号取反后的减数按原码加法进行运算。 原码的加减运算规则比较复杂，因此计算机采用的大多是补码加/减运算。 原码的加减运算规则比较复杂，因此计算机采用的大多是补码加/减运算。",
    "create_time": 1761467354,
    "update_time": 1761467354,
    "_id": "doc-ea2c16caf28ea549ed420e26afbca237"
  },
  "doc-5b233c3ec097f13f398ea0ca159b2c8b": {
    "content": "5. 机器数的定点表示 根据小数点的位置是否固定，在计算机中有两种数据格式：定点表示和浮点表示。在现代计 算机中，通常用补码整数表示整数，用原码小数表示浮点数的尾数部分，用移码表示浮点数的阶 码部分，历年统考真题的命题信息也主要落在这个范畴之内。 定点表示法用来表示定点小数和定点整数。 事实上，在机器内部并没有小数点，只是人为约定了小数点的位置。因此，在定点数的编码 和运算中不用考虑对应的定点数是小数还是整数，而只需关心它们的符号位和数值位即可。 定点数的编码表示法主要有以下4种：原码、补码、反码和移码。 (1)原码表示法 用机器数的最高位表示数的符号，其余各位表示数的绝对值。 零的原码表示有正零和负零两种形式，即[+0]原=0,0000000和[-0]=1,0000000。 原码表示的优点：①与真值的对应关系简单、直观，与真值的转换简单；②用原码实现乘除 运算比较简便。缺点：①0的表示不唯一，有±0两个编码；②用原码实现加减运算比较复杂。 (2)补码表示法 补码表示法中的加减运算统一采用加法操作实现。正数的补码和原码相同，负数的补码等于 模 与该负数绝对值之差。 (3)反码表示法 在计算机内部，反码是原码转换补码的中间表示形式。 负数的补码可采用“按位取反，末位加1”的方法得到，若仅“按位取反”而末位不加1, 则就是负数的反码表示。正数的反码表示和相应的原码表示相同。 反码表示存在以下几个方面的不足：①0的表示不唯一 (存在±0);②表示范围比补码少一 个最小负数。因此，反码在计算机中很少使用。 (4)移码表示法 移码常用来表示浮点数的阶码，它只能表示整数。 移码就是在真值X 上加上一个常数(偏置值),通常这个常数取2”,相当于X 在数轴上向正 方向偏移了若干单位，这就是“移码”一词的由来。 移码(假设机器字长为n+1, 偏置值为2”)具有以下特点： ①移码中零的表示唯一 ②一个真值的移码和补码仅差一个符号位，[x] 的符号位取反即得[x]移(“1”表示正，“0” 表示负，这与其他机器数的符号位取值正好相反),反之亦然。 ③移码全0时，对应真值的最小值;移码全1时，对应真值的最大值。 ④移码保持了数据原有的大小顺序，移码大真值就大，移码小真值就小。 原码、补码、反码和移码这4种编码表示的总结如下： ①原码、补码、反码的符号位相同，正数的机器码相同。 ②原码、反码的表示在数轴上对称，二者都存在+0和-0两个0。 ③补码、移码的表示在数轴上不对称，零的表示唯一，它们比原码、反码多表示一个数。 ④原码很容易判断大小。而负数的补码、反码很难直接判断大小，可采用如下规则快速判断：对于负数，数值位部分越小，其绝对值越大，即负得越多。",
    "create_time": 1761467354,
    "update_time": 1761467354,
    "_id": "doc-5b233c3ec097f13f398ea0ca159b2c8b"
  }
}