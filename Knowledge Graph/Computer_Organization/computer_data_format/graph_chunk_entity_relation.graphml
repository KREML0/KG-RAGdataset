<?xml version='1.0' encoding='utf-8'?>
<graphml xmlns="http://graphml.graphdrawing.org/xmlns" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://graphml.graphdrawing.org/xmlns http://graphml.graphdrawing.org/xmlns/1.0/graphml.xsd">
  <key id="d11" for="edge" attr.name="created_at" attr.type="long" />
  <key id="d10" for="edge" attr.name="file_path" attr.type="string" />
  <key id="d9" for="edge" attr.name="source_id" attr.type="string" />
  <key id="d8" for="edge" attr.name="keywords" attr.type="string" />
  <key id="d7" for="edge" attr.name="description" attr.type="string" />
  <key id="d6" for="edge" attr.name="weight" attr.type="double" />
  <key id="d5" for="node" attr.name="created_at" attr.type="long" />
  <key id="d4" for="node" attr.name="file_path" attr.type="string" />
  <key id="d3" for="node" attr.name="source_id" attr.type="string" />
  <key id="d2" for="node" attr.name="description" attr.type="string" />
  <key id="d1" for="node" attr.name="entity_type" attr.type="string" />
  <key id="d0" for="node" attr.name="entity_id" attr.type="string" />
  <graph edgedefault="undirected">
    <node id="Floating Point Normalization">
      <data key="d0">Floating Point Normalization</data>
      <data key="d1">concept</data>
      <data key="d2">Floating point normalization is a process used in floating-point arithmetic to maximize the retention of significant digits by adjusting the mantissa and exponent so that the leading digit of the mantissa is non-zero.</data>
      <data key="d3">chunk-c22f61a22dddcf7887de6d879988c291</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467378</data>
    </node>
    <node id="Non-Zero Floating Point Number">
      <data key="d0">Non-Zero Floating Point Number</data>
      <data key="d1">concept</data>
      <data key="d2">A non-zero floating-point number is one that requires normalization to ensure the leading digit of its mantissa is valid and within the required range.</data>
      <data key="d3">chunk-c22f61a22dddcf7887de6d879988c291</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467378</data>
    </node>
    <node id="Mantissa">
      <data key="d0">Mantissa</data>
      <data key="d1">component</data>
      <data key="d2">The mantissa is the fractional part of a floating-point number that holds the significant digits.&lt;SEP&gt;The mantissa, also known as the significand, holds the significant digits of a floating point number and contributes to its precision.</data>
      <data key="d3">chunk-c22f61a22dddcf7887de6d879988c291&lt;SEP&gt;chunk-5ea05d0aadedcb24741fd320a2b9543c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467673</data>
    </node>
    <node id="Exponent">
      <data key="d0">Exponent</data>
      <data key="d1">component</data>
      <data key="d2">The exponent, also known as the阶码in Chinese, determines the scale of the floating-point number by specifying the power of the base.&lt;SEP&gt;The exponent determines the scale or position of the decimal point in a floating point number, affecting the range of representable values.</data>
      <data key="d3">chunk-c22f61a22dddcf7887de6d879988c291&lt;SEP&gt;chunk-5ea05d0aadedcb24741fd320a2b9543c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467673</data>
    </node>
    <node id="Left Normalization">
      <data key="d0">Left Normalization</data>
      <data key="d1">method</data>
      <data key="d2">Left normalization is a procedure applied when the leading digit of the mantissa is not a valid significant digit; it involves shifting the mantissa left and decreasing the exponent by one for each shift (base 2).</data>
      <data key="d3">chunk-c22f61a22dddcf7887de6d879988c291</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467378</data>
    </node>
    <node id="Right Normalization">
      <data key="d0">Right Normalization</data>
      <data key="d1">method</data>
      <data key="d2">Right normalization is performed when the significant digits have overflowed into the integer part of the number; it involves shifting the mantissa right by one and increasing the exponent by one (base 2), typically performed only once.</data>
      <data key="d3">chunk-c22f61a22dddcf7887de6d879988c291</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467378</data>
    </node>
    <node id="Base 2">
      <data key="d0">Base 2</data>
      <data key="d1">concept</data>
      <data key="d2">Base 2 refers to the binary system used in floating-point representations where operations like normalization are defined in terms of powers of two.</data>
      <data key="d3">chunk-c22f61a22dddcf7887de6d879988c291</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467378</data>
    </node>
    <node id="Overflow">
      <data key="d0">Overflow</data>
      <data key="d1">concept</data>
      <data key="d2">Overflow occurs during right normalization when the exponent increases beyond its maximum representable value.&lt;SEP&gt;Overflow is a condition in floating point arithmetic when a result exceeds the largest representable value, either positively or negatively.&lt;SEP&gt;Overflow occurs when a number exceeds the maximum representable value for a given data type, resulting in undefined or incorrect values.</data>
      <data key="d3">chunk-c22f61a22dddcf7887de6d879988c291&lt;SEP&gt;chunk-5ea05d0aadedcb24741fd320a2b9543c&lt;SEP&gt;chunk-7661b58ae4a51d1ee96186ef15ec5292</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467756</data>
    </node>
    <node id="Significant Digit">
      <data key="d0">Significant Digit</data>
      <data key="d1">concept</data>
      <data key="d2">A significant digit is a non-zero digit that contributes to the precision of a floating-point number and is preserved during normalization to ensure maximum accuracy.</data>
      <data key="d3">chunk-c22f61a22dddcf7887de6d879988c291</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467379</data>
    </node>
    <node id="Unsigned Integer">
      <data key="d0">Unsigned Integer</data>
      <data key="d1">category</data>
      <data key="d2">An unsigned integer is a numerical representation where all binary bits are used as value bits, with no sign bit, and always represents a positive number.&lt;SEP&gt;Unsigned integer is an integer type that represents only non-negative values, with no sign bit.</data>
      <data key="d3">chunk-eb70606fa9ba73ffc22231992979ee26&lt;SEP&gt;chunk-224035519c723875f8ee06a75cc06f38</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467561</data>
    </node>
    <node id="Binary Encoding">
      <data key="d0">Binary Encoding</data>
      <data key="d1">method</data>
      <data key="d2">Binary encoding refers to the representation of data using binary digits (0s and 1s), with all bits contributing to the magnitude in unsigned integers.&lt;SEP&gt;Binary encoding is the process of representing numerical values in binary form, including sign and magnitude, used in computer systems.</data>
      <data key="d3">chunk-fe930da67280065a9ab94641ffc7e10e&lt;SEP&gt;chunk-224035519c723875f8ee06a75cc06f38</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467404</data>
    </node>
    <node id="Sign Bit">
      <data key="d0">Sign Bit</data>
      <data key="d1">artifact</data>
      <data key="d2">The sign bit is a binary bit used in signed number representations to indicate positive or negative values; it is absent in unsigned integers.&lt;SEP&gt;Sign bit is the most significant bit in a binary number that indicates the sign, where "0" represents positive and "1" represents negative.&lt;SEP&gt;The sign bit is the most significant bit in a binary representation of a signed integer, indicating whether the number is positive or negative.&lt;SEP&gt;The sign bit is the most significant bit in a floating point number that indicates whether the number is positive or negative.&lt;SEP&gt;Sign Bit is the most significant bit in a binary number that indicates whether the number is positive or negative.</data>
      <data key="d3">chunk-224035519c723875f8ee06a75cc06f38&lt;SEP&gt;chunk-5ea05d0aadedcb24741fd320a2b9543c&lt;SEP&gt;chunk-fe930da67280065a9ab94641ffc7e10e&lt;SEP&gt;chunk-ea5d582d57c5196325119e4d99f578d2&lt;SEP&gt;chunk-5b233c3ec097f13f398ea0ca159b2c8b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467831</data>
    </node>
    <node id="Word Length">
      <data key="d0">Word Length</data>
      <data key="d1">concept</data>
      <data key="d2">Word length refers to the number of bits used to represent a number; it affects the maximum value that can be represented.</data>
      <data key="d3">chunk-224035519c723875f8ee06a75cc06f38</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467385</data>
    </node>
    <node id="8-Bit Unsigned Integer">
      <data key="d0">8-Bit Unsigned Integer</data>
      <data key="d1">data</data>
      <data key="d2">An 8-bit unsigned integer uses eight binary digits, with a range from 00000000 (0) to 11111111 (255).</data>
      <data key="d3">chunk-224035519c723875f8ee06a75cc06f38</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467385</data>
    </node>
    <node id="8-Bit Signed Integer">
      <data key="d0">8-Bit Signed Integer</data>
      <data key="d1">data</data>
      <data key="d2">An 8-bit signed integer uses the two's complement representation, with a range from 10000000 (-128) to 01111111 (127).</data>
      <data key="d3">chunk-224035519c723875f8ee06a75cc06f38</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467385</data>
    </node>
    <node id="Maximum Value">
      <data key="d0">Maximum Value</data>
      <data key="d1">concept</data>
      <data key="d2">Maximum value is the highest number that can be represented by a given bit length and encoding format.</data>
      <data key="d3">chunk-224035519c723875f8ee06a75cc06f38</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467385</data>
    </node>
    <node id="Two's Complement">
      <data key="d0">Two's Complement</data>
      <data key="d1">method</data>
      <data key="d2">Two's complement is a binary representation method for signed integers that allows efficient arithmetic operations and handles negative numbers.&lt;SEP&gt;Two's Complement is the binary representation method used for storing signed integers in C Language, where the most significant bit represents the sign and the remaining bits represent the magnitude.&lt;SEP&gt;Two's complement is the standard method used in computer systems to represent signed integers, formed by inverting the bits of a number and adding one to the least significant bit.&lt;SEP&gt;Two's complement is a binary representation method for signed numbers, allowing efficient arithmetic operations and comparison.</data>
      <data key="d3">chunk-1bf253441ffd1d27c8127187db5ecb32&lt;SEP&gt;chunk-ea5d582d57c5196325119e4d99f578d2&lt;SEP&gt;chunk-224035519c723875f8ee06a75cc06f38&lt;SEP&gt;chunk-7f2cde5c650ea54bac6265e49d30e485</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467621</data>
    </node>
    <node id="Address Operation">
      <data key="d0">Address Operation</data>
      <data key="d1">method</data>
      <data key="d2">Address operation refers to the manipulation of memory addresses using integer arithmetic, commonly performed with unsigned integers.</data>
      <data key="d3">chunk-224035519c723875f8ee06a75cc06f38</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467386</data>
    </node>
    <node id="Pointer Representation">
      <data key="d0">Pointer Representation</data>
      <data key="d1">method</data>
      <data key="d2">Pointer representation involves using integers to represent memory addresses, typically implemented using unsigned integers.</data>
      <data key="d3">chunk-224035519c723875f8ee06a75cc06f38</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467387</data>
    </node>
    <node id="Value Range">
      <data key="d0">Value Range</data>
      <data key="d1">concept</data>
      <data key="d2">Value range refers to the set of all possible values that a number representation can express, depending on the bit length and encoding method.</data>
      <data key="d3">chunk-224035519c723875f8ee06a75cc06f38</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467387</data>
    </node>
    <node id="00000000">
      <data key="d0">00000000</data>
      <data key="d1">data</data>
      <data key="d2">The binary sequence 00000000 represents the minimum value of an 8-bit unsigned integer, which is 0.</data>
      <data key="d3">chunk-224035519c723875f8ee06a75cc06f38</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467387</data>
    </node>
    <node id="11111111">
      <data key="d0">11111111</data>
      <data key="d1">data</data>
      <data key="d2">The binary sequence 11111111 represents the maximum value of an 8-bit unsigned integer, which is 255.</data>
      <data key="d3">chunk-224035519c723875f8ee06a75cc06f38</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467387</data>
    </node>
    <node id="10000000">
      <data key="d0">10000000</data>
      <data key="d1">data</data>
      <data key="d2">The binary sequence 10000000 represents the minimum value of an 8-bit signed integer in two's complement, which is -128.</data>
      <data key="d3">chunk-224035519c723875f8ee06a75cc06f38</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467387</data>
    </node>
    <node id="01111111">
      <data key="d0">01111111</data>
      <data key="d1">data</data>
      <data key="d2">The binary sequence 01111111 represents the maximum value of an 8-bit signed integer in two's complement, which is 127.</data>
      <data key="d3">chunk-224035519c723875f8ee06a75cc06f38</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467387</data>
    </node>
    <node id="Signed Integer">
      <data key="d0">Signed Integer</data>
      <data key="d3">chunk-224035519c723875f8ee06a75cc06f38&lt;SEP&gt;chunk-eb70606fa9ba73ffc22231992979ee26&lt;SEP&gt;chunk-ea5d582d57c5196325119e4d99f578d2&lt;SEP&gt;chunk-7661b58ae4a51d1ee96186ef15ec5292</data>
      <data key="d2">Signed integers are commonly represented using the two's complement method to encode negative numbers.&lt;SEP&gt;A signed integer is a numerical representation in computing where the sign is included with the value, typically stored with the sign bit preceding the magnitude.&lt;SEP&gt;Signed integer is an integer type that can represent both positive and negative values, using the most significant bit as a sign bit.&lt;SEP&gt;Signed Integer is a data type that can represent both positive and negative whole numbers, using a sign bit.</data>
      <data key="d1">type</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467756</data>
    </node>
    <node id="True Value">
      <data key="d0">True Value</data>
      <data key="d1">concept</data>
      <data key="d2">True value refers to the actual numerical value of a number, represented with a positive or negative sign, such as +15 or -8, commonly used in daily life.&lt;SEP&gt;True Value refers to the actual numerical value before encoding into machine representations such as original, complement, one’s complement, or bias codes.</data>
      <data key="d3">chunk-fe930da67280065a9ab94641ffc7e10e&lt;SEP&gt;chunk-5b233c3ec097f13f398ea0ca159b2c8b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467831</data>
    </node>
    <node id="Machine Number">
      <data key="d0">Machine Number</data>
      <data key="d1">concept</data>
      <data key="d2">Machine number is a digital representation of a number in computer systems, where the sign is encoded with "0" for positive and "1" for negative, combining sign and magnitude into a single binary format.</data>
      <data key="d3">chunk-fe930da67280065a9ab94641ffc7e10e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467404</data>
    </node>
    <node id="Positive Sign">
      <data key="d0">Positive Sign</data>
      <data key="d1">symbol</data>
      <data key="d2">Positive sign, represented by "+" or typically omitted, indicates a positive number in true value notation.</data>
      <data key="d3">chunk-fe930da67280065a9ab94641ffc7e10e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467404</data>
    </node>
    <node id="Negative Sign">
      <data key="d0">Negative Sign</data>
      <data key="d1">symbol</data>
      <data key="d2">Negative sign, represented by "-", indicates a negative number in true value notation.</data>
      <data key="d3">chunk-fe930da67280065a9ab94641ffc7e10e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467404</data>
    </node>
    <node id="Original Code">
      <data key="d0">Original Code</data>
      <data key="d1">method</data>
      <data key="d2">Original code is a method of representing signed binary numbers where the most significant bit represents the sign (0 for positive, 1 for negative) and the rest represent the magnitude.&lt;SEP&gt;Original code is a binary representation of a signed integer where the sign is represented by a separate bit and the magnitude is stored in true binary form.&lt;SEP&gt;Original Code is a representation method where the most significant bit indicates the sign and the rest represent the absolute value of the number.</data>
      <data key="d3">chunk-fe930da67280065a9ab94641ffc7e10e&lt;SEP&gt;chunk-ea5d582d57c5196325119e4d99f578d2&lt;SEP&gt;chunk-5b233c3ec097f13f398ea0ca159b2c8b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467829</data>
    </node>
    <node id="Complement Code">
      <data key="d0">Complement Code</data>
      <data key="d1">method</data>
      <data key="d2">Complement code is a binary representation method used in computers to simplify arithmetic operations, where negative numbers are represented as the complement of their positive counterparts.&lt;SEP&gt;Complement Code is the representation method used for storing integers in C Language, where signed integers use two's complement and unsigned integers represent absolute values.&lt;SEP&gt;Complement code is a binary representation of a signed integer that simplifies arithmetic operations and ensures a unique representation for zero.&lt;SEP&gt;Complement Code is a representation method for signed integers in computers, where the sign bit is included and negative numbers are represented as the modulus minus the absolute value.</data>
      <data key="d3">chunk-fe930da67280065a9ab94641ffc7e10e&lt;SEP&gt;chunk-ea5d582d57c5196325119e4d99f578d2&lt;SEP&gt;chunk-5b233c3ec097f13f398ea0ca159b2c8b&lt;SEP&gt;chunk-7f2cde5c650ea54bac6265e49d30e485</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467829</data>
    </node>
    <node id="One's Complement">
      <data key="d0">One's Complement</data>
      <data key="d1">method</data>
      <data key="d2">One's complement is a binary representation method where the negative of a number is obtained by inverting all bits of its positive version.&lt;SEP&gt;One's complement is a binary representation method where the negative of a number is obtained by inverting all bits of the positive number.&lt;SEP&gt;One's Complement is a binary representation method used as an intermediate step in computing complement codes, where bits are inverted without adding one.</data>
      <data key="d3">chunk-fe930da67280065a9ab94641ffc7e10e&lt;SEP&gt;chunk-ea5d582d57c5196325119e4d99f578d2&lt;SEP&gt;chunk-5b233c3ec097f13f398ea0ca159b2c8b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467829</data>
    </node>
    <node id="Numerical Part">
      <data key="d0">Numerical Part</data>
      <data key="d1">data</data>
      <data key="d2">Numerical part refers to the portion of a number that represents its magnitude, excluding the sign.</data>
      <data key="d3">chunk-fe930da67280065a9ab94641ffc7e10e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467406</data>
    </node>
    <node id="Binary Digit">
      <data key="d0">Binary Digit</data>
      <data key="d1">artifact</data>
      <data key="d2">Binary digit, or bit, is the basic unit of information in computing, with a value of 0 or 1.</data>
      <data key="d3">chunk-fe930da67280065a9ab94641ffc7e10e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467406</data>
    </node>
    <node id="Comma">
      <data key="d0">Comma</data>
      <data key="d1">artifact</data>
      <data key="d2">Comma is used in binary notation to separate the sign bit from the numerical part, such as in "0,101" where "0" is the sign bit and "101" is the numerical part.</data>
      <data key="d3">chunk-fe930da67280065a9ab94641ffc7e10e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467406</data>
    </node>
    <node id="C Language">
      <data key="d0">C Language</data>
      <data key="d1">concept</data>
      <data key="d2">C Language is a programming language that includes various data types for integer and character handling.&lt;SEP&gt;C Language is a programming language that allows type conversions between different data types, including symbol and word length conversions.&lt;SEP&gt;C Language is a general-purpose programming language widely used for system and application development, known for its low-level memory manipulation and efficient performance.</data>
      <data key="d3">chunk-eb70606fa9ba73ffc22231992979ee26&lt;SEP&gt;chunk-7f2cde5c650ea54bac6265e49d30e485&lt;SEP&gt;chunk-7661b58ae4a51d1ee96186ef15ec5292</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467754</data>
    </node>
    <node id="Short Int">
      <data key="d0">Short Int</data>
      <data key="d1">data</data>
      <data key="d2">Short Int is a signed integer data type in C Language with a size of 16 bits.</data>
      <data key="d3">chunk-7f2cde5c650ea54bac6265e49d30e485</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467426</data>
    </node>
    <node id="Int">
      <data key="d0">Int</data>
      <data key="d1">data</data>
      <data key="d2">Int is a signed integer data type in C Language with a size of 32 bits.</data>
      <data key="d3">chunk-7f2cde5c650ea54bac6265e49d30e485</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467426</data>
    </node>
    <node id="Long Int">
      <data key="d0">Long Int</data>
      <data key="d1">data</data>
      <data key="d2">Long Int is a signed integer data type in C Language with a size of 32 bits on 32-bit machines and 64 bits on 64-bit machines.</data>
      <data key="d3">chunk-7f2cde5c650ea54bac6265e49d30e485</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467426</data>
    </node>
    <node id="Unsigned Short">
      <data key="d0">Unsigned Short</data>
      <data key="d1">data</data>
      <data key="d2">Unsigned Short is an unsigned integer data type in C Language with a size of 16 bits.</data>
      <data key="d3">chunk-7f2cde5c650ea54bac6265e49d30e485</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467426</data>
    </node>
    <node id="Unsigned Int">
      <data key="d0">Unsigned Int</data>
      <data key="d1">data</data>
      <data key="d2">Unsigned Int is an unsigned integer data type in C Language with a size of 32 bits.</data>
      <data key="d3">chunk-7f2cde5c650ea54bac6265e49d30e485</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467426</data>
    </node>
    <node id="Unsigned Long">
      <data key="d0">Unsigned Long</data>
      <data key="d1">data</data>
      <data key="d2">Unsigned Long is an unsigned integer data type in C Language with a size of 32 bits on 32-bit machines and 64 bits on 64-bit machines.</data>
      <data key="d3">chunk-7f2cde5c650ea54bac6265e49d30e485</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467426</data>
    </node>
    <node id="Char">
      <data key="d0">Char</data>
      <data key="d1">data</data>
      <data key="d2">Char is a character data type in C Language with a size of 8 bits, defaulting to unsigned integer interpretation.</data>
      <data key="d3">chunk-7f2cde5c650ea54bac6265e49d30e485</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467426</data>
    </node>
    <node id="Signed">
      <data key="d0">Signed</data>
      <data key="d1">concept</data>
      <data key="d2">Signed refers to integer types that use the most significant bit to represent the sign of the number.</data>
      <data key="d3">chunk-7f2cde5c650ea54bac6265e49d30e485</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467427</data>
    </node>
    <node id="Unsigned">
      <data key="d0">Unsigned</data>
      <data key="d1">concept</data>
      <data key="d2">Unsigned refers to integer types that use all bits to represent the magnitude of the number, with no sign bit.</data>
      <data key="d3">chunk-7f2cde5c650ea54bac6265e49d30e485</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467428</data>
    </node>
    <node id="Offset Code">
      <data key="d0">Offset Code</data>
      <data key="d1">method</data>
      <data key="d2">Offset code is a binary representation where a fixed bias is added to the actual value to represent negative numbers in an unsigned format.</data>
      <data key="d3">chunk-ea5d582d57c5196325119e4d99f578d2</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467453</data>
    </node>
    <node id="n-Bit Signed Integer">
      <data key="d0">n-Bit Signed Integer</data>
      <data key="d1">concept</data>
      <data key="d2">An n-bit signed integer uses n bits to represent integers with a range determined by the encoding method, typically from -2^(n-1) to 2^(n-1)-1 when using two's complement.</data>
      <data key="d3">chunk-ea5d582d57c5196325119e4d99f578d2</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467453</data>
    </node>
    <node id="Two's Complement Representation">
      <data key="d0">Two's Complement Representation</data>
      <data key="d1">method</data>
      <data key="d2">Two's complement representation is the preferred method in computing for representing signed integers, offering a unique zero and allowing signed arithmetic using the same hardware as unsigned operations.</data>
      <data key="d3">chunk-ea5d582d57c5196325119e4d99f578d2</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467453</data>
    </node>
    <node id="Range of n-Bit Signed Integer">
      <data key="d0">Range of n-Bit Signed Integer</data>
      <data key="d1">concept</data>
      <data key="d2">The range of an n-bit signed integer using two's complement is -2^(n-1) to 2^(n-1)-1, providing an additional negative number compared to other representations.</data>
      <data key="d3">chunk-ea5d582d57c5196325119e4d99f578d2</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467454</data>
    </node>
    <node id="进位计数制">
      <data key="d0">进位计数制</data>
      <data key="d1">concept</data>
      <data key="d2">进位计数制是一种数位计数方法，其中每个数位的数值基于基数和位权，计满基数后向高位进位。</data>
      <data key="d3">chunk-ca423326f2f43c01238f9b5f5a0e0862</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467458</data>
    </node>
    <node id="十进制">
      <data key="d0">十进制</data>
      <data key="d1">concept</data>
      <data key="d2">十进制是一种基数为10的进位计数制，使用数码0到9，逢十进一，是日常生活中最常用的计数制。</data>
      <data key="d3">chunk-ca423326f2f43c01238f9b5f5a0e0862</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467458</data>
    </node>
    <node id="二进制">
      <data key="d0">二进制</data>
      <data key="d1">concept</data>
      <data key="d2">二进制是一种基数为2的进位计数制，使用数码0和1，逢二进一，广泛应用于计算机系统中。</data>
      <data key="d3">chunk-ca423326f2f43c01238f9b5f5a0e0862</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467458</data>
    </node>
    <node id="八进制">
      <data key="d0">八进制</data>
      <data key="d1">concept</data>
      <data key="d2">八进制是一种基数为8的进位计数制，使用数码0到7，逢八进一，其三位二进制数可转换为一位八进制数。</data>
      <data key="d3">chunk-ca423326f2f43c01238f9b5f5a0e0862</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467458</data>
    </node>
    <node id="十六进制">
      <data key="d0">十六进制</data>
      <data key="d1">concept</data>
      <data key="d2">十六进制是一种基数为16的进位计数制，使用数码0到9和A到F(分别代表10到15)，逢十六进一，其四位二进制数可转换为一位十六进制数。</data>
      <data key="d3">chunk-ca423326f2f43c01238f9b5f5a0e0862</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467458</data>
    </node>
    <node id="基数">
      <data key="d0">基数</data>
      <data key="d1">concept</data>
      <data key="d2">基数是进位计数制中每个数位所用不同数码的个数，决定了计数进位的规则。</data>
      <data key="d3">chunk-ca423326f2f43c01238f9b5f5a0e0862</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467458</data>
    </node>
    <node id="位权">
      <data key="d0">位权</data>
      <data key="d1">concept</data>
      <data key="d2">位权是每个数位上数码所乘的常数，表示该数码在数值中的权重，与所在数位位置相关。</data>
      <data key="d3">chunk-ca423326f2f43c01238f9b5f5a0e0862</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467458</data>
    </node>
    <node id="二进制数码">
      <data key="d0">二进制数码</data>
      <data key="d1">artifact</data>
      <data key="d2">二进制数码是二进制计数制中使用的0和1两个数码，构成计算机信息的基本单元。</data>
      <data key="d3">chunk-ca423326f2f43c01238f9b5f5a0e0862</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467458</data>
    </node>
    <node id="八进制数码">
      <data key="d0">八进制数码</data>
      <data key="d1">artifact</data>
      <data key="d2">八进制数码是八进制计数制中使用的0到7共八个数码，可以由三位二进制数编码表示。</data>
      <data key="d3">chunk-ca423326f2f43c01238f9b5f5a0e0862</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467460</data>
    </node>
    <node id="十六进制数码">
      <data key="d0">十六进制数码</data>
      <data key="d1">artifact</data>
      <data key="d2">十六进制数码包括0到9和A到F，其中A到F代表10到15，常用于计算机中简化二进制表示。</data>
      <data key="d3">chunk-ca423326f2f43c01238f9b5f5a0e0862</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467460</data>
    </node>
    <node id="后缀标识">
      <data key="d0">后缀标识</data>
      <data key="d1">method</data>
      <data key="d2">后缀标识是一种用于标记数的进位计数制的方法，如B表示二进制，O表示八进制，D表示十进制，H表示十六进制。</data>
      <data key="d3">chunk-ca423326f2f43c01238f9b5f5a0e0862</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467460</data>
    </node>
    <node id="前缀标识">
      <data key="d0">前缀标识</data>
      <data key="d1">method</data>
      <data key="d2">前缀标识是用于表示数的进位计数制的一种方法，如0x表示十六进制，常用于编程和计算机系统中。</data>
      <data key="d3">chunk-ca423326f2f43c01238f9b5f5a0e0862</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467460</data>
    </node>
    <node id="计算机">
      <data key="d0">计算机</data>
      <data key="d1">artifact</data>
      <data key="d2">计算机是使用二进制、八进制和十六进制数进行数据处理和运算的电子设备。</data>
      <data key="d3">chunk-ca423326f2f43c01238f9b5f5a0e0862</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467460</data>
    </node>
    <node id="0～9">
      <data key="d0">0～9</data>
      <data key="d1">artifact</data>
      <data key="d2">The digits 0 to 9 are the numeric symbols used in the decimal system, forming the basis for representing values in decimal counting.</data>
      <data key="d3">chunk-ca423326f2f43c01238f9b5f5a0e0862</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467460</data>
    </node>
    <node id="A～F">
      <data key="d0">A～F</data>
      <data key="d1">artifact</data>
      <data key="d2">The letters A to F represent the values 10 to 15 in the hexadecimal system, extending the digit set beyond 0–9.</data>
      <data key="d3">chunk-ca423326f2f43c01238f9b5f5a0e0862</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467460</data>
    </node>
    <node id="0～7">
      <data key="d0">0～7</data>
      <data key="d1">artifact</data>
      <data key="d2">The digits 0 to 7 are the numeric symbols used in the octal system, forming the complete set of digits for octal counting.</data>
      <data key="d3">chunk-ca423326f2f43c01238f9b5f5a0e0862</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467460</data>
    </node>
    <node id="2³">
      <data key="d0">2³</data>
      <data key="d1">concept</data>
      <data key="d2">The expression 2³ represents the mathematical relationship where three binary digits can be grouped into one octal digit, as 8 = 2³.</data>
      <data key="d3">chunk-ca423326f2f43c01238f9b5f5a0e0862</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467461</data>
    </node>
    <node id="2⁴">
      <data key="d0">2⁴</data>
      <data key="d1">concept</data>
      <data key="d2">The expression 2⁴ represents the mathematical relationship where four binary digits correspond to one hexadecimal digit, as 16 = 2⁴.</data>
      <data key="d3">chunk-ca423326f2f43c01238f9b5f5a0e0862</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467462</data>
    </node>
    <node id="定点数">
      <data key="d0">定点数</data>
      <data key="d1">concept</data>
      <data key="d2">定点数是一种数值表示方法，其小数点位置固定，适用于表示范围有限但精度较高的数值。&lt;SEP&gt;定点数是用于计算机中表示小数的一种数值格式，其小数点位置固定，在乘法运算中需处理其数值部分的乘积。</data>
      <data key="d3">chunk-8b64d30374af75767b82b53c5d492c80&lt;SEP&gt;chunk-fe285d304d7559e78510976eea6cc1c1</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467633</data>
    </node>
    <node id="浮点数">
      <data key="d0">浮点数</data>
      <data key="d1">concept</data>
      <data key="d2">浮点数是一种数值表示方法，其小数点位置可变，通过阶码和尾数表示，能扩大数值的表示范围。</data>
      <data key="d3">chunk-fe285d304d7559e78510976eea6cc1c1</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467490</data>
    </node>
    <node id="字长">
      <data key="d0">字长</data>
      <data key="d1">concept</data>
      <data key="d2">字长是指计算机中用于表示数据的位数，影响数值的表示范围和精度。</data>
      <data key="d3">chunk-fe285d304d7559e78510976eea6cc1c1</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467490</data>
    </node>
    <node id="表示范围">
      <data key="d0">表示范围</data>
      <data key="d1">concept</data>
      <data key="d2">表示范围指数值表示方法能够涵盖的最小值和最大值之间的区间。</data>
      <data key="d3">chunk-fe285d304d7559e78510976eea6cc1c1</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467490</data>
    </node>
    <node id="精度">
      <data key="d0">精度</data>
      <data key="d1">concept</data>
      <data key="d2">精度指数值表示过程中能够区分的最小数值差异，反映表示的细致程度。</data>
      <data key="d3">chunk-fe285d304d7559e78510976eea6cc1c1</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467490</data>
    </node>
    <node id="阶码">
      <data key="d0">阶码</data>
      <data key="d1">artifact</data>
      <data key="d2">阶码是浮点数的一部分，用于表示数值的指数部分，决定数的量级。</data>
      <data key="d3">chunk-fe285d304d7559e78510976eea6cc1c1</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467490</data>
    </node>
    <node id="尾数">
      <data key="d0">尾数</data>
      <data key="d1">artifact</data>
      <data key="d2">尾数是浮点数的一部分，用于表示数值的有效数字部分，决定数的精度。</data>
      <data key="d3">chunk-fe285d304d7559e78510976eea6cc1c1</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467490</data>
    </node>
    <node id="规格化">
      <data key="d0">规格化</data>
      <data key="d1">method</data>
      <data key="d2">规格化是浮点数运算中的一种处理方式，确保尾数的最高位为非零值，以提高表示效率。</data>
      <data key="d3">chunk-fe285d304d7559e78510976eea6cc1c1</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467490</data>
    </node>
    <node id="溢出">
      <data key="d0">溢出</data>
      <data key="d1">concept</data>
      <data key="d2">溢出指当计算结果超出数据表示能力的范围时发生的现象。&lt;SEP&gt;溢出occurs when the result of an arithmetic or logical operation exceeds the capacity of the storage format, leading to data loss or incorrect values.&lt;SEP&gt;溢出发生在数值位相加时最高位产生进位，导致结果超出表示范围。</data>
      <data key="d3">chunk-fe285d304d7559e78510976eea6cc1c1&lt;SEP&gt;chunk-ee63e6f80ae58c99375bb442c346b8a6&lt;SEP&gt;chunk-ea2c16caf28ea549ed420e26afbca237</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467784</data>
    </node>
    <node id="定点运算">
      <data key="d0">定点运算</data>
      <data key="d1">method</data>
      <data key="d2">定点运算指对定点数进行的数学运算，过程相对简单，仅涉及固定小数点的数值操作。</data>
      <data key="d3">chunk-fe285d304d7559e78510976eea6cc1c1</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467492</data>
    </node>
    <node id="浮点运算">
      <data key="d0">浮点运算</data>
      <data key="d1">method</data>
      <data key="d2">浮点运算指对浮点数进行的数学运算，包括尾数和阶码的独立运算及结果规格化。</data>
      <data key="d3">chunk-fe285d304d7559e78510976eea6cc1c1</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467492</data>
    </node>
    <node id="Arithmetic Logic Unit">
      <data key="d0">Arithmetic Logic Unit</data>
      <data key="d1">artifact</data>
      <data key="d2">The Arithmetic Logic Unit (ALU) is a core component of the computer's processor responsible for performing arithmetic and logical operations.</data>
      <data key="d3">chunk-6151c8c091207072ad8e5a4c89b6cd43</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467504</data>
    </node>
    <node id="Shift Register">
      <data key="d0">Shift Register</data>
      <data key="d1">artifact</data>
      <data key="d2">The shift register is a digital circuit used for moving data bits through a series of storage elements.</data>
      <data key="d3">chunk-6151c8c091207072ad8e5a4c89b6cd43</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467504</data>
    </node>
    <node id="Status Register">
      <data key="d0">Status Register</data>
      <data key="d1">artifact</data>
      <data key="d2">The status register (PSW) stores information about the current state of the processor, such as carry and zero flags.</data>
      <data key="d3">chunk-6151c8c091207072ad8e5a4c89b6cd43</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467504</data>
    </node>
    <node id="General-Purpose Register Set">
      <data key="d0">General-Purpose Register Set</data>
      <data key="d1">artifact</data>
      <data key="d2">The general-purpose register set consists of multiple registers used to hold data temporarily during processing.</data>
      <data key="d3">chunk-6151c8c091207072ad8e5a4c89b6cd43</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467504</data>
    </node>
    <node id="Addition">
      <data key="d0">Addition</data>
      <data key="d1">method</data>
      <data key="d2">Addition is a fundamental arithmetic operation performed by the ALU, forming the basis for other arithmetic functions.</data>
      <data key="d3">chunk-6151c8c091207072ad8e5a4c89b6cd43</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467504</data>
    </node>
    <node id="Subtraction">
      <data key="d0">Subtraction</data>
      <data key="d1">operation</data>
      <data key="d2">Subtraction is an arithmetic operation implemented through the ALU, typically using addition with complemented operands.&lt;SEP&gt;Subtraction refers to the arithmetic operation [A] - [B], used for comparing two signed numbers.</data>
      <data key="d3">chunk-1bf253441ffd1d27c8127187db5ecb32&lt;SEP&gt;chunk-6151c8c091207072ad8e5a4c89b6cd43</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467621</data>
    </node>
    <node id="Multiplication">
      <data key="d0">Multiplication</data>
      <data key="d1">method</data>
      <data key="d2">Multiplication is an arithmetic operation executed by the ALU, usually reduced to repeated addition.</data>
      <data key="d3">chunk-6151c8c091207072ad8e5a4c89b6cd43</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467504</data>
    </node>
    <node id="Division">
      <data key="d0">Division</data>
      <data key="d1">method</data>
      <data key="d2">Division is an arithmetic operation performed by the ALU, often implemented via iterative subtraction or multiplication.</data>
      <data key="d3">chunk-6151c8c091207072ad8e5a4c89b6cd43</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467504</data>
    </node>
    <node id="Logical AND">
      <data key="d0">Logical AND</data>
      <data key="d1">method</data>
      <data key="d2">Logical AND is a binary operation that produces a true output only when both inputs are true.</data>
      <data key="d3">chunk-6151c8c091207072ad8e5a4c89b6cd43</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467506</data>
    </node>
    <node id="Logical OR">
      <data key="d0">Logical OR</data>
      <data key="d1">method</data>
      <data key="d2">Logical OR is a binary operation that produces a true output if at least one input is true.</data>
      <data key="d3">chunk-6151c8c091207072ad8e5a4c89b6cd43</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467506</data>
    </node>
    <node id="Logical NOT">
      <data key="d0">Logical NOT</data>
      <data key="d1">method</data>
      <data key="d2">Logical NOT is a unary operation that inverts the input value.</data>
      <data key="d3">chunk-6151c8c091207072ad8e5a4c89b6cd43</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467506</data>
    </node>
    <node id="Logical XOR">
      <data key="d0">Logical XOR</data>
      <data key="d1">method</data>
      <data key="d2">Logical XOR is a binary operation that outputs true when the inputs differ.</data>
      <data key="d3">chunk-6151c8c091207072ad8e5a4c89b6cd43</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467506</data>
    </node>
    <node id="Shifting">
      <data key="d0">Shifting</data>
      <data key="d1">method</data>
      <data key="d2">Shifting refers to moving bits within a register, either left or right, to facilitate arithmetic or logical operations.</data>
      <data key="d3">chunk-6151c8c091207072ad8e5a4c89b6cd43</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467506</data>
    </node>
    <node id="Twos Complement">
      <data key="d0">Twos Complement</data>
      <data key="d1">method</data>
      <data key="d2">Two’s complement is a method for representing negative numbers in binary form, allowing subtraction via addition.</data>
      <data key="d3">chunk-6151c8c091207072ad8e5a4c89b6cd43</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467506</data>
    </node>
    <node id="One-Bit Full Adder">
      <data key="d0">One-Bit Full Adder</data>
      <data key="d1">artifact</data>
      <data key="d2">The one-bit full adder (FA) is the fundamental building block of digital adders, with three inputs (A, B, C_in) and two outputs (sum, C_out).</data>
      <data key="d3">chunk-6151c8c091207072ad8e5a4c89b6cd43</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467506</data>
    </node>
    <node id="Serial Carry Adder">
      <data key="d0">Serial Carry Adder</data>
      <data key="d1">artifact</data>
      <data key="d2">The serial carry adder, also known as a ripple carry adder, connects multiple full adders in sequence where carry propagates from one stage to the next.</data>
      <data key="d3">chunk-6151c8c091207072ad8e5a4c89b6cd43</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467506</data>
    </node>
    <node id="Carry Propagation Delay">
      <data key="d0">Carry Propagation Delay</data>
      <data key="d1">concept</data>
      <data key="d2">Carry propagation delay refers to the time delay caused by the sequential transmission of carry signals through each stage of a serial carry adder.</data>
      <data key="d3">chunk-6151c8c091207072ad8e5a4c89b6cd43</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467507</data>
    </node>
    <node id="Parallel Carry Adder">
      <data key="d0">Parallel Carry Adder</data>
      <data key="d1">artifact</data>
      <data key="d2">The parallel carry adder, also known as a carry-lookahead adder (CLA), computes carry signals in parallel to reduce delay.</data>
      <data key="d3">chunk-6151c8c091207072ad8e5a4c89b6cd43</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467508</data>
    </node>
    <node id="Carry-Lookahead Unit">
      <data key="d0">Carry-Lookahead Unit</data>
      <data key="d1">artifact</data>
      <data key="d2">The carry-lookahead unit (CLA) is a circuit that generates carry signals simultaneously for all bit positions, improving performance.</data>
      <data key="d3">chunk-6151c8c091207072ad8e5a4c89b6cd43</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467508</data>
    </node>
    <node id="4-Bit Carry-Lookahead Adder">
      <data key="d0">4-Bit Carry-Lookahead Adder</data>
      <data key="d1">artifact</data>
      <data key="d2">The 4-bit carry-lookahead adder is a specific implementation of a parallel carry adder using a CLA unit for four bits.</data>
      <data key="d3">chunk-6151c8c091207072ad8e5a4c89b6cd43</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467508</data>
    </node>
    <node id="Overflow Flag">
      <data key="d0">Overflow Flag</data>
      <data key="d1">artifact</data>
      <data key="d2">The overflow flag (OF) indicates whether an arithmetic operation results in an overflow beyond the representable range.</data>
      <data key="d3">chunk-6151c8c091207072ad8e5a4c89b6cd43</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467508</data>
    </node>
    <node id="Carry Flag">
      <data key="d0">Carry Flag</data>
      <data key="d1">artifact</data>
      <data key="d2">The carry flag (CF) indicates whether a carry-out occurred from the most significant bit during an addition operation.</data>
      <data key="d3">chunk-6151c8c091207072ad8e5a4c89b6cd43</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467508</data>
    </node>
    <node id="Sign Flag">
      <data key="d0">Sign Flag</data>
      <data key="d1">artifact</data>
      <data key="d2">The sign flag (SF) indicates the sign of the result after an arithmetic operation, typically set by the most significant bit.</data>
      <data key="d3">chunk-6151c8c091207072ad8e5a4c89b6cd43</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467508</data>
    </node>
    <node id="Zero Flag">
      <data key="d0">Zero Flag</data>
      <data key="d1">data</data>
      <data key="d2">The zero flag (ZF) indicates whether the result of an operation is zero.&lt;SEP&gt;Zero Flag (ZF) is a processor status flag that is set to 1 when the result of an operation is zero.</data>
      <data key="d3">chunk-ba5ba3047ff33c33c3e78b969b12b98e&lt;SEP&gt;chunk-6151c8c091207072ad8e5a4c89b6cd43</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467687</data>
    </node>
    <node id="n-Bit Adder">
      <data key="d0">n-Bit Adder</data>
      <data key="d1">artifact</data>
      <data key="d2">An n-bit adder is a digital circuit designed to add two n-bit binary numbers.</data>
      <data key="d3">chunk-6151c8c091207072ad8e5a4c89b6cd43</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467508</data>
    </node>
    <node id="ALU Operation Control">
      <data key="d0">ALU Operation Control</data>
      <data key="d1">concept</data>
      <data key="d2">The ALU operation control is a signal input (ALUop) that determines the operation mode of the ALU.</data>
      <data key="d3">chunk-6151c8c091207072ad8e5a4c89b6cd43</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467509</data>
    </node>
    <node id="补码">
      <data key="d0">补码</data>
      <data key="d1">concept</data>
      <data key="d2">补码是计算机中表示有符号整数的一种二进制编码方式，用于简化加减法运算。&lt;SEP&gt;补码is the binary representation used for signed integers in computers, where negative numbers are represented by inverting the bits of the absolute value and adding one.&lt;SEP&gt;补码is a representation method for signed integers in binary form, where the negative of a number is represented by inverting bits and adding one.</data>
      <data key="d3">chunk-ee63e6f80ae58c99375bb442c346b8a6&lt;SEP&gt;chunk-d6401acae9e97b990cd8ff7387370e66&lt;SEP&gt;chunk-278906376b45ec28050699d283cb1aeb</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467748</data>
    </node>
    <node id="二进制运算规则">
      <data key="d0">二进制运算规则</data>
      <data key="d1">method</data>
      <data key="d2">二进制运算规则指在二进制计算中逢二进一，是补码运算的基础。</data>
      <data key="d3">chunk-d6401acae9e97b990cd8ff7387370e66</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467509</data>
    </node>
    <node id="加法运算">
      <data key="d0">加法运算</data>
      <data key="d1">method</data>
      <data key="d2">加法运算是将两个数的补码直接相加，符号位与数值位一同参与。&lt;SEP&gt;加法运算是原码乘法中的基本操作之一，用于累加部分积与被乘数的相应位的乘积。</data>
      <data key="d3">chunk-8b64d30374af75767b82b53c5d492c80&lt;SEP&gt;chunk-d6401acae9e97b990cd8ff7387370e66</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467634</data>
    </node>
    <node id="减法运算">
      <data key="d0">减法运算</data>
      <data key="d1">method</data>
      <data key="d2">减法运算是通过将被减数与减数的负数补码相加实现。</data>
      <data key="d3">chunk-d6401acae9e97b990cd8ff7387370e66</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467509</data>
    </node>
    <node id="符号位">
      <data key="d0">符号位</data>
      <data key="d1">concept</data>
      <data key="d2">符号位是补码中用于表示数正负的最高位，参与运算并直接决定结果符号。&lt;SEP&gt;符号位用于表示数值的正负，在原码乘法中通过异或运算确定乘积的符号。&lt;SEP&gt;符号位是表示数值正负的二进制位，通常位于数的最高位。</data>
      <data key="d3">chunk-8b64d30374af75767b82b53c5d492c80&lt;SEP&gt;chunk-d6401acae9e97b990cd8ff7387370e66&lt;SEP&gt;chunk-ea2c16caf28ea549ed420e26afbca237</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467784</data>
    </node>
    <node id="高位丢弃">
      <data key="d0">高位丢弃</data>
      <data key="d1">concept</data>
      <data key="d2">高位丢弃是指运算结束后，超出n+1位的结果高位被丢弃，仅保留n+1位。</data>
      <data key="d3">chunk-d6401acae9e97b990cd8ff7387370e66</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467509</data>
    </node>
    <node id="n+1位">
      <data key="d0">n+1位</data>
      <data key="d1">data</data>
      <data key="d2">n+1位是补码运算结果的位数，用于保留运算结果。</data>
      <data key="d3">chunk-d6401acae9e97b990cd8ff7387370e66</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467509</data>
    </node>
    <node id="n-Bit Carry-Lookahead Adder">
      <data key="d0">n-Bit Carry-Lookahead Adder</data>
      <data key="d1">artifact</data>
      <data key="d2">An n-bit carry-lookahead adder extends the carry-lookahead principle to n-bit wide additions, with increased design complexity.</data>
      <data key="d3">chunk-6151c8c091207072ad8e5a4c89b6cd43</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467510</data>
    </node>
    <node id="Binary">
      <data key="d0">Binary</data>
      <data key="d1">concept</data>
      <data key="d2">Binary is a numerical system using only two states, 0 and 1, which forms the foundation of all digital information encoding in computer systems.</data>
      <data key="d3">chunk-3878dd58bdab1629f78e313f678153cc</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467528</data>
    </node>
    <node id="Computer System">
      <data key="d0">Computer System</data>
      <data key="d1">organization</data>
      <data key="d2">A computer system is an integrated set of hardware and software components that process and store data using binary code.</data>
      <data key="d3">chunk-3878dd58bdab1629f78e313f678153cc</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467528</data>
    </node>
    <node id="High And Low Voltage">
      <data key="d0">High And Low Voltage</data>
      <data key="d1">naturalobject</data>
      <data key="d2">High and low voltage are physical states used to represent binary digits 1 and 0 in electronic circuits.</data>
      <data key="d3">chunk-3878dd58bdab1629f78e313f678153cc</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467528</data>
    </node>
    <node id="Positive And Negative Charge">
      <data key="d0">Positive And Negative Charge</data>
      <data key="d1">naturalobject</data>
      <data key="d2">Positive and negative charge are physical polarities used to represent binary states 1 and 0 in electronic components.</data>
      <data key="d3">chunk-3878dd58bdab1629f78e313f678153cc</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467528</data>
    </node>
    <node id="Logical Value True">
      <data key="d0">Logical Value True</data>
      <data key="d1">concept</data>
      <data key="d2">Logical value true corresponds to the binary digit 1 and is used in logic operations and programming decisions.</data>
      <data key="d3">chunk-3878dd58bdab1629f78e313f678153cc</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467528</data>
    </node>
    <node id="Logical Value False">
      <data key="d0">Logical Value False</data>
      <data key="d1">concept</data>
      <data key="d2">Logical value false corresponds to the binary digit 0 and is used in logic operations and programming decisions.</data>
      <data key="d3">chunk-3878dd58bdab1629f78e313f678153cc</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467528</data>
    </node>
    <node id="Logic Gate Circuit">
      <data key="d0">Logic Gate Circuit</data>
      <data key="d1">artifact</data>
      <data key="d2">A logic gate circuit is an electronic component designed to perform basic logical operations using binary inputs and outputs.</data>
      <data key="d3">chunk-3878dd58bdab1629f78e313f678153cc</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467528</data>
    </node>
    <node id="Arithmetic Operation">
      <data key="d0">Arithmetic Operation</data>
      <data key="d1">method</data>
      <data key="d2">Arithmetic operations in computing are carried out using binary codes and implemented via logical gate circuits.</data>
      <data key="d3">chunk-3878dd58bdab1629f78e313f678153cc</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467528</data>
    </node>
    <node id="Overflow Detection Method">
      <data key="d0">Overflow Detection Method</data>
      <data key="d1">method</data>
      <data key="d2">The Overflow Detection Method is a technique used to determine whether an arithmetic operation results in overflow, particularly in binary arithmetic with signed numbers.</data>
      <data key="d3">chunk-bc20958ae5e844428623c62227b67c7b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467544</data>
    </node>
    <node id="Two Numbers with Same Sign Addition">
      <data key="d0">Two Numbers with Same Sign Addition</data>
      <data key="d1">concept</data>
      <data key="d2">Two Numbers with Same Sign Addition refers to adding two numbers that have the same sign, which can potentially lead to overflow if the result's sign differs from the operands.</data>
      <data key="d3">chunk-bc20958ae5e844428623c62227b67c7b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467544</data>
    </node>
    <node id="Two Numbers with Different Signs Subtraction">
      <data key="d0">Two Numbers with Different Signs Subtraction</data>
      <data key="d1">concept</data>
      <data key="d2">Two Numbers with Different Signs Subtraction refers to subtracting numbers with opposite signs, which can result in overflow when the outcome has a sign inconsistent with expectations.</data>
      <data key="d3">chunk-bc20958ae5e844428623c62227b67c7b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467544</data>
    </node>
    <node id="Positive Number Addition Resulting in Negative">
      <data key="d0">Positive Number Addition Resulting in Negative</data>
      <data key="d1">concept</data>
      <data key="d2">A positive number addition resulting in a negative outcome indicates overflow, as the sign bit is set to 1 despite both operands being positive.</data>
      <data key="d3">chunk-bc20958ae5e844428623c62227b67c7b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467544</data>
    </node>
    <node id="Negative Number Minus Positive Number Resulting in Positive">
      <data key="d0">Negative Number Minus Positive Number Resulting in Positive</data>
      <data key="d1">concept</data>
      <data key="d2">Subtracting a positive number from a negative number that yields a positive result indicates overflow, reflecting an inconsistency in sign behavior.</data>
      <data key="d3">chunk-bc20958ae5e844428623c62227b67c7b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467544</data>
    </node>
    <node id="Three Methods for Overflow Detection">
      <data key="d0">Three Methods for Overflow Detection</data>
      <data key="d1">concept</data>
      <data key="d2">There are three primary methods for detecting overflow in fixed-point two's complement arithmetic: one-sign-bit method, dual-sign-bit method, and carry-based method.</data>
      <data key="d3">chunk-bc20958ae5e844428623c62227b67c7b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467544</data>
    </node>
    <node id="One Sign Bit">
      <data key="d0">One Sign Bit</data>
      <data key="d1">method</data>
      <data key="d2">The One Sign Bit method is a technique for overflow detection where overflow is identified when the signs of the operands are the same but the sign of the result differs.</data>
      <data key="d3">chunk-bc20958ae5e844428623c62227b67c7b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467544</data>
    </node>
    <node id="Dual Sign Bits">
      <data key="d0">Dual Sign Bits</data>
      <data key="d1">method</data>
      <data key="d2">The Dual Sign Bits method, also known as mod 4 complement, uses two sign bits to detect overflow; identical sign bits indicate no overflow, while differing bits indicate overflow.</data>
      <data key="d3">chunk-bc20958ae5e844428623c62227b67c7b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467544</data>
    </node>
    <node id="Mod 4 Complement">
      <data key="d0">Mod 4 Complement</data>
      <data key="d1">concept</data>
      <data key="d2">Mod 4 Complement is an alternative name for the Dual Sign Bits method, where overflow is determined by comparing the two sign bits.</data>
      <data key="d3">chunk-bc20958ae5e844428623c62227b67c7b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467546</data>
    </node>
    <node id="Sign Bit and High-Order Carry Comparison">
      <data key="d0">Sign Bit and High-Order Carry Comparison</data>
      <data key="d1">method</data>
      <data key="d2">The Sign Bit and High-Order Carry Comparison method evaluates overflow by comparing the carry from the sign bit (Cn) with the carry from the high-order bit (Cn1).</data>
      <data key="d3">chunk-bc20958ae5e844428623c62227b67c7b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467546</data>
    </node>
    <node id="Cn Carry">
      <data key="d0">Cn Carry</data>
      <data key="d1">data</data>
      <data key="d2">Cn Carry refers to the carry generated from the sign bit (the most significant bit) during binary addition or subtraction.</data>
      <data key="d3">chunk-bc20958ae5e844428623c62227b67c7b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467546</data>
    </node>
    <node id="Cn1 Carry">
      <data key="d0">Cn1 Carry</data>
      <data key="d1">data</data>
      <data key="d2">Cn1 Carry refers to the carry generated from the second highest bit (the next-to-most-significant bit) in binary arithmetic.</data>
      <data key="d3">chunk-bc20958ae5e844428623c62227b67c7b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467546</data>
    </node>
    <node id="Fixed-Point Two's Complement Arithmetic">
      <data key="d0">Fixed-Point Two's Complement Arithmetic</data>
      <data key="d1">concept</data>
      <data key="d2">Fixed-Point Two's Complement Arithmetic is the foundational numerical system used in digital computers for representing signed integers and performing arithmetic operations.</data>
      <data key="d3">chunk-bc20958ae5e844428623c62227b67c7b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467546</data>
    </node>
    <node id="Type Conversion">
      <data key="d0">Type Conversion</data>
      <data key="d1">method</data>
      <data key="d2">Type conversion in C Language refers to the process of converting a value from one data type to another, including explicit casting with the format "TYPEb = (TYPE)a".&lt;SEP&gt;Type Conversion in C Language involves changing one data type to another during assignment or operations, either implicitly or explicitly.</data>
      <data key="d3">chunk-eb70606fa9ba73ffc22231992979ee26&lt;SEP&gt;chunk-7661b58ae4a51d1ee96186ef15ec5292</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467754</data>
    </node>
    <node id="Integer Type">
      <data key="d0">Integer Type</data>
      <data key="d1">category</data>
      <data key="d2">Integer type is a data type in C Language used for representing whole numbers, which can be signed or unsigned.</data>
      <data key="d3">chunk-eb70606fa9ba73ffc22231992979ee26</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467561</data>
    </node>
    <node id="Word Length Conversion">
      <data key="d0">Word Length Conversion</data>
      <data key="d1">method</data>
      <data key="d2">Word length conversion refers to the process of changing the bit width of an integer value, either from smaller to larger or vice versa.</data>
      <data key="d3">chunk-eb70606fa9ba73ffc22231992979ee26</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467561</data>
    </node>
    <node id="Zero Extension">
      <data key="d0">Zero Extension</data>
      <data key="d1">method</data>
      <data key="d2">Zero extension is the process of expanding the higher bits of an unsigned integer with zeros when converting from a smaller to a larger word length.</data>
      <data key="d3">chunk-eb70606fa9ba73ffc22231992979ee26</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467561</data>
    </node>
    <node id="Sign Extension">
      <data key="d0">Sign Extension</data>
      <data key="d1">method</data>
      <data key="d2">Sign extension is the process of expanding the higher bits of a signed integer with copies of the sign bit when converting from a smaller to a larger word length.</data>
      <data key="d3">chunk-eb70606fa9ba73ffc22231992979ee26</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467561</data>
    </node>
    <node id="Char Type">
      <data key="d0">Char Type</data>
      <data key="d1">type</data>
      <data key="d2">Char type in C Language is an 8-bit unsigned integer representing a single character.&lt;SEP&gt;Char Type in C Language is a fundamental data type used to represent single characters, typically 8 bits in size, and can be promoted to int during type conversion.</data>
      <data key="d3">chunk-eb70606fa9ba73ffc22231992979ee26&lt;SEP&gt;chunk-7661b58ae4a51d1ee96186ef15ec5292</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467756</data>
    </node>
    <node id="Int Type">
      <data key="d0">Int Type</data>
      <data key="d1">data</data>
      <data key="d2">Int type in C Language is a standard integer data type, typically 32 bits, used to represent whole numbers.&lt;SEP&gt;The int type is a data type that occupies 4 bytes in memory and is commonly used to store integer values.</data>
      <data key="d3">chunk-eb70606fa9ba73ffc22231992979ee26&lt;SEP&gt;chunk-09b53b0df067c5056104774d13e5e395</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467711</data>
    </node>
    <node id="16-Bit Integer">
      <data key="d0">16-Bit Integer</data>
      <data key="d1">data</data>
      <data key="d2">16-bit integer is a numeric data type that uses 16 bits to store a value, either signed or unsigned.</data>
      <data key="d3">chunk-eb70606fa9ba73ffc22231992979ee26</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467562</data>
    </node>
    <node id="32-Bit Integer">
      <data key="d0">32-Bit Integer</data>
      <data key="d1">data</data>
      <data key="d2">32-bit integer is a numeric data type that uses 32 bits to store a value, either signed or unsigned.</data>
      <data key="d3">chunk-eb70606fa9ba73ffc22231992979ee26</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467562</data>
    </node>
    <node id="High-Bit Extension">
      <data key="d0">High-Bit Extension</data>
      <data key="d1">concept</data>
      <data key="d2">High-bit extension refers to the process of filling the most significant bits during word length expansion, based on the integer type (zero or sign).</data>
      <data key="d3">chunk-eb70606fa9ba73ffc22231992979ee26</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467562</data>
    </node>
    <node id="Low-Bit Truncation">
      <data key="d0">Low-Bit Truncation</data>
      <data key="d1">method</data>
      <data key="d2">Low-bit truncation is the process of discarding higher bits when converting from a larger to a smaller word length.</data>
      <data key="d3">chunk-eb70606fa9ba73ffc22231992979ee26</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467562</data>
    </node>
    <node id="Symbol Conversion">
      <data key="d0">Symbol Conversion</data>
      <data key="d1">method</data>
      <data key="d2">Symbol conversion refers to the process of changing the sign interpretation of a value during type conversion between signed and unsigned integers in C Language.</data>
      <data key="d3">chunk-eb70606fa9ba73ffc22231992979ee26</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467562</data>
    </node>
    <node id="Floating Point Addition and Subtraction">
      <data key="d0">Floating Point Addition and Subtraction</data>
      <data key="d1">method</data>
      <data key="d2">Floating point addition and subtraction involves separate exponent and mantissa operations, including alignment, mantissa arithmetic, normalization, rounding, and overflow checking.</data>
      <data key="d3">chunk-b661f934d6911328f3c940a7306bdabc</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467583</data>
    </node>
    <node id="Exponent Alignment">
      <data key="d0">Exponent Alignment</data>
      <data key="d1">method</data>
      <data key="d2">Exponent alignment ensures that the exponents of two floating point numbers are equal by adjusting the smaller exponent and shifting the mantissa right, preserving accuracy through reserved bits.</data>
      <data key="d3">chunk-b661f934d6911328f3c940a7306bdabc</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467583</data>
    </node>
    <node id="Mantissa Addition and Subtraction">
      <data key="d0">Mantissa Addition and Subtraction</data>
      <data key="d1">method</data>
      <data key="d2">Mantissa addition and subtraction follows fixed-point arithmetic rules after exponent alignment, with the hidden bit of IEEE 754 format being restored during computation.</data>
      <data key="d3">chunk-b661f934d6911328f3c940a7306bdabc</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467583</data>
    </node>
    <node id="Mantissa Normalization">
      <data key="d0">Mantissa Normalization</data>
      <data key="d1">method</data>
      <data key="d2">Mantissa normalization ensures the result mantissa is in standard form, adjusting the exponent and shifting mantissa as necessary to meet normalization conditions.</data>
      <data key="d3">chunk-b661f934d6911328f3c940a7306bdabc</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467583</data>
    </node>
    <node id="Rounding">
      <data key="d0">Rounding</data>
      <data key="d1">concept</data>
      <data key="d2">Rounding adjusts the final result to fit the designated format, using one of four IEEE 754 modes: round to nearest, round toward positive infinity, round toward negative infinity, or truncate.&lt;SEP&gt;Rounding is the process of approximating a number to a specified number of digits, especially during type conversion when precision is lost.</data>
      <data key="d3">chunk-b661f934d6911328f3c940a7306bdabc&lt;SEP&gt;chunk-7661b58ae4a51d1ee96186ef15ec5292</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467756</data>
    </node>
    <node id="Exponent Overflow Check">
      <data key="d0">Exponent Overflow Check</data>
      <data key="d1">method</data>
      <data key="d2">Exponent overflow check detects when the exponent exceeds the maximum representable value, indicating a positive overflow condition that leads to exceptional results.</data>
      <data key="d3">chunk-b661f934d6911328f3c940a7306bdabc</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467583</data>
    </node>
    <node id="Exponent Underflow">
      <data key="d0">Exponent Underflow</data>
      <data key="d1">method</data>
      <data key="d2">Exponent underflow occurs when the exponent goes below the minimum representable value, typically treated as a machine zero.</data>
      <data key="d3">chunk-b661f934d6911328f3c940a7306bdabc</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467583</data>
    </node>
    <node id="IEEE 754 Standard">
      <data key="d0">IEEE 754 Standard</data>
      <data key="d1">standard</data>
      <data key="d2">IEEE 754 is a widely accepted standard for floating-point arithmetic that defines formats, operations, and rounding modes for floating-point numbers.</data>
      <data key="d3">chunk-b661f934d6911328f3c940a7306bdabc</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467583</data>
    </node>
    <node id="Hidden Bit">
      <data key="d0">Hidden Bit</data>
      <data key="d1">artifact</data>
      <data key="d2">The hidden bit is an implicit leading 1 in the mantissa of IEEE 754 floating-point numbers, which is not stored but used in computations for efficiency.&lt;SEP&gt;The Hidden Bit is a bit in IEEE754 floating-point format that is not explicitly stored but assumed to be 1 for normalized numbers.</data>
      <data key="d3">chunk-b661f934d6911328f3c940a7306bdabc&lt;SEP&gt;chunk-7661b58ae4a51d1ee96186ef15ec5292</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467756</data>
    </node>
    <node id="Round to Nearest">
      <data key="d0">Round to Nearest</data>
      <data key="d1">concept</data>
      <data key="d2">Round to nearest is an IEEE 754 rounding mode that selects the closest representable number, favoring even numbers when equidistant.</data>
      <data key="d3">chunk-b661f934d6911328f3c940a7306bdabc</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467585</data>
    </node>
    <node id="Round Toward Positive Infinity">
      <data key="d0">Round Toward Positive Infinity</data>
      <data key="d1">concept</data>
      <data key="d2">Round toward positive infinity is an IEEE 754 rounding mode that rounds toward +∞, selecting the next higher representable number.</data>
      <data key="d3">chunk-b661f934d6911328f3c940a7306bdabc</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467585</data>
    </node>
    <node id="Round Toward Negative Infinity">
      <data key="d0">Round Toward Negative Infinity</data>
      <data key="d1">concept</data>
      <data key="d2">Round toward negative infinity is an IEEE 754 rounding mode that rounds toward -∞, selecting the next lower representable number.</data>
      <data key="d3">chunk-b661f934d6911328f3c940a7306bdabc</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467585</data>
    </node>
    <node id="Truncate">
      <data key="d0">Truncate</data>
      <data key="d1">concept</data>
      <data key="d2">Truncate is an IEEE 754 rounding mode that removes lower-order bits without adjustment, effectively rounding toward zero.</data>
      <data key="d3">chunk-b661f934d6911328f3c940a7306bdabc</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467585</data>
    </node>
    <node id="Significant Bit">
      <data key="d0">Significant Bit</data>
      <data key="d1">artifact</data>
      <data key="d2">Significant bits are the digits in the mantissa that contribute to precision, with shifting during alignment potentially leading to loss if not preserved.</data>
      <data key="d3">chunk-b661f934d6911328f3c940a7306bdabc</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467585</data>
    </node>
    <node id="Exponent Difference">
      <data key="d0">Exponent Difference</data>
      <data key="d1">data</data>
      <data key="d2">Exponent difference is the value obtained by subtracting the smaller exponent from the larger one to determine alignment steps.</data>
      <data key="d3">chunk-b661f934d6911328f3c940a7306bdabc</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467585</data>
    </node>
    <node id="Right Shift">
      <data key="d0">Right Shift</data>
      <data key="d1">method</data>
      <data key="d2">Right shift is the operation performed on the mantissa when aligning exponents, where bits are shifted to the right, and the least significant bits are preserved for precision.&lt;SEP&gt;Right shift is a binary operation that moves bits to the right, used in division to align the divisor for comparison.</data>
      <data key="d3">chunk-b661f934d6911328f3c940a7306bdabc&lt;SEP&gt;chunk-ac11d99928fbdb7cf8188b4d1e45043f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467607</data>
    </node>
    <node id="Left Shift">
      <data key="d0">Left Shift</data>
      <data key="d1">method</data>
      <data key="d2">Left shift is the operation required when aligning exponents by moving the larger exponent to the smaller, but this results in the loss of the most significant bits and causes errors.</data>
      <data key="d3">chunk-b661f934d6911328f3c940a7306bdabc</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467586</data>
    </node>
    <node id="Suppressed Bits">
      <data key="d0">Suppressed Bits</data>
      <data key="d1">data</data>
      <data key="d2">Suppressed bits are the lower-order bits that are temporarily retained during right shifts to preserve precision during intermediate operations.</data>
      <data key="d3">chunk-b661f934d6911328f3c940a7306bdabc</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467586</data>
    </node>
    <node id="Division Operation">
      <data key="d0">Division Operation</data>
      <data key="d1">method</data>
      <data key="d2">The division operation is a computational procedure involving iterative shift and addition/subtraction processes, used to compute the quotient of two numbers.</data>
      <data key="d3">chunk-ac11d99928fbdb7cf8188b4d1e45043f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467605</data>
    </node>
    <node id="Original Code Division">
      <data key="d0">Original Code Division</data>
      <data key="d1">method</data>
      <data key="d2">Original code division is a division method similar to multiplication, involving iterative shift and addition/subtraction, with increased complexity.</data>
      <data key="d3">chunk-ac11d99928fbdb7cf8188b4d1e45043f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467605</data>
    </node>
    <node id="Fixed-Point Number">
      <data key="d0">Fixed-Point Number</data>
      <data key="d1">concept</data>
      <data key="d2">A fixed-point number is a number representation in computing where the decimal point is fixed at a specific position.&lt;SEP&gt;Fixed-point number is a numerical representation method where the decimal point is fixed at a specific position, making it less flexible than floating-point representation for handling very large or very small numbers.</data>
      <data key="d3">chunk-5ea05d0aadedcb24741fd320a2b9543c&lt;SEP&gt;chunk-ac11d99928fbdb7cf8188b4d1e45043f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467675</data>
    </node>
    <node id="2n-Bit Number">
      <data key="d0">2n-Bit Number</data>
      <data key="d1">data</data>
      <data key="d2">A 2n-bit number is a binary number with twice the bit length of an n-bit number, used to represent the dividend in division operations.</data>
      <data key="d3">chunk-ac11d99928fbdb7cf8188b4d1e45043f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467605</data>
    </node>
    <node id="n-Bit Number">
      <data key="d0">n-Bit Number</data>
      <data key="d1">data</data>
      <data key="d2">An n-bit number is a binary number with n bits, used to represent the divisor in division operations.</data>
      <data key="d3">chunk-ac11d99928fbdb7cf8188b4d1e45043f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467605</data>
    </node>
    <node id="n-Bit Quotient">
      <data key="d0">n-Bit Quotient</data>
      <data key="d1">data</data>
      <data key="d2">An n-bit quotient is the result of dividing a 2n-bit number by an n-bit number, yielding a result with n bits.</data>
      <data key="d3">chunk-ac11d99928fbdb7cf8188b4d1e45043f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467605</data>
    </node>
    <node id="Dividend Extension">
      <data key="d0">Dividend Extension</data>
      <data key="d1">concept</data>
      <data key="d2">Dividend extension refers to the process of expanding the dividend by adding zeros to meet operand size requirements in division.</data>
      <data key="d3">chunk-ac11d99928fbdb7cf8188b4d1e45043f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467605</data>
    </node>
    <node id="Fixed-Point Positive Fraction">
      <data key="d0">Fixed-Point Positive Fraction</data>
      <data key="d1">concept</data>
      <data key="d2">A fixed-point positive fraction is a representation of a positive fractional number using fixed-point notation.</data>
      <data key="d3">chunk-ac11d99928fbdb7cf8188b4d1e45043f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467605</data>
    </node>
    <node id="Fixed-Point Positive Integer">
      <data key="d0">Fixed-Point Positive Integer</data>
      <data key="d1">concept</data>
      <data key="d2">A fixed-point positive integer is a representation of a non-negative integer using fixed-point notation.</data>
      <data key="d3">chunk-ac11d99928fbdb7cf8188b4d1e45043f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467607</data>
    </node>
    <node id="Zero Division Exception">
      <data key="d0">Zero Division Exception</data>
      <data key="d1">concept</data>
      <data key="d2">A zero division exception occurs when the divisor is zero, triggering an error condition requiring system intervention.</data>
      <data key="d3">chunk-ac11d99928fbdb7cf8188b4d1e45043f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467607</data>
    </node>
    <node id="Operating System Exception Handler">
      <data key="d0">Operating System Exception Handler</data>
      <data key="d1">organization</data>
      <data key="d2">The operating system exception handler is a component of the operating system responsible for managing runtime errors such as division by zero.</data>
      <data key="d3">chunk-ac11d99928fbdb7cf8188b4d1e45043f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467607</data>
    </node>
    <node id="Hand Calculation Steps">
      <data key="d0">Hand Calculation Steps</data>
      <data key="d1">method</data>
      <data key="d2">Hand calculation steps describe the manual procedures for performing division, including comparison, subtraction, and shifting.</data>
      <data key="d3">chunk-ac11d99928fbdb7cf8188b4d1e45043f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467607</data>
    </node>
    <node id="Intermediate Remainder">
      <data key="d0">Intermediate Remainder</data>
      <data key="d1">data</data>
      <data key="d2">An intermediate remainder is the result of a subtraction step during division, used as input for the next iteration.</data>
      <data key="d3">chunk-ac11d99928fbdb7cf8188b4d1e45043f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467607</data>
    </node>
    <node id="Quotient Bit">
      <data key="d0">Quotient Bit</data>
      <data key="d1">data</data>
      <data key="d2">A quotient bit is a single bit (0 or 1) of the final quotient determined during each iteration of the division process.</data>
      <data key="d3">chunk-ac11d99928fbdb7cf8188b4d1e45043f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467607</data>
    </node>
    <node id="Subtraction Step">
      <data key="d0">Subtraction Step</data>
      <data key="d1">method</data>
      <data key="d2">A subtraction step is a fundamental operation in the division process where the divisor is subtracted from the intermediate remainder to determine the quotient bit.</data>
      <data key="d3">chunk-ac11d99928fbdb7cf8188b4d1e45043f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467607</data>
    </node>
    <node id="Comparison Step">
      <data key="d0">Comparison Step</data>
      <data key="d1">method</data>
      <data key="d2">A comparison step is used to determine whether the intermediate remainder is sufficient to subtract the divisor, guiding the decision to set the quotient bit to 1 or 0.</data>
      <data key="d3">chunk-ac11d99928fbdb7cf8188b4d1e45043f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467608</data>
    </node>
    <node id="Iteration Process">
      <data key="d0">Iteration Process</data>
      <data key="d1">concept</data>
      <data key="d2">The iteration process refers to the repeated execution of subtraction, shift, and comparison operations in the division algorithm until all quotient bits are determined.</data>
      <data key="d3">chunk-ac11d99928fbdb7cf8188b4d1e45043f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467609</data>
    </node>
    <node id="ZF">
      <data key="d0">ZF</data>
      <data key="d1">concept</data>
      <data key="d2">ZF is the zero flag used in processor status flags to indicate whether the result of an operation is zero.</data>
      <data key="d3">chunk-1bf253441ffd1d27c8127187db5ecb32</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467621</data>
    </node>
    <node id="OF">
      <data key="d0">OF</data>
      <data key="d1">concept</data>
      <data key="d2">OF is the overflow flag used in processor status flags to indicate whether an arithmetic overflow has occurred.</data>
      <data key="d3">chunk-1bf253441ffd1d27c8127187db5ecb32</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467621</data>
    </node>
    <node id="SF">
      <data key="d0">SF</data>
      <data key="d1">concept</data>
      <data key="d2">SF is the sign flag used in processor status flags to indicate the sign of the result of an operation.</data>
      <data key="d3">chunk-1bf253441ffd1d27c8127187db5ecb32</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467621</data>
    </node>
    <node id="A">
      <data key="d0">A</data>
      <data key="d1">data</data>
      <data key="d2">A is a signed number represented in two's complement form used for arithmetic comparison.&lt;SEP&gt;A represents one of the two unsigned numbers involved in the comparison operation.</data>
      <data key="d3">chunk-1bf253441ffd1d27c8127187db5ecb32&lt;SEP&gt;chunk-ba5ba3047ff33c33c3e78b969b12b98e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467687</data>
    </node>
    <node id="B">
      <data key="d0">B</data>
      <data key="d1">data</data>
      <data key="d2">B is a signed number represented in two's complement form used for arithmetic comparison.&lt;SEP&gt;B represents the second unsigned number involved in the comparison operation.</data>
      <data key="d3">chunk-1bf253441ffd1d27c8127187db5ecb32&lt;SEP&gt;chunk-ba5ba3047ff33c33c3e78b969b12b98e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467687</data>
    </node>
    <node id="Result">
      <data key="d0">Result</data>
      <data key="d1">data</data>
      <data key="d2">Result is the outcome of the subtraction operation [A] - [B], whose sign and zero status are determined by flags ZF, OF, and SF.</data>
      <data key="d3">chunk-1bf253441ffd1d27c8127187db5ecb32</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467621</data>
    </node>
    <node id="Comparison of Signed Numbers">
      <data key="d0">Comparison of Signed Numbers</data>
      <data key="d1">concept</data>
      <data key="d2">Comparison of signed numbers involves analyzing ZF, OF, and SF flags after performing [A] - [B] to determine the relative magnitude of A and B.</data>
      <data key="d3">chunk-1bf253441ffd1d27c8127187db5ecb32</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467623</data>
    </node>
    <node id="原码乘法">
      <data key="d0">原码乘法</data>
      <data key="d1">method</data>
      <data key="d2">原码乘法是一种定点乘法运算方法，其特点是符号位与数值位分开计算，符号位通过两个乘数符号位的异或运算得到，数值位则为两个乘数绝对值的乘积。</data>
      <data key="d3">chunk-8b64d30374af75767b82b53c5d492c80</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467633</data>
    </node>
    <node id="数值位">
      <data key="d0">数值位</data>
      <data key="d1">concept</data>
      <data key="d2">数值位表示数值的大小部分，在原码乘法中参与绝对值的乘积运算，运算过程视为无符号数的乘积。&lt;SEP&gt;数值位是表示数值大小的二进制位，位于符号位之后。</data>
      <data key="d3">chunk-8b64d30374af75767b82b53c5d492c80&lt;SEP&gt;chunk-ea2c16caf28ea549ed420e26afbca237</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467784</data>
    </node>
    <node id="绝对值">
      <data key="d0">绝对值</data>
      <data key="d1">concept</data>
      <data key="d2">绝对值是去除数值符号后的正值，用于原码乘法中数值位的运算。</data>
      <data key="d3">chunk-8b64d30374af75767b82b53c5d492c80</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467633</data>
    </node>
    <node id="部分积">
      <data key="d0">部分积</data>
      <data key="d1">concept</data>
      <data key="d2">部分积是乘法运算中的中间结果，初始值为0，通过累加与移位操作逐步逼近最终乘积。</data>
      <data key="d3">chunk-8b64d30374af75767b82b53c5d492c80</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467633</data>
    </node>
    <node id="逻辑右移">
      <data key="d0">逻辑右移</data>
      <data key="d1">method</data>
      <data key="d2">逻辑右移是一种位运算，将数值位右移一位，高位补0，用于原码乘法中每轮运算后的更新操作。</data>
      <data key="d3">chunk-8b64d30374af75767b82b53c5d492c80</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467633</data>
    </node>
    <node id="异或运算">
      <data key="d0">异或运算</data>
      <data key="d1">method</data>
      <data key="d2">异或运算是布尔运算中的一种，用于计算两个符号位的组合以确定乘积的符号。</data>
      <data key="d3">chunk-8b64d30374af75767b82b53c5d492c80</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467633</data>
    </node>
    <node id="移位运算">
      <data key="d0">移位运算</data>
      <data key="d1">method</data>
      <data key="d2">移位运算是原码乘法中的基本操作之一，通过右移更新部分积，实现乘法过程的逐步逼近。</data>
      <data key="d3">chunk-8b64d30374af75767b82b53c5d492c80</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467634</data>
    </node>
    <node id="n位无符号数">
      <data key="d0">n位无符号数</data>
      <data key="d1">concept</data>
      <data key="d2">n位无符号数是在原码乘法运算中，被当作无符号整数参与乘积计算的数值。</data>
      <data key="d3">chunk-8b64d30374af75767b82b53c5d492c80</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467634</data>
    </node>
    <node id="X">
      <data key="d0">X</data>
      <data key="d1">data</data>
      <data key="d2">X represents the multiplicand in the original code, which is used in the multiplication process and is shifted and added based on the bits of the multiplier.&lt;SEP&gt;X is the input to the adder, representing the first operand; its binary form varies based on whether the number is signed or unsigned.</data>
      <data key="d3">chunk-8b64d30374af75767b82b53c5d492c80&lt;SEP&gt;chunk-278906376b45ec28050699d283cb1aeb</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467750</data>
    </node>
    <node id="y-i">
      <data key="d0">y-i</data>
      <data key="d1">variable</data>
      <data key="d2">y-i represents the i-th bit of the multiplier in binary form, used to determine whether the multiplicand X should be added to the partial product.</data>
      <data key="d3">chunk-8b64d30374af75767b82b53c5d492c80</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467634</data>
    </node>
    <node id="P">
      <data key="d0">P</data>
      <data key="d1">variable</data>
      <data key="d2">P refers to the partial product, which is the intermediate result during the multiplication process and is updated in successive steps of addition and right shift.</data>
      <data key="d3">chunk-8b64d30374af75767b82b53c5d492c80</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467634</data>
    </node>
    <node id="Binary Number">
      <data key="d0">Binary Number</data>
      <data key="d1">concept</data>
      <data key="d2">A binary number is a number expressed in the base-2 numeral system, using only digits 0 and 1.</data>
      <data key="d3">chunk-9a74c12334c1c89b7dc2a0d69025220d</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467653</data>
    </node>
    <node id="Octal Number">
      <data key="d0">Octal Number</data>
      <data key="d1">concept</data>
      <data key="d2">An octal number is a number expressed in the base-8 numeral system, using digits 0 through 7.</data>
      <data key="d3">chunk-9a74c12334c1c89b7dc2a0d69025220d</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467653</data>
    </node>
    <node id="Hexadecimal Number">
      <data key="d0">Hexadecimal Number</data>
      <data key="d1">concept</data>
      <data key="d2">A hexadecimal number is a number expressed in the base-16 numeral system, using digits 0–9 and letters A–F.</data>
      <data key="d3">chunk-9a74c12334c1c89b7dc2a0d69025220d</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467653</data>
    </node>
    <node id="Decimal Number">
      <data key="d0">Decimal Number</data>
      <data key="d1">concept</data>
      <data key="d2">A decimal number is a number expressed in the base-10 numeral system, using digits 0 through 9.</data>
      <data key="d3">chunk-9a74c12334c1c89b7dc2a0d69025220d</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467653</data>
    </node>
    <node id="Binary Fraction">
      <data key="d0">Binary Fraction</data>
      <data key="d1">concept</data>
      <data key="d2">A binary fraction is a fractional number expressed in binary form, with a binary point separating integer and fractional parts.</data>
      <data key="d3">chunk-9a74c12334c1c89b7dc2a0d69025220d</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467653</data>
    </node>
    <node id="Grouping By Three">
      <data key="d0">Grouping By Three</data>
      <data key="d1">method</data>
      <data key="d2">Grouping by three refers to dividing binary digits into groups of three bits to convert to octal.</data>
      <data key="d3">chunk-9a74c12334c1c89b7dc2a0d69025220d</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467653</data>
    </node>
    <node id="Grouping By Four">
      <data key="d0">Grouping By Four</data>
      <data key="d1">method</data>
      <data key="d2">Grouping by four refers to dividing binary digits into groups of four bits to convert to hexadecimal.</data>
      <data key="d3">chunk-9a74c12334c1c89b7dc2a0d69025220d</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467653</data>
    </node>
    <node id="Power Expansion Addition Method">
      <data key="d0">Power Expansion Addition Method</data>
      <data key="d1">method</data>
      <data key="d2">The power expansion addition method converts any base number to decimal by multiplying each digit by its positional power and summing the results.</data>
      <data key="d3">chunk-9a74c12334c1c89b7dc2a0d69025220d</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467653</data>
    </node>
    <node id="Base Multiplication Division Method">
      <data key="d0">Base Multiplication Division Method</data>
      <data key="d1">method</data>
      <data key="d2">The base multiplication division method converts decimal numbers to any base using division for integer parts and multiplication for fractional parts.</data>
      <data key="d3">chunk-9a74c12334c1c89b7dc2a0d69025220d</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467655</data>
    </node>
    <node id="Integer Part">
      <data key="d0">Integer Part</data>
      <data key="d1">concept</data>
      <data key="d2">The integer part of a number is the portion to the left of the decimal point.</data>
      <data key="d3">chunk-9a74c12334c1c89b7dc2a0d69025220d</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467655</data>
    </node>
    <node id="Fractional Part">
      <data key="d0">Fractional Part</data>
      <data key="d1">concept</data>
      <data key="d2">The fractional part of a number is the portion to the right of the decimal point.</data>
      <data key="d3">chunk-9a74c12334c1c89b7dc2a0d69025220d</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467655</data>
    </node>
    <node id="Division By Base Method">
      <data key="d0">Division By Base Method</data>
      <data key="d1">method</data>
      <data key="d2">The division by base method is used to convert decimal integer parts into another base by repeatedly dividing by the target base and collecting remainders.</data>
      <data key="d3">chunk-9a74c12334c1c89b7dc2a0d69025220d</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467655</data>
    </node>
    <node id="Multiplication By Base Method">
      <data key="d0">Multiplication By Base Method</data>
      <data key="d1">method</data>
      <data key="d2">The multiplication by base method is used to convert decimal fractional parts into another base by repeatedly multiplying by the target base and collecting integer parts.</data>
      <data key="d3">chunk-9a74c12334c1c89b7dc2a0d69025220d</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467655</data>
    </node>
    <node id="Binary Point">
      <data key="d0">Binary Point</data>
      <data key="d1">artifact</data>
      <data key="d2">The binary point is a symbol (analogous to the decimal point) that separates the integer and fractional parts in binary numbers.</data>
      <data key="d3">chunk-9a74c12334c1c89b7dc2a0d69025220d</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467655</data>
    </node>
    <node id="Positional Weight">
      <data key="d0">Positional Weight</data>
      <data key="d1">concept</data>
      <data key="d2">Positional weight refers to the value of a digit based on its position in a numeral system, calculated as the base raised to the position index.</data>
      <data key="d3">chunk-9a74c12334c1c89b7dc2a0d69025220d</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467655</data>
    </node>
    <node id="Any Base Number">
      <data key="d0">Any Base Number</data>
      <data key="d3">chunk-9a74c12334c1c89b7dc2a0d69025220d</data>
      <data key="d2">Any base number can be converted to decimal using the power expansion addition method, which multiplies each digit by its positional weight and sums the results.</data>
      <data key="d1">UNKNOWN</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467656</data>
    </node>
    <node id="Floating Point Representation">
      <data key="d0">Floating Point Representation</data>
      <data key="d1">concept</data>
      <data key="d2">Floating point representation is a method of encoding real numbers in computing, allowing the decimal point to float to accommodate a wide range of values with maintained precision.</data>
      <data key="d3">chunk-5ea05d0aadedcb24741fd320a2b9543c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467673</data>
    </node>
    <node id="Sign">
      <data key="d0">Sign</data>
      <data key="d1">component</data>
      <data key="d2">The sign component in a floating point number indicates whether the number is positive or negative.</data>
      <data key="d3">chunk-5ea05d0aadedcb24741fd320a2b9543c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467673</data>
    </node>
    <node id="Floating Point Range">
      <data key="d0">Floating Point Range</data>
      <data key="d1">concept</data>
      <data key="d2">The floating point range refers to the interval of values that can be represented by a floating point format, determined by the exponent.</data>
      <data key="d3">chunk-5ea05d0aadedcb24741fd320a2b9543c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467673</data>
    </node>
    <node id="Floating Point Precision">
      <data key="d0">Floating Point Precision</data>
      <data key="d1">concept</data>
      <data key="d2">Floating point precision is the degree of accuracy with which a floating point number can represent real numbers, determined by the number of bits in the mantissa.</data>
      <data key="d3">chunk-5ea05d0aadedcb24741fd320a2b9543c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467673</data>
    </node>
    <node id="Positive Overflow">
      <data key="d0">Positive Overflow</data>
      <data key="d1">event</data>
      <data key="d2">Positive overflow occurs when a computation yields a result greater than the largest representable positive number, requiring interruption and overflow handling.</data>
      <data key="d3">chunk-5ea05d0aadedcb24741fd320a2b9543c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467673</data>
    </node>
    <node id="Negative Overflow">
      <data key="d0">Negative Overflow</data>
      <data key="d1">event</data>
      <data key="d2">Negative overflow occurs when a computation yields a result less than the smallest representable negative number in magnitude, requiring interruption and overflow handling.</data>
      <data key="d3">chunk-5ea05d0aadedcb24741fd320a2b9543c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467673</data>
    </node>
    <node id="Positive Underflow">
      <data key="d0">Positive Underflow</data>
      <data key="d1">event</data>
      <data key="d2">Positive underflow occurs when a computation results in a value between zero and the smallest positive representable number, causing it to be treated as machine zero.</data>
      <data key="d3">chunk-5ea05d0aadedcb24741fd320a2b9543c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467675</data>
    </node>
    <node id="Negative Underflow">
      <data key="d0">Negative Underflow</data>
      <data key="d1">event</data>
      <data key="d2">Negative underflow occurs when a computation results in a value between zero and the most negative representable number in magnitude, also treated as machine zero.</data>
      <data key="d3">chunk-5ea05d0aadedcb24741fd320a2b9543c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467675</data>
    </node>
    <node id="Underflow">
      <data key="d0">Underflow</data>
      <data key="d1">event</data>
      <data key="d2">Underflow is a condition where a result is too small to be represented accurately, and is treated as machine zero.</data>
      <data key="d3">chunk-5ea05d0aadedcb24741fd320a2b9543c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467675</data>
    </node>
    <node id="Machine Zero">
      <data key="d0">Machine Zero</data>
      <data key="d1">concept</data>
      <data key="d2">Machine zero is the smallest value that a computer's floating point system recognizes as zero, used to represent values that are too small to store accurately.</data>
      <data key="d3">chunk-5ea05d0aadedcb24741fd320a2b9543c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467675</data>
    </node>
    <node id="Electronic Mass">
      <data key="d0">Electronic Mass</data>
      <data key="d1">data</data>
      <data key="d2">Electronic mass is a physical constant approximately equal to 9×10⁻²⁸ grams, often represented in floating point format for computational efficiency.</data>
      <data key="d3">chunk-5ea05d0aadedcb24741fd320a2b9543c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467675</data>
    </node>
    <node id="Solar Mass">
      <data key="d0">Solar Mass</data>
      <data key="d1">data</data>
      <data key="d2">Solar mass is a physical constant approximately equal to 2×10³⁰ grams, frequently represented using floating point notation.</data>
      <data key="d3">chunk-5ea05d0aadedcb24741fd320a2b9543c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467675</data>
    </node>
    <node id="Exponent Field">
      <data key="d0">Exponent Field</data>
      <data key="d1">component</data>
      <data key="d2">The exponent field in a floating point number stores the exponent value, determining the scale of the number and contributing to the overall range.</data>
      <data key="d3">chunk-5ea05d0aadedcb24741fd320a2b9543c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467676</data>
    </node>
    <node id="Unsigned Number Comparison">
      <data key="d0">Unsigned Number Comparison</data>
      <data key="d1">concept</data>
      <data key="d2">Unsigned number comparison involves evaluating the relative magnitude of two unsigned integers using zero flag (ZF) and carry/borrow flag (CF) in processor status flags.</data>
      <data key="d3">chunk-ba5ba3047ff33c33c3e78b969b12b98e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467687</data>
    </node>
    <node id="Carry Borrow Flag">
      <data key="d0">Carry Borrow Flag</data>
      <data key="d1">data</data>
      <data key="d2">Carry Borrow Flag (CF) is a processor status flag that is set to 1 when a borrow occurs during subtraction of unsigned numbers.</data>
      <data key="d3">chunk-ba5ba3047ff33c33c3e78b969b12b98e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467687</data>
    </node>
    <node id="A-B Operation">
      <data key="d0">A-B Operation</data>
      <data key="d1">method</data>
      <data key="d2">The A-B operation is a subtraction operation between two unsigned numbers used to evaluate their relative values based on ZF and CF outcomes.</data>
      <data key="d3">chunk-ba5ba3047ff33c33c3e78b969b12b98e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467687</data>
    </node>
    <node id="Result Zero Case">
      <data key="d0">Result Zero Case</data>
      <data key="d1">concept</data>
      <data key="d2">Result Zero Case occurs when A equals B, resulting in zero output, setting ZF=1 and CF=0.</data>
      <data key="d3">chunk-ba5ba3047ff33c33c3e78b969b12b98e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467687</data>
    </node>
    <node id="Result Non-Zero No Borrow Case">
      <data key="d0">Result Non-Zero No Borrow Case</data>
      <data key="d1">concept</data>
      <data key="d2">Result Non-Zero No Borrow Case occurs when A is greater than B, producing a non-zero result without borrow, hence ZF=0 and CF=0.</data>
      <data key="d3">chunk-ba5ba3047ff33c33c3e78b969b12b98e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467687</data>
    </node>
    <node id="Result Non-Zero With Borrow Case">
      <data key="d0">Result Non-Zero With Borrow Case</data>
      <data key="d1">concept</data>
      <data key="d2">Result Non-Zero With Borrow Case occurs when A is less than B, resulting in a non-zero result with borrow, setting ZF=0 and CF=1.</data>
      <data key="d3">chunk-ba5ba3047ff33c33c3e78b969b12b98e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467689</data>
    </node>
    <node id="A Equals B">
      <data key="d0">A Equals B</data>
      <data key="d1">concept</data>
      <data key="d2">A Equals B is a logical condition that holds true when the result of A-B is zero, indicating that the two unsigned numbers are equal.</data>
      <data key="d3">chunk-ba5ba3047ff33c33c3e78b969b12b98e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467689</data>
    </node>
    <node id="A Greater Than B">
      <data key="d0">A Greater Than B</data>
      <data key="d1">concept</data>
      <data key="d2">A Greater Than B is a logical condition derived when A-B produces a non-zero result with no borrow, meaning A is larger than B.</data>
      <data key="d3">chunk-ba5ba3047ff33c33c3e78b969b12b98e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467689</data>
    </node>
    <node id="A Less Than B">
      <data key="d0">A Less Than B</data>
      <data key="d1">concept</data>
      <data key="d2">A Less Than B is a logical condition triggered when A-B results in a borrow, indicating that A is smaller than B.</data>
      <data key="d3">chunk-ba5ba3047ff33c33c3e78b969b12b98e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467689</data>
    </node>
    <node id="Data Endianness">
      <data key="d0">Data Endianness</data>
      <data key="d1">concept</data>
      <data key="d2">Data endianness refers to the order in which bytes of a multi-byte data type are stored in memory, categorized as big endian or little endian.</data>
      <data key="d3">chunk-09b53b0df067c5056104774d13e5e395</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467711</data>
    </node>
    <node id="Big Endian">
      <data key="d0">Big Endian</data>
      <data key="d1">method</data>
      <data key="d2">Big endian is a byte ordering method where the most significant byte is stored at the lowest memory address.</data>
      <data key="d3">chunk-09b53b0df067c5056104774d13e5e395</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467711</data>
    </node>
    <node id="Little Endian">
      <data key="d0">Little Endian</data>
      <data key="d1">method</data>
      <data key="d2">Little endian is a byte ordering method where the least significant byte is stored at the lowest memory address.</data>
      <data key="d3">chunk-09b53b0df067c5056104774d13e5e395</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467711</data>
    </node>
    <node id="Least Significant Byte">
      <data key="d0">Least Significant Byte</data>
      <data key="d1">artifact</data>
      <data key="d2">The least significant byte (LSB) represents the lowest-order byte in a multi-byte data value.</data>
      <data key="d3">chunk-09b53b0df067c5056104774d13e5e395</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467711</data>
    </node>
    <node id="Most Significant Byte">
      <data key="d0">Most Significant Byte</data>
      <data key="d1">artifact</data>
      <data key="d2">The most significant byte (MSB) represents the highest-order byte in a multi-byte data value.</data>
      <data key="d3">chunk-09b53b0df067c5056104774d13e5e395</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467711</data>
    </node>
    <node id="32-Bit Computer">
      <data key="d0">32-Bit Computer</data>
      <data key="d1">naturalobject</data>
      <data key="d2">A 32-bit computer is a system where data words are 32 bits long, and the memory addresses are typically byte-addressed.</data>
      <data key="d3">chunk-09b53b0df067c5056104774d13e5e395</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467711</data>
    </node>
    <node id="Float Type">
      <data key="d0">Float Type</data>
      <data key="d1">type</data>
      <data key="d2">The float type is a data type that occupies 4 bytes in memory and is used to store single-precision floating-point numbers.&lt;SEP&gt;Float Type in C Language represents single-precision floating-point numbers, corresponding to IEEE754 single-precision format with 24-bit precision including the hidden bit.</data>
      <data key="d3">chunk-09b53b0df067c5056104774d13e5e395&lt;SEP&gt;chunk-7661b58ae4a51d1ee96186ef15ec5292</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467754</data>
    </node>
    <node id="Double Type">
      <data key="d0">Double Type</data>
      <data key="d1">type</data>
      <data key="d2">The double type is a data type that occupies 8 bytes in memory and is used to store double-precision floating-point numbers.&lt;SEP&gt;Double Type in C Language represents double-precision floating-point numbers, corresponding to IEEE754 double-precision format with 53-bit precision including the hidden bit.</data>
      <data key="d3">chunk-09b53b0df067c5056104774d13e5e395&lt;SEP&gt;chunk-7661b58ae4a51d1ee96186ef15ec5292</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467754</data>
    </node>
    <node id="Memory Address">
      <data key="d0">Memory Address</data>
      <data key="d1">artifact</data>
      <data key="d2">A memory address is a unique identifier for a location in computer memory where data is stored, typically byte-addressed.</data>
      <data key="d3">chunk-09b53b0df067c5056104774d13e5e395</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467712</data>
    </node>
    <node id="Boundary Alignment">
      <data key="d0">Boundary Alignment</data>
      <data key="d1">concept</data>
      <data key="d2">Boundary alignment is a storage requirement where data must be stored at memory addresses that are multiples of their size to enable efficient memory access.</data>
      <data key="d3">chunk-09b53b0df067c5056104774d13e5e395</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467712</data>
    </node>
    <node id="RISC">
      <data key="d0">RISC</data>
      <data key="d1">organization</data>
      <data key="d2">RISC (Reduced Instruction Set Computer) is a class of processors that typically use boundary-aligned memory access to optimize instruction fetching and execution.</data>
      <data key="d3">chunk-09b53b0df067c5056104774d13e5e395</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467712</data>
    </node>
    <node id="C Language Struct">
      <data key="d0">C Language Struct</data>
      <data key="d1">content</data>
      <data key="d2">C Language Struct is a user-defined data type in the C programming language that groups related variables together and follows specific alignment rules.</data>
      <data key="d3">chunk-09b53b0df067c5056104774d13e5e395</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467712</data>
    </node>
    <node id="Character Type">
      <data key="d0">Character Type</data>
      <data key="d1">data</data>
      <data key="d2">The character type (char) is a data type that occupies 1 byte and is used to store individual characters.</data>
      <data key="d3">chunk-09b53b0df067c5056104774d13e5e395</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467712</data>
    </node>
    <node id="Short Type">
      <data key="d0">Short Type</data>
      <data key="d1">data</data>
      <data key="d2">The short type is a data type that occupies 2 bytes and is used to store small integer values.</data>
      <data key="d3">chunk-09b53b0df067c5056104774d13e5e395</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467712</data>
    </node>
    <node id="Struct Length">
      <data key="d0">Struct Length</data>
      <data key="d1">data</data>
      <data key="d2">The struct length is the total size of a struct object, which must be a multiple of the largest alignment requirement among its members.</data>
      <data key="d3">chunk-09b53b0df067c5056104774d13e5e395</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467712</data>
    </node>
    <node id="Alignment Value">
      <data key="d0">Alignment Value</data>
      <data key="d1">concept</data>
      <data key="d2">The alignment value defines the required memory boundary for a data type, measured in bytes.</data>
      <data key="d3">chunk-09b53b0df067c5056104774d13e5e395</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467713</data>
    </node>
    <node id="Padding Bytes">
      <data key="d0">Padding Bytes</data>
      <data key="d1">artifact</data>
      <data key="d2">Padding bytes are unused bytes inserted into memory to ensure data alignment, improving access efficiency.</data>
      <data key="d3">chunk-09b53b0df067c5056104774d13e5e395</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467714</data>
    </node>
    <node id="Halfword Address">
      <data key="d0">Halfword Address</data>
      <data key="d1">artifact</data>
      <data key="d2">A halfword address is a memory address that must be a multiple of 2, corresponding to the alignment requirement for halfword-sized data (typically 2 bytes).</data>
      <data key="d3">chunk-09b53b0df067c5056104774d13e5e395</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467714</data>
    </node>
    <node id="Word Address">
      <data key="d0">Word Address</data>
      <data key="d1">artifact</data>
      <data key="d2">A word address is a memory address that must be a multiple of 4, corresponding to the alignment requirement for word-sized data (typically 4 bytes in a 32-bit system).</data>
      <data key="d3">chunk-09b53b0df067c5056104774d13e5e395</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467714</data>
    </node>
    <node id="定点数的移位运算">
      <data key="d0">定点数的移位运算</data>
      <data key="d1">concept</data>
      <data key="d2">定点数的移位运算refers to the technique of using shift operations to perform multiplication and division in binary arithmetic, especially when direct multiplication or division circuits are unavailable.</data>
      <data key="d3">chunk-ee63e6f80ae58c99375bb442c346b8a6</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467715</data>
    </node>
    <node id="加法和移位">
      <data key="d0">加法和移位</data>
      <data key="d1">method</data>
      <data key="d2">加法和移位is a computational method that combines addition and bit shifting to achieve multiplication and division operations in binary arithmetic.</data>
      <data key="d3">chunk-ee63e6f80ae58c99375bb442c346b8a6</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467715</data>
    </node>
    <node id="二进制整数">
      <data key="d0">二进制整数</data>
      <data key="d1">data</data>
      <data key="d2">二进制整数is a numerical representation in base-2 used in computer systems for storing and processing integer values.</data>
      <data key="d3">chunk-ee63e6f80ae58c99375bb442c346b8a6</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467715</data>
    </node>
    <node id="左移一位">
      <data key="d0">左移一位</data>
      <data key="d1">method</data>
      <data key="d2">左移一位is a bit-level operation that shifts all bits in a binary number one position to the left, equivalent to multiplication by 2 if no overflow occurs.</data>
      <data key="d3">chunk-ee63e6f80ae58c99375bb442c346b8a6</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467715</data>
    </node>
    <node id="右移一位">
      <data key="d0">右移一位</data>
      <data key="d1">method</data>
      <data key="d2">右移一位is a bit-level operation that shifts all bits in a binary number one position to the right, equivalent to division by 2 if the least significant bit is ignored.</data>
      <data key="d3">chunk-ee63e6f80ae58c99375bb442c346b8a6</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467715</data>
    </node>
    <node id="逻辑移位">
      <data key="d0">逻辑移位</data>
      <data key="d1">method</data>
      <data key="d2">逻辑移位is a type of bit shift operation treating the operand as an unsigned integer, where zeros are filled in from the opposite end.</data>
      <data key="d3">chunk-ee63e6f80ae58c99375bb442c346b8a6</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467715</data>
    </node>
    <node id="算术移位">
      <data key="d0">算术移位</data>
      <data key="d1">method</data>
      <data key="d2">算术移位is a type of bit shift operation that considers the sign bit, treating the operand as a signed integer using two's complement representation.</data>
      <data key="d3">chunk-ee63e6f80ae58c99375bb442c346b8a6</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467715</data>
    </node>
    <node id="无符号整数">
      <data key="d0">无符号整数</data>
      <data key="d1">concept</data>
      <data key="d2">无符号整数is a binary integer representation that does not include a sign bit, meaning all bits represent magnitude.&lt;SEP&gt;无符号整数is an integer representation that uses binary digits exclusively for magnitude, equivalent to positive numbers in two's complement.</data>
      <data key="d3">chunk-ee63e6f80ae58c99375bb442c346b8a6&lt;SEP&gt;chunk-278906376b45ec28050699d283cb1aeb</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467748</data>
    </node>
    <node id="有符号整数">
      <data key="d0">有符号整数</data>
      <data key="d1">data</data>
      <data key="d2">有符号整数is a binary integer representation that includes a sign bit, with values stored in two's complement form.</data>
      <data key="d3">chunk-ee63e6f80ae58c99375bb442c346b8a6</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467717</data>
    </node>
    <node id="精度影响">
      <data key="d0">精度影响</data>
      <data key="d1">concept</data>
      <data key="d2">精度影响refers to the degradation of data accuracy resulting from bit loss during right shift operations, particularly in signed integers.</data>
      <data key="d3">chunk-ee63e6f80ae58c99375bb442c346b8a6</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467718</data>
    </node>
    <node id="加减运算电路">
      <data key="d0">加减运算电路</data>
      <data key="d1">artifact</data>
      <data key="d2">The加减运算电路is a digital circuit designed to perform both addition and subtraction operations using a modified adder with control logic.</data>
      <data key="d3">chunk-278906376b45ec28050699d283cb1aeb</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467748</data>
    </node>
    <node id="反向器">
      <data key="d0">反向器</data>
      <data key="d1">artifact</data>
      <data key="d2">反向器is a digital logic component that inverts the input signal, used here to implement bit-wise NOT operation on Y.</data>
      <data key="d3">chunk-278906376b45ec28050699d283cb1aeb</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467748</data>
    </node>
    <node id="2选1多路选择器">
      <data key="d0">2选1多路选择器</data>
      <data key="d1">artifact</data>
      <data key="d2">2选1多路选择器is a digital switch that selects one of two input signals based on a control signal, used here to choose between Y and Y inverted.</data>
      <data key="d3">chunk-278906376b45ec28050699d283cb1aeb</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467748</data>
    </node>
    <node id="控制端Sub">
      <data key="d0">控制端Sub</data>
      <data key="d1">artifact</data>
      <data key="d2">控制端Sub is a control signal that determines whether the circuit performs addition or subtraction by selecting the appropriate input to the adder.</data>
      <data key="d3">chunk-278906376b45ec28050699d283cb1aeb</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467748</data>
    </node>
    <node id="低位进位">
      <data key="d0">低位进位</data>
      <data key="d1">concept</data>
      <data key="d2">低位进位is a carry signal fed into the least significant bit of the adder, used to add 1 in subtraction to achieve the negative complement.</data>
      <data key="d3">chunk-278906376b45ec28050699d283cb1aeb</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467748</data>
    </node>
    <node id="有符号数">
      <data key="d0">有符号数</data>
      <data key="d1">concept</data>
      <data key="d2">有符号数is an integer representation in two's complement form, where the most significant bit indicates the sign.</data>
      <data key="d3">chunk-278906376b45ec28050699d283cb1aeb</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467748</data>
    </node>
    <node id="Y">
      <data key="d0">Y</data>
      <data key="d1">data</data>
      <data key="d2">Y is the input to the adder, representing the second operand; its form depends on whether the number is signed or unsigned.</data>
      <data key="d3">chunk-278906376b45ec28050699d283cb1aeb</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467750</data>
    </node>
    <node id="零标志ZF">
      <data key="d0">零标志ZF</data>
      <data key="d1">concept</data>
      <data key="d2">零标志ZF is a flag that indicates whether the result of an operation is zero; ZF = 1 means the result is zero.</data>
      <data key="d3">chunk-278906376b45ec28050699d283cb1aeb</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467750</data>
    </node>
    <node id="溢出标志OF">
      <data key="d0">溢出标志OF</data>
      <data key="d1">concept</data>
      <data key="d2">溢出标志OF is a flag used to detect overflow in signed arithmetic; it is the XOR of the carry into and out of the sign bit.</data>
      <data key="d3">chunk-278906376b45ec28050699d283cb1aeb</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467750</data>
    </node>
    <node id="符号标志SF">
      <data key="d0">符号标志SF</data>
      <data key="d1">concept</data>
      <data key="d2">符号标志SF indicates the sign of the result, represented by the most significant bit of the output.</data>
      <data key="d3">chunk-278906376b45ec28050699d283cb1aeb</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467750</data>
    </node>
    <node id="进/借位标志CF">
      <data key="d0">进/借位标志CF</data>
      <data key="d1">concept</data>
      <data key="d2">进/借位标志CF indicates carry (for addition) or borrow (for subtraction) in unsigned arithmetic; it reflects overflow in unsigned operations.</data>
      <data key="d3">chunk-278906376b45ec28050699d283cb1aeb</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467750</data>
    </node>
    <node id="图2.9">
      <data key="d0">图2.9</data>
      <data key="d1">content</data>
      <data key="d2">图2.9 is a diagram illustrating the加减运算电路design, including components such as the adder, multiplexer, and inverters.</data>
      <data key="d3">chunk-278906376b45ec28050699d283cb1aeb</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467750</data>
    </node>
    <node id="运算结果">
      <data key="d0">运算结果</data>
      <data key="d3">chunk-278906376b45ec28050699d283cb1aeb</data>
      <data key="d2">The零标志ZF is set based on whether the result of an arithmetic operation is zero.</data>
      <data key="d1">UNKNOWN</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467752</data>
    </node>
    <node id="减法">
      <data key="d0">减法</data>
      <data key="d3">chunk-278906376b45ec28050699d283cb1aeb</data>
      <data key="d2">Subtraction is implemented by adding the two's complement of the subtrahend, which is Y+1.</data>
      <data key="d1">UNKNOWN</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467753</data>
    </node>
    <node id="Long Double Type">
      <data key="d0">Long Double Type</data>
      <data key="d1">type</data>
      <data key="d2">Long Double Type in C Language represents extended double-precision floating-point numbers, with its size and format varying by compiler and processor architecture.</data>
      <data key="d3">chunk-7661b58ae4a51d1ee96186ef15ec5292</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467754</data>
    </node>
    <node id="IEEE754">
      <data key="d0">IEEE754</data>
      <data key="d1">standard</data>
      <data key="d2">IEEE754 is a technical standard for floating-point arithmetic established by the Institute of Electrical and Electronics Engineers, defining formats for single and double precision.</data>
      <data key="d3">chunk-7661b58ae4a51d1ee96186ef15ec5292</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467754</data>
    </node>
    <node id="Implicit Type Conversion">
      <data key="d0">Implicit Type Conversion</data>
      <data key="d1">method</data>
      <data key="d2">Implicit Type Conversion, also known as coercion, is a system-driven data type conversion that occurs automatically without explicit syntax.</data>
      <data key="d3">chunk-7661b58ae4a51d1ee96186ef15ec5292</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467754</data>
    </node>
    <node id="Integral Types">
      <data key="d0">Integral Types</data>
      <data key="d1">type</data>
      <data key="d2">Integral Types in C Language include char, int, long, and their signed/unsigned variants, used to represent whole numbers.</data>
      <data key="d3">chunk-7661b58ae4a51d1ee96186ef15ec5292</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467754</data>
    </node>
    <node id="Floating-Point Types">
      <data key="d0">Floating-Point Types</data>
      <data key="d1">type</data>
      <data key="d2">Floating-Point Types in C Language include float, double, and long double, used to represent real numbers with decimal points.</data>
      <data key="d3">chunk-7661b58ae4a51d1ee96186ef15ec5292</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467755</data>
    </node>
    <node id="Precision Loss">
      <data key="d0">Precision Loss</data>
      <data key="d1">concept</data>
      <data key="d2">Precision Loss refers to the reduction in the accuracy of a number due to insufficient bit representation during conversion.</data>
      <data key="d3">chunk-7661b58ae4a51d1ee96186ef15ec5292</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467756</data>
    </node>
    <node id="Memory Representation">
      <data key="d0">Memory Representation</data>
      <data key="d1">concept</data>
      <data key="d2">Memory Representation describes how data types are stored in computer memory, including size and bit layout.</data>
      <data key="d3">chunk-7661b58ae4a51d1ee96186ef15ec5292</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467756</data>
    </node>
    <node id="Long Type">
      <data key="d0">Long Type</data>
      <data key="d3">chunk-7661b58ae4a51d1ee96186ef15ec5292</data>
      <data key="d2">When int and long types are involved in an operation, the int type is promoted to long type to preserve precision and avoid overflow.</data>
      <data key="d1">UNKNOWN</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467759</data>
    </node>
    <node id="原码加减法运算">
      <data key="d0">原码加减法运算</data>
      <data key="d1">method</data>
      <data key="d2">原码加减法运算是计算机中处理带符号数加减法的一种方法，涉及符号位与数值位的分开处理。</data>
      <data key="d3">chunk-ea2c16caf28ea549ed420e26afbca237</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467784</data>
    </node>
    <node id="加法规则">
      <data key="d0">加法规则</data>
      <data key="d1">concept</data>
      <data key="d2">加法规则是原码加减法中的核心逻辑之一，遵循同号求和、异号求差的原则。</data>
      <data key="d3">chunk-ea2c16caf28ea549ed420e26afbca237</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467784</data>
    </node>
    <node id="减法规则">
      <data key="d0">减法规则</data>
      <data key="d1">concept</data>
      <data key="d2">减法规则是原码加减法中将减数符号取反后按加法处理的规则。</data>
      <data key="d3">chunk-ea2c16caf28ea549ed420e26afbca237</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467784</data>
    </node>
    <node id="绝对值大的数">
      <data key="d0">绝对值大的数</data>
      <data key="d1">concept</data>
      <data key="d2">绝对值大的数在异号相加时决定结果符号，其数值位被用作被减数。</data>
      <data key="d3">chunk-ea2c16caf28ea549ed420e26afbca237</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467784</data>
    </node>
    <node id="补码加减运算">
      <data key="d0">补码加减运算</data>
      <data key="d1">method</data>
      <data key="d2">补码加减运算是计算机中普遍采用的加减法运算方式，简化了硬件实现。</data>
      <data key="d3">chunk-ea2c16caf28ea549ed420e26afbca237</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467784</data>
    </node>
    <node id="最高数值位">
      <data key="d0">最高数值位</data>
      <data key="d1">concept</data>
      <data key="d2">最高数值位是数值部分的最高有效位，其相加结果影响溢出判断。</data>
      <data key="d3">chunk-ea2c16caf28ea549ed420e26afbca237</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467786</data>
    </node>
    <node id="减数">
      <data key="d0">减数</data>
      <data key="d1">concept</data>
      <data key="d2">减数是减法运算中被减去的数。</data>
      <data key="d3">chunk-ea2c16caf28ea549ed420e26afbca237</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467786</data>
    </node>
    <node id="被减数">
      <data key="d0">被减数</data>
      <data key="d1">concept</data>
      <data key="d2">被减数是减法运算中减去其他数的初始数。</data>
      <data key="d3">chunk-ea2c16caf28ea549ed420e26afbca237</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467786</data>
    </node>
    <node id="同号求和">
      <data key="d0">同号求和</data>
      <data key="d1">concept</data>
      <data key="d2">同号求和是原码加法规则中的原则，表示两个数符号相同时，其数值位相加，结果符号与原数相同。</data>
      <data key="d3">chunk-ea2c16caf28ea549ed420e26afbca237</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467786</data>
    </node>
    <node id="异号求差">
      <data key="d0">异号求差</data>
      <data key="d1">concept</data>
      <data key="d2">异号求差是原码加法规则中的原则，表示两个数符号不同时，进行绝对值大的减绝对值小的，结果符号与绝对值大的数相同。</data>
      <data key="d3">chunk-ea2c16caf28ea549ed420e26afbca237</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467786</data>
    </node>
    <node id="Machine Number Fixed-Point Representation">
      <data key="d0">Machine Number Fixed-Point Representation</data>
      <data key="d1">concept</data>
      <data key="d2">Machine Number Fixed-Point Representation is a data format in computers where the position of the decimal point is fixed, used to represent fixed-point numbers.</data>
      <data key="d3">chunk-5b233c3ec097f13f398ea0ca159b2c8b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467829</data>
    </node>
    <node id="Floating-Point Representation">
      <data key="d0">Floating-Point Representation</data>
      <data key="d1">concept</data>
      <data key="d2">Floating-Point Representation is a data format in computers where the decimal point can move, used to represent real numbers with varying precision.</data>
      <data key="d3">chunk-5b233c3ec097f13f398ea0ca159b2c8b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467829</data>
    </node>
    <node id="Bias Code">
      <data key="d0">Bias Code</data>
      <data key="d1">method</data>
      <data key="d2">Bias Code is a representation method used primarily for exponent fields in floating-point numbers, where a constant bias is added to the true value.</data>
      <data key="d3">chunk-5b233c3ec097f13f398ea0ca159b2c8b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467829</data>
    </node>
    <node id="Fixed-Point Integer">
      <data key="d0">Fixed-Point Integer</data>
      <data key="d1">concept</data>
      <data key="d2">Fixed-Point Integer is a type of fixed-point number representing integers in computer systems with a fixed decimal point.</data>
      <data key="d3">chunk-5b233c3ec097f13f398ea0ca159b2c8b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467829</data>
    </node>
    <node id="Fixed-Point Fraction">
      <data key="d0">Fixed-Point Fraction</data>
      <data key="d1">concept</data>
      <data key="d2">Fixed-Point Fraction is a type of fixed-point number representing fractional values with a fixed decimal point.</data>
      <data key="d3">chunk-5b233c3ec097f13f398ea0ca159b2c8b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467829</data>
    </node>
    <node id="Machine Word Length">
      <data key="d0">Machine Word Length</data>
      <data key="d1">concept</data>
      <data key="d2">Machine Word Length is the number of bits used to represent a value in a computer system.</data>
      <data key="d3">chunk-5b233c3ec097f13f398ea0ca159b2c8b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467831</data>
    </node>
    <node id="Numerical Bits">
      <data key="d0">Numerical Bits</data>
      <data key="d1">artifact</data>
      <data key="d2">Numerical Bits are the bits in a machine number that represent the magnitude or value of the number.</data>
      <data key="d3">chunk-5b233c3ec097f13f398ea0ca159b2c8b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467831</data>
    </node>
    <node id="Zero">
      <data key="d0">Zero</data>
      <data key="d1">concept</data>
      <data key="d2">Zero is a number whose representation in machine codes can vary depending on the encoding method, such as positive zero and negative zero in original and one’s complement forms.</data>
      <data key="d3">chunk-5b233c3ec097f13f398ea0ca159b2c8b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467831</data>
    </node>
    <node id="Floating-Point Exponent">
      <data key="d0">Floating-Point Exponent</data>
      <data key="d1">artifact</data>
      <data key="d2">Floating-Point Exponent is the part of a floating-point number that indicates the power of the base by which the mantissa is multiplied.</data>
      <data key="d3">chunk-5b233c3ec097f13f398ea0ca159b2c8b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467831</data>
    </node>
    <node id="Floating-Point Mantissa">
      <data key="d0">Floating-Point Mantissa</data>
      <data key="d1">artifact</data>
      <data key="d2">Floating-Point Mantissa is the significant digits part of a floating-point number.</data>
      <data key="d3">chunk-5b233c3ec097f13f398ea0ca159b2c8b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467831</data>
    </node>
    <node id="Bias Value">
      <data key="d0">Bias Value</data>
      <data key="d1">concept</data>
      <data key="d2">Bias Value is a constant added to the actual exponent to obtain its unbiased form in floating-point representation.</data>
      <data key="d3">chunk-5b233c3ec097f13f398ea0ca159b2c8b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467831</data>
    </node>
    <node id="Modulus">
      <data key="d0">Modulus</data>
      <data key="d1">concept</data>
      <data key="d2">Modulus refers to the base of the number system used in computing, such as 2 in binary arithmetic.</data>
      <data key="d3">chunk-5b233c3ec097f13f398ea0ca159b2c8b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467832</data>
    </node>
    <node id="Number Axis">
      <data key="d0">Number Axis</data>
      <data key="d1">concept</data>
      <data key="d2">Number Axis is a conceptual line representing numerical values, where the position of a code corresponds to its magnitude.</data>
      <data key="d3">chunk-5b233c3ec097f13f398ea0ca159b2c8b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467832</data>
    </node>
    <node id="Addition Operation">
      <data key="d0">Addition Operation</data>
      <data key="d3">chunk-5b233c3ec097f13f398ea0ca159b2c8b</data>
      <data key="d2">Complement Code allows addition and subtraction to be performed using only addition operations.</data>
      <data key="d1">UNKNOWN</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761467834</data>
    </node>
    <edge source="Floating Point Normalization" target="Mantissa">
      <data key="d6">1.0</data>
      <data key="d7">Floating point normalization modifies the mantissa to ensure all significant digits are preserved and positioned correctly.</data>
      <data key="d8">adjustment,digit preservation</data>
      <data key="d9">chunk-c22f61a22dddcf7887de6d879988c291</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467380</data>
    </edge>
    <edge source="Floating Point Normalization" target="Exponent">
      <data key="d6">1.0</data>
      <data key="d7">Floating point normalization updates the exponent in response to mantissa shifts to maintain the value of the number.</data>
      <data key="d8">adjustment,scaling</data>
      <data key="d9">chunk-c22f61a22dddcf7887de6d879988c291</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467380</data>
    </edge>
    <edge source="Floating Point Normalization" target="Non-Zero Floating Point Number">
      <data key="d6">1.0</data>
      <data key="d7">Normalization is required for all non-zero floating-point numbers to ensure consistent and accurate representation.</data>
      <data key="d8">prerequisite,requirement</data>
      <data key="d9">chunk-c22f61a22dddcf7887de6d879988c291</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467380</data>
    </edge>
    <edge source="Floating Point Normalization" target="Significant Digit">
      <data key="d6">1.0</data>
      <data key="d7">Floating point normalization ensures that significant digits are retained and properly positioned within the mantissa to maximize precision.</data>
      <data key="d8">digit preservation,precision enhancement</data>
      <data key="d9">chunk-c22f61a22dddcf7887de6d879988c291</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467381</data>
    </edge>
    <edge source="Mantissa" target="Left Normalization">
      <data key="d6">1.0</data>
      <data key="d7">In left normalization, the mantissa is shifted left and the exponent is decreased by one for each shift, when the leading digit is not valid.</data>
      <data key="d8">exponent adjustment,left shift</data>
      <data key="d9">chunk-c22f61a22dddcf7887de6d879988c291</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467380</data>
    </edge>
    <edge source="Mantissa" target="Right Normalization">
      <data key="d6">1.0</data>
      <data key="d7">In right normalization, the mantissa is shifted right by one position and the exponent is increased by one to prevent overflow into the integer part.</data>
      <data key="d8">exponent adjustment,right shift</data>
      <data key="d9">chunk-c22f61a22dddcf7887de6d879988c291</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467381</data>
    </edge>
    <edge source="Mantissa" target="Floating Point Precision">
      <data key="d6">1.0</data>
      <data key="d7">The number of bits in the mantissa determines the precision of the floating point representation.</data>
      <data key="d8">precision determination</data>
      <data key="d9">chunk-5ea05d0aadedcb24741fd320a2b9543c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467677</data>
    </edge>
    <edge source="Mantissa" target="Floating Point Representation">
      <data key="d6">1.0</data>
      <data key="d7">The floating point representation includes a mantissa that stores the significant digits of the number.</data>
      <data key="d8">component structure</data>
      <data key="d9">chunk-5ea05d0aadedcb24741fd320a2b9543c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467678</data>
    </edge>
    <edge source="Exponent" target="Floating Point Representation">
      <data key="d6">1.0</data>
      <data key="d7">The floating point representation uses an exponent to define the scale of the number.</data>
      <data key="d8">component structure</data>
      <data key="d9">chunk-5ea05d0aadedcb24741fd320a2b9543c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467678</data>
    </edge>
    <edge source="Exponent" target="Floating Point Range">
      <data key="d6">1.0</data>
      <data key="d7">The number of bits in the exponent determines the range of values that can be represented.</data>
      <data key="d8">range determination</data>
      <data key="d9">chunk-5ea05d0aadedcb24741fd320a2b9543c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467679</data>
    </edge>
    <edge source="Exponent" target="Exponent Field">
      <data key="d6">1.0</data>
      <data key="d7">The exponent field directly corresponds to the exponent component in floating point representation.</data>
      <data key="d8">component correspondence</data>
      <data key="d9">chunk-5ea05d0aadedcb24741fd320a2b9543c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467679</data>
    </edge>
    <edge source="Left Normalization" target="Base 2">
      <data key="d6">1.0</data>
      <data key="d7">Left normalization uses base 2 operations where each left shift corresponds to dividing by two and adjusting the exponent accordingly.</data>
      <data key="d8">algorithm foundation,binary system</data>
      <data key="d9">chunk-c22f61a22dddcf7887de6d879988c291</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467381</data>
    </edge>
    <edge source="Right Normalization" target="Overflow">
      <data key="d6">1.0</data>
      <data key="d7">Right normalization may cause overflow if the exponent increases beyond its maximum allowable value.</data>
      <data key="d8">error condition,risk</data>
      <data key="d9">chunk-c22f61a22dddcf7887de6d879988c291</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467380</data>
    </edge>
    <edge source="Right Normalization" target="Base 2">
      <data key="d6">1.0</data>
      <data key="d7">Right normalization in base 2 uses right shifts (multiplication by two) and exponent increment to maintain number precision.</data>
      <data key="d8">algorithm foundation,binary system</data>
      <data key="d9">chunk-c22f61a22dddcf7887de6d879988c291</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467381</data>
    </edge>
    <edge source="Overflow" target="Positive Overflow">
      <data key="d6">1.0</data>
      <data key="d7">Positive overflow is a specific case of the general overflow condition in floating point arithmetic.</data>
      <data key="d8">overflow condition</data>
      <data key="d9">chunk-5ea05d0aadedcb24741fd320a2b9543c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467677</data>
    </edge>
    <edge source="Overflow" target="Negative Overflow">
      <data key="d6">1.0</data>
      <data key="d7">Negative overflow is a specific case of the general overflow condition in floating point arithmetic.</data>
      <data key="d8">overflow condition</data>
      <data key="d9">chunk-5ea05d0aadedcb24741fd320a2b9543c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467678</data>
    </edge>
    <edge source="Unsigned Integer" target="Binary Encoding">
      <data key="d6">1.0</data>
      <data key="d7">An unsigned integer uses binary encoding to represent numerical values, where all bits are used for magnitude.</data>
      <data key="d8">bit usage,representation</data>
      <data key="d9">chunk-224035519c723875f8ee06a75cc06f38</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467388</data>
    </edge>
    <edge source="Unsigned Integer" target="Sign Bit">
      <data key="d6">1.0</data>
      <data key="d7">Unsigned integers do not include a sign bit and default to positive values.</data>
      <data key="d8">exclusion,positive default</data>
      <data key="d9">chunk-224035519c723875f8ee06a75cc06f38</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467388</data>
    </edge>
    <edge source="Unsigned Integer" target="Word Length">
      <data key="d6">1.0</data>
      <data key="d7">The word length determines the range of values that an unsigned integer can represent.</data>
      <data key="d8">range,representation capacity</data>
      <data key="d9">chunk-224035519c723875f8ee06a75cc06f38</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467389</data>
    </edge>
    <edge source="Unsigned Integer" target="Address Operation">
      <data key="d6">1.0</data>
      <data key="d7">Address operations use unsigned integers to manage and calculate memory addresses.</data>
      <data key="d8">application,computational use</data>
      <data key="d9">chunk-224035519c723875f8ee06a75cc06f38</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467389</data>
    </edge>
    <edge source="Unsigned Integer" target="Pointer Representation">
      <data key="d6">1.0</data>
      <data key="d7">Pointer representation typically uses unsigned integers to represent memory addresses.</data>
      <data key="d8">application,data structure use</data>
      <data key="d9">chunk-224035519c723875f8ee06a75cc06f38</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467390</data>
    </edge>
    <edge source="Unsigned Integer" target="8-Bit Unsigned Integer">
      <data key="d6">1.0</data>
      <data key="d7">An 8-bit unsigned integer is a specific representation of the general concept of an unsigned integer.</data>
      <data key="d8">data type,specific instance</data>
      <data key="d9">chunk-224035519c723875f8ee06a75cc06f38</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467390</data>
    </edge>
    <edge source="Unsigned Integer" target="Value Range">
      <data key="d6">1.0</data>
      <data key="d7">The value range of an unsigned integer is determined by its bit length, with no negative values.</data>
      <data key="d8">capacity,numerical representation</data>
      <data key="d9">chunk-224035519c723875f8ee06a75cc06f38</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467390</data>
    </edge>
    <edge source="Unsigned Integer" target="Zero Extension">
      <data key="d6">1.0</data>
      <data key="d7">When converting an unsigned integer from a smaller to a larger word length, zero extension fills the higher bits with zeros.</data>
      <data key="d8">bit filling,data conversion</data>
      <data key="d9">chunk-eb70606fa9ba73ffc22231992979ee26</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467564</data>
    </edge>
    <edge source="Sign Bit" target="Positive Sign">
      <data key="d6">1.0</data>
      <data key="d7">In machine number encoding, a sign bit of "0" corresponds to a positive sign in the true value.</data>
      <data key="d8">binary representation</data>
      <data key="d9">chunk-fe930da67280065a9ab94641ffc7e10e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467407</data>
    </edge>
    <edge source="Sign Bit" target="Negative Sign">
      <data key="d6">1.0</data>
      <data key="d7">In machine number encoding, a sign bit of "1" corresponds to a negative sign in the true value.</data>
      <data key="d8">binary representation</data>
      <data key="d9">chunk-fe930da67280065a9ab94641ffc7e10e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467407</data>
    </edge>
    <edge source="Sign Bit" target="Comma">
      <data key="d6">1.0</data>
      <data key="d7">The comma is used to visually separate the sign bit from the numerical part in binary representations like "0,101".</data>
      <data key="d8">notation separator</data>
      <data key="d9">chunk-fe930da67280065a9ab94641ffc7e10e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467408</data>
    </edge>
    <edge source="Sign Bit" target="Complement Code">
      <data key="d6">1.0</data>
      <data key="d7">In complement code, the sign bit is included in the binary representation and can be processed along with the magnitude bits during arithmetic operations.</data>
      <data key="d8">binary representation,sign handling</data>
      <data key="d9">chunk-ea5d582d57c5196325119e4d99f578d2</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467455</data>
    </edge>
    <edge source="Sign Bit" target="Sign">
      <data key="d6">1.0</data>
      <data key="d7">The sign bit is the bit-level representation of the sign component in a floating point number.</data>
      <data key="d8">component correspondence</data>
      <data key="d9">chunk-5ea05d0aadedcb24741fd320a2b9543c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467678</data>
    </edge>
    <edge source="Sign Bit" target="Numerical Bits">
      <data key="d6">1.0</data>
      <data key="d7">In a machine number, the sign bit is separated from the numerical bits to represent polarity.</data>
      <data key="d8">bit division,encoding structure</data>
      <data key="d9">chunk-5b233c3ec097f13f398ea0ca159b2c8b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467834</data>
    </edge>
    <edge source="8-Bit Unsigned Integer" target="Maximum Value">
      <data key="d6">1.0</data>
      <data key="d7">The maximum value of an 8-bit unsigned integer is 255, achieved when all bits are set to 1.</data>
      <data key="d8">numerical range</data>
      <data key="d9">chunk-224035519c723875f8ee06a75cc06f38</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467388</data>
    </edge>
    <edge source="8-Bit Unsigned Integer" target="00000000">
      <data key="d6">1.0</data>
      <data key="d7">The binary sequence 00000000 is the binary representation of the minimum value of an 8-bit unsigned integer.</data>
      <data key="d8">minimum value representation</data>
      <data key="d9">chunk-224035519c723875f8ee06a75cc06f38</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467390</data>
    </edge>
    <edge source="8-Bit Unsigned Integer" target="11111111">
      <data key="d6">1.0</data>
      <data key="d7">The binary sequence 11111111 is the binary representation of the maximum value of an 8-bit unsigned integer.</data>
      <data key="d8">maximum value representation</data>
      <data key="d9">chunk-224035519c723875f8ee06a75cc06f38</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467391</data>
    </edge>
    <edge source="8-Bit Signed Integer" target="Maximum Value">
      <data key="d6">1.0</data>
      <data key="d7">The maximum value of an 8-bit signed integer in two's complement is 127, represented by 01111111.</data>
      <data key="d8">numerical range,two's complement</data>
      <data key="d9">chunk-224035519c723875f8ee06a75cc06f38</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467389</data>
    </edge>
    <edge source="8-Bit Signed Integer" target="10000000">
      <data key="d6">1.0</data>
      <data key="d7">The binary sequence 10000000 is the two's complement representation of the minimum value of an 8-bit signed integer (-128).</data>
      <data key="d8">minimum value representation</data>
      <data key="d9">chunk-224035519c723875f8ee06a75cc06f38</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467389</data>
    </edge>
    <edge source="8-Bit Signed Integer" target="01111111">
      <data key="d6">1.0</data>
      <data key="d7">The binary sequence 01111111 is the two's complement representation of the maximum value of an 8-bit signed integer (127).</data>
      <data key="d8">maximum value representation</data>
      <data key="d9">chunk-224035519c723875f8ee06a75cc06f38</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467389</data>
    </edge>
    <edge source="Two's Complement" target="Signed Integer">
      <data key="d6">1.0</data>
      <data key="d7">Signed integers are commonly represented using the two's complement method to encode negative numbers.</data>
      <data key="d8">encoding method,signed representation</data>
      <data key="d9">chunk-224035519c723875f8ee06a75cc06f38</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467388</data>
    </edge>
    <edge source="Two's Complement" target="Complement Code">
      <data key="d6">2.0</data>
      <data key="d7">Complement Code refers to Two's Complement as the specific method used for storing signed integers in C Language.&lt;SEP&gt;Two's complement is the same as complement code, representing a method where signed integers are stored using a unique zero and simplified arithmetic operations.</data>
      <data key="d8">representation type,synonymy,technical definition,technical equivalence</data>
      <data key="d9">chunk-ea5d582d57c5196325119e4d99f578d2&lt;SEP&gt;chunk-7f2cde5c650ea54bac6265e49d30e485</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467456</data>
    </edge>
    <edge source="Signed Integer" target="Sign Extension">
      <data key="d6">1.0</data>
      <data key="d7">When converting a signed integer from a smaller to a larger word length, sign extension fills the higher bits with the sign bit.</data>
      <data key="d8">bit filling,data conversion</data>
      <data key="d9">chunk-eb70606fa9ba73ffc22231992979ee26</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467564</data>
    </edge>
    <edge source="True Value" target="Positive Sign">
      <data key="d6">1.0</data>
      <data key="d7">True value uses a positive sign (+) to denote positive numbers, which may be omitted.</data>
      <data key="d8">sign representation</data>
      <data key="d9">chunk-fe930da67280065a9ab94641ffc7e10e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467406</data>
    </edge>
    <edge source="True Value" target="Negative Sign">
      <data key="d6">1.0</data>
      <data key="d7">True value uses a negative sign (-) to denote negative numbers.</data>
      <data key="d8">sign representation</data>
      <data key="d9">chunk-fe930da67280065a9ab94641ffc7e10e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467407</data>
    </edge>
    <edge source="True Value" target="Machine Number">
      <data key="d6">1.0</data>
      <data key="d7">Machine number is the digitalized version of a true value, used in computer systems to represent signed numbers.</data>
      <data key="d8">digital encoding,numerical representation</data>
      <data key="d9">chunk-fe930da67280065a9ab94641ffc7e10e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467407</data>
    </edge>
    <edge source="True Value" target="Bias Code">
      <data key="d6">1.0</data>
      <data key="d7">Bias Code represents True Value after adding a fixed bias value.</data>
      <data key="d8">encoding offset,saturation</data>
      <data key="d9">chunk-5b233c3ec097f13f398ea0ca159b2c8b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467834</data>
    </edge>
    <edge source="True Value" target="Complement Code">
      <data key="d6">1.0</data>
      <data key="d7">Complement Code expresses a negative number as the modulus minus its absolute value.</data>
      <data key="d8">modulo arithmetic</data>
      <data key="d9">chunk-5b233c3ec097f13f398ea0ca159b2c8b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467835</data>
    </edge>
    <edge source="Machine Number" target="Original Code">
      <data key="d6">1.0</data>
      <data key="d7">Original code is one of the methods used to represent machine numbers with a sign bit and magnitude.</data>
      <data key="d8">representation method</data>
      <data key="d9">chunk-fe930da67280065a9ab94641ffc7e10e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467407</data>
    </edge>
    <edge source="Machine Number" target="Complement Code">
      <data key="d6">1.0</data>
      <data key="d7">Complement code is a method used in machine numbers to represent negative values efficiently for arithmetic operations.</data>
      <data key="d8">representation method</data>
      <data key="d9">chunk-fe930da67280065a9ab94641ffc7e10e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467408</data>
    </edge>
    <edge source="Machine Number" target="One's Complement">
      <data key="d6">1.0</data>
      <data key="d7">One's complement is a method used to represent machine numbers by inverting all bits of the positive number.</data>
      <data key="d8">representation method</data>
      <data key="d9">chunk-fe930da67280065a9ab94641ffc7e10e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467408</data>
    </edge>
    <edge source="Machine Number" target="Numerical Part">
      <data key="d6">1.0</data>
      <data key="d7">The numerical part of a number represents its magnitude within a machine number.</data>
      <data key="d8">magnitude representation</data>
      <data key="d9">chunk-fe930da67280065a9ab94641ffc7e10e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467408</data>
    </edge>
    <edge source="Machine Number" target="Binary Digit">
      <data key="d6">1.0</data>
      <data key="d7">Binary digits (bits) form the fundamental building blocks of machine numbers in digital systems.</data>
      <data key="d8">data unit</data>
      <data key="d9">chunk-fe930da67280065a9ab94641ffc7e10e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467409</data>
    </edge>
    <edge source="Original Code" target="Complement Code">
      <data key="d6">2.0</data>
      <data key="d7">Complement code offers a unique zero representation, unlike original code, which has both positive and negative zero.&lt;SEP&gt;Complement Code is derived from Original Code and used to simplify arithmetic operations in digital systems.</data>
      <data key="d8">binary arithmetic,comparative advantage,numerical representation,zero representation</data>
      <data key="d9">chunk-ea5d582d57c5196325119e4d99f578d2&lt;SEP&gt;chunk-5b233c3ec097f13f398ea0ca159b2c8b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467832</data>
    </edge>
    <edge source="Original Code" target="Zero">
      <data key="d6">1.0</data>
      <data key="d7">Original Code has two representations for zero: positive zero and negative zero.</data>
      <data key="d8">representation inconsistency</data>
      <data key="d9">chunk-5b233c3ec097f13f398ea0ca159b2c8b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467834</data>
    </edge>
    <edge source="Original Code" target="Number Axis">
      <data key="d6">1.0</data>
      <data key="d7">Original Code is symmetrically represented on the number axis, with both positive and negative zero.</data>
      <data key="d8">symmetric representation</data>
      <data key="d9">chunk-5b233c3ec097f13f398ea0ca159b2c8b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467834</data>
    </edge>
    <edge source="Complement Code" target="Short Int">
      <data key="d6">1.0</data>
      <data key="d7">Short Int is stored in two's complement form, where the most significant bit indicates the sign.</data>
      <data key="d8">binary representation,storage method</data>
      <data key="d9">chunk-7f2cde5c650ea54bac6265e49d30e485</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467430</data>
    </edge>
    <edge source="Complement Code" target="Int">
      <data key="d6">1.0</data>
      <data key="d7">Int is stored in two's complement form, with the sign bit indicating the number’s sign.</data>
      <data key="d8">binary representation,storage method</data>
      <data key="d9">chunk-7f2cde5c650ea54bac6265e49d30e485</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467430</data>
    </edge>
    <edge source="Complement Code" target="Long Int">
      <data key="d6">1.0</data>
      <data key="d7">Long Int is stored in two's complement form, with sign bit determining the value's polarity.</data>
      <data key="d8">binary representation,storage method</data>
      <data key="d9">chunk-7f2cde5c650ea54bac6265e49d30e485</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467431</data>
    </edge>
    <edge source="Complement Code" target="Unsigned Short">
      <data key="d6">1.0</data>
      <data key="d7">Unsigned Short is stored in two's complement form but interpreted as absolute values, with no sign bit.</data>
      <data key="d8">absolute value,storage method</data>
      <data key="d9">chunk-7f2cde5c650ea54bac6265e49d30e485</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467431</data>
    </edge>
    <edge source="Complement Code" target="Unsigned Int">
      <data key="d6">1.0</data>
      <data key="d7">Unsigned Int is stored in two's complement form but treated as absolute values.</data>
      <data key="d8">absolute value,storage method</data>
      <data key="d9">chunk-7f2cde5c650ea54bac6265e49d30e485</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467431</data>
    </edge>
    <edge source="Complement Code" target="Unsigned Long">
      <data key="d6">1.0</data>
      <data key="d7">Unsigned Long is stored in two's complement form but all bits represent magnitude.</data>
      <data key="d8">absolute value,storage method</data>
      <data key="d9">chunk-7f2cde5c650ea54bac6265e49d30e485</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467432</data>
    </edge>
    <edge source="Complement Code" target="Char">
      <data key="d6">1.0</data>
      <data key="d7">Char is stored in two's complement form but interpreted as an unsigned integer by default.</data>
      <data key="d8">storage method,unsigned interpretation</data>
      <data key="d9">chunk-7f2cde5c650ea54bac6265e49d30e485</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467432</data>
    </edge>
    <edge source="Complement Code" target="One's Complement">
      <data key="d6">2.0</data>
      <data key="d7">Complement code simplifies arithmetic operations compared to one's complement, which requires extra handling for end-around carry.&lt;SEP&gt;One's Complement is the intermediate form used to convert Original Code to Complement Code.</data>
      <data key="d8">arithmetic simplicity,comparative advantage,conversion,intermediate representation</data>
      <data key="d9">chunk-ea5d582d57c5196325119e4d99f578d2&lt;SEP&gt;chunk-5b233c3ec097f13f398ea0ca159b2c8b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467833</data>
    </edge>
    <edge source="Complement Code" target="Offset Code">
      <data key="d6">1.0</data>
      <data key="d7">Complement code allows the sign bit to be included in arithmetic operations, unlike offset code where the bias must be adjusted separately.</data>
      <data key="d8">arithmetic compatibility,comparative advantage</data>
      <data key="d9">chunk-ea5d582d57c5196325119e4d99f578d2</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467456</data>
    </edge>
    <edge source="Complement Code" target="n-Bit Signed Integer">
      <data key="d6">1.0</data>
      <data key="d7">In computing, n-bit signed integers are universally represented using two's complement, which provides the range from -2^(n-1) to 2^(n-1)-1.</data>
      <data key="d8">range validity,standard representation</data>
      <data key="d9">chunk-ea5d582d57c5196325119e4d99f578d2</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467456</data>
    </edge>
    <edge source="Complement Code" target="Addition Operation">
      <data key="d6">1.0</data>
      <data key="d7">Complement Code allows addition and subtraction to be performed using only addition operations.</data>
      <data key="d8">arithmetic simplification,unified computation</data>
      <data key="d9">chunk-5b233c3ec097f13f398ea0ca159b2c8b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467834</data>
    </edge>
    <edge source="Complement Code" target="Zero">
      <data key="d6">1.0</data>
      <data key="d7">Complement Code provides a unique representation for zero, avoiding ambiguity.</data>
      <data key="d8">unique representation</data>
      <data key="d9">chunk-5b233c3ec097f13f398ea0ca159b2c8b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467835</data>
    </edge>
    <edge source="Complement Code" target="Number Axis">
      <data key="d6">2.0</data>
      <data key="d7">Complement Code is asymmetrically represented on the number axis, allowing one more number than original code.&lt;SEP&gt;The complement code preserves the natural ordering of values on the number axis.</data>
      <data key="d8">asymmetric representation,monotonicity,value ordering</data>
      <data key="d9">chunk-5b233c3ec097f13f398ea0ca159b2c8b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467836</data>
    </edge>
    <edge source="Complement Code" target="Modulus">
      <data key="d6">1.0</data>
      <data key="d7">The modulus in complement code is determined by the base of the number system (e.g., 2 for binary).</data>
      <data key="d8">arithmetic base,number system</data>
      <data key="d9">chunk-5b233c3ec097f13f398ea0ca159b2c8b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467836</data>
    </edge>
    <edge source="One's Complement" target="Zero">
      <data key="d6">1.0</data>
      <data key="d7">One's Complement also has two representations for zero: positive zero and negative zero.</data>
      <data key="d8">representation inconsistency</data>
      <data key="d9">chunk-5b233c3ec097f13f398ea0ca159b2c8b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467832</data>
    </edge>
    <edge source="One's Complement" target="Number Axis">
      <data key="d6">1.0</data>
      <data key="d7">One's Complement is symmetric on the number axis and includes both positive and negative zero.</data>
      <data key="d8">symmetric representation</data>
      <data key="d9">chunk-5b233c3ec097f13f398ea0ca159b2c8b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467836</data>
    </edge>
    <edge source="Numerical Part" target="Comma">
      <data key="d6">1.0</data>
      <data key="d7">The comma separates the numerical part from the sign bit in binary number notation.</data>
      <data key="d8">notation separator</data>
      <data key="d9">chunk-fe930da67280065a9ab94641ffc7e10e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467408</data>
    </edge>
    <edge source="C Language" target="Short Int">
      <data key="d6">1.0</data>
      <data key="d7">Short Int is a data type defined within the C Language for signed 16-bit integers.</data>
      <data key="d8">data type,integer type</data>
      <data key="d9">chunk-7f2cde5c650ea54bac6265e49d30e485</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467428</data>
    </edge>
    <edge source="C Language" target="Int">
      <data key="d6">1.0</data>
      <data key="d7">Int is a data type defined within the C Language for signed 32-bit integers.</data>
      <data key="d8">data type,integer type</data>
      <data key="d9">chunk-7f2cde5c650ea54bac6265e49d30e485</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467428</data>
    </edge>
    <edge source="C Language" target="Long Int">
      <data key="d6">1.0</data>
      <data key="d7">Long Int is a data type defined within the C Language for signed integers with variable size depending on the machine architecture.</data>
      <data key="d8">data type,integer type</data>
      <data key="d9">chunk-7f2cde5c650ea54bac6265e49d30e485</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467429</data>
    </edge>
    <edge source="C Language" target="Unsigned Short">
      <data key="d6">1.0</data>
      <data key="d7">Unsigned Short is a data type defined within the C Language for unsigned 16-bit integers.</data>
      <data key="d8">data type,integer type</data>
      <data key="d9">chunk-7f2cde5c650ea54bac6265e49d30e485</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467430</data>
    </edge>
    <edge source="C Language" target="Unsigned Int">
      <data key="d6">1.0</data>
      <data key="d7">Unsigned Int is a data type defined within the C Language for unsigned 32-bit integers.</data>
      <data key="d8">data type,integer type</data>
      <data key="d9">chunk-7f2cde5c650ea54bac6265e49d30e485</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467430</data>
    </edge>
    <edge source="C Language" target="Unsigned Long">
      <data key="d6">1.0</data>
      <data key="d7">Unsigned Long is a data type defined within the C Language for unsigned integers with variable size depending on the machine architecture.</data>
      <data key="d8">data type,integer type</data>
      <data key="d9">chunk-7f2cde5c650ea54bac6265e49d30e485</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467431</data>
    </edge>
    <edge source="C Language" target="Char">
      <data key="d6">1.0</data>
      <data key="d7">Char is a data type defined within the C Language for 8-bit characters, interpreted as unsigned integers by default.</data>
      <data key="d8">character type,data type</data>
      <data key="d9">chunk-7f2cde5c650ea54bac6265e49d30e485</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467432</data>
    </edge>
    <edge source="C Language" target="Type Conversion">
      <data key="d6">1.0</data>
      <data key="d7">C Language supports type conversions between data types, including explicit type casting with the syntax "TYPEb = (TYPE)a".</data>
      <data key="d8">data transformation,language feature</data>
      <data key="d9">chunk-eb70606fa9ba73ffc22231992979ee26</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467564</data>
    </edge>
    <edge source="C Language" target="Float Type">
      <data key="d6">1.0</data>
      <data key="d7">In C Language, float type corresponds to IEEE754 single-precision floating-point format with 24-bit precision including the hidden bit.</data>
      <data key="d8">data type specification,precision</data>
      <data key="d9">chunk-7661b58ae4a51d1ee96186ef15ec5292</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467757</data>
    </edge>
    <edge source="C Language" target="Double Type">
      <data key="d6">1.0</data>
      <data key="d7">In C Language, double type corresponds to IEEE754 double-precision floating-point format with 53-bit precision including the hidden bit.</data>
      <data key="d8">data type specification,precision</data>
      <data key="d9">chunk-7661b58ae4a51d1ee96186ef15ec5292</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467760</data>
    </edge>
    <edge source="C Language" target="Long Double Type">
      <data key="d6">1.0</data>
      <data key="d7">In C Language, long double type may vary in size and format based on the compiler and processor, unlike standard IEEE754 types.</data>
      <data key="d8">architecture dependence,data type specification</data>
      <data key="d9">chunk-7661b58ae4a51d1ee96186ef15ec5292</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467760</data>
    </edge>
    <edge source="Short Int" target="Signed">
      <data key="d6">1.0</data>
      <data key="d7">Signed Short Int uses the most significant bit to represent the sign, affecting its range of representable values.</data>
      <data key="d8">numeric range,sign representation</data>
      <data key="d9">chunk-7f2cde5c650ea54bac6265e49d30e485</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467428</data>
    </edge>
    <edge source="Int" target="Signed">
      <data key="d6">1.0</data>
      <data key="d7">Signed Int uses the most significant bit to represent the sign, restricting its positive range.</data>
      <data key="d8">numeric range,sign representation</data>
      <data key="d9">chunk-7f2cde5c650ea54bac6265e49d30e485</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467429</data>
    </edge>
    <edge source="Long Int" target="Signed">
      <data key="d6">1.0</data>
      <data key="d7">Signed Long Int uses the most significant bit to represent the sign, influencing its data range.</data>
      <data key="d8">numeric range,sign representation</data>
      <data key="d9">chunk-7f2cde5c650ea54bac6265e49d30e485</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467430</data>
    </edge>
    <edge source="Unsigned Short" target="Unsigned">
      <data key="d6">1.0</data>
      <data key="d7">Unsigned Short uses all bits for magnitude, with no sign bit, allowing larger positive values.</data>
      <data key="d8">bit utilization,no sign bit</data>
      <data key="d9">chunk-7f2cde5c650ea54bac6265e49d30e485</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467428</data>
    </edge>
    <edge source="Unsigned Int" target="Unsigned">
      <data key="d6">1.0</data>
      <data key="d7">Unsigned Int uses all bits for magnitude, allowing full range of positive values.</data>
      <data key="d8">bit utilization,no sign bit</data>
      <data key="d9">chunk-7f2cde5c650ea54bac6265e49d30e485</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467429</data>
    </edge>
    <edge source="Unsigned Long" target="Unsigned">
      <data key="d6">1.0</data>
      <data key="d7">Unsigned Long uses all bits for magnitude, with no sign bit, maximizing positive range.</data>
      <data key="d8">bit utilization,no sign bit</data>
      <data key="d9">chunk-7f2cde5c650ea54bac6265e49d30e485</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467430</data>
    </edge>
    <edge source="n-Bit Signed Integer" target="Range of n-Bit Signed Integer">
      <data key="d6">1.0</data>
      <data key="d7">The range of an n-bit signed integer is directly determined by the choice of encoding method, with two's complement extending the minimum negative value.</data>
      <data key="d8">range definition,representation dependency</data>
      <data key="d9">chunk-ea5d582d57c5196325119e4d99f578d2</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467455</data>
    </edge>
    <edge source="进位计数制" target="十进制">
      <data key="d6">1.0</data>
      <data key="d7">进位计数制包括十进制，十进制是日常生活中最常使用的计数制。</data>
      <data key="d8">type,usage</data>
      <data key="d9">chunk-ca423326f2f43c01238f9b5f5a0e0862</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467462</data>
    </edge>
    <edge source="进位计数制" target="二进制">
      <data key="d6">1.0</data>
      <data key="d7">进位计数制包括二进制，二进制是计算机中使用最多的计数制。</data>
      <data key="d8">computational usage,type</data>
      <data key="d9">chunk-ca423326f2f43c01238f9b5f5a0e0862</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467462</data>
    </edge>
    <edge source="进位计数制" target="八进制">
      <data key="d6">1.0</data>
      <data key="d7">进位计数制包括八进制，其与二进制的转换非常方便，三位二进制数对应一位八进制数。</data>
      <data key="d8">conversion convenience,type</data>
      <data key="d9">chunk-ca423326f2f43c01238f9b5f5a0e0862</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467463</data>
    </edge>
    <edge source="进位计数制" target="十六进制">
      <data key="d6">1.0</data>
      <data key="d7">进位计数制包括十六进制，其与二进制的转换极为方便，四位二进制数对应一位十六进制数。</data>
      <data key="d8">conversion convenience,type</data>
      <data key="d9">chunk-ca423326f2f43c01238f9b5f5a0e0862</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467463</data>
    </edge>
    <edge source="十进制" target="基数">
      <data key="d6">1.0</data>
      <data key="d7">十进制的基数为10，表示其使用0到9共10个不同数码。</data>
      <data key="d8">mathematical property</data>
      <data key="d9">chunk-ca423326f2f43c01238f9b5f5a0e0862</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467462</data>
    </edge>
    <edge source="十进制" target="位权">
      <data key="d6">1.0</data>
      <data key="d7">十进制数中的每个数码乘以相应位权后求和，可得该数的数值大小。</data>
      <data key="d8">numerical representation</data>
      <data key="d9">chunk-ca423326f2f43c01238f9b5f5a0e0862</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467463</data>
    </edge>
    <edge source="十进制" target="后缀标识">
      <data key="d6">1.0</data>
      <data key="d7">后缀标识中使用D表示十进制数，通常可省略。</data>
      <data key="d8">notation method</data>
      <data key="d9">chunk-ca423326f2f43c01238f9b5f5a0e0862</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467464</data>
    </edge>
    <edge source="十进制" target="0～9">
      <data key="d6">1.0</data>
      <data key="d7">The decimal system uses the digit set 0 to 9, which consists of ten distinct numerals.</data>
      <data key="d8">digit set</data>
      <data key="d9">chunk-ca423326f2f43c01238f9b5f5a0e0862</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467465</data>
    </edge>
    <edge source="二进制" target="基数">
      <data key="d6">1.0</data>
      <data key="d7">二进制的基数为2，表示其使用0和1两个数码，计数逢二进一。</data>
      <data key="d8">mathematical property</data>
      <data key="d9">chunk-ca423326f2f43c01238f9b5f5a0e0862</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467463</data>
    </edge>
    <edge source="二进制" target="位权">
      <data key="d6">1.0</data>
      <data key="d7">二进制数中每个数码乘以位权后相加，构成该数的数值。</data>
      <data key="d8">numerical representation</data>
      <data key="d9">chunk-ca423326f2f43c01238f9b5f5a0e0862</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467465</data>
    </edge>
    <edge source="二进制" target="计算机">
      <data key="d6">1.0</data>
      <data key="d7">计算机使用二进制数作为基本数据表示方式，以0和1进行信息处理。</data>
      <data key="d8">data representation</data>
      <data key="d9">chunk-ca423326f2f43c01238f9b5f5a0e0862</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467466</data>
    </edge>
    <edge source="二进制" target="后缀标识">
      <data key="d6">1.0</data>
      <data key="d7">后缀标识中使用B表示二进制数，用于标明其进位制。</data>
      <data key="d8">notation method</data>
      <data key="d9">chunk-ca423326f2f43c01238f9b5f5a0e0862</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467466</data>
    </edge>
    <edge source="二进制" target="2³">
      <data key="d6">1.0</data>
      <data key="d7">The binary system uses 2³ as the basis for conversion to octal, where each group of three binary digits forms one octal digit.</data>
      <data key="d8">conversion basis</data>
      <data key="d9">chunk-ca423326f2f43c01238f9b5f5a0e0862</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467467</data>
    </edge>
    <edge source="二进制" target="2⁴">
      <data key="d6">1.0</data>
      <data key="d7">The binary system uses 2⁴ as the basis for conversion to hexadecimal, where each group of four binary digits forms one hexadecimal digit.</data>
      <data key="d8">conversion basis</data>
      <data key="d9">chunk-ca423326f2f43c01238f9b5f5a0e0862</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467467</data>
    </edge>
    <edge source="八进制" target="基数">
      <data key="d6">1.0</data>
      <data key="d7">八进制的基数为8，表示其使用0到7共8个数码，计数逢八进一。</data>
      <data key="d8">mathematical property</data>
      <data key="d9">chunk-ca423326f2f43c01238f9b5f5a0e0862</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467463</data>
    </edge>
    <edge source="八进制" target="位权">
      <data key="d6">1.0</data>
      <data key="d7">八进制数使用位权来确定每个数码的数值贡献。</data>
      <data key="d8">numerical representation</data>
      <data key="d9">chunk-ca423326f2f43c01238f9b5f5a0e0862</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467464</data>
    </edge>
    <edge source="八进制" target="计算机">
      <data key="d6">1.0</data>
      <data key="d7">八进制在计算机系统中用于简化二进制的表示，便于程序员阅读和操作。</data>
      <data key="d8">data representation</data>
      <data key="d9">chunk-ca423326f2f43c01238f9b5f5a0e0862</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467464</data>
    </edge>
    <edge source="八进制" target="后缀标识">
      <data key="d6">1.0</data>
      <data key="d7">后缀标识中使用O表示八进制数，用于标识其计数制。</data>
      <data key="d8">notation method</data>
      <data key="d9">chunk-ca423326f2f43c01238f9b5f5a0e0862</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467465</data>
    </edge>
    <edge source="八进制" target="0～7">
      <data key="d6">1.0</data>
      <data key="d7">The octal system uses the digit set 0 to 7, which includes eight distinct numerals.</data>
      <data key="d8">digit set</data>
      <data key="d9">chunk-ca423326f2f43c01238f9b5f5a0e0862</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467465</data>
    </edge>
    <edge source="十六进制" target="基数">
      <data key="d6">1.0</data>
      <data key="d7">十六进制的基数为16，表示其使用0到9和A到F共16个数码，计数逢十六进一。</data>
      <data key="d8">mathematical property</data>
      <data key="d9">chunk-ca423326f2f43c01238f9b5f5a0e0862</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467464</data>
    </edge>
    <edge source="十六进制" target="计算机">
      <data key="d6">1.0</data>
      <data key="d7">十六进制在计算机中用于简化二进制的表示，常用于内存地址和颜色编码。</data>
      <data key="d8">data representation</data>
      <data key="d9">chunk-ca423326f2f43c01238f9b5f5a0e0862</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467464</data>
    </edge>
    <edge source="十六进制" target="位权">
      <data key="d6">1.0</data>
      <data key="d7">十六进制数基于位权系统，通过数码乘以对应位权求和得到数值。</data>
      <data key="d8">numerical representation</data>
      <data key="d9">chunk-ca423326f2f43c01238f9b5f5a0e0862</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467465</data>
    </edge>
    <edge source="十六进制" target="后缀标识">
      <data key="d6">1.0</data>
      <data key="d7">后缀标识中使用H表示十六进制数，用于明确其计数制。</data>
      <data key="d8">notation method</data>
      <data key="d9">chunk-ca423326f2f43c01238f9b5f5a0e0862</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467465</data>
    </edge>
    <edge source="十六进制" target="前缀标识">
      <data key="d6">1.0</data>
      <data key="d7">前缀标识中使用0x表示十六进制数，常见于编程语言中。</data>
      <data key="d8">notation method</data>
      <data key="d9">chunk-ca423326f2f43c01238f9b5f5a0e0862</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467466</data>
    </edge>
    <edge source="十六进制" target="A～F">
      <data key="d6">1.0</data>
      <data key="d7">The hexadecimal system extends its digit set using the letters A to F, which represent the decimal values 10 to 15.</data>
      <data key="d8">digit extension</data>
      <data key="d9">chunk-ca423326f2f43c01238f9b5f5a0e0862</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467466</data>
    </edge>
    <edge source="定点数" target="溢出">
      <data key="d6">1.0</data>
      <data key="d7">定点运算在结果超出表示范围时发生溢出。</data>
      <data key="d8">computation,overflow condition</data>
      <data key="d9">chunk-fe285d304d7559e78510976eea6cc1c1</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467493</data>
    </edge>
    <edge source="浮点数" target="表示范围">
      <data key="d6">1.0</data>
      <data key="d7">浮点数的表示范围远大于定点数，当两者字长相同时。</data>
      <data key="d8">data representation,数值范围优势</data>
      <data key="d9">chunk-fe285d304d7559e78510976eea6cc1c1</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467492</data>
    </edge>
    <edge source="浮点数" target="精度">
      <data key="d6">1.0</data>
      <data key="d7">浮点数虽扩大了表示范围，但与定点数相比精度降低。</data>
      <data key="d8">data representation,精度降低</data>
      <data key="d9">chunk-fe285d304d7559e78510976eea6cc1c1</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467493</data>
    </edge>
    <edge source="浮点数" target="阶码">
      <data key="d6">1.0</data>
      <data key="d7">浮点数由阶码和尾数两部分构成。</data>
      <data key="d8">component structure,representation</data>
      <data key="d9">chunk-fe285d304d7559e78510976eea6cc1c1</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467493</data>
    </edge>
    <edge source="浮点数" target="尾数">
      <data key="d6">1.0</data>
      <data key="d7">浮点数由阶码和尾数两部分构成。</data>
      <data key="d8">component structure,representation</data>
      <data key="d9">chunk-fe285d304d7559e78510976eea6cc1c1</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467494</data>
    </edge>
    <edge source="浮点数" target="溢出">
      <data key="d6">1.0</data>
      <data key="d7">浮点运算中仅当规格化后阶码超出范围时才发生溢出。</data>
      <data key="d8">computation,overflow condition</data>
      <data key="d9">chunk-fe285d304d7559e78510976eea6cc1c1</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467494</data>
    </edge>
    <edge source="阶码" target="浮点运算">
      <data key="d6">1.0</data>
      <data key="d7">浮点运算需对阶码进行独立运算。</data>
      <data key="d8">computation,operation component</data>
      <data key="d9">chunk-fe285d304d7559e78510976eea6cc1c1</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467492</data>
    </edge>
    <edge source="尾数" target="浮点运算">
      <data key="d6">1.0</data>
      <data key="d7">浮点运算需对尾数进行独立运算。</data>
      <data key="d8">computation,operation component</data>
      <data key="d9">chunk-fe285d304d7559e78510976eea6cc1c1</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467494</data>
    </edge>
    <edge source="规格化" target="浮点运算">
      <data key="d6">1.0</data>
      <data key="d7">浮点运算结果需进行规格化处理。</data>
      <data key="d8">computational step,processing requirement</data>
      <data key="d9">chunk-fe285d304d7559e78510976eea6cc1c1</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467493</data>
    </edge>
    <edge source="溢出" target="左移一位">
      <data key="d6">1.0</data>
      <data key="d7">左移一位may cause溢出if the most significant bit shifts out and the new sign bit differs from the original.</data>
      <data key="d8">overflow risk,sign change</data>
      <data key="d9">chunk-ee63e6f80ae58c99375bb442c346b8a6</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467720</data>
    </edge>
    <edge source="溢出" target="原码加减法运算">
      <data key="d6">1.0</data>
      <data key="d7">原码加减法运算中，数值位相加产生进位即发生溢出。</data>
      <data key="d8">error condition,numerical limitation</data>
      <data key="d9">chunk-ea2c16caf28ea549ed420e26afbca237</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467788</data>
    </edge>
    <edge source="定点运算" target="浮点运算">
      <data key="d6">1.0</data>
      <data key="d7">浮点运算比定点运算更复杂，因涉及阶码与尾数双重运算。</data>
      <data key="d8">complexity comparison,computational method</data>
      <data key="d9">chunk-fe285d304d7559e78510976eea6cc1c1</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467494</data>
    </edge>
    <edge source="Arithmetic Logic Unit" target="One-Bit Full Adder">
      <data key="d6">1.0</data>
      <data key="d7">The one-bit full adder is the basic unit used in constructing the ALU for binary addition.</data>
      <data key="d8">core component,fundamental building block</data>
      <data key="d9">chunk-6151c8c091207072ad8e5a4c89b6cd43</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467511</data>
    </edge>
    <edge source="Arithmetic Logic Unit" target="Logical AND">
      <data key="d6">1.0</data>
      <data key="d7">The ALU supports logical AND as one of its primary logic operations.</data>
      <data key="d8">logic function,supported operation</data>
      <data key="d9">chunk-6151c8c091207072ad8e5a4c89b6cd43</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467511</data>
    </edge>
    <edge source="Arithmetic Logic Unit" target="Logical OR">
      <data key="d6">1.0</data>
      <data key="d7">The ALU supports logical OR as one of its primary logic operations.</data>
      <data key="d8">logic function,supported operation</data>
      <data key="d9">chunk-6151c8c091207072ad8e5a4c89b6cd43</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467512</data>
    </edge>
    <edge source="Arithmetic Logic Unit" target="Logical NOT">
      <data key="d6">1.0</data>
      <data key="d7">The ALU supports logical NOT as one of its primary logic operations.</data>
      <data key="d8">logic function,supported operation</data>
      <data key="d9">chunk-6151c8c091207072ad8e5a4c89b6cd43</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467512</data>
    </edge>
    <edge source="Arithmetic Logic Unit" target="Logical XOR">
      <data key="d6">1.0</data>
      <data key="d7">The ALU supports logical XOR as one of its primary logic operations.</data>
      <data key="d8">logic function,supported operation</data>
      <data key="d9">chunk-6151c8c091207072ad8e5a4c89b6cd43</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467513</data>
    </edge>
    <edge source="Arithmetic Logic Unit" target="Addition">
      <data key="d6">1.0</data>
      <data key="d7">The ALU performs addition as the foundational arithmetic operation.</data>
      <data key="d8">arithmetic function,core operation</data>
      <data key="d9">chunk-6151c8c091207072ad8e5a4c89b6cd43</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467513</data>
    </edge>
    <edge source="Arithmetic Logic Unit" target="Subtraction">
      <data key="d6">1.0</data>
      <data key="d7">The ALU performs subtraction through addition using two’s complement representation.</data>
      <data key="d8">arithmetic function,core operation</data>
      <data key="d9">chunk-6151c8c091207072ad8e5a4c89b6cd43</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467514</data>
    </edge>
    <edge source="Arithmetic Logic Unit" target="Multiplication">
      <data key="d6">1.0</data>
      <data key="d7">Multiplication is implemented in the ALU through repeated addition and shifting.</data>
      <data key="d8">arithmetic function,core operation</data>
      <data key="d9">chunk-6151c8c091207072ad8e5a4c89b6cd43</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467514</data>
    </edge>
    <edge source="Arithmetic Logic Unit" target="Division">
      <data key="d6">1.0</data>
      <data key="d7">Division is implemented in the ALU via iterative subtraction or multiplication.</data>
      <data key="d8">arithmetic function,core operation</data>
      <data key="d9">chunk-6151c8c091207072ad8e5a4c89b6cd43</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467515</data>
    </edge>
    <edge source="Arithmetic Logic Unit" target="n-Bit Adder">
      <data key="d6">1.0</data>
      <data key="d7">The ALU implements an n-bit adder to perform multi-bit addition operations.</data>
      <data key="d8">computational unit,implemented using</data>
      <data key="d9">chunk-6151c8c091207072ad8e5a4c89b6cd43</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467515</data>
    </edge>
    <edge source="Arithmetic Logic Unit" target="ALU Operation Control">
      <data key="d6">1.0</data>
      <data key="d7">The ALU operation control signal determines the function performed by the ALU.</data>
      <data key="d8">control interface,instruction decoding</data>
      <data key="d9">chunk-6151c8c091207072ad8e5a4c89b6cd43</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467515</data>
    </edge>
    <edge source="Subtraction" target="B">
      <data key="d6">1.0</data>
      <data key="d7">B is the second operand in the [A] - [B] subtraction operation.</data>
      <data key="d8">arithmetic operation,operand</data>
      <data key="d9">chunk-1bf253441ffd1d27c8127187db5ecb32</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467623</data>
    </edge>
    <edge source="Subtraction" target="Result">
      <data key="d6">1.0</data>
      <data key="d7">The result of the subtraction [A] - [B] is analyzed using ZF, OF, and SF to determine the relationship between A and B.</data>
      <data key="d8">flag evaluation,operation outcome</data>
      <data key="d9">chunk-1bf253441ffd1d27c8127187db5ecb32</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467623</data>
    </edge>
    <edge source="Subtraction" target="Comparison of Signed Numbers">
      <data key="d6">1.0</data>
      <data key="d7">The comparison of signed numbers is fundamentally based on the subtraction operation [A] - [B].</data>
      <data key="d8">arithmetic basis,logical foundation</data>
      <data key="d9">chunk-1bf253441ffd1d27c8127187db5ecb32</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467624</data>
    </edge>
    <edge source="Subtraction" target="A">
      <data key="d6">1.0</data>
      <data key="d7">A is one of the operands in the [A] - [B] subtraction operation.</data>
      <data key="d8">arithmetic operation,operand</data>
      <data key="d9">chunk-1bf253441ffd1d27c8127187db5ecb32</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467626</data>
    </edge>
    <edge source="One-Bit Full Adder" target="Carry Propagation Delay">
      <data key="d6">1.0</data>
      <data key="d7">The one-bit full adder contributes to carry propagation delay in serial carry adders due to its sequential dependence on previous carry signals.</data>
      <data key="d8">delay mechanism,signal dependency</data>
      <data key="d9">chunk-6151c8c091207072ad8e5a4c89b6cd43</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467512</data>
    </edge>
    <edge source="Serial Carry Adder" target="Carry Propagation Delay">
      <data key="d6">1.0</data>
      <data key="d7">The serial carry adder is limited by carry propagation delay, which increases with the number of bits.</data>
      <data key="d8">performance limit,signal propagation</data>
      <data key="d9">chunk-6151c8c091207072ad8e5a4c89b6cd43</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467513</data>
    </edge>
    <edge source="Parallel Carry Adder" target="Carry-Lookahead Unit">
      <data key="d6">1.0</data>
      <data key="d7">The parallel carry adder uses the carry-lookahead unit to generate carry signals in parallel, reducing delay.</data>
      <data key="d8">design principle,functional relationship</data>
      <data key="d9">chunk-6151c8c091207072ad8e5a4c89b6cd43</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467513</data>
    </edge>
    <edge source="4-Bit Carry-Lookahead Adder" target="n-Bit Carry-Lookahead Adder">
      <data key="d6">1.0</data>
      <data key="d7">The 4-bit carry-lookahead adder is a concrete example of an n-bit carry-lookahead adder for n=4.</data>
      <data key="d8">implementation example,specific instance</data>
      <data key="d9">chunk-6151c8c091207072ad8e5a4c89b6cd43</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467516</data>
    </edge>
    <edge source="Overflow Flag" target="n-Bit Carry-Lookahead Adder">
      <data key="d6">1.0</data>
      <data key="d7">The n-bit carry-lookahead adder generates the overflow flag to detect arithmetic overflow.</data>
      <data key="d8">flag signaling,output generation</data>
      <data key="d9">chunk-6151c8c091207072ad8e5a4c89b6cd43</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467514</data>
    </edge>
    <edge source="Carry Flag" target="n-Bit Carry-Lookahead Adder">
      <data key="d6">1.0</data>
      <data key="d7">The n-bit carry-lookahead adder generates the carry flag to indicate carry-out from the most significant bit.</data>
      <data key="d8">flag signaling,output generation</data>
      <data key="d9">chunk-6151c8c091207072ad8e5a4c89b6cd43</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467514</data>
    </edge>
    <edge source="Sign Flag" target="n-Bit Carry-Lookahead Adder">
      <data key="d6">1.0</data>
      <data key="d7">The n-bit carry-lookahead adder generates the sign flag to reflect the sign of the result.</data>
      <data key="d8">flag signaling,output generation</data>
      <data key="d9">chunk-6151c8c091207072ad8e5a4c89b6cd43</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467515</data>
    </edge>
    <edge source="Zero Flag" target="n-Bit Carry-Lookahead Adder">
      <data key="d6">1.0</data>
      <data key="d7">The n-bit carry-lookahead adder generates the zero flag to indicate whether the result is zero.</data>
      <data key="d8">flag signaling,output generation</data>
      <data key="d9">chunk-6151c8c091207072ad8e5a4c89b6cd43</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467515</data>
    </edge>
    <edge source="Zero Flag" target="Unsigned Number Comparison">
      <data key="d6">1.0</data>
      <data key="d7">The value of Zero Flag (ZF) is determined during unsigned number comparison to assess equality between A and B.</data>
      <data key="d8">flag evaluation,logical condition</data>
      <data key="d9">chunk-ba5ba3047ff33c33c3e78b969b12b98e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467689</data>
    </edge>
    <edge source="Zero Flag" target="A Equals B">
      <data key="d6">1.0</data>
      <data key="d7">When ZF is set to 1, it indicates that A equals B.</data>
      <data key="d8">flag state,outcome indicator</data>
      <data key="d9">chunk-ba5ba3047ff33c33c3e78b969b12b98e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467691</data>
    </edge>
    <edge source="Zero Flag" target="A Greater Than B">
      <data key="d6">1.0</data>
      <data key="d7">When ZF is 0 and CF is 0, it indicates that A is greater than B.</data>
      <data key="d8">flag state,outcome indicator</data>
      <data key="d9">chunk-ba5ba3047ff33c33c3e78b969b12b98e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467692</data>
    </edge>
    <edge source="n-Bit Adder" target="n-Bit Carry-Lookahead Adder">
      <data key="d6">1.0</data>
      <data key="d7">The n-bit carry-lookahead adder is an optimized version of the n-bit adder designed to reduce carry propagation delay.</data>
      <data key="d8">enhanced version,performance optimization</data>
      <data key="d9">chunk-6151c8c091207072ad8e5a4c89b6cd43</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467513</data>
    </edge>
    <edge source="补码" target="二进制运算规则">
      <data key="d6">1.0</data>
      <data key="d7">补码运算基于二进制运算规则，逢二进一。</data>
      <data key="d8">computational basis,operational rule</data>
      <data key="d9">chunk-d6401acae9e97b990cd8ff7387370e66</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467511</data>
    </edge>
    <edge source="补码" target="加法运算">
      <data key="d6">1.0</data>
      <data key="d7">补码用于加法运算时，两个操作数的补码直接相加。</data>
      <data key="d8">direct addition,operation method</data>
      <data key="d9">chunk-d6401acae9e97b990cd8ff7387370e66</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467512</data>
    </edge>
    <edge source="补码" target="减法运算">
      <data key="d6">1.0</data>
      <data key="d7">补码用于减法时，将减数取负后与被减数补码相加。</data>
      <data key="d8">negation addition,operation method</data>
      <data key="d9">chunk-d6401acae9e97b990cd8ff7387370e66</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467512</data>
    </edge>
    <edge source="补码" target="符号位">
      <data key="d6">1.0</data>
      <data key="d7">符号位是补码的一部分，参与运算并决定结果符号。</data>
      <data key="d8">bit representation,sign handling</data>
      <data key="d9">chunk-d6401acae9e97b990cd8ff7387370e66</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467512</data>
    </edge>
    <edge source="补码" target="高位丢弃">
      <data key="d6">1.0</data>
      <data key="d7">补码运算结果中高位被丢弃，确保结果在n+1位范围内。</data>
      <data key="d8">overflow handling,result truncation</data>
      <data key="d9">chunk-d6401acae9e97b990cd8ff7387370e66</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467513</data>
    </edge>
    <edge source="补码" target="n+1位">
      <data key="d6">1.0</data>
      <data key="d7">补码运算结果保留n+1位，该位数是补码结果的标准长度。</data>
      <data key="d8">bit width,result representation</data>
      <data key="d9">chunk-d6401acae9e97b990cd8ff7387370e66</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467514</data>
    </edge>
    <edge source="补码" target="算术移位">
      <data key="d6">1.0</data>
      <data key="d7">算术移位is performed on二进制整数represented in补码, with overflow detected when the sign bit changes after shift.</data>
      <data key="d8">overflow detection,two's complement operation</data>
      <data key="d9">chunk-ee63e6f80ae58c99375bb442c346b8a6</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467720</data>
    </edge>
    <edge source="补码" target="有符号数">
      <data key="d6">1.0</data>
      <data key="d7">有符号数is represented in two's complement form.</data>
      <data key="d8">data encoding,representation method</data>
      <data key="d9">chunk-278906376b45ec28050699d283cb1aeb</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467751</data>
    </edge>
    <edge source="补码" target="无符号整数">
      <data key="d6">1.0</data>
      <data key="d7">无符号整数is equivalent to the positive representation in two's complement, where the binary form matches the unsigned value.</data>
      <data key="d8">binary encoding,representation equivalence</data>
      <data key="d9">chunk-278906376b45ec28050699d283cb1aeb</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467752</data>
    </edge>
    <edge source="补码" target="减法">
      <data key="d6">1.0</data>
      <data key="d7">Subtraction is implemented by adding the two's complement of the subtrahend, which is Y+1.</data>
      <data key="d8">arithmetic operation,negative representation</data>
      <data key="d9">chunk-278906376b45ec28050699d283cb1aeb</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467753</data>
    </edge>
    <edge source="加法运算" target="部分积">
      <data key="d6">1.0</data>
      <data key="d7">部分积通过与X×y-i的加法运算进行更新。</data>
      <data key="d8">accumulation,computation step</data>
      <data key="d9">chunk-8b64d30374af75767b82b53c5d492c80</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467636</data>
    </edge>
    <edge source="加法运算" target="n位无符号数">
      <data key="d6">1.0</data>
      <data key="d7">两个n位无符号数相乘需要进行n次加法运算。</data>
      <data key="d8">arithmetic process,computational operation</data>
      <data key="d9">chunk-8b64d30374af75767b82b53c5d492c80</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467637</data>
    </edge>
    <edge source="符号位" target="原码乘法">
      <data key="d6">1.0</data>
      <data key="d7">在原码乘法中，乘积的符号位由两个乘数符号位进行异或运算得到。</data>
      <data key="d8">operation component,sign determination</data>
      <data key="d9">chunk-8b64d30374af75767b82b53c5d492c80</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467635</data>
    </edge>
    <edge source="符号位" target="异或运算">
      <data key="d6">1.0</data>
      <data key="d7">符号位的生成依赖于两个乘数符号位的异或运算。</data>
      <data key="d8">logic operation,sign calculation</data>
      <data key="d9">chunk-8b64d30374af75767b82b53c5d492c80</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467636</data>
    </edge>
    <edge source="符号位" target="加法规则">
      <data key="d6">1.0</data>
      <data key="d7">加法规则涉及根据符号位是否相同决定进行加法或减法操作。</data>
      <data key="d8">conditional logic,sign handling</data>
      <data key="d9">chunk-ea2c16caf28ea549ed420e26afbca237</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467787</data>
    </edge>
    <edge source="Binary" target="Computer System">
      <data key="d6">1.0</data>
      <data key="d7">Binary is used to encode all information within a computer system, serving as the primary representation method.</data>
      <data key="d8">data encoding,fundamental representation</data>
      <data key="d9">chunk-3878dd58bdab1629f78e313f678153cc</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467529</data>
    </edge>
    <edge source="Binary" target="High And Low Voltage">
      <data key="d6">1.0</data>
      <data key="d7">High and low voltage states are used to physically represent binary digits 0 and 1.</data>
      <data key="d8">binary state mapping,physical representation</data>
      <data key="d9">chunk-3878dd58bdab1629f78e313f678153cc</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467530</data>
    </edge>
    <edge source="Binary" target="Positive And Negative Charge">
      <data key="d6">1.0</data>
      <data key="d7">Positive and negative charge polarities serve as a physical representation of binary digits 0 and 1.</data>
      <data key="d8">binary state mapping,physical representation</data>
      <data key="d9">chunk-3878dd58bdab1629f78e313f678153cc</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467530</data>
    </edge>
    <edge source="Binary" target="Logical Value True">
      <data key="d6">1.0</data>
      <data key="d7">The binary value 1 directly corresponds to the logical value "true" in computing and logic.</data>
      <data key="d8">logical correspondence,truth value mapping</data>
      <data key="d9">chunk-3878dd58bdab1629f78e313f678153cc</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467530</data>
    </edge>
    <edge source="Binary" target="Logical Value False">
      <data key="d6">1.0</data>
      <data key="d7">The binary value 0 directly corresponds to the logical value "false" in computing and logic.</data>
      <data key="d8">logical correspondence,truth value mapping</data>
      <data key="d9">chunk-3878dd58bdab1629f78e313f678153cc</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467531</data>
    </edge>
    <edge source="Binary" target="Logic Gate Circuit">
      <data key="d6">1.0</data>
      <data key="d7">Binary values are processed and manipulated through logic gate circuits to execute logical operations.</data>
      <data key="d8">implementation method,logic execution</data>
      <data key="d9">chunk-3878dd58bdab1629f78e313f678153cc</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467531</data>
    </edge>
    <edge source="Logic Gate Circuit" target="Arithmetic Operation">
      <data key="d6">1.0</data>
      <data key="d7">Arithmetic operations are implemented on logic gate circuits using binary codes and logical rules.</data>
      <data key="d8">computational implementation,operation execution</data>
      <data key="d9">chunk-3878dd58bdab1629f78e313f678153cc</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467529</data>
    </edge>
    <edge source="Overflow Detection Method" target="Three Methods for Overflow Detection">
      <data key="d6">1.0</data>
      <data key="d7">The Overflow Detection Method encompasses three distinct techniques: one-sign-bit, dual-sign-bit, and carry-based methods.</data>
      <data key="d8">classification</data>
      <data key="d9">chunk-bc20958ae5e844428623c62227b67c7b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467547</data>
    </edge>
    <edge source="Overflow Detection Method" target="One Sign Bit">
      <data key="d6">1.0</data>
      <data key="d7">The One Sign Bit method is a specific implementation of the Overflow Detection Method based on sign comparison.</data>
      <data key="d8">implementation,technique</data>
      <data key="d9">chunk-bc20958ae5e844428623c62227b67c7b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467547</data>
    </edge>
    <edge source="Overflow Detection Method" target="Dual Sign Bits">
      <data key="d6">2.0</data>
      <data key="d7">The Dual Sign Bits method provides an alternative approach to overflow detection by using two sign bits to detect discrepancies.&lt;SEP&gt;The Dual Sign Bits method is another implementation of the Overflow Detection Method, relying on dual sign bit checking.</data>
      <data key="d8">alternative,implementation,technique</data>
      <data key="d9">chunk-bc20958ae5e844428623c62227b67c7b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467548</data>
    </edge>
    <edge source="Overflow Detection Method" target="Sign Bit and High-Order Carry Comparison">
      <data key="d6">1.0</data>
      <data key="d7">The Sign Bit and High-Order Carry Comparison method is a third implementation of the Overflow Detection Method, using carry analysis.</data>
      <data key="d8">implementation,technique</data>
      <data key="d9">chunk-bc20958ae5e844428623c62227b67c7b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467548</data>
    </edge>
    <edge source="Overflow Detection Method" target="Cn Carry">
      <data key="d6">1.0</data>
      <data key="d7">Cn Carry serves as one of the data inputs used in the overflow detection process.</data>
      <data key="d8">carry signal,data input</data>
      <data key="d9">chunk-bc20958ae5e844428623c62227b67c7b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467549</data>
    </edge>
    <edge source="Overflow Detection Method" target="Cn1 Carry">
      <data key="d6">1.0</data>
      <data key="d7">Cn1 Carry is another critical data input used in determining overflow in arithmetic operations.</data>
      <data key="d8">carry signal,data input</data>
      <data key="d9">chunk-bc20958ae5e844428623c62227b67c7b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467549</data>
    </edge>
    <edge source="Two Numbers with Same Sign Addition" target="One Sign Bit">
      <data key="d6">1.0</data>
      <data key="d7">Overflow is possible when two numbers with the same sign are added, and this method checks for sign inconsistency in the result.</data>
      <data key="d8">condition,trigger</data>
      <data key="d9">chunk-bc20958ae5e844428623c62227b67c7b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467548</data>
    </edge>
    <edge source="Two Numbers with Different Signs Subtraction" target="One Sign Bit">
      <data key="d6">1.0</data>
      <data key="d7">Overflow may occur during subtraction of numbers with different signs, and this method detects such cases by sign mismatch.</data>
      <data key="d8">condition,trigger</data>
      <data key="d9">chunk-bc20958ae5e844428623c62227b67c7b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467548</data>
    </edge>
    <edge source="Dual Sign Bits" target="Mod 4 Complement">
      <data key="d6">1.0</data>
      <data key="d7">Mod 4 Complement is a synonym for the Dual Sign Bits method, used in the context of overflow detection.</data>
      <data key="d8">synonym</data>
      <data key="d9">chunk-bc20958ae5e844428623c62227b67c7b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467548</data>
    </edge>
    <edge source="Sign Bit and High-Order Carry Comparison" target="Cn Carry">
      <data key="d6">1.0</data>
      <data key="d7">The carry from the sign bit (Cn) is examined in relation to the carry from the high-order bit (Cn1) to determine overflow.</data>
      <data key="d8">carry analysis</data>
      <data key="d9">chunk-bc20958ae5e844428623c62227b67c7b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467547</data>
    </edge>
    <edge source="Sign Bit and High-Order Carry Comparison" target="Cn1 Carry">
      <data key="d6">1.0</data>
      <data key="d7">The method evaluates whether the carry from the high-order bit (Cn1) matches the carry from the sign bit (Cn) to detect overflow.</data>
      <data key="d8">carry analysis</data>
      <data key="d9">chunk-bc20958ae5e844428623c62227b67c7b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467547</data>
    </edge>
    <edge source="Type Conversion" target="Word Length Conversion">
      <data key="d6">1.0</data>
      <data key="d7">Type conversion between integers of different word lengths typically begins with word length conversion before final symbol type adjustment.</data>
      <data key="d8">conversion process,preliminary step</data>
      <data key="d9">chunk-eb70606fa9ba73ffc22231992979ee26</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467565</data>
    </edge>
    <edge source="Type Conversion" target="Symbol Conversion">
      <data key="d6">1.0</data>
      <data key="d7">Type conversion in C Language includes symbol conversion, which involves reinterpreting the bit pattern when changing between signed and unsigned integer types.</data>
      <data key="d8">conversion process,data interpretation</data>
      <data key="d9">chunk-eb70606fa9ba73ffc22231992979ee26</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467566</data>
    </edge>
    <edge source="Type Conversion" target="Implicit Type Conversion">
      <data key="d6">1.0</data>
      <data key="d7">Implicit type conversion is a subset of type conversion where the system automatically performs the conversion without explicit user intervention.</data>
      <data key="d8">automatic processing,form of conversion</data>
      <data key="d9">chunk-7661b58ae4a51d1ee96186ef15ec5292</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467757</data>
    </edge>
    <edge source="Word Length Conversion" target="High-Bit Extension">
      <data key="d6">1.0</data>
      <data key="d7">In word length conversion, high-bit extension is used when increasing the bit width, based on whether the number is signed or unsigned.</data>
      <data key="d8">bit expansion,conversion process</data>
      <data key="d9">chunk-eb70606fa9ba73ffc22231992979ee26</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467564</data>
    </edge>
    <edge source="Word Length Conversion" target="Low-Bit Truncation">
      <data key="d6">1.0</data>
      <data key="d7">In word length conversion, low-bit truncation is applied when decreasing the bit width, by keeping only the lower bits.</data>
      <data key="d8">conversion process,data reduction</data>
      <data key="d9">chunk-eb70606fa9ba73ffc22231992979ee26</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467565</data>
    </edge>
    <edge source="Char Type" target="Int Type">
      <data key="d6">2.0</data>
      <data key="d7">The char type, being an 8-bit unsigned integer, is converted to int type by zero-extending the higher bits.&lt;SEP&gt;During type conversion in C, char type is automatically promoted to int type, which is part of the standard integral type hierarchy.</data>
      <data key="d8">data promotion,implicit conversion,type conversion,type promotion</data>
      <data key="d9">chunk-eb70606fa9ba73ffc22231992979ee26&lt;SEP&gt;chunk-7661b58ae4a51d1ee96186ef15ec5292</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467758</data>
    </edge>
    <edge source="Int Type" target="Most Significant Byte">
      <data key="d6">1.0</data>
      <data key="d7">In a 32-bit int, the most significant byte is located at the highest memory address in little endian and the lowest in big endian.</data>
      <data key="d8">byte location,data structure</data>
      <data key="d9">chunk-09b53b0df067c5056104774d13e5e395</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467715</data>
    </edge>
    <edge source="Int Type" target="Least Significant Byte">
      <data key="d6">1.0</data>
      <data key="d7">In a 32-bit int, the least significant byte is located at the lowest memory address in little endian and the highest in big endian.</data>
      <data key="d8">byte location,data structure</data>
      <data key="d9">chunk-09b53b0df067c5056104774d13e5e395</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467717</data>
    </edge>
    <edge source="Int Type" target="Long Type">
      <data key="d6">1.0</data>
      <data key="d7">When int and long types are involved in an operation, the int type is promoted to long type to preserve precision and avoid overflow.</data>
      <data key="d8">range expansion,type promotion</data>
      <data key="d9">chunk-7661b58ae4a51d1ee96186ef15ec5292</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467759</data>
    </edge>
    <edge source="Int Type" target="Float Type">
      <data key="d6">2.0</data>
      <data key="d7">When int type is converted to float, precision loss may occur if the number has more than 24 effective bits, requiring rounding.&lt;SEP&gt;When float is converted to int, the fractional part is truncated, and overflow may occur if the value exceeds int range.</data>
      <data key="d8">data truncation,precision loss,range limitations,type conversion behavior</data>
      <data key="d9">chunk-7661b58ae4a51d1ee96186ef15ec5292</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467759</data>
    </edge>
    <edge source="Int Type" target="Double Type">
      <data key="d6">1.0</data>
      <data key="d7">When double is converted to int, the fractional part is discarded, and overflow is possible for very large values.</data>
      <data key="d8">data truncation,range limitations</data>
      <data key="d9">chunk-7661b58ae4a51d1ee96186ef15ec5292</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467760</data>
    </edge>
    <edge source="16-Bit Integer" target="32-Bit Integer">
      <data key="d6">1.0</data>
      <data key="d7">A 16-bit integer can be converted to a 32-bit integer by extending higher bits using zero or sign extension.</data>
      <data key="d8">extension,word length conversion</data>
      <data key="d9">chunk-eb70606fa9ba73ffc22231992979ee26</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467564</data>
    </edge>
    <edge source="Floating Point Addition and Subtraction" target="Exponent Alignment">
      <data key="d6">1.0</data>
      <data key="d7">Floating point addition and subtraction begins with exponent alignment to synchronize the scale of the operands.</data>
      <data key="d8">phase,step</data>
      <data key="d9">chunk-b661f934d6911328f3c940a7306bdabc</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467587</data>
    </edge>
    <edge source="Floating Point Addition and Subtraction" target="Mantissa Addition and Subtraction">
      <data key="d6">1.0</data>
      <data key="d7">After alignment, mantissa addition or subtraction is performed using fixed-point rules with restoration of the hidden bit.</data>
      <data key="d8">phase,step</data>
      <data key="d9">chunk-b661f934d6911328f3c940a7306bdabc</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467587</data>
    </edge>
    <edge source="Floating Point Addition and Subtraction" target="Mantissa Normalization">
      <data key="d6">1.0</data>
      <data key="d7">Following arithmetic, the result must be normalized to ensure the leading bit is 1 and the representation is standard.</data>
      <data key="d8">phase,step</data>
      <data key="d9">chunk-b661f934d6911328f3c940a7306bdabc</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467587</data>
    </edge>
    <edge source="Floating Point Addition and Subtraction" target="Rounding">
      <data key="d6">1.0</data>
      <data key="d7">Rounding is applied after normalization to reduce the precision to the target format, using one of the IEEE 754 modes.</data>
      <data key="d8">phase,step</data>
      <data key="d9">chunk-b661f934d6911328f3c940a7306bdabc</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467589</data>
    </edge>
    <edge source="Floating Point Addition and Subtraction" target="Exponent Overflow Check">
      <data key="d6">1.0</data>
      <data key="d7">A final check is performed to detect exponent overflow after normalization and rounding.</data>
      <data key="d8">phase,step</data>
      <data key="d9">chunk-b661f934d6911328f3c940a7306bdabc</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467590</data>
    </edge>
    <edge source="Floating Point Addition and Subtraction" target="Exponent Underflow">
      <data key="d6">1.0</data>
      <data key="d7">Exponent underflow is detected during the process and handled by treating the result as machine zero.</data>
      <data key="d8">phase,step</data>
      <data key="d9">chunk-b661f934d6911328f3c940a7306bdabc</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467590</data>
    </edge>
    <edge source="Exponent Alignment" target="Exponent Difference">
      <data key="d6">1.0</data>
      <data key="d7">The exponent difference is calculated to determine how much mantissa adjustment is needed during alignment.</data>
      <data key="d8">computation input</data>
      <data key="d9">chunk-b661f934d6911328f3c940a7306bdabc</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467587</data>
    </edge>
    <edge source="Exponent Alignment" target="Hidden Bit">
      <data key="d6">1.0</data>
      <data key="d7">During exponent alignment, the hidden bit must be preserved in the mantissa to prevent precision loss.</data>
      <data key="d8">impact,preservation</data>
      <data key="d9">chunk-b661f934d6911328f3c940a7306bdabc</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467588</data>
    </edge>
    <edge source="Exponent Alignment" target="Right Shift">
      <data key="d6">1.0</data>
      <data key="d7">Exponent alignment uses right shift to adjust the mantissa of the smaller exponent to align with the larger one.</data>
      <data key="d8">alignment mechanism,operation</data>
      <data key="d9">chunk-b661f934d6911328f3c940a7306bdabc</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467588</data>
    </edge>
    <edge source="Exponent Alignment" target="Left Shift">
      <data key="d6">1.0</data>
      <data key="d7">Left shift is an incorrect approach when aligning exponents, as it causes the loss of leading bits and results in error.</data>
      <data key="d8">error source,inefficient method</data>
      <data key="d9">chunk-b661f934d6911328f3c940a7306bdabc</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467589</data>
    </edge>
    <edge source="Mantissa Addition and Subtraction" target="Hidden Bit">
      <data key="d6">1.0</data>
      <data key="d7">The hidden bit must be restored during addition/subtraction to ensure full mantissa accuracy.</data>
      <data key="d8">normalization support,required input</data>
      <data key="d9">chunk-b661f934d6911328f3c940a7306bdabc</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467587</data>
    </edge>
    <edge source="Mantissa Addition and Subtraction" target="Suppressed Bits">
      <data key="d6">1.0</data>
      <data key="d7">Suppressed bits are retained during mantissa operations to maintain accuracy and are used in intermediate steps.</data>
      <data key="d8">input preservation,precision maintenance</data>
      <data key="d9">chunk-b661f934d6911328f3c940a7306bdabc</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467589</data>
    </edge>
    <edge source="Rounding" target="Round to Nearest">
      <data key="d6">1.0</data>
      <data key="d7">Round to nearest is one of four IEEE 754 rounding modes used during the final step of processing.</data>
      <data key="d8">mode selection</data>
      <data key="d9">chunk-b661f934d6911328f3c940a7306bdabc</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467587</data>
    </edge>
    <edge source="Rounding" target="Round Toward Positive Infinity">
      <data key="d6">1.0</data>
      <data key="d7">Round toward positive infinity is one of four IEEE 754 rounding modes applied to adjust final results.</data>
      <data key="d8">mode selection</data>
      <data key="d9">chunk-b661f934d6911328f3c940a7306bdabc</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467588</data>
    </edge>
    <edge source="Rounding" target="Round Toward Negative Infinity">
      <data key="d6">1.0</data>
      <data key="d7">Round toward negative infinity is one of four IEEE 754 rounding modes used to manage rounding direction.</data>
      <data key="d8">mode selection</data>
      <data key="d9">chunk-b661f934d6911328f3c940a7306bdabc</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467589</data>
    </edge>
    <edge source="Rounding" target="Truncate">
      <data key="d6">1.0</data>
      <data key="d7">Truncate is a simple IEEE 754 rounding mode that discards lower bits without adjustment.</data>
      <data key="d8">mode selection</data>
      <data key="d9">chunk-b661f934d6911328f3c940a7306bdabc</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467589</data>
    </edge>
    <edge source="Rounding" target="Suppressed Bits">
      <data key="d6">1.0</data>
      <data key="d7">The suppressed bits are used during rounding to ensure the final result maintains as much accuracy as possible.</data>
      <data key="d8">final handling,precision restoration</data>
      <data key="d9">chunk-b661f934d6911328f3c940a7306bdabc</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467590</data>
    </edge>
    <edge source="Exponent Overflow Check" target="Exponent Underflow">
      <data key="d6">1.0</data>
      <data key="d7">Both exponent overflow and underflow are checked to identify extreme exponent values during processing.</data>
      <data key="d8">dual condition detection</data>
      <data key="d9">chunk-b661f934d6911328f3c940a7306bdabc</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467590</data>
    </edge>
    <edge source="Hidden Bit" target="IEEE754">
      <data key="d6">1.0</data>
      <data key="d7">In IEEE754, the hidden bit is an implied leading bit not stored in the mantissa but assumed to be 1 for normalized numbers.</data>
      <data key="d8">bit representation,normalized numbers</data>
      <data key="d9">chunk-7661b58ae4a51d1ee96186ef15ec5292</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467759</data>
    </edge>
    <edge source="Right Shift" target="Intermediate Remainder">
      <data key="d6">1.0</data>
      <data key="d7">The intermediate remainder is used as input to the right shift operation in the next step.</data>
      <data key="d8">data manipulation,iterative process step</data>
      <data key="d9">chunk-ac11d99928fbdb7cf8188b4d1e45043f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467610</data>
    </edge>
    <edge source="Division Operation" target="Original Code Division">
      <data key="d6">1.0</data>
      <data key="d7">Original code division is a type of division operation involving iterative shift and add/subtract operations.</data>
      <data key="d8">algorithm similarity,computational process</data>
      <data key="d9">chunk-ac11d99928fbdb7cf8188b4d1e45043f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467609</data>
    </edge>
    <edge source="Division Operation" target="Hand Calculation Steps">
      <data key="d6">1.0</data>
      <data key="d7">Hand calculation steps are used to implement the division operation manually.</data>
      <data key="d8">algorithm detail,manual implementation</data>
      <data key="d9">chunk-ac11d99928fbdb7cf8188b4d1e45043f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467610</data>
    </edge>
    <edge source="Division Operation" target="Quotient Bit">
      <data key="d6">1.0</data>
      <data key="d7">Each quotient bit is generated during an iteration of the division operation based on subtraction results.</data>
      <data key="d8">output bit,quotient generation</data>
      <data key="d9">chunk-ac11d99928fbdb7cf8188b4d1e45043f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467611</data>
    </edge>
    <edge source="Division Operation" target="Iteration Process">
      <data key="d6">1.0</data>
      <data key="d7">The iteration process is a key structural element in the division operation, enabling bit-by-bit quotient construction.</data>
      <data key="d8">computational phase,repetition mechanism</data>
      <data key="d9">chunk-ac11d99928fbdb7cf8188b4d1e45043f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467612</data>
    </edge>
    <edge source="Fixed-Point Number" target="2n-Bit Number">
      <data key="d6">1.0</data>
      <data key="d7">A fixed-point number is represented as a 2n-bit number during division operations to accommodate the dividend size.</data>
      <data key="d8">data representation,size requirement</data>
      <data key="d9">chunk-ac11d99928fbdb7cf8188b4d1e45043f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467609</data>
    </edge>
    <edge source="Fixed-Point Number" target="n-Bit Number">
      <data key="d6">1.0</data>
      <data key="d7">A fixed-point number is divided by an n-bit number to yield an n-bit quotient.</data>
      <data key="d8">data representation,operand size</data>
      <data key="d9">chunk-ac11d99928fbdb7cf8188b4d1e45043f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467610</data>
    </edge>
    <edge source="Fixed-Point Number" target="Floating Point Representation">
      <data key="d6">1.0</data>
      <data key="d7">Fixed-point number representation is less flexible than floating point representation for handling a wide range of magnitudes.</data>
      <data key="d8">comparison,representation method</data>
      <data key="d9">chunk-5ea05d0aadedcb24741fd320a2b9543c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467680</data>
    </edge>
    <edge source="2n-Bit Number" target="n-Bit Quotient">
      <data key="d6">1.0</data>
      <data key="d7">A 2n-bit number divided by an n-bit number produces an n-bit quotient.</data>
      <data key="d8">arithmetic outcome,result relation</data>
      <data key="d9">chunk-ac11d99928fbdb7cf8188b4d1e45043f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467610</data>
    </edge>
    <edge source="Dividend Extension" target="Fixed-Point Positive Fraction">
      <data key="d6">1.0</data>
      <data key="d7">In fixed-point positive fractions, the dividend is extended by adding n zeros to the low end.</data>
      <data key="d8">bit expansion,operand preparation</data>
      <data key="d9">chunk-ac11d99928fbdb7cf8188b4d1e45043f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467609</data>
    </edge>
    <edge source="Dividend Extension" target="Fixed-Point Positive Integer">
      <data key="d6">1.0</data>
      <data key="d7">In fixed-point positive integers, the dividend is extended by adding n zeros to the high end.</data>
      <data key="d8">bit expansion,operand preparation</data>
      <data key="d9">chunk-ac11d99928fbdb7cf8188b4d1e45043f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467610</data>
    </edge>
    <edge source="Zero Division Exception" target="Operating System Exception Handler">
      <data key="d6">1.0</data>
      <data key="d7">When a zero division occurs, the operating system invokes its exception handler to manage the error.</data>
      <data key="d8">error handling,system response</data>
      <data key="d9">chunk-ac11d99928fbdb7cf8188b4d1e45043f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467609</data>
    </edge>
    <edge source="Hand Calculation Steps" target="Iteration Process">
      <data key="d6">1.0</data>
      <data key="d7">The iteration process is a core component of the hand calculation steps used in manual division.</data>
      <data key="d8">algorithmic phase,procedural flow</data>
      <data key="d9">chunk-ac11d99928fbdb7cf8188b4d1e45043f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467611</data>
    </edge>
    <edge source="Intermediate Remainder" target="Subtraction Step">
      <data key="d6">1.0</data>
      <data key="d7">The intermediate remainder is the input operand used in the subtraction step of each iteration.</data>
      <data key="d8">data input,operation execution</data>
      <data key="d9">chunk-ac11d99928fbdb7cf8188b4d1e45043f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467611</data>
    </edge>
    <edge source="Subtraction Step" target="Comparison Step">
      <data key="d6">1.0</data>
      <data key="d7">The comparison step follows the subtraction step to evaluate whether a successful subtraction occurred in the prior step.</data>
      <data key="d8">decision point,sequential logic</data>
      <data key="d9">chunk-ac11d99928fbdb7cf8188b4d1e45043f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467610</data>
    </edge>
    <edge source="ZF" target="A">
      <data key="d6">2.0</data>
      <data key="d7">When ZF=1, it indicates that A equals B, signifying no difference in value after subtraction.&lt;SEP&gt;When ZF=1, it confirms that A and B are equal.</data>
      <data key="d8">comparison condition,equality assessment,equality check</data>
      <data key="d9">chunk-1bf253441ffd1d27c8127187db5ecb32</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467623</data>
    </edge>
    <edge source="ZF" target="Result">
      <data key="d6">1.0</data>
      <data key="d7">If ZF=1, the result is zero, meaning A equals B.</data>
      <data key="d8">zero detection</data>
      <data key="d9">chunk-1bf253441ffd1d27c8127187db5ecb32</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467624</data>
    </edge>
    <edge source="ZF" target="Comparison of Signed Numbers">
      <data key="d6">1.0</data>
      <data key="d7">ZF is used in the comparison to determine if A equals B.</data>
      <data key="d8">condition indicator,equality test</data>
      <data key="d9">chunk-1bf253441ffd1d27c8127187db5ecb32</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467624</data>
    </edge>
    <edge source="OF" target="Result">
      <data key="d6">1.0</data>
      <data key="d7">If OF=1, the operation has overflowed, requiring special interpretation of the sign flag.</data>
      <data key="d8">arithmetic boundary,overflow detection</data>
      <data key="d9">chunk-1bf253441ffd1d27c8127187db5ecb32</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467624</data>
    </edge>
    <edge source="OF" target="A">
      <data key="d6">1.0</data>
      <data key="d7">When OF=1 during the subtraction of A and B, it indicates an overflow has occurred, affecting the validity of the sign flag SF.</data>
      <data key="d8">overflow condition,sign ambiguity</data>
      <data key="d9">chunk-1bf253441ffd1d27c8127187db5ecb32</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467625</data>
    </edge>
    <edge source="OF" target="SF">
      <data key="d6">1.0</data>
      <data key="d7">The relationship between OF and SF determines whether the comparison result is valid or inverted due to overflow.</data>
      <data key="d8">flag correlation,sign overflow logic</data>
      <data key="d9">chunk-1bf253441ffd1d27c8127187db5ecb32</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467625</data>
    </edge>
    <edge source="OF" target="Comparison of Signed Numbers">
      <data key="d6">1.0</data>
      <data key="d7">OF is crucial for correcting sign interpretation when overflow occurs.</data>
      <data key="d8">logical correction,overflow detection</data>
      <data key="d9">chunk-1bf253441ffd1d27c8127187db5ecb32</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467625</data>
    </edge>
    <edge source="SF" target="Result">
      <data key="d6">1.0</data>
      <data key="d7">If SF=1, the result is negative; if SF=0, the result is non-negative.</data>
      <data key="d8">sign determination,sign indication</data>
      <data key="d9">chunk-1bf253441ffd1d27c8127187db5ecb32</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467625</data>
    </edge>
    <edge source="SF" target="A">
      <data key="d6">1.0</data>
      <data key="d7">When SF=0, it indicates the result of A minus B is non-negative; when SF=1, it indicates the result is negative.</data>
      <data key="d8">result sign determination,sign analysis</data>
      <data key="d9">chunk-1bf253441ffd1d27c8127187db5ecb32</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467625</data>
    </edge>
    <edge source="SF" target="Comparison of Signed Numbers">
      <data key="d6">1.0</data>
      <data key="d7">SF helps interpret the sign of the result, but its meaning must be adjusted when OF=1.</data>
      <data key="d8">result interpretation,sign flag</data>
      <data key="d9">chunk-1bf253441ffd1d27c8127187db5ecb32</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467626</data>
    </edge>
    <edge source="A" target="B">
      <data key="d6">1.0</data>
      <data key="d7">A and B are compared using the subtraction [A] - [B] and the resulting flags ZF, OF, and SF to determine whether A &gt; B or A &lt; B.</data>
      <data key="d8">comparison operation,signed number analysis</data>
      <data key="d9">chunk-1bf253441ffd1d27c8127187db5ecb32</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467626</data>
    </edge>
    <edge source="A" target="Result Zero Case">
      <data key="d6">1.0</data>
      <data key="d7">When the result of A-B is zero, it implies that A equals B.</data>
      <data key="d8">equality condition</data>
      <data key="d9">chunk-ba5ba3047ff33c33c3e78b969b12b98e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467690</data>
    </edge>
    <edge source="A" target="Result Non-Zero No Borrow Case">
      <data key="d6">1.0</data>
      <data key="d7">When the result of A-B is non-zero with no borrow, it indicates that A is greater than B.</data>
      <data key="d8">greater-than condition</data>
      <data key="d9">chunk-ba5ba3047ff33c33c3e78b969b12b98e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467691</data>
    </edge>
    <edge source="A" target="Result Non-Zero With Borrow Case">
      <data key="d6">1.0</data>
      <data key="d7">When the result of A-B includes a borrow, it implies that A is less than B.</data>
      <data key="d8">less-than condition</data>
      <data key="d9">chunk-ba5ba3047ff33c33c3e78b969b12b98e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467692</data>
    </edge>
    <edge source="B" target="Result Zero Case">
      <data key="d6">1.0</data>
      <data key="d7">When the result of A-B is zero, it confirms that B equals A.</data>
      <data key="d8">equality condition</data>
      <data key="d9">chunk-ba5ba3047ff33c33c3e78b969b12b98e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467691</data>
    </edge>
    <edge source="B" target="Result Non-Zero No Borrow Case">
      <data key="d6">1.0</data>
      <data key="d7">When A-B yields no borrow and non-zero result, B is less than A.</data>
      <data key="d8">greater-than condition</data>
      <data key="d9">chunk-ba5ba3047ff33c33c3e78b969b12b98e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467692</data>
    </edge>
    <edge source="B" target="Result Non-Zero With Borrow Case">
      <data key="d6">1.0</data>
      <data key="d7">When a borrow occurs in A-B, B exceeds A in value.</data>
      <data key="d8">less-than condition</data>
      <data key="d9">chunk-ba5ba3047ff33c33c3e78b969b12b98e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467692</data>
    </edge>
    <edge source="原码乘法" target="数值位">
      <data key="d6">1.0</data>
      <data key="d7">原码乘法中乘积的数值位由两个乘数的绝对值相乘得到。</data>
      <data key="d8">magnitude computation,operation component</data>
      <data key="d9">chunk-8b64d30374af75767b82b53c5d492c80</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467636</data>
    </edge>
    <edge source="原码乘法" target="绝对值">
      <data key="d6">1.0</data>
      <data key="d7">原码乘法运算中，两个乘数的数值部分均需取绝对值后参与运算。</data>
      <data key="d8">input transformation,operand requirement</data>
      <data key="d9">chunk-8b64d30374af75767b82b53c5d492c80</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467637</data>
    </edge>
    <edge source="原码乘法" target="部分积">
      <data key="d6">1.0</data>
      <data key="d7">部分积作为原码乘法过程中的中间结果，从0开始，通过n次加法和右移逐步更新。</data>
      <data key="d8">intermediate result,iterative accumulation</data>
      <data key="d9">chunk-8b64d30374af75767b82b53c5d492c80</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467637</data>
    </edge>
    <edge source="数值位" target="最高数值位">
      <data key="d6">1.0</data>
      <data key="d7">最高数值位是数值位中的最高位，其运算结果影响溢出判断。</data>
      <data key="d8">computation boundary,digit position</data>
      <data key="d9">chunk-ea2c16caf28ea549ed420e26afbca237</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467787</data>
    </edge>
    <edge source="数值位" target="加法规则">
      <data key="d6">1.0</data>
      <data key="d7">加法规则需要对数值位进行加法运算，取决于符号位状态。</data>
      <data key="d8">arithmetic process,numeric computation</data>
      <data key="d9">chunk-ea2c16caf28ea549ed420e26afbca237</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467788</data>
    </edge>
    <edge source="部分积" target="逻辑右移">
      <data key="d6">1.0</data>
      <data key="d7">每一轮运算中，部分积在加法后进行逻辑右移一位。</data>
      <data key="d8">bit shift operation,computation step</data>
      <data key="d9">chunk-8b64d30374af75767b82b53c5d492c80</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467635</data>
    </edge>
    <edge source="移位运算" target="n位无符号数">
      <data key="d6">1.0</data>
      <data key="d7">两个n位无符号数相乘需要进行n次移位运算。</data>
      <data key="d8">arithmetic process,computational operation</data>
      <data key="d9">chunk-8b64d30374af75767b82b53c5d492c80</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467637</data>
    </edge>
    <edge source="X" target="P">
      <data key="d6">1.0</data>
      <data key="d7">The partial product P is updated by adding X multiplied by the current bit y-i during each iteration of the multiplication.</data>
      <data key="d8">multiplication step,partial product</data>
      <data key="d9">chunk-8b64d30374af75767b82b53c5d492c80</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467636</data>
    </edge>
    <edge source="X" target="y-i">
      <data key="d6">1.0</data>
      <data key="d7">X is multiplied by the current bit y-i of the multiplier to contribute to the partial product in the multiplication algorithm.</data>
      <data key="d8">multiplicand,multiplier bit</data>
      <data key="d9">chunk-8b64d30374af75767b82b53c5d492c80</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467638</data>
    </edge>
    <edge source="X" target="加减运算电路">
      <data key="d6">1.0</data>
      <data key="d7">X is an input operand to the adder in the加减运算电路.</data>
      <data key="d8">data handling,operand input</data>
      <data key="d9">chunk-278906376b45ec28050699d283cb1aeb</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467754</data>
    </edge>
    <edge source="y-i" target="P">
      <data key="d6">1.0</data>
      <data key="d7">The value of the bit y-i determines whether X is added to the partial product P in that step of the algorithm.</data>
      <data key="d8">bit-wise control,partial product</data>
      <data key="d9">chunk-8b64d30374af75767b82b53c5d492c80</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467637</data>
    </edge>
    <edge source="Binary Number" target="Octal Number">
      <data key="d6">1.0</data>
      <data key="d7">Binary numbers can be converted to octal by grouping bits into sets of three and replacing each group with its octal equivalent.</data>
      <data key="d8">conversion method,grouping by three</data>
      <data key="d9">chunk-9a74c12334c1c89b7dc2a0d69025220d</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467656</data>
    </edge>
    <edge source="Binary Number" target="Hexadecimal Number">
      <data key="d6">1.0</data>
      <data key="d7">Binary numbers can be converted to hexadecimal by grouping bits into sets of four and replacing each group with its hexadecimal equivalent.</data>
      <data key="d8">conversion method,grouping by four</data>
      <data key="d9">chunk-9a74c12334c1c89b7dc2a0d69025220d</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467657</data>
    </edge>
    <edge source="Binary Number" target="Binary Point">
      <data key="d6">1.0</data>
      <data key="d7">The binary point is used to separate the integer and fractional parts in binary numbers.</data>
      <data key="d8">digit separator,number structure</data>
      <data key="d9">chunk-9a74c12334c1c89b7dc2a0d69025220d</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467658</data>
    </edge>
    <edge source="Binary Number" target="Positional Weight">
      <data key="d6">1.0</data>
      <data key="d7">Each digit in a binary number has a value based on its position, determined by the positional weight of the digit.</data>
      <data key="d8">digit value,numerical representation</data>
      <data key="d9">chunk-9a74c12334c1c89b7dc2a0d69025220d</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467658</data>
    </edge>
    <edge source="Decimal Number" target="Any Base Number">
      <data key="d6">1.0</data>
      <data key="d7">Any base number can be converted to decimal using the power expansion addition method, which multiplies each digit by its positional weight and sums the results.</data>
      <data key="d8">conversion method,power expansion addition</data>
      <data key="d9">chunk-9a74c12334c1c89b7dc2a0d69025220d</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467656</data>
    </edge>
    <edge source="Decimal Number" target="Integer Part">
      <data key="d6">1.0</data>
      <data key="d7">The integer part of a decimal number is processed separately during conversion to another base using division by base method.</data>
      <data key="d8">number component,processing segment</data>
      <data key="d9">chunk-9a74c12334c1c89b7dc2a0d69025220d</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467658</data>
    </edge>
    <edge source="Decimal Number" target="Fractional Part">
      <data key="d6">1.0</data>
      <data key="d7">The fractional part of a decimal number is processed separately during conversion to another base using multiplication by base method.</data>
      <data key="d8">number component,processing segment</data>
      <data key="d9">chunk-9a74c12334c1c89b7dc2a0d69025220d</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467658</data>
    </edge>
    <edge source="Decimal Number" target="Base Multiplication Division Method">
      <data key="d6">1.0</data>
      <data key="d7">The base multiplication division method is used to convert decimal numbers to any base by applying division to the integer part and multiplication to the fractional part.</data>
      <data key="d8">conversion strategy,systematic approach</data>
      <data key="d9">chunk-9a74c12334c1c89b7dc2a0d69025220d</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467658</data>
    </edge>
    <edge source="Integer Part" target="Division By Base Method">
      <data key="d6">1.0</data>
      <data key="d7">The division by base method is applied to the integer part of a decimal number to convert it to another base.</data>
      <data key="d8">conversion technique,integer handling</data>
      <data key="d9">chunk-9a74c12334c1c89b7dc2a0d69025220d</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467657</data>
    </edge>
    <edge source="Fractional Part" target="Multiplication By Base Method">
      <data key="d6">1.0</data>
      <data key="d7">The multiplication by base method is applied to the fractional part of a decimal number to convert it to another base.</data>
      <data key="d8">conversion technique,fraction handling</data>
      <data key="d9">chunk-9a74c12334c1c89b7dc2a0d69025220d</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467657</data>
    </edge>
    <edge source="Floating Point Representation" target="Sign">
      <data key="d6">1.0</data>
      <data key="d7">The floating point representation consists of a sign bit to indicate positive or negative value.</data>
      <data key="d8">component structure</data>
      <data key="d9">chunk-5ea05d0aadedcb24741fd320a2b9543c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467677</data>
    </edge>
    <edge source="Floating Point Representation" target="Electronic Mass">
      <data key="d6">1.0</data>
      <data key="d7">Electronic mass is commonly represented using floating point notation due to its extreme magnitude.</data>
      <data key="d8">data representation</data>
      <data key="d9">chunk-5ea05d0aadedcb24741fd320a2b9543c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467679</data>
    </edge>
    <edge source="Floating Point Representation" target="Solar Mass">
      <data key="d6">1.0</data>
      <data key="d7">Solar mass is often represented using floating point format to handle its large scale effectively.</data>
      <data key="d8">data representation</data>
      <data key="d9">chunk-5ea05d0aadedcb24741fd320a2b9543c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467680</data>
    </edge>
    <edge source="Positive Underflow" target="Underflow">
      <data key="d6">1.0</data>
      <data key="d7">Positive underflow is a specific case of the general underflow condition in floating point arithmetic.</data>
      <data key="d8">underflow condition</data>
      <data key="d9">chunk-5ea05d0aadedcb24741fd320a2b9543c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467677</data>
    </edge>
    <edge source="Negative Underflow" target="Underflow">
      <data key="d6">1.0</data>
      <data key="d7">Negative underflow is a specific case of the general underflow condition in floating point arithmetic.</data>
      <data key="d8">underflow condition</data>
      <data key="d9">chunk-5ea05d0aadedcb24741fd320a2b9543c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467678</data>
    </edge>
    <edge source="Underflow" target="Machine Zero">
      <data key="d6">1.0</data>
      <data key="d7">When underflow occurs, the result is treated as machine zero.</data>
      <data key="d8">result handling</data>
      <data key="d9">chunk-5ea05d0aadedcb24741fd320a2b9543c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467678</data>
    </edge>
    <edge source="Unsigned Number Comparison" target="Carry Borrow Flag">
      <data key="d6">1.0</data>
      <data key="d7">The value of Carry Borrow Flag (CF) is evaluated during unsigned number comparison to detect borrowing during subtraction.</data>
      <data key="d8">flag evaluation,logical condition</data>
      <data key="d9">chunk-ba5ba3047ff33c33c3e78b969b12b98e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467690</data>
    </edge>
    <edge source="Carry Borrow Flag" target="A Less Than B">
      <data key="d6">1.0</data>
      <data key="d7">When CF is set to 1, it indicates that A is less than B.</data>
      <data key="d8">flag state,outcome indicator</data>
      <data key="d9">chunk-ba5ba3047ff33c33c3e78b969b12b98e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467691</data>
    </edge>
    <edge source="A-B Operation" target="Result Zero Case">
      <data key="d6">1.0</data>
      <data key="d7">The A-B operation leads to the Result Zero Case when A equals B, indicating equality.</data>
      <data key="d8">conditional outcome,equality test</data>
      <data key="d9">chunk-ba5ba3047ff33c33c3e78b969b12b98e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467689</data>
    </edge>
    <edge source="A-B Operation" target="Result Non-Zero No Borrow Case">
      <data key="d6">1.0</data>
      <data key="d7">The A-B operation results in non-zero with no borrow, indicating A is greater than B.</data>
      <data key="d8">conditional outcome,greater-than test</data>
      <data key="d9">chunk-ba5ba3047ff33c33c3e78b969b12b98e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467690</data>
    </edge>
    <edge source="A-B Operation" target="Result Non-Zero With Borrow Case">
      <data key="d6">1.0</data>
      <data key="d7">The A-B operation produces a non-zero result with borrow, indicating A is less than B.</data>
      <data key="d8">conditional outcome,less-than test</data>
      <data key="d9">chunk-ba5ba3047ff33c33c3e78b969b12b98e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467691</data>
    </edge>
    <edge source="Data Endianness" target="Big Endian">
      <data key="d6">1.0</data>
      <data key="d7">Big endian is a specific implementation of data endianness where the most significant byte is stored first.</data>
      <data key="d8">byte ordering,data representation</data>
      <data key="d9">chunk-09b53b0df067c5056104774d13e5e395</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467715</data>
    </edge>
    <edge source="Data Endianness" target="Little Endian">
      <data key="d6">1.0</data>
      <data key="d7">Little endian is a specific implementation of data endianness where the least significant byte is stored first.</data>
      <data key="d8">byte ordering,data representation</data>
      <data key="d9">chunk-09b53b0df067c5056104774d13e5e395</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467717</data>
    </edge>
    <edge source="32-Bit Computer" target="Memory Address">
      <data key="d6">1.0</data>
      <data key="d7">In a 32-bit computer, memory is byte-addressed, and each address holds one byte.</data>
      <data key="d8">addressing scheme,memory architecture</data>
      <data key="d9">chunk-09b53b0df067c5056104774d13e5e395</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467715</data>
    </edge>
    <edge source="Float Type" target="IEEE754">
      <data key="d6">1.0</data>
      <data key="d7">The float type implements the IEEE754 single-precision floating-point standard with a 24-bit mantissa including the hidden bit.</data>
      <data key="d8">format specification,standard compliance</data>
      <data key="d9">chunk-7661b58ae4a51d1ee96186ef15ec5292</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467758</data>
    </edge>
    <edge source="Float Type" target="Double Type">
      <data key="d6">3.0</data>
      <data key="d7">When float and double types are used together, float is promoted to double due to higher precision, and the result is double.&lt;SEP&gt;When double is converted to float, risk of overflow and rounding errors arises due to reduced precision and range.&lt;SEP&gt;When float is converted to double, the value is preserved with higher precision because double has more bits.</data>
      <data key="d8">conversion,overflow risk,precision comparison,precision loss,precision preservation</data>
      <data key="d9">chunk-7661b58ae4a51d1ee96186ef15ec5292</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467760</data>
    </edge>
    <edge source="Double Type" target="IEEE754">
      <data key="d6">1.0</data>
      <data key="d7">The double type implements the IEEE754 double-precision floating-point standard with a 53-bit mantissa including the hidden bit.</data>
      <data key="d8">format specification,standard compliance</data>
      <data key="d9">chunk-7661b58ae4a51d1ee96186ef15ec5292</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467757</data>
    </edge>
    <edge source="Memory Address" target="Boundary Alignment">
      <data key="d6">1.0</data>
      <data key="d7">Boundary alignment ensures that data is stored at memory addresses that are multiples of their size, enabling single-visit access.</data>
      <data key="d8">data storage,memory access efficiency</data>
      <data key="d9">chunk-09b53b0df067c5056104774d13e5e395</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467717</data>
    </edge>
    <edge source="Boundary Alignment" target="Padding Bytes">
      <data key="d6">1.0</data>
      <data key="d7">Padding bytes are inserted to satisfy boundary alignment requirements, even though they consume extra storage space.</data>
      <data key="d8">memory optimization,space efficiency</data>
      <data key="d9">chunk-09b53b0df067c5056104774d13e5e395</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467718</data>
    </edge>
    <edge source="Boundary Alignment" target="RISC">
      <data key="d6">1.0</data>
      <data key="d7">RISC processors typically use boundary alignment to allow consistent and fast instruction fetch, enabling efficient instruction pipelining.</data>
      <data key="d8">instruction efficiency,processor design</data>
      <data key="d9">chunk-09b53b0df067c5056104774d13e5e395</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467719</data>
    </edge>
    <edge source="Boundary Alignment" target="Halfword Address">
      <data key="d6">1.0</data>
      <data key="d7">Boundary alignment requires that halfword-sized data be stored at addresses that are multiples of 2.</data>
      <data key="d8">addressing rule,memory alignment</data>
      <data key="d9">chunk-09b53b0df067c5056104774d13e5e395</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467720</data>
    </edge>
    <edge source="Boundary Alignment" target="Word Address">
      <data key="d6">1.0</data>
      <data key="d7">Boundary alignment requires that word-sized data be stored at addresses that are multiples of 4.</data>
      <data key="d8">addressing rule,memory alignment</data>
      <data key="d9">chunk-09b53b0df067c5056104774d13e5e395</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467720</data>
    </edge>
    <edge source="C Language Struct" target="Struct Length">
      <data key="d6">1.0</data>
      <data key="d7">The length of a C language struct must be a multiple of the largest alignment value among its members.</data>
      <data key="d8">data structuring,memory layout</data>
      <data key="d9">chunk-09b53b0df067c5056104774d13e5e395</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467715</data>
    </edge>
    <edge source="C Language Struct" target="Alignment Value">
      <data key="d6">1.0</data>
      <data key="d7">Each member of a C language struct must be aligned to a multiple of its alignment value.</data>
      <data key="d8">data structure rule,memory alignment</data>
      <data key="d9">chunk-09b53b0df067c5056104774d13e5e395</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467717</data>
    </edge>
    <edge source="定点数的移位运算" target="加法和移位">
      <data key="d6">1.0</data>
      <data key="d7">定点数的移位运算relies on the combined use of addition and shifting to emulate multiplication and division.</data>
      <data key="d8">alternative arithmetic,computation method</data>
      <data key="d9">chunk-ee63e6f80ae58c99375bb442c346b8a6</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467719</data>
    </edge>
    <edge source="二进制整数" target="左移一位">
      <data key="d6">1.0</data>
      <data key="d7">左移一位on a二进制整数multiplies its value by 2 if no overflow occurs.</data>
      <data key="d8">bit manipulation,multiplication equivalent</data>
      <data key="d9">chunk-ee63e6f80ae58c99375bb442c346b8a6</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467719</data>
    </edge>
    <edge source="二进制整数" target="右移一位">
      <data key="d6">1.0</data>
      <data key="d7">右移一位on a二进制整数divides its value by 2 if the least significant bit is discarded.</data>
      <data key="d8">bit manipulation,division equivalent</data>
      <data key="d9">chunk-ee63e6f80ae58c99375bb442c346b8a6</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467720</data>
    </edge>
    <edge source="右移一位" target="精度影响">
      <data key="d6">1.0</data>
      <data key="d7">右移一位may cause精度影响when the least significant bit being shifted out is 1, leading to loss of accuracy.</data>
      <data key="d8">accuracy reduction,bit loss</data>
      <data key="d9">chunk-ee63e6f80ae58c99375bb442c346b8a6</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467719</data>
    </edge>
    <edge source="逻辑移位" target="无符号整数">
      <data key="d6">1.0</data>
      <data key="d7">逻辑移位applies to无符号整数and fills the vacated positions with zeros.</data>
      <data key="d8">unsigned representation,zero fill</data>
      <data key="d9">chunk-ee63e6f80ae58c99375bb442c346b8a6</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467719</data>
    </edge>
    <edge source="算术移位" target="有符号整数">
      <data key="d6">1.0</data>
      <data key="d7">算术移位applies to有符号整数and fills the vacated positions with the sign bit.</data>
      <data key="d8">sign extension,signed representation</data>
      <data key="d9">chunk-ee63e6f80ae58c99375bb442c346b8a6</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467719</data>
    </edge>
    <edge source="无符号整数" target="进/借位标志CF">
      <data key="d6">1.0</data>
      <data key="d7">The进/借位标志CF is used to detect overflow in unsigned arithmetic.</data>
      <data key="d8">carry detection,unsigned arithmetic</data>
      <data key="d9">chunk-278906376b45ec28050699d283cb1aeb</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467753</data>
    </edge>
    <edge source="加减运算电路" target="反向器">
      <data key="d6">1.0</data>
      <data key="d7">The加减运算电路uses n inverters to invert the bits of Y for subtraction.</data>
      <data key="d8">bit inversion,signal processing</data>
      <data key="d9">chunk-278906376b45ec28050699d283cb1aeb</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467751</data>
    </edge>
    <edge source="加减运算电路" target="2选1多路选择器">
      <data key="d6">1.0</data>
      <data key="d7">The加减运算电路uses a 2选1多路选择器to select between Y and its inverted form based on the Sub control signal.</data>
      <data key="d8">control logic,input selection</data>
      <data key="d9">chunk-278906376b45ec28050699d283cb1aeb</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467752</data>
    </edge>
    <edge source="加减运算电路" target="控制端Sub">
      <data key="d6">1.0</data>
      <data key="d7">The控制端Sub controls whether the circuit performs addition or subtraction.</data>
      <data key="d8">control signal,operation mode</data>
      <data key="d9">chunk-278906376b45ec28050699d283cb1aeb</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467753</data>
    </edge>
    <edge source="加减运算电路" target="Y">
      <data key="d6">1.0</data>
      <data key="d7">Y is an input operand to the adder in the加减运算电路.</data>
      <data key="d8">data handling,operand input</data>
      <data key="d9">chunk-278906376b45ec28050699d283cb1aeb</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467757</data>
    </edge>
    <edge source="加减运算电路" target="图2.9">
      <data key="d6">1.0</data>
      <data key="d7">The加减运算电路is depicted in图2.9.</data>
      <data key="d8">diagram representation,visual design</data>
      <data key="d9">chunk-278906376b45ec28050699d283cb1aeb</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467758</data>
    </edge>
    <edge source="控制端Sub" target="低位进位">
      <data key="d6">1.0</data>
      <data key="d7">The控制端Sub is connected to the least significant bit input of the adder to provide the carry-in for subtraction (adding 1).</data>
      <data key="d8">carry input,signal routing</data>
      <data key="d9">chunk-278906376b45ec28050699d283cb1aeb</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467751</data>
    </edge>
    <edge source="有符号数" target="溢出标志OF">
      <data key="d6">1.0</data>
      <data key="d7">The溢出标志OF is used to detect overflow in arithmetic involving有符号数.</data>
      <data key="d8">overflow detection,signed arithmetic</data>
      <data key="d9">chunk-278906376b45ec28050699d283cb1aeb</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467753</data>
    </edge>
    <edge source="有符号数" target="符号标志SF">
      <data key="d6">1.0</data>
      <data key="d7">The符号标志SF reflects the sign of the result in signed arithmetic.</data>
      <data key="d8">result polarity,sign indication</data>
      <data key="d9">chunk-278906376b45ec28050699d283cb1aeb</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467753</data>
    </edge>
    <edge source="零标志ZF" target="运算结果">
      <data key="d6">1.0</data>
      <data key="d7">The零标志ZF is set based on whether the result of an arithmetic operation is zero.</data>
      <data key="d8">flag indication,outcome status</data>
      <data key="d9">chunk-278906376b45ec28050699d283cb1aeb</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467752</data>
    </edge>
    <edge source="Integral Types" target="Floating-Point Types">
      <data key="d6">1.0</data>
      <data key="d7">Integral types like int and long are converted to floating-point types such as float and double during expressions, following the hierarchy from smaller to larger types.</data>
      <data key="d8">conversion path,type hierarchy</data>
      <data key="d9">chunk-7661b58ae4a51d1ee96186ef15ec5292</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467757</data>
    </edge>
    <edge source="原码加减法运算" target="加法规则">
      <data key="d6">1.0</data>
      <data key="d7">原码加减法运算包含加法规则作为其核心组成部分。</data>
      <data key="d8">algorithmic logic,rule-based process</data>
      <data key="d9">chunk-ea2c16caf28ea549ed420e26afbca237</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467787</data>
    </edge>
    <edge source="原码加减法运算" target="减法规则">
      <data key="d6">1.0</data>
      <data key="d7">原码加减法运算包含减法规则作为其核心组成部分。</data>
      <data key="d8">algorithmic logic,rule-based process</data>
      <data key="d9">chunk-ea2c16caf28ea549ed420e26afbca237</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467787</data>
    </edge>
    <edge source="原码加减法运算" target="补码加减运算">
      <data key="d6">1.0</data>
      <data key="d7">由于原码加减法规则复杂，计算机普遍采用补码加减运算作为替代方案。</data>
      <data key="d8">computational alternative,method replacement</data>
      <data key="d9">chunk-ea2c16caf28ea549ed420e26afbca237</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467788</data>
    </edge>
    <edge source="加法规则" target="绝对值大的数">
      <data key="d6">1.0</data>
      <data key="d7">加法规则中，当符号位不同时，结果符号由绝对值大的数决定。</data>
      <data key="d8">magnitude comparison,result sign determination</data>
      <data key="d9">chunk-ea2c16caf28ea549ed420e26afbca237</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467788</data>
    </edge>
    <edge source="加法规则" target="同号求和">
      <data key="d6">1.0</data>
      <data key="d7">加法规则包含“同号求和”这一子规则，用于处理符号相同的数的加法。</data>
      <data key="d8">arithmetic logic,rule component</data>
      <data key="d9">chunk-ea2c16caf28ea549ed420e26afbca237</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467789</data>
    </edge>
    <edge source="加法规则" target="异号求差">
      <data key="d6">1.0</data>
      <data key="d7">加法规则包含“异号求差”这一子规则，用于处理符号不同的数的加法。</data>
      <data key="d8">arithmetic logic,rule component</data>
      <data key="d9">chunk-ea2c16caf28ea549ed420e26afbca237</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467789</data>
    </edge>
    <edge source="减法规则" target="减数">
      <data key="d6">1.0</data>
      <data key="d7">减法规则要求将减数符号取反后参与加法运算。</data>
      <data key="d8">arithmetic logic,operand transformation</data>
      <data key="d9">chunk-ea2c16caf28ea549ed420e26afbca237</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467788</data>
    </edge>
    <edge source="减法规则" target="被减数">
      <data key="d6">1.0</data>
      <data key="d7">减法规则中被减数保持不变并参与加法运算。</data>
      <data key="d8">arithmetic process,operand handling</data>
      <data key="d9">chunk-ea2c16caf28ea549ed420e26afbca237</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467788</data>
    </edge>
    <edge source="Machine Number Fixed-Point Representation" target="Floating-Point Representation">
      <data key="d6">1.0</data>
      <data key="d7">Machine Number Fixed-Point Representation and Floating-Point Representation are two different data formats used in computer systems.</data>
      <data key="d8">data format comparison</data>
      <data key="d9">chunk-5b233c3ec097f13f398ea0ca159b2c8b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467832</data>
    </edge>
    <edge source="Bias Code" target="Floating-Point Exponent">
      <data key="d6">1.0</data>
      <data key="d7">Bias Code is used to represent the floating-point exponent in machine numbers.</data>
      <data key="d8">exponent encoding,numeric representation</data>
      <data key="d9">chunk-5b233c3ec097f13f398ea0ca159b2c8b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467832</data>
    </edge>
    <edge source="Bias Code" target="Zero">
      <data key="d6">1.0</data>
      <data key="d7">Bias Code provides a unique representation for zero in the exponent field.</data>
      <data key="d8">unique representation</data>
      <data key="d9">chunk-5b233c3ec097f13f398ea0ca159b2c8b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467833</data>
    </edge>
    <edge source="Bias Code" target="Number Axis">
      <data key="d6">2.0</data>
      <data key="d7">Bias Code is asymmetrically represented on the number axis and does not include negative zero.&lt;SEP&gt;Bias Code maintains the same ordering as the true values on the number axis.</data>
      <data key="d8">asymmetric representation,monotonicity,value ordering</data>
      <data key="d9">chunk-5b233c3ec097f13f398ea0ca159b2c8b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467835</data>
    </edge>
    <edge source="Machine Word Length" target="Numerical Bits">
      <data key="d6">1.0</data>
      <data key="d7">The number of numerical bits in a machine number is determined by the machine word length minus the sign bit.</data>
      <data key="d8">bit structure,data encoding</data>
      <data key="d9">chunk-5b233c3ec097f13f398ea0ca159b2c8b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467833</data>
    </edge>
    <edge source="Machine Word Length" target="Bias Value">
      <data key="d6">1.0</data>
      <data key="d7">The bias value is typically set to 2^(n-1), where n is the exponent bit length, derived from machine word length.</data>
      <data key="d8">configurable constant,encoding parameter</data>
      <data key="d9">chunk-5b233c3ec097f13f398ea0ca159b2c8b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761467834</data>
    </edge>
  </graph>
</graphml>
