<?xml version='1.0' encoding='utf-8'?>
<graphml xmlns="http://graphml.graphdrawing.org/xmlns" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://graphml.graphdrawing.org/xmlns http://graphml.graphdrawing.org/xmlns/1.0/graphml.xsd">
  <key id="d11" for="edge" attr.name="created_at" attr.type="long" />
  <key id="d10" for="edge" attr.name="file_path" attr.type="string" />
  <key id="d9" for="edge" attr.name="source_id" attr.type="string" />
  <key id="d8" for="edge" attr.name="keywords" attr.type="string" />
  <key id="d7" for="edge" attr.name="description" attr.type="string" />
  <key id="d6" for="edge" attr.name="weight" attr.type="double" />
  <key id="d5" for="node" attr.name="created_at" attr.type="long" />
  <key id="d4" for="node" attr.name="file_path" attr.type="string" />
  <key id="d3" for="node" attr.name="source_id" attr.type="string" />
  <key id="d2" for="node" attr.name="description" attr.type="string" />
  <key id="d1" for="node" attr.name="entity_type" attr.type="string" />
  <key id="d0" for="node" attr.name="entity_id" attr.type="string" />
  <graph edgedefault="undirected">
    <node id="Throughput Rate">
      <data key="d0">Throughput Rate</data>
      <data key="d1">concept</data>
      <data key="d2">The throughput rate refers to the number of tasks or output results completed by a pipeline per unit time.</data>
      <data key="d3">chunk-d2fd5e9039a63352ee73f215fc8aeb15</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735529</data>
    </node>
    <node id="Pipeline Throughput Rate">
      <data key="d0">Pipeline Throughput Rate</data>
      <data key="d1">concept</data>
      <data key="d2">Pipeline throughput rate (TP) is defined as the number of tasks completed in a unit of time.</data>
      <data key="d3">chunk-d2fd5e9039a63352ee73f215fc8aeb15</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735529</data>
    </node>
    <node id="Task Count">
      <data key="d0">Task Count</data>
      <data key="d1">data</data>
      <data key="d2">Task count (n) represents the total number of tasks processed in a pipeline.</data>
      <data key="d3">chunk-d2fd5e9039a63352ee73f215fc8aeb15</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735529</data>
    </node>
    <node id="Total Time">
      <data key="d0">Total Time</data>
      <data key="d1">data</data>
      <data key="d2">Total time (T) is the time required to complete n tasks in a pipeline.</data>
      <data key="d3">chunk-d2fd5e9039a63352ee73f215fc8aeb15</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735529</data>
    </node>
    <node id="Number of Pipeline Stages">
      <data key="d0">Number of Pipeline Stages</data>
      <data key="d1">data</data>
      <data key="d2">Number of pipeline stages (k) refers to the number of segments in a pipeline.</data>
      <data key="d3">chunk-d2fd5e9039a63352ee73f215fc8aeb15</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735529</data>
    </node>
    <node id="Clock Cycle">
      <data key="d0">Clock Cycle</data>
      <data key="d1">concept</data>
      <data key="d2">Clock Cycle is the fundamental timing unit in modern CPUs, representing the time period of a single cycle in a processor’s operation. It corresponds to one tick of the system clock and serves as the basic time unit during which operations are synchronized within the processor’s pipeline. Each clock cycle provides a discrete time interval in which a single step of a machine instruction or a set of micro-operations can be executed sequentially. The duration of a clock cycle, denoted as Δt, is determined by the longest stage in the pipeline, ensuring that all stages complete within one cycle. This timing unit is essential for coordinating the execution of instructions and measuring the overall execution time of computational tasks. Clock cycles enable the sequential and synchronized execution of operations across various pipeline stages, ensuring reliable and efficient processing within the CPU.</data>
      <data key="d3">chunk-0efa36a872f0b1511a047f0591cba52c&lt;SEP&gt;chunk-643c2ebb8e3d3384d19f217865cc3b8f&lt;SEP&gt;chunk-3c7856616d478c58fdce251c9a2b68ac&lt;SEP&gt;chunk-f67ff7c347b613bc05733f64a51c9c17&lt;SEP&gt;chunk-3ac380505fdc239a4da36a89716b6444&lt;SEP&gt;chunk-d2fd5e9039a63352ee73f215fc8aeb15&lt;SEP&gt;chunk-951a0e05d8d102dbb38963722260d96a&lt;SEP&gt;chunk-5ea0f23d1c767bafc743ff484eb189e1</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736810</data>
    </node>
    <node id="Maximum Throughput Rate">
      <data key="d0">Maximum Throughput Rate</data>
      <data key="d1">concept</data>
      <data key="d2">Maximum throughput rate (TPmax) is the highest achievable throughput when the number of tasks approaches infinity, calculated as 1/Δt.</data>
      <data key="d3">chunk-d2fd5e9039a63352ee73f215fc8aeb15</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735529</data>
    </node>
    <node id="Speedup Ratio">
      <data key="d0">Speedup Ratio</data>
      <data key="d1">concept</data>
      <data key="d2">Speedup ratio (S) is the ratio of the time required to complete tasks without a pipeline to the time required with a pipeline.</data>
      <data key="d3">chunk-d2fd5e9039a63352ee73f215fc8aeb15</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735529</data>
    </node>
    <node id="Non-Pipelined Total Time">
      <data key="d0">Non-Pipelined Total Time</data>
      <data key="d1">data</data>
      <data key="d2">Non-pipelined total time (T₀) is the time to complete n tasks sequentially, given by knΔt.</data>
      <data key="d3">chunk-d2fd5e9039a63352ee73f215fc8aeb15</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735530</data>
    </node>
    <node id="Pipelined Total Time">
      <data key="d0">Pipelined Total Time</data>
      <data key="d1">data</data>
      <data key="d2">Pipelined total time (Tₖ) is the time to complete n tasks using a k-stage pipeline, calculated as (k + n - 1)Δt.</data>
      <data key="d3">chunk-d2fd5e9039a63352ee73f215fc8aeb15</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735530</data>
    </node>
    <node id="Maximum Speedup Ratio">
      <data key="d0">Maximum Speedup Ratio</data>
      <data key="d1">concept</data>
      <data key="d2">Maximum speedup ratio (Smax) is the highest achievable speedup when the number of tasks approaches infinity, calculated as k.</data>
      <data key="d3">chunk-d2fd5e9039a63352ee73f215fc8aeb15</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735530</data>
    </node>
    <node id="Ideal Continuous Input">
      <data key="d0">Ideal Continuous Input</data>
      <data key="d1">concept</data>
      <data key="d2">Ideal continuous input refers to the condition where tasks are fed into the pipeline without interruption, enabling optimal performance.</data>
      <data key="d3">chunk-d2fd5e9039a63352ee73f215fc8aeb15</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735530</data>
    </node>
    <node id="k">
      <data key="d0">k</data>
      <data key="d1">data</data>
      <data key="d2">k represents the number of stages in the pipeline, a key parameter in calculating pipeline performance metrics.</data>
      <data key="d3">chunk-d2fd5e9039a63352ee73f215fc8aeb15</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735530</data>
    </node>
    <node id="Δt">
      <data key="d0">Δt</data>
      <data key="d1">data</data>
      <data key="d2">Δt represents the clock cycle duration, a fundamental timing unit in pipeline execution.</data>
      <data key="d3">chunk-d2fd5e9039a63352ee73f215fc8aeb15</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735530</data>
    </node>
    <node id="n">
      <data key="d0">n</data>
      <data key="d1">data</data>
      <data key="d2">n represents the number of tasks processed in the pipeline, a variable used in throughput and speedup calculations.</data>
      <data key="d3">chunk-d2fd5e9039a63352ee73f215fc8aeb15</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735530</data>
    </node>
    <node id="T">
      <data key="d0">T</data>
      <data key="d1">data</data>
      <data key="d2">T represents the total time required to complete n tasks using a pipeline.</data>
      <data key="d3">chunk-d2fd5e9039a63352ee73f215fc8aeb15</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735530</data>
    </node>
    <node id="T₀">
      <data key="d0">T₀</data>
      <data key="d1">data</data>
      <data key="d2">T₀ represents the total time required to complete n tasks without using a pipeline.</data>
      <data key="d3">chunk-d2fd5e9039a63352ee73f215fc8aeb15</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735532</data>
    </node>
    <node id="Tₖ">
      <data key="d0">Tₖ</data>
      <data key="d1">data</data>
      <data key="d2">Tₖ represents the total time required to complete n tasks using a k-stage pipeline.</data>
      <data key="d3">chunk-d2fd5e9039a63352ee73f215fc8aeb15</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735532</data>
    </node>
    <node id="Instruction Cycle">
      <data key="d0">Instruction Cycle</data>
      <data key="d1">concept</data>
      <data key="d2">The Instruction Cycle is a sequence of steps in a processor's operation, including fetch, indirect addressing, execution, and interrupt handling, each with specific data flow requirements.&lt;SEP&gt;The instruction cycle is the total time required for a CPU to fetch and execute a single instruction, consisting of multiple phases such as fetch, indirect addressing, execution, and interrupt handling.</data>
      <data key="d3">chunk-06dc541c0ea968720bb78e8c162eb159&lt;SEP&gt;chunk-643c2ebb8e3d3384d19f217865cc3b8f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735893</data>
    </node>
    <node id="Data Flow">
      <data key="d0">Data Flow</data>
      <data key="d1">concept</data>
      <data key="d2">Data Flow refers to the ordered sequence of data access required for instruction execution, varying by instruction and execution phase.&lt;SEP&gt;Data Flow describes the movement of data through the Data Path, including the sources, intermediaries, and destinations of information in a CPU.</data>
      <data key="d3">chunk-cf0a63e25f70bb6e12f2ee7720496542&lt;SEP&gt;chunk-06dc541c0ea968720bb78e8c162eb159</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736554</data>
    </node>
    <node id="PC">
      <data key="d0">PC</data>
      <data key="d1">artifact</data>
      <data key="d2">PC (Program Counter) is a register that holds the address of the next instruction to be executed.&lt;SEP&gt;PC(程序计数器)是控制器中用于存储当前指令地址并指向下一条指令位置的寄存器。</data>
      <data key="d3">chunk-7c0bc146aeae05e551f80c74f57bf6cc&lt;SEP&gt;chunk-06dc541c0ea968720bb78e8c162eb159</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735658</data>
    </node>
    <node id="IR">
      <data key="d0">IR</data>
      <data key="d1">artifact</data>
      <data key="d2">IR (Instruction Register) stores the current instruction being executed.&lt;SEP&gt;IR(指令寄存器)是控制器中用于存放当前正在执行的指令的寄存器。</data>
      <data key="d3">chunk-7c0bc146aeae05e551f80c74f57bf6cc&lt;SEP&gt;chunk-06dc541c0ea968720bb78e8c162eb159</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735658</data>
    </node>
    <node id="MAR">
      <data key="d0">MAR</data>
      <data key="d1">artifact</data>
      <data key="d2">MAR (Memory Address Register) holds the address of the memory location to be accessed.</data>
      <data key="d3">chunk-06dc541c0ea968720bb78e8c162eb159</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735548</data>
    </node>
    <node id="MDR">
      <data key="d0">MDR</data>
      <data key="d1">artifact</data>
      <data key="d2">MDR (Memory Data Register) holds the data being transferred to or from memory.</data>
      <data key="d3">chunk-06dc541c0ea968720bb78e8c162eb159</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735548</data>
    </node>
    <node id="CU">
      <data key="d0">CU</data>
      <data key="d1">artifact</data>
      <data key="d2">CU (Control Unit) coordinates and controls the operations of the processor by issuing control signals.</data>
      <data key="d3">chunk-06dc541c0ea968720bb78e8c162eb159</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735548</data>
    </node>
    <node id="ALU">
      <data key="d0">ALU</data>
      <data key="d1">artifact</data>
      <data key="d2">ALU (Arithmetic Logic Unit) performs arithmetic and logical operations on data.&lt;SEP&gt;ALU stands for Arithmetic Logic Unit, a component in a processor that performs arithmetic and logical operations.&lt;SEP&gt;ALU (Arithmetic Logic Unit) is a fundamental component of a CPU responsible for performing arithmetic and logical operations.&lt;SEP&gt;The ALU (Arithmetic Logic Unit) is a digital circuit within the Data Path that performs arithmetic and logical operations on data.</data>
      <data key="d3">chunk-cf0a63e25f70bb6e12f2ee7720496542&lt;SEP&gt;chunk-cc56d9863e6de5d5a6e95e87766d0742&lt;SEP&gt;chunk-06dc541c0ea968720bb78e8c162eb159&lt;SEP&gt;chunk-2a63536239036e36be43b7e72d560b24</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736549</data>
    </node>
    <node id="SP">
      <data key="d0">SP</data>
      <data key="d1">artifact</data>
      <data key="d2">SP (Stack Pointer) indicates the top of the stack and is used during stack operations.</data>
      <data key="d3">chunk-06dc541c0ea968720bb78e8c162eb159</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735550</data>
    </node>
    <node id="Main Memory">
      <data key="d0">Main Memory</data>
      <data key="d1">naturalobject</data>
      <data key="d2">Main Memory is the primary storage unit in a computer system where instructions and data are stored temporarily.&lt;SEP&gt;Main memory is an external storage within the CPU that holds programs and data, implemented using RAM.&lt;SEP&gt;Main memory is the primary storage used by the CPU to store and retrieve instructions and data during execution.&lt;SEP&gt;Main Memory is the primary storage used by the CPU to access instructions and data sequentially.&lt;SEP&gt;Main memory is the primary storage shared by all cores in a multi-core system for storing data and instructions.&lt;SEP&gt;Main memory is the primary storage in a computer system, also known as RAM.</data>
      <data key="d3">chunk-06dc541c0ea968720bb78e8c162eb159&lt;SEP&gt;chunk-643c2ebb8e3d3384d19f217865cc3b8f&lt;SEP&gt;chunk-fe06e06cd53b2ace66af32c5e482dce9&lt;SEP&gt;chunk-62d730248fb05de6d5c2902d76480b63&lt;SEP&gt;chunk-acb6520440fa5141fe4d034f3e5e6edf&lt;SEP&gt;chunk-ea027e504c6e7bd731aebc2b71512e1c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736285</data>
    </node>
    <node id="Address Bus">
      <data key="d0">Address Bus</data>
      <data key="d1">artifact</data>
      <data key="d2">Address Bus is a communication pathway for transmitting memory addresses.</data>
      <data key="d3">chunk-06dc541c0ea968720bb78e8c162eb159</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735550</data>
    </node>
    <node id="Data Bus">
      <data key="d0">Data Bus</data>
      <data key="d1">artifact</data>
      <data key="d2">Data Bus is a communication pathway for transferring data between components.&lt;SEP&gt;Data Bus is a communication pathway that transfers data between components of the CPU and memory.</data>
      <data key="d3">chunk-acb6520440fa5141fe4d034f3e5e6edf&lt;SEP&gt;chunk-06dc541c0ea968720bb78e8c162eb159</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735993</data>
    </node>
    <node id="Control Bus">
      <data key="d0">Control Bus</data>
      <data key="d1">artifact</data>
      <data key="d2">Control Bus is a communication pathway for sending control signals between components.</data>
      <data key="d3">chunk-06dc541c0ea968720bb78e8c162eb159</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735550</data>
    </node>
    <node id="Fetch Cycle">
      <data key="d0">Fetch Cycle</data>
      <data key="d1">event</data>
      <data key="d2">The Fetch Cycle is the phase in the Instruction Cycle where the next instruction is retrieved from main memory into the instruction register.</data>
      <data key="d3">chunk-06dc541c0ea968720bb78e8c162eb159</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735550</data>
    </node>
    <node id="Indirect Addressing Cycle">
      <data key="d0">Indirect Addressing Cycle</data>
      <data key="d1">concept</data>
      <data key="d2">The Indirect Addressing Cycle is the phase where the effective address of an operand is fetched from memory.&lt;SEP&gt;The indirect addressing cycle is an additional phase required to retrieve the effective address of an operand by accessing memory twice.</data>
      <data key="d3">chunk-06dc541c0ea968720bb78e8c162eb159&lt;SEP&gt;chunk-643c2ebb8e3d3384d19f217865cc3b8f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735893</data>
    </node>
    <node id="Execution Cycle">
      <data key="d0">Execution Cycle</data>
      <data key="d1">event</data>
      <data key="d2">The Execution Cycle is the phase where the instruction is processed by the ALU based on the opcode.</data>
      <data key="d3">chunk-06dc541c0ea968720bb78e8c162eb159</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735550</data>
    </node>
    <node id="Interrupt Cycle">
      <data key="d0">Interrupt Cycle</data>
      <data key="d1">concept</data>
      <data key="d2">The Interrupt Cycle is the phase where the processor handles an interrupt request, saving the current state and jumping to the interrupt service routine.&lt;SEP&gt;The interrupt cycle is a phase in the instruction cycle that occurs when a CPU detects an interrupt request, involving saving the current state and switching to an interrupt service routine.</data>
      <data key="d3">chunk-06dc541c0ea968720bb78e8c162eb159&lt;SEP&gt;chunk-643c2ebb8e3d3384d19f217865cc3b8f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735893</data>
    </node>
    <node id="Effective Address">
      <data key="d0">Effective Address</data>
      <data key="d1">concept</data>
      <data key="d2">Effective Address is the actual memory address from which data is retrieved, potentially derived through indirect addressing.</data>
      <data key="d3">chunk-06dc541c0ea968720bb78e8c162eb159</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735552</data>
    </node>
    <node id="Program Breakpoint">
      <data key="d0">Program Breakpoint</data>
      <data key="d1">concept</data>
      <data key="d2">Program Breakpoint is the instruction address where execution was paused, commonly saved during interrupt handling.</data>
      <data key="d3">chunk-06dc541c0ea968720bb78e8c162eb159</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735552</data>
    </node>
    <node id="Stack">
      <data key="d0">Stack</data>
      <data key="d1">artifact</data>
      <data key="d2">Stack is a Last-In-First-Out (LIFO) data structure used to store temporary data, including return addresses and program states.&lt;SEP&gt;The stack is used to store the breakpoint and PSW values during exception or interrupt processing to support nested operations.</data>
      <data key="d3">chunk-06dc541c0ea968720bb78e8c162eb159&lt;SEP&gt;chunk-d405a4a8ff3786f94e93e3a9b7786551</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736112</data>
    </node>
    <node id="控制器">
      <data key="d0">控制器</data>
      <data key="d1">artifact</data>
      <data key="d2">控制器是计算机系统的指挥中心，负责从主存中取指令、译码、产生控制信号，并协调CPU、主存、输入设备和输出设备之间的数据流动。</data>
      <data key="d3">chunk-7c0bc146aeae05e551f80c74f57bf6cc</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735656</data>
    </node>
    <node id="运算器部件">
      <data key="d0">运算器部件</data>
      <data key="d1">artifact</data>
      <data key="d2">运算器部件通过数据总线与内存储器、输入设备和输出设备传输数据，是计算机中执行算术和逻辑运算的核心部件。</data>
      <data key="d3">chunk-7c0bc146aeae05e551f80c74f57bf6cc</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735656</data>
    </node>
    <node id="内存储器">
      <data key="d0">内存储器</data>
      <data key="d1">artifact</data>
      <data key="d2">内存储器是计算机中用于存储程序和数据的部件，通过地址总线接收地址信息，通过控制总线接收控制信号，通过数据总线与其他部件交换数据。</data>
      <data key="d3">chunk-7c0bc146aeae05e551f80c74f57bf6cc</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735656</data>
    </node>
    <node id="输入设备">
      <data key="d0">输入设备</data>
      <data key="d1">artifact</data>
      <data key="d2">输入设备用于将外部数据输入到计算机系统中，通过接口电路与总线连接，从地址总线接收地址信息，从控制总线接收控制信号，并通过数据总线传送数据。</data>
      <data key="d3">chunk-7c0bc146aeae05e551f80c74f57bf6cc</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735656</data>
    </node>
    <node id="输出设备">
      <data key="d0">输出设备</data>
      <data key="d1">artifact</data>
      <data key="d2">输出设备用于将计算机处理后的数据输出到外部，通过接口电路与总线连接，从地址总线接收地址信息，从控制总线接收控制信号，并通过数据总线接收数据。</data>
      <data key="d3">chunk-7c0bc146aeae05e551f80c74f57bf6cc</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735656</data>
    </node>
    <node id="数据总线">
      <data key="d0">数据总线</data>
      <data key="d1">artifact</data>
      <data key="d2">数据总线是计算机系统中用于在各部件之间传输数据的共享通道。</data>
      <data key="d3">chunk-7c0bc146aeae05e551f80c74f57bf6cc</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735656</data>
    </node>
    <node id="地址总线">
      <data key="d0">地址总线</data>
      <data key="d1">artifact</data>
      <data key="d2">地址总线是计算机系统中用于传输地址信息的通道，连接各部件以定位内存或设备位置。</data>
      <data key="d3">chunk-7c0bc146aeae05e551f80c74f57bf6cc</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735656</data>
    </node>
    <node id="控制总线">
      <data key="d0">控制总线</data>
      <data key="d1">artifact</data>
      <data key="d2">控制总线是计算机系统中用于传输控制信号的通道，用于协调各部件的操作。</data>
      <data key="d3">chunk-7c0bc146aeae05e551f80c74f57bf6cc</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735656</data>
    </node>
    <node id="硬布线控制器">
      <data key="d0">硬布线控制器</data>
      <data key="d1">artifact</data>
      <data key="d2">硬布线控制器是根据控制信号的逻辑关系直接设计硬件电路实现的控制器，其控制流程由硬件决定。</data>
      <data key="d3">chunk-7c0bc146aeae05e551f80c74f57bf6cc</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735658</data>
    </node>
    <node id="微程序控制器">
      <data key="d0">微程序控制器</data>
      <data key="d1">concept</data>
      <data key="d2">微程序控制器是将控制信号以微程序形式存储在控制存储器中，通过执行微程序来产生控制信号的一种控制器。&lt;SEP&gt;The microprogram controller is a control unit in a computer that manages the execution of machine instructions through a sequence of microinstructions.</data>
      <data key="d3">chunk-7c0bc146aeae05e551f80c74f57bf6cc&lt;SEP&gt;chunk-7b1e3d6a0816b7c4daa74cc9c66df994</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736153</data>
    </node>
    <node id="指令信息">
      <data key="d0">指令信息</data>
      <data key="d1">data</data>
      <data key="d2">指令信息是控制器从数据总线接收的、用于后续译码和执行的内容。</data>
      <data key="d3">chunk-7c0bc146aeae05e551f80c74f57bf6cc</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735658</data>
    </node>
    <node id="指令转移地址">
      <data key="d0">指令转移地址</data>
      <data key="d1">data</data>
      <data key="d2">指令转移地址是控制器从运算器部件接收的，用于确定下一条指令执行位置的信息。</data>
      <data key="d3">chunk-7c0bc146aeae05e551f80c74f57bf6cc</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735658</data>
    </node>
    <node id="控制信号">
      <data key="d0">控制信号</data>
      <data key="d1">data</data>
      <data key="d2">控制信号是控制器向系统中各部件发送的，用于启动或协调其运行的信号。</data>
      <data key="d3">chunk-7c0bc146aeae05e551f80c74f57bf6cc</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735658</data>
    </node>
    <node id="CPU">
      <data key="d0">CPU</data>
      <data key="d1">artifact</data>
      <data key="d2">CPU, the central processing unit, is the primary component of a computer system responsible for executing instructions and managing data operations. It serves as the core processing engine, performing most of the computational tasks within a computer. The CPU consists of several key functional units, including the control unit, which directs the operation of the processor by managing instruction flow, and the arithmetic logic unit (ALU), which performs arithmetic and logical operations. Additionally, the CPU contains registers that store temporary data and intermediate results during processing. As the central hub for data flow and instruction execution, the CPU coordinates all major operations within the system, ensuring the smooth functioning of software and hardware components. It is also responsible for handling exceptions and interrupts—abnormal or unexpected events that require immediate attention during execution—such as hardware failures, software errors, or external signals from input devices. The role of the CPU is fundamental to computer operation, making it indispensable for processing and managing information across all computing platforms.&lt;SEP&gt;The CPU is the central processing unit of a computer system, responsible for executing instructions and managing data processing.&lt;SEP&gt;The CPU (Central Processing Unit) is the primary component of a computer system that processes instructions and manages data flow, composed of the Data Path and Control Unit.&lt;SEP&gt;The CPU is the central processing unit that executes instructions and checks for interrupt requests after each instruction completion.</data>
      <data key="d3">chunk-7c0bc146aeae05e551f80c74f57bf6cc&lt;SEP&gt;chunk-cf0a63e25f70bb6e12f2ee7720496542&lt;SEP&gt;chunk-53c573d4212b8c79ccafbdbdcd65d8e9&lt;SEP&gt;chunk-643c2ebb8e3d3384d19f217865cc3b8f&lt;SEP&gt;chunk-cc2d0105e935d9886fe36f0b3286af0f&lt;SEP&gt;chunk-d405a4a8ff3786f94e93e3a9b7786551&lt;SEP&gt;chunk-7e297f32d868dbd2d51d7a047e223119&lt;SEP&gt;chunk-62d730248fb05de6d5c2902d76480b63&lt;SEP&gt;chunk-56dad084d2f83de29d62a2ae33cfc843&lt;SEP&gt;chunk-acb6520440fa5141fe4d034f3e5e6edf&lt;SEP&gt;chunk-de401d6e0254effcba3f6fcd81cefe60</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736653</data>
    </node>
    <node id="接口电路">
      <data key="d0">接口电路</data>
      <data key="d3">chunk-7c0bc146aeae05e551f80c74f57bf6cc</data>
      <data key="d2">输入设备通过接口电路与总线连接，实现数据与总线间传输。</data>
      <data key="d1">UNKNOWN</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735661</data>
    </node>
    <node id="主存">
      <data key="d0">主存</data>
      <data key="d3">chunk-7c0bc146aeae05e551f80c74f57bf6cc&lt;SEP&gt;chunk-7b1e3d6a0816b7c4daa74cc9c66df994</data>
      <data key="d2">控制器从主存中取出指令，并管理下一条指令的位置。&lt;SEP&gt;Main memory is the primary storage of a computer where machine instructions and data are stored.</data>
      <data key="d1">naturalobject</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736156</data>
    </node>
    <node id="SISD">
      <data key="d0">SISD</data>
      <data key="d1">concept</data>
      <data key="d2">SISD refers to a single instruction stream and single data stream computer architecture, representing traditional serial processing with one processor and one memory unit.</data>
      <data key="d3">chunk-cc56d9863e6de5d5a6e95e87766d0742</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735665</data>
    </node>
    <node id="SIMD">
      <data key="d0">SIMD</data>
      <data key="d1">concept</data>
      <data key="d2">SIMD refers to a single instruction stream and multiple data streams architecture, enabling data-level parallelism where one instruction operates on multiple data elements simultaneously.</data>
      <data key="d3">chunk-cc56d9863e6de5d5a6e95e87766d0742</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735665</data>
    </node>
    <node id="MISD">
      <data key="d0">MISD</data>
      <data key="d1">concept</data>
      <data key="d2">MISD refers to a multiple instruction stream and single data stream architecture, which theoretically involves multiple instructions operating on the same data, but no practical implementations exist.</data>
      <data key="d3">chunk-cc56d9863e6de5d5a6e95e87766d0742</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735665</data>
    </node>
    <node id="MIMD">
      <data key="d0">MIMD</data>
      <data key="d1">concept</data>
      <data key="d2">MIMD refers to a multiple instruction stream and multiple data stream architecture, supporting higher-level parallelism such as thread-level or task-level parallelism.</data>
      <data key="d3">chunk-cc56d9863e6de5d5a6e95e87766d0742</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735665</data>
    </node>
    <node id="Single Instruction Stream">
      <data key="d0">Single Instruction Stream</data>
      <data key="d1">concept</data>
      <data key="d2">Single instruction stream is a computational model where one instruction sequence controls the execution across one or more processing units.</data>
      <data key="d3">chunk-cc56d9863e6de5d5a6e95e87766d0742</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735665</data>
    </node>
    <node id="Multiple Data Streams">
      <data key="d0">Multiple Data Streams</data>
      <data key="d1">concept</data>
      <data key="d2">Multiple data streams represent the simultaneous processing of distinct data sets under a single instruction stream, enabling parallel data operations.</data>
      <data key="d3">chunk-cc56d9863e6de5d5a6e95e87766d0742</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735665</data>
    </node>
    <node id="Multiple Instruction Streams">
      <data key="d0">Multiple Instruction Streams</data>
      <data key="d1">concept</data>
      <data key="d2">Multiple instruction streams refer to the execution of different instruction sequences on separate processing units.</data>
      <data key="d3">chunk-cc56d9863e6de5d5a6e95e87766d0742</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735665</data>
    </node>
    <node id="Single Data Stream">
      <data key="d0">Single Data Stream</data>
      <data key="d1">concept</data>
      <data key="d2">Single data stream is a data structure where a single set of data is processed, typically in non-parallel computation models.</data>
      <data key="d3">chunk-cc56d9863e6de5d5a6e95e87766d0742</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735665</data>
    </node>
    <node id="Vector Processor">
      <data key="d0">Vector Processor</data>
      <data key="d1">artifact</data>
      <data key="d2">A vector processor is a type of CPU that supports vectorized instructions for direct operand operations on one-dimensional arrays, enhancing performance in numerical simulations.</data>
      <data key="d3">chunk-cc56d9863e6de5d5a6e95e87766d0742</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735667</data>
    </node>
    <node id="Serial Processor">
      <data key="d0">Serial Processor</data>
      <data key="d1">artifact</data>
      <data key="d2">A serial processor is a conventional CPU that processes data items sequentially, one at a time, without parallelism.</data>
      <data key="d3">chunk-cc56d9863e6de5d5a6e95e87766d0742</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735667</data>
    </node>
    <node id="Instruction Control Component">
      <data key="d0">Instruction Control Component</data>
      <data key="d1">artifact</data>
      <data key="d2">An instruction control component is responsible for managing and distributing instructions to processing units in a parallel architecture.</data>
      <data key="d3">chunk-cc56d9863e6de5d5a6e95e87766d0742</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735667</data>
    </node>
    <node id="Processor">
      <data key="d0">Processor</data>
      <data key="d1">artifact</data>
      <data key="d2">A processor is a hardware component responsible for executing instructions in a computer system.&lt;SEP&gt;A processor is the central component in computing that controls the execution of instructions and manages data processing.</data>
      <data key="d3">chunk-cc56d9863e6de5d5a6e95e87766d0742&lt;SEP&gt;chunk-3c7856616d478c58fdce251c9a2b68ac</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736782</data>
    </node>
    <node id="Memory">
      <data key="d0">Memory</data>
      <data key="d1">naturalobject</data>
      <data key="d2">Memory refers to the storage system within a computer that holds data and instructions for processing.&lt;SEP&gt;Memory is a sequential logic element used to store large amounts of data and is a core component in data path systems.&lt;SEP&gt;Memory is a storage component in the CPU system that holds data and instructions and is accessed via a memory address register.</data>
      <data key="d3">chunk-2459f394250f45963236273137f4db0c&lt;SEP&gt;chunk-0efa36a872f0b1511a047f0591cba52c&lt;SEP&gt;chunk-cc56d9863e6de5d5a6e95e87766d0742</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736798</data>
    </node>
    <node id="Vector Register">
      <data key="d0">Vector Register</data>
      <data key="d1">artifact</data>
      <data key="d2">A vector register is a register designed to hold multiple data elements in vector format for use in vector operations.</data>
      <data key="d3">chunk-cc56d9863e6de5d5a6e95e87766d0742</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735667</data>
    </node>
    <node id="Shared Memory">
      <data key="d0">Shared Memory</data>
      <data key="d1">artifact</data>
      <data key="d2">Shared memory is a memory architecture where all processing units can access a common memory space, facilitating communication in multiprocessor systems.</data>
      <data key="d3">chunk-cc56d9863e6de5d5a6e95e87766d0742</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735667</data>
    </node>
    <node id="Private Memory">
      <data key="d0">Private Memory</data>
      <data key="d1">artifact</data>
      <data key="d2">Private memory is dedicated storage allocated to individual nodes or processors in a system, not accessible directly by others.</data>
      <data key="d3">chunk-cc56d9863e6de5d5a6e95e87766d0742</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735668</data>
    </node>
    <node id="Message Passing">
      <data key="d0">Message Passing</data>
      <data key="d1">method</data>
      <data key="d2">Message passing is a communication method in distributed systems where data is transferred between nodes through explicit send and receive operations.</data>
      <data key="d3">chunk-cc56d9863e6de5d5a6e95e87766d0742</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735669</data>
    </node>
    <node id="Data-Level Parallelism">
      <data key="d0">Data-Level Parallelism</data>
      <data key="d1">concept</data>
      <data key="d2">Data-level parallelism refers to the execution of a single instruction on multiple data items simultaneously, characteristic of SIMD architectures.</data>
      <data key="d3">chunk-cc56d9863e6de5d5a6e95e87766d0742</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735669</data>
    </node>
    <node id="Thread-Level Parallelism">
      <data key="d0">Thread-Level Parallelism</data>
      <data key="d1">concept</data>
      <data key="d2">Thread-level parallelism refers to the execution of multiple threads concurrently, typical of MIMD systems.&lt;SEP&gt;Thread-level parallelism is the capability to execute instructions from multiple threads concurrently, improving overall throughput.</data>
      <data key="d3">chunk-f67ff7c347b613bc05733f64a51c9c17&lt;SEP&gt;chunk-cc56d9863e6de5d5a6e95e87766d0742</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736741</data>
    </node>
    <node id="Serial Hardware">
      <data key="d0">Serial Hardware</data>
      <data key="d1">artifact</data>
      <data key="d2">Serial hardware refers to computing platforms designed for sequential processing of instructions and data, such as traditional single-core processors.</data>
      <data key="d3">chunk-cc56d9863e6de5d5a6e95e87766d0742</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735669</data>
    </node>
    <node id="Parallel Hardware">
      <data key="d0">Parallel Hardware</data>
      <data key="d1">artifact</data>
      <data key="d2">Parallel hardware refers to computing systems designed to execute multiple instructions or operations simultaneously.</data>
      <data key="d3">chunk-cc56d9863e6de5d5a6e95e87766d0742</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735669</data>
    </node>
    <node id="For Loop">
      <data key="d0">For Loop</data>
      <data key="d1">concept</data>
      <data key="d2">A for loop is a control flow construct used to iterate over a sequence of data, commonly optimized in SIMD architectures.</data>
      <data key="d3">chunk-cc56d9863e6de5d5a6e95e87766d0742</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735669</data>
    </node>
    <node id="Case Statement">
      <data key="d0">Case Statement</data>
      <data key="d1">concept</data>
      <data key="d2">A case statement is a programming construct that evaluates a value and executes different code blocks based on that value.</data>
      <data key="d3">chunk-cc56d9863e6de5d5a6e95e87766d0742</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735670</data>
    </node>
    <node id="Switch Statement">
      <data key="d0">Switch Statement</data>
      <data key="d1">concept</data>
      <data key="d2">A switch statement is a conditional construct that selects one of many possible execution paths based on an input value.</data>
      <data key="d3">chunk-cc56d9863e6de5d5a6e95e87766d0742</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735670</data>
    </node>
    <node id="Numerical Simulation">
      <data key="d0">Numerical Simulation</data>
      <data key="d1">concept</data>
      <data key="d2">Numerical simulation is a computational technique used for modeling complex systems, especially effective in vector processor environments.</data>
      <data key="d3">chunk-cc56d9863e6de5d5a6e95e87766d0742</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735670</data>
    </node>
    <node id="Vectorized Instruction Set">
      <data key="d0">Vectorized Instruction Set</data>
      <data key="d1">artifact</data>
      <data key="d2">A vectorized instruction set is a set of machine-level instructions designed to operate on multiple data elements efficiently through vector registers.</data>
      <data key="d3">chunk-cc56d9863e6de5d5a6e95e87766d0742</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735670</data>
    </node>
    <node id="Pipe-lining">
      <data key="d0">Pipe-lining</data>
      <data key="d1">method</data>
      <data key="d2">Pipelining is a technique used in processors to improve instruction throughput by overlapping execution phases of multiple instructions.</data>
      <data key="d3">chunk-cc56d9863e6de5d5a6e95e87766d0742</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735670</data>
    </node>
    <node id="Multi-Module Cross-Organization">
      <data key="d0">Multi-Module Cross-Organization</data>
      <data key="d1">method</data>
      <data key="d2">Multi-module cross-organization refers to a memory organization method using multiple modules with interleaved access to improve bandwidth.</data>
      <data key="d3">chunk-cc56d9863e6de5d5a6e95e87766d0742</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735670</data>
    </node>
    <node id="Single Address Space">
      <data key="d0">Single Address Space</data>
      <data key="d1">concept</data>
      <data key="d2">A single address space is a memory model where all processors share a unified memory address range.</data>
      <data key="d3">chunk-cc56d9863e6de5d5a6e95e87766d0742</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735670</data>
    </node>
    <node id="Multiprocessor System">
      <data key="d0">Multiprocessor System</data>
      <data key="d1">artifact</data>
      <data key="d2">A multiprocessor system is a computer system containing multiple processors sharing a common memory and control bus.</data>
      <data key="d3">chunk-cc56d9863e6de5d5a6e95e87766d0742</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735670</data>
    </node>
    <node id="Multicomputer System">
      <data key="d0">Multicomputer System</data>
      <data key="d1">artifact</data>
      <data key="d2">A multicomputer system consists of multiple interconnected computers, each with its own private memory, communicating via message passing.</data>
      <data key="d3">chunk-cc56d9863e6de5d5a6e95e87766d0742</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735670</data>
    </node>
    <node id="Traditional Serial Computer Architecture">
      <data key="d0">Traditional Serial Computer Architecture</data>
      <data key="d3">chunk-cc56d9863e6de5d5a6e95e87766d0742</data>
      <data key="d2">SISD is the foundational model of serial, single-processor systems with a single instruction and data stream.</data>
      <data key="d1">UNKNOWN</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735672</data>
    </node>
    <node id="Theoretical Architecture">
      <data key="d0">Theoretical Architecture</data>
      <data key="d3">chunk-cc56d9863e6de5d5a6e95e87766d0742</data>
      <data key="d2">MISD is a theoretical model with no known practical computer systems.</data>
      <data key="d1">UNKNOWN</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735673</data>
    </node>
    <node id="Pipelining">
      <data key="d0">Pipelining</data>
      <data key="d3">chunk-cc56d9863e6de5d5a6e95e87766d0742</data>
      <data key="d2">SISD processors may use pipelining to improve instruction throughput through overlapping execution stages.</data>
      <data key="d1">UNKNOWN</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735674</data>
    </node>
    <node id="流水线的逻辑结构">
      <data key="d0">流水线的逻辑结构</data>
      <data key="d1">concept</data>
      <data key="d2">The logical structure of a pipeline, where each stage is followed by a pipeline register to store processed data for the next stage.</data>
      <data key="d3">chunk-062a2e851dd9b26735dc96a7d8a4b551</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735718</data>
    </node>
    <node id="流水段寄存器">
      <data key="d0">流水段寄存器</data>
      <data key="d1">artifact</data>
      <data key="d2">Pipeline segment registers are used to latch data at the end of each pipeline stage, ensuring results are available in the next clock cycle.</data>
      <data key="d3">chunk-062a2e851dd9b26735dc96a7d8a4b551</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735718</data>
    </node>
    <node id="统一时钟CLK">
      <data key="d0">统一时钟CLK</data>
      <data key="d1">concept</data>
      <data key="d2">A unified clock signal (CLK) used to synchronize all registers and data storage units in the pipeline.</data>
      <data key="d3">chunk-062a2e851dd9b26735dc96a7d8a4b551</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735718</data>
    </node>
    <node id="IF">
      <data key="d0">IF</data>
      <data key="d1">segment</data>
      <data key="d2">IF (Instruction Fetch) is the first stage of the pipeline where instructions are fetched from memory.</data>
      <data key="d3">chunk-062a2e851dd9b26735dc96a7d8a4b551</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735718</data>
    </node>
    <node id="ID">
      <data key="d0">ID</data>
      <data key="d1">segment</data>
      <data key="d2">ID (Instruction Decode) is the second stage where instructions are decoded and operands are identified.</data>
      <data key="d3">chunk-062a2e851dd9b26735dc96a7d8a4b551</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735718</data>
    </node>
    <node id="EX">
      <data key="d0">EX</data>
      <data key="d1">segment</data>
      <data key="d2">EX (Execute) is the third stage where arithmetic or logical operations are performed.</data>
      <data key="d3">chunk-062a2e851dd9b26735dc96a7d8a4b551</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735718</data>
    </node>
    <node id="MEM">
      <data key="d0">MEM</data>
      <data key="d1">segment</data>
      <data key="d2">MEM (Memory Access) is the fourth stage where data is read from or written to memory.</data>
      <data key="d3">chunk-062a2e851dd9b26735dc96a7d8a4b551</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735718</data>
    </node>
    <node id="WB">
      <data key="d0">WB</data>
      <data key="d1">segment</data>
      <data key="d2">WB (Write Back) is the fifth stage where the result is written back to a register.</data>
      <data key="d3">chunk-062a2e851dd9b26735dc96a7d8a4b551</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735718</data>
    </node>
    <node id="指令">
      <data key="d0">指令</data>
      <data key="d1">content</data>
      <data key="d2">An instruction that passes through the pipeline stages and is processed sequentially.</data>
      <data key="d3">chunk-062a2e851dd9b26735dc96a7d8a4b551</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735720</data>
    </node>
    <node id="时钟周期">
      <data key="d0">时钟周期</data>
      <data key="d1">concept</data>
      <data key="d2">A single cycle of the clock signal (CLK) that triggers data latching and processing transitions in the pipeline.&lt;SEP&gt;A clock cycle is the basic unit of time in a processor, with ideal pipeline operation completing one instruction per clock cycle.</data>
      <data key="d3">chunk-062a2e851dd9b26735dc96a7d8a4b551&lt;SEP&gt;chunk-48932a772d41e90269193af10a0bbbb3</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736555</data>
    </node>
    <node id="数据存储器">
      <data key="d0">数据存储器</data>
      <data key="d1">artifact</data>
      <data key="d2">Data storage units used to hold data during pipeline processing, synchronized with the clock.</data>
      <data key="d3">chunk-062a2e851dd9b26735dc96a7d8a4b551</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735720</data>
    </node>
    <node id="流水线中将同时存在5条不同的指令并行执行">
      <data key="d0">流水线中将同时存在5条不同的指令并行执行</data>
      <data key="d1">concept</data>
      <data key="d2">The pipeline allows five different instructions to be processed in parallel, one in each of the five functional stages.</data>
      <data key="d3">chunk-062a2e851dd9b26735dc96a7d8a4b551</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735720</data>
    </node>
    <node id="Hardwired Controller">
      <data key="d0">Hardwired Controller</data>
      <data key="d1">method</data>
      <data key="d2">The hardwired controller is a type of control unit in a CPU that uses complex combinational logic circuits and flip-flops to generate micro-operation control signals based on instruction requirements, timing, and system state.&lt;SEP&gt;The hardwired controller is a type of control unit that uses combinational logic circuits to generate control signals, known for its high speed due to minimal circuit delay.</data>
      <data key="d3">chunk-cc2d0105e935d9886fe36f0b3286af0f&lt;SEP&gt;chunk-91a81db4ce70f9dbc729e1840db41cff</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735797</data>
    </node>
    <node id="Combinational Logic Controller">
      <data key="d0">Combinational Logic Controller</data>
      <data key="d1">method</data>
      <data key="d2">The combinational logic controller is an alternative name for the hardwired controller, emphasizing its implementation using combinational logic gates.</data>
      <data key="d3">chunk-cc2d0105e935d9886fe36f0b3286af0f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735735</data>
    </node>
    <node id="Instruction Opcode">
      <data key="d0">Instruction Opcode</data>
      <data key="d1">concept</data>
      <data key="d2">The instruction opcode is the part of an instruction that specifies the operation to be performed and determines the control signals generated by the control unit.</data>
      <data key="d3">chunk-cc2d0105e935d9886fe36f0b3286af0f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735735</data>
    </node>
    <node id="Control Unit">
      <data key="d0">Control Unit</data>
      <data key="d1">artifact</data>
      <data key="d2">The Control Unit (CU) is a component of the CPU responsible for generating control signals that coordinate the operations of the processor based on instruction decoding, clock pulses, and feedback from the execution unit.&lt;SEP&gt;The Control Unit is the component within the CPU that manages instruction execution by generating appropriate control signals.&lt;SEP&gt;The Control Unit is the component of a CPU responsible for generating control signals to manage and coordinate the operations within the Data Path.&lt;SEP&gt;The control unit generates control signals to sequence operations and issue commands such as read and write to memory.</data>
      <data key="d3">chunk-cf0a63e25f70bb6e12f2ee7720496542&lt;SEP&gt;chunk-de401d6e0254effcba3f6fcd81cefe60&lt;SEP&gt;chunk-cc2d0105e935d9886fe36f0b3286af0f&lt;SEP&gt;chunk-0efa36a872f0b1511a047f0591cba52c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736798</data>
    </node>
    <node id="Instruction Decoder">
      <data key="d0">Instruction Decoder</data>
      <data key="d1">artifact</data>
      <data key="d2">The Instruction Decoder is a circuit that converts the n-bit opcode from the instruction register into 2^n output signals, each corresponding to a unique instruction.&lt;SEP&gt;The Instruction Decoder (ID) interprets the operation code of an instruction and prepares control signals for execution.</data>
      <data key="d3">chunk-cc2d0105e935d9886fe36f0b3286af0f&lt;SEP&gt;chunk-de401d6e0254effcba3f6fcd81cefe60</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736499</data>
    </node>
    <node id="Timing Generator">
      <data key="d0">Timing Generator</data>
      <data key="d1">artifact</data>
      <data key="d2">The Timing Generator, also known as the节拍发生器, produces timing signals (ticks) that regulate the sequence of micro-operations within each clock cycle.</data>
      <data key="d3">chunk-cc2d0105e935d9886fe36f0b3286af0f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735735</data>
    </node>
    <node id="Clock Pulse">
      <data key="d0">Clock Pulse</data>
      <data key="d1">concept</data>
      <data key="d2">The clock pulse is an electrical signal with a frequency equal to the machine’s main frequency, used to synchronize operations within the control unit.</data>
      <data key="d3">chunk-cc2d0105e935d9886fe36f0b3286af0f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735735</data>
    </node>
    <node id="Flag">
      <data key="d0">Flag</data>
      <data key="d1">data</data>
      <data key="d2">The flag is a feedback signal from the execution unit indicating the status of the CPU, such as zero, carry, or overflow.</data>
      <data key="d3">chunk-cc2d0105e935d9886fe36f0b3286af0f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735735</data>
    </node>
    <node id="Micro-operation Command">
      <data key="d0">Micro-operation Command</data>
      <data key="d1">concept</data>
      <data key="d2">A micro-operation command is a control signal that initiates a basic operation within the CPU, issued in a specific time order by the control unit.</data>
      <data key="d3">chunk-cc2d0105e935d9886fe36f0b3286af0f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735737</data>
    </node>
    <node id="RISC">
      <data key="d0">RISC</data>
      <data key="d1">organization</data>
      <data key="d2">RISC (Reduced Instruction Set Computing) is a processor design philosophy that typically employs hardwired controllers for high-speed execution.</data>
      <data key="d3">chunk-cc2d0105e935d9886fe36f0b3286af0f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735737</data>
    </node>
    <node id="Microprogramming Method">
      <data key="d0">Microprogramming Method</data>
      <data key="d1">method</data>
      <data key="d2">The microprogramming method is an alternative approach to implementing control logic that overcomes the complexity and inflexibility of hardwired controllers by using a sequence of microinstructions stored in control memory.</data>
      <data key="d3">chunk-cc2d0105e935d9886fe36f0b3286af0f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735737</data>
    </node>
    <node id="Instruction Register">
      <data key="d0">Instruction Register</data>
      <data key="d1">artifact</data>
      <data key="d2">The Instruction Register (IR) stores the instruction currently being executed and provides the opcode to the instruction decoder.&lt;SEP&gt;The instruction register (IR) holds the instruction fetched from main memory.&lt;SEP&gt;The Instruction Register stores the currently fetched instruction for decoding and execution.&lt;SEP&gt;Instruction Register stores the current instruction being executed by the CPU.&lt;SEP&gt;The Instruction Register (IR) holds the current instruction being executed.&lt;SEP&gt;The instruction register holds the current instruction being executed and receives data from the memory data register.</data>
      <data key="d3">chunk-0efa36a872f0b1511a047f0591cba52c&lt;SEP&gt;chunk-643c2ebb8e3d3384d19f217865cc3b8f&lt;SEP&gt;chunk-fe06e06cd53b2ace66af32c5e482dce9&lt;SEP&gt;chunk-cc2d0105e935d9886fe36f0b3286af0f&lt;SEP&gt;chunk-acb6520440fa5141fe4d034f3e5e6edf&lt;SEP&gt;chunk-de401d6e0254effcba3f6fcd81cefe60</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736797</data>
    </node>
    <node id="Microprogrammed Controller">
      <data key="d0">Microprogrammed Controller</data>
      <data key="d1">method</data>
      <data key="d2">The microprogrammed controller is a control unit that uses a control storage unit to store microinstructions, offering flexibility and ease of modification.</data>
      <data key="d3">chunk-91a81db4ce70f9dbc729e1840db41cff</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735797</data>
    </node>
    <node id="Control Storage Unit">
      <data key="d0">Control Storage Unit</data>
      <data key="d1">artifact</data>
      <data key="d2">The control storage unit is a memory component in a microprogrammed controller that stores microinstructions for executing machine instructions.</data>
      <data key="d3">chunk-91a81db4ce70f9dbc729e1840db41cff</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735797</data>
    </node>
    <node id="Combinational Logic Circuits">
      <data key="d0">Combinational Logic Circuits</data>
      <data key="d1">artifact</data>
      <data key="d2">Combinational logic circuits are hardware components used in hardwired controllers that generate control signals based on input conditions.</data>
      <data key="d3">chunk-91a81db4ce70f9dbc729e1840db41cff</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735797</data>
    </node>
    <node id="Speed">
      <data key="d0">Speed</data>
      <data key="d1">concept</data>
      <data key="d2">Speed refers to the performance metric of a controller, where hardwired controllers are faster due to direct logic implementation.</data>
      <data key="d3">chunk-91a81db4ce70f9dbc729e1840db41cff</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735797</data>
    </node>
    <node id="Flexibility">
      <data key="d0">Flexibility</data>
      <data key="d1">concept</data>
      <data key="d2">Flexibility is a design characteristic that allows modification or addition of new functions, a strength of microprogrammed controllers.</data>
      <data key="d3">chunk-91a81db4ce70f9dbc729e1840db41cff</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735797</data>
    </node>
    <node id="Maintainability">
      <data key="d0">Maintainability</data>
      <data key="d1">concept</data>
      <data key="d2">Maintainability refers to the ease of debugging and updating a controller, which is improved in microprogrammed controllers.</data>
      <data key="d3">chunk-91a81db4ce70f9dbc729e1840db41cff</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735797</data>
    </node>
    <node id="Regularity">
      <data key="d0">Regularity</data>
      <data key="d1">concept</data>
      <data key="d2">Regularity denotes a consistent and standardized design structure, a key advantage of microprogrammed controllers.</data>
      <data key="d3">chunk-91a81db4ce70f9dbc729e1840db41cff</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735797</data>
    </node>
    <node id="Functionality">
      <data key="d0">Functionality</data>
      <data key="d1">concept</data>
      <data key="d2">Functionality refers to the ability of a controller to support new features or operations, limited in hardwired controllers after design.</data>
      <data key="d3">chunk-91a81db4ce70f9dbc729e1840db41cff</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735798</data>
    </node>
    <node id="Instruction Execution">
      <data key="d0">Instruction Execution</data>
      <data key="d1">concept</data>
      <data key="d2">Instruction execution is the process by which a control unit processes machine instructions, influenced by the controller type.&lt;SEP&gt;Instruction Execution refers to the process by which the CPU interprets and performs a single instruction.&lt;SEP&gt;Instruction Execution refers to the process by which a CPU carries out the operations specified by a machine instruction, involving data flow through the Data Path.&lt;SEP&gt;Instruction execution refers to the CPU processing of machine instructions, which is distinct from interrupt generation.</data>
      <data key="d3">chunk-56dad084d2f83de29d62a2ae33cfc843&lt;SEP&gt;chunk-91a81db4ce70f9dbc729e1840db41cff&lt;SEP&gt;chunk-de401d6e0254effcba3f6fcd81cefe60&lt;SEP&gt;chunk-cf0a63e25f70bb6e12f2ee7720496542</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736656</data>
    </node>
    <node id="Control Signal Generation">
      <data key="d0">Control Signal Generation</data>
      <data key="d1">concept</data>
      <data key="d2">Control signal generation is the process of producing timing and operational signals within a controller, determined by its design.&lt;SEP&gt;Control Signal Generation is the process by which the controller produces signals to manage and coordinate the functional units of the CPU.</data>
      <data key="d3">chunk-de401d6e0254effcba3f6fcd81cefe60&lt;SEP&gt;chunk-91a81db4ce70f9dbc729e1840db41cff</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736501</data>
    </node>
    <node id="Combination Logic Controller">
      <data key="d0">Combination Logic Controller</data>
      <data key="d1">method</data>
      <data key="d2">The combination logic controller is an alternative name for the hardwired controller, emphasizing its reliance on combinational logic circuits to generate control signals.</data>
      <data key="d3">chunk-91a81db4ce70f9dbc729e1840db41cff</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735799</data>
    </node>
    <node id="Microprogram Controller">
      <data key="d0">Microprogram Controller</data>
      <data key="d1">method</data>
      <data key="d2">The microprogram controller uses stored logic to implement machine instructions by converting them into microprograms stored in a control memory, with microoperations generated by microinstructions.</data>
      <data key="d3">chunk-fe06e06cd53b2ace66af32c5e482dce9</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735810</data>
    </node>
    <node id="Control Storage">
      <data key="d0">Control Storage</data>
      <data key="d1">artifact</data>
      <data key="d2">The control storage is a dedicated memory within the CPU that stores microprograms, implemented using ROM.</data>
      <data key="d3">chunk-fe06e06cd53b2ace66af32c5e482dce9</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735810</data>
    </node>
    <node id="Microinstruction">
      <data key="d0">Microinstruction</data>
      <data key="d1">artifact</data>
      <data key="d2">A microinstruction is a collection of microcommands that defines one step of a microprogram, containing operation control and sequence control fields.</data>
      <data key="d3">chunk-fe06e06cd53b2ace66af32c5e482dce9</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735810</data>
    </node>
    <node id="Microoperation">
      <data key="d0">Microoperation</data>
      <data key="d1">concept</data>
      <data key="d2">A microoperation is the basic action performed by the execution unit in response to a microcommand, representing the smallest unit in the control sequence.</data>
      <data key="d3">chunk-fe06e06cd53b2ace66af32c5e482dce9</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735810</data>
    </node>
    <node id="Microcommand">
      <data key="d0">Microcommand</data>
      <data key="d1">concept</data>
      <data key="d2">A microcommand is a control signal sent from the control unit to the execution unit, representing a specific control action, such as enabling a gate or triggering a register.</data>
      <data key="d3">chunk-fe06e06cd53b2ace66af32c5e482dce9</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735810</data>
    </node>
    <node id="Operation Control Field">
      <data key="d0">Operation Control Field</data>
      <data key="d1">artifact</data>
      <data key="d2">The operation control field, also known as the microoperation code field, generates the necessary control signals for a given step in a microprogram.</data>
      <data key="d3">chunk-fe06e06cd53b2ace66af32c5e482dce9</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735810</data>
    </node>
    <node id="Sequence Control Field">
      <data key="d0">Sequence Control Field</data>
      <data key="d1">artifact</data>
      <data key="d2">The sequence control field, also known as the microaddress code field, determines the address of the next microinstruction to be executed.</data>
      <data key="d3">chunk-fe06e06cd53b2ace66af32c5e482dce9</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735810</data>
    </node>
    <node id="Microcycle">
      <data key="d0">Microcycle</data>
      <data key="d1">concept</data>
      <data key="d2">A microcycle is the time required to fetch and execute one microinstruction from the control storage, typically equivalent to one clock cycle.</data>
      <data key="d3">chunk-fe06e06cd53b2ace66af32c5e482dce9</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735810</data>
    </node>
    <node id="Program">
      <data key="d0">Program</data>
      <data key="d1">content</data>
      <data key="d2">A program is an ordered set of machine instructions designed to perform a specific function.</data>
      <data key="d3">chunk-fe06e06cd53b2ace66af32c5e482dce9</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735812</data>
    </node>
    <node id="Microprogram">
      <data key="d0">Microprogram</data>
      <data key="d1">content</data>
      <data key="d2">A microprogram is an ordered sequence of microinstructions that describes the execution of a machine instruction, serving as a real-time interpreter for machine instructions.</data>
      <data key="d3">chunk-fe06e06cd53b2ace66af32c5e482dce9</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735812</data>
    </node>
    <node id="Address Register">
      <data key="d0">Address Register</data>
      <data key="d1">artifact</data>
      <data key="d2">The address register (MAR) stores the address for reading from or writing to main memory.</data>
      <data key="d3">chunk-fe06e06cd53b2ace66af32c5e482dce9</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735812</data>
    </node>
    <node id="Microinstruction Address Register">
      <data key="d0">Microinstruction Address Register</data>
      <data key="d1">artifact</data>
      <data key="d2">The microinstruction address register (μPC or CMAR) holds the address within the control storage for the next microinstruction to be executed.</data>
      <data key="d3">chunk-fe06e06cd53b2ace66af32c5e482dce9</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735812</data>
    </node>
    <node id="Microinstruction Register">
      <data key="d0">Microinstruction Register</data>
      <data key="d1">artifact</data>
      <data key="d2">The microinstruction register (μIR or CMDR) stores the microinstruction read from control storage.</data>
      <data key="d3">chunk-fe06e06cd53b2ace66af32c5e482dce9</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735812</data>
    </node>
    <node id="Machine Instruction">
      <data key="d0">Machine Instruction</data>
      <data key="d1">content</data>
      <data key="d2">A machine instruction is a command in a program that the processor executes directly, composed of opcode and operands.</data>
      <data key="d3">chunk-fe06e06cd53b2ace66af32c5e482dce9</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735812</data>
    </node>
    <node id="ROM">
      <data key="d0">ROM</data>
      <data key="d1">artifact</data>
      <data key="d2">ROM is a read-only memory used to implement control storage for storing microprograms.</data>
      <data key="d3">chunk-fe06e06cd53b2ace66af32c5e482dce9</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735813</data>
    </node>
    <node id="RAM">
      <data key="d0">RAM</data>
      <data key="d1">artifact</data>
      <data key="d2">RAM is a random-access memory used to implement main memory for storing programs and data.</data>
      <data key="d3">chunk-fe06e06cd53b2ace66af32c5e482dce9</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735814</data>
    </node>
    <node id="Microcommand Compatibility">
      <data key="d0">Microcommand Compatibility</data>
      <data key="d1">concept</data>
      <data key="d2">Microcommand compatibility refers to the property that allows certain microcommands to be executed simultaneously without conflict.</data>
      <data key="d3">chunk-fe06e06cd53b2ace66af32c5e482dce9</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735814</data>
    </node>
    <node id="Microcommand Mutual Exclusivity">
      <data key="d0">Microcommand Mutual Exclusivity</data>
      <data key="d1">concept</data>
      <data key="d2">Microcommand mutual exclusivity refers to the condition that certain microcommands cannot be executed simultaneously in the system.</data>
      <data key="d3">chunk-fe06e06cd53b2ace66af32c5e482dce9</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735814</data>
    </node>
    <node id="Control Hazard">
      <data key="d0">Control Hazard</data>
      <data key="d1">concept</data>
      <data key="d2">Control hazard refers to a situation in a processor pipeline where the execution order of instructions is changed due to transfer, return, interrupt, or exception, leading to a disruption in the instruction flow.&lt;SEP&gt;Control hazard occurs due to the uncertainty in branch or jump instructions, disrupting the linear flow of the pipeline.</data>
      <data key="d3">chunk-01427518a698286307aa6708cae3234c&lt;SEP&gt;chunk-951a0e05d8d102dbb38963722260d96a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736217</data>
    </node>
    <node id="Program Counter">
      <data key="d0">Program Counter</data>
      <data key="d1">artifact</data>
      <data key="d2">Program Counter (PC) is a register that holds the address of the next instruction to be executed and is modified during control flow changes.&lt;SEP&gt;The Program Counter (PC) holds the address of the next instruction to be executed and is incremented after each instruction fetch.&lt;SEP&gt;Program Counter holds the address of the next instruction to be executed and automatically increments for sequential execution.&lt;SEP&gt;A program counter is a register that holds the address of the next instruction to be executed, essential in instruction processing.&lt;SEP&gt;The Program Counter (PC) holds the address of the next instruction to be executed.&lt;SEP&gt;A program counter is a register that holds the address of the next instruction to be executed and is maintained independently for each thread in hardware multithreading.&lt;SEP&gt;The program counter is a register that holds the address of the next instruction to be executed and can send its content to the memory address register.</data>
      <data key="d3">chunk-2459f394250f45963236273137f4db0c&lt;SEP&gt;chunk-f67ff7c347b613bc05733f64a51c9c17&lt;SEP&gt;chunk-0efa36a872f0b1511a047f0591cba52c&lt;SEP&gt;chunk-643c2ebb8e3d3384d19f217865cc3b8f&lt;SEP&gt;chunk-01427518a698286307aa6708cae3234c&lt;SEP&gt;chunk-acb6520440fa5141fe4d034f3e5e6edf&lt;SEP&gt;chunk-de401d6e0254effcba3f6fcd81cefe60</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736797</data>
    </node>
    <node id="Branch Instruction">
      <data key="d0">Branch Instruction</data>
      <data key="d1">instruction</data>
      <data key="d2">Branch instruction is a type of command that alters the normal sequential execution of instructions by changing the flow of control.</data>
      <data key="d3">chunk-01427518a698286307aa6708cae3234c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735849</data>
    </node>
    <node id="Pipeline Stall">
      <data key="d0">Pipeline Stall</data>
      <data key="d1">concept</data>
      <data key="d2">Pipeline stall occurs when the execution of subsequent instructions is delayed due to a control hazard or other pipeline blocking condition.&lt;SEP&gt;A pipeline stall occurs when the processor cannot execute the next instruction due to a dependency or delay, such as a cache miss, requiring a pause in execution.</data>
      <data key="d3">chunk-f67ff7c347b613bc05733f64a51c9c17&lt;SEP&gt;chunk-01427518a698286307aa6708cae3234c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736741</data>
    </node>
    <node id="Delay Loss Time Slot C">
      <data key="d0">Delay Loss Time Slot C</data>
      <data key="d1">concept</data>
      <data key="d2">Delay loss time slot C represents the number of clock cycles delayed due to pipeline blocking from control hazards.</data>
      <data key="d3">chunk-01427518a698286307aa6708cae3234c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735849</data>
    </node>
    <node id="NOP Instruction">
      <data key="d0">NOP Instruction</data>
      <data key="d1">instruction</data>
      <data key="d2">NOP (No Operation) instruction is a placeholder used in software to insert idle cycles to resolve timing issues in processor pipelines.&lt;SEP&gt;A NOP (No Operation) instruction is an artificial instruction inserted into the code to delay execution and resolve timing conflicts.</data>
      <data key="d3">chunk-01427518a698286307aa6708cae3234c&lt;SEP&gt;chunk-951a0e05d8d102dbb38963722260d96a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736222</data>
    </node>
    <node id="Branch Prediction">
      <data key="d0">Branch Prediction</data>
      <data key="d1">method</data>
      <data key="d2">Branch prediction is a technique used by processors to guess the outcome of a branch instruction and prefetch the next instruction to reduce pipeline stalls.</data>
      <data key="d3">chunk-01427518a698286307aa6708cae3234c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735849</data>
    </node>
    <node id="Static Branch Prediction">
      <data key="d0">Static Branch Prediction</data>
      <data key="d1">method</data>
      <data key="d2">Static branch prediction is a simple method that uses fixed rules, such as always predicting a branch as not taken.</data>
      <data key="d3">chunk-01427518a698286307aa6708cae3234c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735849</data>
    </node>
    <node id="Dynamic Branch Prediction">
      <data key="d0">Dynamic Branch Prediction</data>
      <data key="d1">method</data>
      <data key="d2">Dynamic branch prediction uses historical data from previous branch executions to make more accurate predictions.&lt;SEP&gt;Dynamic Branch Prediction is a technique used in superscalar CPUs to anticipate the outcome of branch instructions, enabling more efficient out-of-order execution and reducing pipeline stalls.</data>
      <data key="d3">chunk-01427518a698286307aa6708cae3234c&lt;SEP&gt;chunk-3ac380505fdc239a4da36a89716b6444</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736311</data>
    </node>
    <node id="Cache Miss">
      <data key="d0">Cache Miss</data>
      <data key="d1">concept</data>
      <data key="d2">Cache miss occurs when requested data is not found in the cache, causing the processor to access slower main memory and potentially stalling the pipeline.&lt;SEP&gt;A cache miss is a condition in which the requested data is not found in the cache, forcing the processor to fetch it from main memory, causing a delay.</data>
      <data key="d3">chunk-f67ff7c347b613bc05733f64a51c9c17&lt;SEP&gt;chunk-01427518a698286307aa6708cae3234c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736741</data>
    </node>
    <node id="Controller">
      <data key="d0">Controller</data>
      <data key="d1">artifact</data>
      <data key="d2">The controller is a component of the CPU that coordinates and manages the execution of instructions across computer components.</data>
      <data key="d3">chunk-7e297f32d868dbd2d51d7a047e223119</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735890</data>
    </node>
    <node id="Arithmetic Logic Unit">
      <data key="d0">Arithmetic Logic Unit</data>
      <data key="d1">artifact</data>
      <data key="d2">The Arithmetic Logic Unit (ALU) is a component of the CPU responsible for performing arithmetic and logical operations on data.&lt;SEP&gt;Arithmetic Logic Unit is a digital circuit within the CPU that performs arithmetic and logical operations on data.&lt;SEP&gt;An Arithmetic Logic Unit (ALU) is a digital circuit that performs arithmetic and logical operations and is a key component in data paths.&lt;SEP&gt;The Arithmetic Logic Unit (ALU) is a core component of the运算器, responsible for performing arithmetic and logical operations.&lt;SEP&gt;The arithmetic logic unit performs arithmetic and logical operations and requires input data to be held in temporary registers to maintain stability during computation.</data>
      <data key="d3">chunk-2459f394250f45963236273137f4db0c&lt;SEP&gt;chunk-0efa36a872f0b1511a047f0591cba52c&lt;SEP&gt;chunk-7e297f32d868dbd2d51d7a047e223119&lt;SEP&gt;chunk-acb6520440fa5141fe4d034f3e5e6edf&lt;SEP&gt;chunk-de401d6e0254effcba3f6fcd81cefe60</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736797</data>
    </node>
    <node id="Instruction Control">
      <data key="d0">Instruction Control</data>
      <data key="d1">concept</data>
      <data key="d2">Instruction control refers to the process of fetching, analyzing, and executing instructions to manage the sequence of program execution.</data>
      <data key="d3">chunk-7e297f32d868dbd2d51d7a047e223119</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735890</data>
    </node>
    <node id="Operation Control">
      <data key="d0">Operation Control</data>
      <data key="d1">concept</data>
      <data key="d2">Operation control is a CPU function that generates and coordinates signals required to execute instructions across hardware components.</data>
      <data key="d3">chunk-7e297f32d868dbd2d51d7a047e223119</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735890</data>
    </node>
    <node id="Time Control">
      <data key="d0">Time Control</data>
      <data key="d1">concept</data>
      <data key="d2">Time control manages the timing, duration, and sequence of operational signals within the CPU.</data>
      <data key="d3">chunk-7e297f32d868dbd2d51d7a047e223119</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735890</data>
    </node>
    <node id="Data Processing">
      <data key="d0">Data Processing</data>
      <data key="d1">concept</data>
      <data key="d2">Data processing involves performing arithmetic and logical operations on data to produce results.</data>
      <data key="d3">chunk-7e297f32d868dbd2d51d7a047e223119</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735890</data>
    </node>
    <node id="Interrupt Handling">
      <data key="d0">Interrupt Handling</data>
      <data key="d1">concept</data>
      <data key="d2">Interrupt handling deals with the detection and response to abnormal situations or external requests during program execution.</data>
      <data key="d3">chunk-7e297f32d868dbd2d51d7a047e223119</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735890</data>
    </node>
    <node id="Program Execution">
      <data key="d0">Program Execution</data>
      <data key="d1">concept</data>
      <data key="d2">Program execution is the process by which a computer carries out a sequence of instructions stored in memory.</data>
      <data key="d3">chunk-7e297f32d868dbd2d51d7a047e223119</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735891</data>
    </node>
    <node id="Fetch Phase">
      <data key="d0">Fetch Phase</data>
      <data key="d1">concept</data>
      <data key="d2">The fetch phase involves retrieving an instruction from memory and analyzing it, also referred to as the fetch cycle.</data>
      <data key="d3">chunk-643c2ebb8e3d3384d19f217865cc3b8f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735893</data>
    </node>
    <node id="Execute Phase">
      <data key="d0">Execute Phase</data>
      <data key="d1">concept</data>
      <data key="d2">The execute phase is responsible for performing the actual operation specified by the instruction, also known as the execution cycle.</data>
      <data key="d3">chunk-643c2ebb8e3d3384d19f217865cc3b8f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735893</data>
    </node>
    <node id="JMPX Instruction">
      <data key="d0">JMPX Instruction</data>
      <data key="d1">instruction</data>
      <data key="d2">JMPX is an unconditional transfer instruction that does not require accessing main memory during execution, thus only including fetch and execute phases.</data>
      <data key="d3">chunk-643c2ebb8e3d3384d19f217865cc3b8f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735893</data>
    </node>
    <node id="Stack Pointer">
      <data key="d0">Stack Pointer</data>
      <data key="d1">artifact</data>
      <data key="d2">The Stack Pointer (SP) keeps track of the top of the stack, which grows toward lower memory addresses.&lt;SEP&gt;Stack Pointer is a register that indicates the top of the stack in memory, used for managing function calls and local variables.</data>
      <data key="d3">chunk-acb6520440fa5141fe4d034f3e5e6edf&lt;SEP&gt;chunk-643c2ebb8e3d3384d19f217865cc3b8f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735993</data>
    </node>
    <node id="Machine Cycle">
      <data key="d0">Machine Cycle</data>
      <data key="d1">concept</data>
      <data key="d2">A machine cycle is a historical grouping of operations such as fetch, operand fetch, execution, and interrupt response in early computer systems.</data>
      <data key="d3">chunk-643c2ebb8e3d3384d19f217865cc3b8f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735895</data>
    </node>
    <node id="Beat">
      <data key="d0">Beat</data>
      <data key="d1">concept</data>
      <data key="d2">A beat is a subdivision of a machine cycle used in older computer systems to define precise timing for operations.</data>
      <data key="d3">chunk-643c2ebb8e3d3384d19f217865cc3b8f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735895</data>
    </node>
    <node id="Pulse">
      <data key="d0">Pulse</data>
      <data key="d1">concept</data>
      <data key="d2">A pulse is a basic timing unit within a beat used to synchronize internal CPU operations.</data>
      <data key="d3">chunk-643c2ebb8e3d3384d19f217865cc3b8f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735895</data>
    </node>
    <node id="Input/Output Device">
      <data key="d0">Input/Output Device</data>
      <data key="d1">artifact</data>
      <data key="d2">An input/output device is a peripheral component that communicates with the CPU, typically requiring interrupt handling for data transfer.</data>
      <data key="d3">chunk-643c2ebb8e3d3384d19f217865cc3b8f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735895</data>
    </node>
    <node id="Execution Phase">
      <data key="d0">Execution Phase</data>
      <data key="d3">chunk-643c2ebb8e3d3384d19f217865cc3b8f</data>
      <data key="d2">The execution phase follows the indirect addressing cycle only when indirect addressing is used.</data>
      <data key="d1">UNKNOWN</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735899</data>
    </node>
    <node id="CPU Internal Single Bus Architecture">
      <data key="d0">CPU Internal Single Bus Architecture</data>
      <data key="d1">method</data>
      <data key="d2">CPU internal single bus architecture connects ALU and all registers to a single internal bus, resulting in simple design but high data transfer conflicts and low performance.</data>
      <data key="d3">chunk-2a63536239036e36be43b7e72d560b24</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735981</data>
    </node>
    <node id="Single Bus Structure Data Path">
      <data key="d0">Single Bus Structure Data Path</data>
      <data key="d1">concept</data>
      <data key="d2">Single bus structure data path is a basic CPU architecture where all components share a single internal bus, leading to potential data conflicts and limited performance.</data>
      <data key="d3">chunk-2a63536239036e36be43b7e72d560b24</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735981</data>
    </node>
    <node id="Single Cycle Processor">
      <data key="d0">Single Cycle Processor</data>
      <data key="d1">method</data>
      <data key="d2">A single cycle processor (CPI=1) cannot use the single bus method because only one operation can occur per clock cycle, limiting the completion of all instruction steps.&lt;SEP&gt;The single cycle processor executes all instructions within a single clock cycle, requiring each instruction to take the time of the longest instruction, leading to inefficiency for shorter instructions.</data>
      <data key="d3">chunk-3c7856616d478c58fdce251c9a2b68ac&lt;SEP&gt;chunk-2a63536239036e36be43b7e72d560b24</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736780</data>
    </node>
    <node id="CPU Internal Multi Bus Architecture">
      <data key="d0">CPU Internal Multi Bus Architecture</data>
      <data key="d1">method</data>
      <data key="d2">CPU internal multi bus architecture uses two or more buses, enabling simultaneous data transmission across multiple paths and improving instruction execution efficiency.</data>
      <data key="d3">chunk-2a63536239036e36be43b7e72d560b24</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735981</data>
    </node>
    <node id="Multi Bus Structure Data Path">
      <data key="d0">Multi Bus Structure Data Path</data>
      <data key="d1">concept</data>
      <data key="d2">Multi bus structure data path allows multiple data transfers in parallel by connecting registers to multiple public buses, enhancing performance compared to single bus systems.</data>
      <data key="d3">chunk-2a63536239036e36be43b7e72d560b24</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735981</data>
    </node>
    <node id="Dedicated Data Path">
      <data key="d0">Dedicated Data Path</data>
      <data key="d1">method</data>
      <data key="d2">Dedicated data path arranges circuit connections based on data and address flow directions during instruction execution, eliminating shared bus usage and achieving high performance at the cost of increased hardware.</data>
      <data key="d3">chunk-2a63536239036e36be43b7e72d560b24</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735981</data>
    </node>
    <node id="Internal Bus">
      <data key="d0">Internal Bus</data>
      <data key="d1">artifact</data>
      <data key="d2">Internal bus refers to the communication pathways within a single component, such as the CPU, connecting its internal registers and arithmetic units.</data>
      <data key="d3">chunk-2a63536239036e36be43b7e72d560b24</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735981</data>
    </node>
    <node id="System Bus">
      <data key="d0">System Bus</data>
      <data key="d1">artifact</data>
      <data key="d2">System bus connects different components of a computer system, such as the CPU, memory, and I/O interfaces.</data>
      <data key="d3">chunk-2a63536239036e36be43b7e72d560b24</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735981</data>
    </node>
    <node id="Registers">
      <data key="d0">Registers</data>
      <data key="d1">artifact</data>
      <data key="d2">Registers are high-speed storage units within the CPU used to temporarily hold data and instructions during processing.</data>
      <data key="d3">chunk-2a63536239036e36be43b7e72d560b24</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735983</data>
    </node>
    <node id="Performance">
      <data key="d0">Performance</data>
      <data key="d1">concept</data>
      <data key="d2">Performance refers to the efficiency and speed of instruction execution in a data path architecture, influenced by bus structure and data transfer capability.</data>
      <data key="d3">chunk-2a63536239036e36be43b7e72d560b24</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735983</data>
    </node>
    <node id="Data Transfer Conflict">
      <data key="d0">Data Transfer Conflict</data>
      <data key="d1">concept</data>
      <data key="d2">Data transfer conflict occurs when multiple components attempt to use a shared bus simultaneously, leading to bottlenecks and reduced performance in single bus architectures.</data>
      <data key="d3">chunk-2a63536239036e36be43b7e72d560b24</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735983</data>
    </node>
    <node id="Instruction Execution Efficiency">
      <data key="d0">Instruction Execution Efficiency</data>
      <data key="d1">concept</data>
      <data key="d2">Instruction execution efficiency measures how quickly and effectively a processor completes instruction steps, which is improved by multi bus and dedicated data path structures.</data>
      <data key="d3">chunk-2a63536239036e36be43b7e72d560b24</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735983</data>
    </node>
    <node id="Hardware Complexity">
      <data key="d0">Hardware Complexity</data>
      <data key="d1">concept</data>
      <data key="d2">Hardware complexity refers to the physical and circuit design burden of implementing a data path, which increases significantly in dedicated data path systems.</data>
      <data key="d3">chunk-2a63536239036e36be43b7e72d560b24</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735983</data>
    </node>
    <node id="Register">
      <data key="d0">Register</data>
      <data key="d1">artifact</data>
      <data key="d2">Register is a small, fast storage location within the CPU used to hold data, instructions, or addresses temporarily during processing.&lt;SEP&gt;A register is a sequential logic element that stores binary data and is used for temporary storage in data paths.&lt;SEP&gt;A register is a small, fast storage location within the CPU used to hold data temporarily during processing.</data>
      <data key="d3">chunk-acb6520440fa5141fe4d034f3e5e6edf&lt;SEP&gt;chunk-2459f394250f45963236273137f4db0c&lt;SEP&gt;chunk-de401d6e0254effcba3f6fcd81cefe60</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736495</data>
    </node>
    <node id="User Visible Register">
      <data key="d0">User Visible Register</data>
      <data key="d1">artifact</data>
      <data key="d2">User visible registers are accessible to programmers and can be directly manipulated in assembly or machine language to reduce memory access.</data>
      <data key="d3">chunk-acb6520440fa5141fe4d034f3e5e6edf</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735990</data>
    </node>
    <node id="User Invisible Register">
      <data key="d0">User Invisible Register</data>
      <data key="d1">artifact</data>
      <data key="d2">User invisible registers are not accessible to programmers and are used internally by control units to manage CPU operations.</data>
      <data key="d3">chunk-acb6520440fa5141fe4d034f3e5e6edf</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735990</data>
    </node>
    <node id="General Purpose Register Group">
      <data key="d0">General Purpose Register Group</data>
      <data key="d1">artifact</data>
      <data key="d2">General Purpose Register Group consists of registers that store operands, addresses, and intermediate results, such as AX, BX, CX, DX, SP.&lt;SEP&gt;A general purpose register group consists of multiple registers used for storing data and operands during program execution.&lt;SEP&gt;The General Purpose Register Group (GPRs) consists of multiple registers used for general data storage and manipulation in the CPU.&lt;SEP&gt;A general purpose register group is a set of registers allocated uniquely for each thread in hardware multithreading to store thread-specific data.</data>
      <data key="d3">chunk-f67ff7c347b613bc05733f64a51c9c17&lt;SEP&gt;chunk-2459f394250f45963236273137f4db0c&lt;SEP&gt;chunk-acb6520440fa5141fe4d034f3e5e6edf&lt;SEP&gt;chunk-de401d6e0254effcba3f6fcd81cefe60</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736740</data>
    </node>
    <node id="Base Index Register">
      <data key="d0">Base Index Register</data>
      <data key="d1">artifact</data>
      <data key="d2">Base Index Register is a type of register used for address calculation in memory access operations.</data>
      <data key="d3">chunk-acb6520440fa5141fe4d034f3e5e6edf</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735990</data>
    </node>
    <node id="Program Status Word Register">
      <data key="d0">Program Status Word Register</data>
      <data key="d1">artifact</data>
      <data key="d2">Program Status Word Register stores status flags from arithmetic and logic operations, such as overflow, sign, zero, and carry.&lt;SEP&gt;The Program Status Word Register (PSW) stores the status flags (e.g., ZF, SF, OF, CF) resulting from arithmetic and logical operations.</data>
      <data key="d3">chunk-acb6520440fa5141fe4d034f3e5e6edf&lt;SEP&gt;chunk-de401d6e0254effcba3f6fcd81cefe60</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736495</data>
    </node>
    <node id="Memory Address Register">
      <data key="d0">Memory Address Register</data>
      <data key="d1">artifact</data>
      <data key="d2">Memory Address Register stores the address of a memory location to be accessed.&lt;SEP&gt;The memory address register holds the address of the memory location to be accessed and can receive data from the bus.</data>
      <data key="d3">chunk-acb6520440fa5141fe4d034f3e5e6edf&lt;SEP&gt;chunk-0efa36a872f0b1511a047f0591cba52c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736797</data>
    </node>
    <node id="Memory Data Register">
      <data key="d0">Memory Data Register</data>
      <data key="d1">artifact</data>
      <data key="d2">Memory Data Register holds data being transferred to or from memory.&lt;SEP&gt;The memory data register temporarily holds data transferred between the CPU and main memory.</data>
      <data key="d3">chunk-acb6520440fa5141fe4d034f3e5e6edf&lt;SEP&gt;chunk-0efa36a872f0b1511a047f0591cba52c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736797</data>
    </node>
    <node id="Temporary Register">
      <data key="d0">Temporary Register</data>
      <data key="d1">artifact</data>
      <data key="d2">Temporary Register is used to temporarily hold data retrieved from the data bus or general-purpose registers before it is sent to the ALU.</data>
      <data key="d3">chunk-acb6520440fa5141fe4d034f3e5e6edf</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735992</data>
    </node>
    <node id="Accumulator">
      <data key="d0">Accumulator</data>
      <data key="d1">artifact</data>
      <data key="d2">Accumulator is a register used to store intermediate results of arithmetic and logical operations performed by the ALU.&lt;SEP&gt;The accumulator is a register that holds the result of arithmetic and logical operations and can be updated by writing data from temporary register Z.</data>
      <data key="d3">chunk-acb6520440fa5141fe4d034f3e5e6edf&lt;SEP&gt;chunk-0efa36a872f0b1511a047f0591cba52c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736802</data>
    </node>
    <node id="Shift Register">
      <data key="d0">Shift Register</data>
      <data key="d1">artifact</data>
      <data key="d2">Shift Register holds data that can be shifted left or right based on control signals, enabling bit manipulation.&lt;SEP&gt;A shift register is a sequential logic element that shifts data bits through its stages, used for data manipulation.</data>
      <data key="d3">chunk-acb6520440fa5141fe4d034f3e5e6edf&lt;SEP&gt;chunk-2459f394250f45963236273137f4db0c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736388</data>
    </node>
    <node id="Overflow Flag">
      <data key="d0">Overflow Flag</data>
      <data key="d1">artifact</data>
      <data key="d2">Overflow Flag is a single bit in the Program Status Word Register that indicates when the result of an arithmetic operation exceeds the maximum representable value.</data>
      <data key="d3">chunk-acb6520440fa5141fe4d034f3e5e6edf</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735992</data>
    </node>
    <node id="Sign Flag">
      <data key="d0">Sign Flag</data>
      <data key="d1">artifact</data>
      <data key="d2">Sign Flag is a single bit in the Program Status Word Register that indicates whether the result of an operation is negative.</data>
      <data key="d3">chunk-acb6520440fa5141fe4d034f3e5e6edf</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735993</data>
    </node>
    <node id="Zero Flag">
      <data key="d0">Zero Flag</data>
      <data key="d1">artifact</data>
      <data key="d2">Zero Flag is a single bit in the Program Status Word Register that indicates whether the result of an operation is zero.</data>
      <data key="d3">chunk-acb6520440fa5141fe4d034f3e5e6edf</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735993</data>
    </node>
    <node id="Carry Flag">
      <data key="d0">Carry Flag</data>
      <data key="d1">artifact</data>
      <data key="d2">Carry Flag is a single bit in the Program Status Word Register that indicates a carry out from the most significant bit during addition or a borrow in subtraction.</data>
      <data key="d3">chunk-acb6520440fa5141fe4d034f3e5e6edf</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735993</data>
    </node>
    <node id="Assembly Language">
      <data key="d0">Assembly Language</data>
      <data key="d1">method</data>
      <data key="d2">Assembly Language is a low-level programming language that uses symbolic representations of machine instructions.</data>
      <data key="d3">chunk-acb6520440fa5141fe4d034f3e5e6edf</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735993</data>
    </node>
    <node id="Machine Language">
      <data key="d0">Machine Language</data>
      <data key="d1">method</data>
      <data key="d2">Machine Language is a low-level programming language consisting of binary codes directly executed by the CPU.</data>
      <data key="d3">chunk-acb6520440fa5141fe4d034f3e5e6edf</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761735993</data>
    </node>
    <node id="Multi-Core Processor">
      <data key="d0">Multi-Core Processor</data>
      <data key="d1">concept</data>
      <data key="d2">A multi-core processor integrates multiple processing units, called cores, into a single CPU, enabling parallel execution of tasks.</data>
      <data key="d3">chunk-ea027e504c6e7bd731aebc2b71512e1c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736025</data>
    </node>
    <node id="Core">
      <data key="d0">Core</data>
      <data key="d1">artifact</data>
      <data key="d2">A core is an individual processing unit within a multi-core processor, capable of executing instructions independently.</data>
      <data key="d3">chunk-ea027e504c6e7bd731aebc2b71512e1c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736025</data>
    </node>
    <node id="On-Chip Multi-Processor">
      <data key="d0">On-Chip Multi-Processor</data>
      <data key="d1">concept</data>
      <data key="d2">On-chip multi-processor refers to a multi-core processor where multiple cores are integrated onto a single chip.</data>
      <data key="d3">chunk-ea027e504c6e7bd731aebc2b71512e1c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736025</data>
    </node>
    <node id="Cache">
      <data key="d0">Cache</data>
      <data key="d1">artifact</data>
      <data key="d2">Cache is a high-speed memory used by each core or shared among cores to improve data access speed.</data>
      <data key="d3">chunk-ea027e504c6e7bd731aebc2b71512e1c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736025</data>
    </node>
    <node id="Multi-Threaded Execution">
      <data key="d0">Multi-Threaded Execution</data>
      <data key="d1">method</data>
      <data key="d2">Multi-threaded execution is a technique used in multi-core systems where multiple threads run simultaneously to maximize hardware utilization.</data>
      <data key="d3">chunk-ea027e504c6e7bd731aebc2b71512e1c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736025</data>
    </node>
    <node id="Multi-Process Execution">
      <data key="d0">Multi-Process Execution</data>
      <data key="d1">method</data>
      <data key="d2">Multi-process execution refers to running multiple processes concurrently, often used in conjunction with multi-threading to enhance performance.</data>
      <data key="d3">chunk-ea027e504c6e7bd731aebc2b71512e1c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736025</data>
    </node>
    <node id="Parallel Execution">
      <data key="d0">Parallel Execution</data>
      <data key="d1">concept</data>
      <data key="d2">Parallel execution is the simultaneous execution of multiple threads or processes on separate cores, enabling true concurrency.</data>
      <data key="d3">chunk-ea027e504c6e7bd731aebc2b71512e1c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736025</data>
    </node>
    <node id="Interleaved Execution">
      <data key="d0">Interleaved Execution</data>
      <data key="d1">concept</data>
      <data key="d2">Interleaved execution describes the behavior of multi-threading on a single core, where threads take turns and do not execute simultaneously.</data>
      <data key="d3">chunk-ea027e504c6e7bd731aebc2b71512e1c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736026</data>
    </node>
    <node id="Single-Core System">
      <data key="d0">Single-Core System</data>
      <data key="d1">concept</data>
      <data key="d2">A single-core system has only one processing unit and cannot support true parallel execution of threads.</data>
      <data key="d3">chunk-ea027e504c6e7bd731aebc2b71512e1c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736027</data>
    </node>
    <node id="Exception">
      <data key="d0">Exception</data>
      <data key="d1">concept</data>
      <data key="d2">An exception is an unexpected event generated internally by the CPU, detected synchronously during the execution of an instruction.&lt;SEP&gt;An exception is an event occurring during CPU instruction execution that requires immediate handling.&lt;SEP&gt;An exception is a hardware-detected event that occurs during the execution of a specific instruction, such as page fault or overflow.</data>
      <data key="d3">chunk-56dad084d2f83de29d62a2ae33cfc843&lt;SEP&gt;chunk-53c573d4212b8c79ccafbdbdcd65d8e9&lt;SEP&gt;chunk-d405a4a8ff3786f94e93e3a9b7786551</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736656</data>
    </node>
    <node id="Interrupt">
      <data key="d0">Interrupt</data>
      <data key="d1">concept</data>
      <data key="d2">An interrupt is a request from an external device to the CPU, typically for input or output operations, triggered asynchronously.&lt;SEP&gt;An interrupt is a signal requesting the CPU to suspend its current operations and handle a higher-priority task.&lt;SEP&gt;An interrupt is an event from outside the CPU that is unrelated to instruction execution, such as I/O device signals or special events like pressing the Esc key or timer expiration.</data>
      <data key="d3">chunk-56dad084d2f83de29d62a2ae33cfc843&lt;SEP&gt;chunk-53c573d4212b8c79ccafbdbdcd65d8e9&lt;SEP&gt;chunk-d405a4a8ff3786f94e93e3a9b7786551</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736653</data>
    </node>
    <node id="User Program">
      <data key="d0">User Program</data>
      <data key="d1">content</data>
      <data key="d2">User program is the software being executed by the CPU, which can be interrupted or suspended during execution.</data>
      <data key="d3">chunk-53c573d4212b8c79ccafbdbdcd65d8e9</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736064</data>
    </node>
    <node id="Instruction i">
      <data key="d0">Instruction i</data>
      <data key="d1">data</data>
      <data key="d2">Instruction i refers to the i-th instruction in the user program being executed by the CPU.</data>
      <data key="d3">chunk-53c573d4212b8c79ccafbdbdcd65d8e9</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736064</data>
    </node>
    <node id="Interrupt Request Signal">
      <data key="d0">Interrupt Request Signal</data>
      <data key="d1">data</data>
      <data key="d2">Interrupt request signal is a signal sent from an external device to the CPU to initiate an interrupt.</data>
      <data key="d3">chunk-53c573d4212b8c79ccafbdbdcd65d8e9</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736064</data>
    </node>
    <node id="Exception Handling Procedure">
      <data key="d0">Exception Handling Procedure</data>
      <data key="d1">method</data>
      <data key="d2">The exception handling procedure is the process by which the CPU responds to and resolves an exception event.</data>
      <data key="d3">chunk-53c573d4212b8c79ccafbdbdcd65d8e9</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736064</data>
    </node>
    <node id="Interrupt Handling Procedure">
      <data key="d0">Interrupt Handling Procedure</data>
      <data key="d1">method</data>
      <data key="d2">The interrupt handling procedure is the process by which the CPU responds to and resolves an interrupt request.</data>
      <data key="d3">chunk-53c573d4212b8c79ccafbdbdcd65d8e9</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736064</data>
    </node>
    <node id="Operating System">
      <data key="d0">Operating System</data>
      <data key="d1">organization</data>
      <data key="d2">The operating system manages hardware resources and handles exceptions and interrupts through system routines and device drivers.</data>
      <data key="d3">chunk-53c573d4212b8c79ccafbdbdcd65d8e9</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736065</data>
    </node>
    <node id="Device Driver">
      <data key="d0">Device Driver</data>
      <data key="d1">artifact</data>
      <data key="d2">Device driver is a software component that allows the operating system to communicate with hardware devices.</data>
      <data key="d3">chunk-53c573d4212b8c79ccafbdbdcd65d8e9</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736066</data>
    </node>
    <node id="Exception Return Instruction">
      <data key="d0">Exception Return Instruction</data>
      <data key="d1">artifact</data>
      <data key="d2">Exception return instruction is a CPU instruction used to resume execution after an exception has been handled.</data>
      <data key="d3">chunk-53c573d4212b8c79ccafbdbdcd65d8e9</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736066</data>
    </node>
    <node id="Interrupt Return Instruction">
      <data key="d0">Interrupt Return Instruction</data>
      <data key="d1">artifact</data>
      <data key="d2">Interrupt return instruction is a CPU instruction used to resume execution after an interrupt has been handled.</data>
      <data key="d3">chunk-53c573d4212b8c79ccafbdbdcd65d8e9</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736066</data>
    </node>
    <node id="Fatal Error">
      <data key="d0">Fatal Error</data>
      <data key="d1">concept</data>
      <data key="d2">A fatal error is a non-recoverable issue detected during exception or interrupt handling, leading to the termination of the user program.</data>
      <data key="d3">chunk-53c573d4212b8c79ccafbdbdcd65d8e9</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736066</data>
    </node>
    <node id="Synchronous Event">
      <data key="d0">Synchronous Event</data>
      <data key="d1">concept</data>
      <data key="d2">A synchronous event is an occurrence that happens in lockstep with the instruction execution, such as an exception detected by the CPU during instruction processing.</data>
      <data key="d3">chunk-53c573d4212b8c79ccafbdbdcd65d8e9</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736066</data>
    </node>
    <node id="Asynchronous Event">
      <data key="d0">Asynchronous Event</data>
      <data key="d1">concept</data>
      <data key="d2">An asynchronous event is an occurrence that is independent of the current instruction execution, such as an interrupt triggered by an external device.</data>
      <data key="d3">chunk-53c573d4212b8c79ccafbdbdcd65d8e9</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736066</data>
    </node>
    <node id="Instruction i+1">
      <data key="d0">Instruction i+1</data>
      <data key="d1">data</data>
      <data key="d2">Instruction i+1 refers to the next instruction following the i-th instruction in the user program, which the CPU resumes execution from after handling an interrupt.</data>
      <data key="d3">chunk-53c573d4212b8c79ccafbdbdcd65d8e9</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736066</data>
    </node>
    <node id="Interrupt Response Process">
      <data key="d0">Interrupt Response Process</data>
      <data key="d1">process</data>
      <data key="d2">The interrupt response process is the sequence of steps the CPU follows when responding to an interrupt request.</data>
      <data key="d3">chunk-d405a4a8ff3786f94e93e3a9b7786551</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736110</data>
    </node>
    <node id="Exception Response Process">
      <data key="d0">Exception Response Process</data>
      <data key="d1">process</data>
      <data key="d2">The exception response process is the sequence of steps the CPU follows when handling an exception.</data>
      <data key="d3">chunk-d405a4a8ff3786f94e93e3a9b7786551</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736110</data>
    </node>
    <node id="Disable Interrupts">
      <data key="d0">Disable Interrupts</data>
      <data key="d1">method</data>
      <data key="d2">Disable interrupts is a step in the response process to prevent new interrupts from disrupting the current handling.</data>
      <data key="d3">chunk-d405a4a8ff3786f94e93e3a9b7786551</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736110</data>
    </node>
    <node id="Save Breakpoint and Program State">
      <data key="d0">Save Breakpoint and Program State</data>
      <data key="d1">method</data>
      <data key="d2">Saving breakpoint and program state ensures the CPU can resume the interrupted program correctly later.</data>
      <data key="d3">chunk-d405a4a8ff3786f94e93e3a9b7786551</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736110</data>
    </node>
    <node id="Identify Exception and Interrupt and Transfer to Handler">
      <data key="d0">Identify Exception and Interrupt and Transfer to Handler</data>
      <data key="d1">method</data>
      <data key="d2">This method identifies the source of the exception or interrupt and transfers control to the appropriate handler.</data>
      <data key="d3">chunk-d405a4a8ff3786f94e93e3a9b7786551</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736110</data>
    </node>
    <node id="Interrupt Allowance (IF) Trigger">
      <data key="d0">Interrupt Allowance (IF) Trigger</data>
      <data key="d1">artifact</data>
      <data key="d2">The IF trigger controls whether the CPU can respond to interrupts; if set to 1, interrupts are allowed; if set to 0, interrupts are disabled.</data>
      <data key="d3">chunk-d405a4a8ff3786f94e93e3a9b7786551</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736112</data>
    </node>
    <node id="Breakpoint">
      <data key="d0">Breakpoint</data>
      <data key="d1">concept</data>
      <data key="d2">The breakpoint is the return address where the CPU will resume execution after handling the exception or interrupt.&lt;SEP&gt;A breakpoint is a debugging tool that sets a trap to suspend execution at a specific instruction for inspection.</data>
      <data key="d3">chunk-62d730248fb05de6d5c2902d76480b63&lt;SEP&gt;chunk-d405a4a8ff3786f94e93e3a9b7786551</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736278</data>
    </node>
    <node id="Program Status Word (PSW)">
      <data key="d0">Program Status Word (PSW)</data>
      <data key="d1">data</data>
      <data key="d2">The PSW contains the current state of the CPU and must be saved during exception or interrupt handling to restore it later.</data>
      <data key="d3">chunk-d405a4a8ff3786f94e93e3a9b7786551</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736112</data>
    </node>
    <node id="Specific Register">
      <data key="d0">Specific Register</data>
      <data key="d1">artifact</data>
      <data key="d2">A specific register is an alternative storage location to the stack for saving breakpoint and PSW values.</data>
      <data key="d3">chunk-d405a4a8ff3786f94e93e3a9b7786551</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736112</data>
    </node>
    <node id="Exception Status Register">
      <data key="d0">Exception Status Register</data>
      <data key="d1">artifact</data>
      <data key="d2">The exception status register records the cause of an exception and is used in software-based identification.</data>
      <data key="d3">chunk-d405a4a8ff3786f94e93e3a9b7786551</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736112</data>
    </node>
    <node id="Unified Exception or Interrupt Query Program">
      <data key="d0">Unified Exception or Interrupt Query Program</data>
      <data key="d1">content</data>
      <data key="d2">The unified query program is used by the operating system to detect and prioritize exceptions and interrupts.</data>
      <data key="d3">chunk-d405a4a8ff3786f94e93e3a9b7786551</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736112</data>
    </node>
    <node id="Software Identification">
      <data key="d0">Software Identification</data>
      <data key="d1">method</data>
      <data key="d2">Software identification involves using a status register and a query program to determine the type of exception or interrupt.</data>
      <data key="d3">chunk-d405a4a8ff3786f94e93e3a9b7786551</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736112</data>
    </node>
    <node id="Hardware Identification">
      <data key="d0">Hardware Identification</data>
      <data key="d1">method</data>
      <data key="d2">Hardware identification, also known as vector interrupt, uses a vector table to map interrupt type numbers to handler addresses.</data>
      <data key="d3">chunk-d405a4a8ff3786f94e93e3a9b7786551</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736114</data>
    </node>
    <node id="Interrupt Vector">
      <data key="d0">Interrupt Vector</data>
      <data key="d1">data</data>
      <data key="d2">The interrupt vector is the starting address of an interrupt service routine and is stored in the interrupt vector table.</data>
      <data key="d3">chunk-d405a4a8ff3786f94e93e3a9b7786551</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736114</data>
    </node>
    <node id="Interrupt Vector Table">
      <data key="d0">Interrupt Vector Table</data>
      <data key="d1">data</data>
      <data key="d2">The interrupt vector table maps each interrupt type number to its corresponding interrupt vector.</data>
      <data key="d3">chunk-d405a4a8ff3786f94e93e3a9b7786551</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736114</data>
    </node>
    <node id="Interrupt Type Number">
      <data key="d0">Interrupt Type Number</data>
      <data key="d1">data</data>
      <data key="d2">Each interrupt or exception is assigned a unique number used to identify it in the vector table.</data>
      <data key="d3">chunk-d405a4a8ff3786f94e93e3a9b7786551</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736114</data>
    </node>
    <node id="Interrupt Service Program">
      <data key="d0">Interrupt Service Program</data>
      <data key="d1">content</data>
      <data key="d2">The interrupt service program is the routine executed by the CPU after identifying an interrupt, responsible for handling the event.</data>
      <data key="d3">chunk-d405a4a8ff3786f94e93e3a9b7786551</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736114</data>
    </node>
    <node id="Single Interrupt or Exception Handling">
      <data key="d0">Single Interrupt or Exception Handling</data>
      <data key="d1">process</data>
      <data key="d2">The entire response process is atomic and cannot be interrupted during execution.</data>
      <data key="d3">chunk-d405a4a8ff3786f94e93e3a9b7786551</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736114</data>
    </node>
    <node id="微地址形成部件">
      <data key="d0">微地址形成部件</data>
      <data key="d1">artifact</data>
      <data key="d2">The microaddress formation component generates initial and subsequent microaddresses to ensure continuous execution of microinstructions.&lt;SEP&gt;The microaddress formation unit generates the starting address of a microprogram based on the machine instruction's operation code.</data>
      <data key="d3">chunk-7c0597dc102c9fca5be6ec61fc5d051b&lt;SEP&gt;chunk-7b1e3d6a0816b7c4daa74cc9c66df994</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736647</data>
    </node>
    <node id="微指令地址寄存器">
      <data key="d0">微指令地址寄存器</data>
      <data key="d1">artifact</data>
      <data key="d2">The microinstruction address register receives microaddresses from the microaddress formation component and prepares for microinstruction reading.</data>
      <data key="d3">chunk-7b1e3d6a0816b7c4daa74cc9c66df994</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736153</data>
    </node>
    <node id="控制存储器">
      <data key="d0">控制存储器</data>
      <data key="d1">artifact</data>
      <data key="d2">The control memory is the core component of the microprogram controller, storing microprograms corresponding to each machine instruction.&lt;SEP&gt;Control memory stores microinstructions and is used to generate control signals during instruction execution.</data>
      <data key="d3">chunk-96defdcda60eaf79fff26bdc712404aa&lt;SEP&gt;chunk-7b1e3d6a0816b7c4daa74cc9c66df994</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736376</data>
    </node>
    <node id="微指令寄存器">
      <data key="d0">微指令寄存器</data>
      <data key="d1">artifact</data>
      <data key="d2">The microinstruction register holds the microinstruction word, with its bit length equal to the microinstruction word length.</data>
      <data key="d3">chunk-7b1e3d6a0816b7c4daa74cc9c66df994</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736153</data>
    </node>
    <node id="μPC">
      <data key="d0">μPC</data>
      <data key="d1">artifact</data>
      <data key="d2">μPC (Microprogram Counter) stores the address of the current microinstruction and is used to control the flow of microinstruction execution.&lt;SEP&gt;μPC (Microprogram Counter) is the register that holds the address of the current microinstruction being executed.</data>
      <data key="d3">chunk-7c0597dc102c9fca5be6ec61fc5d051b&lt;SEP&gt;chunk-7b1e3d6a0816b7c4daa74cc9c66df994</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736652</data>
    </node>
    <node id="CM">
      <data key="d0">CM</data>
      <data key="d1">artifact</data>
      <data key="d2">CM (Control Memory) refers to the control storage used to hold microprograms for various machine instructions.</data>
      <data key="d3">chunk-7b1e3d6a0816b7c4daa74cc9c66df994</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736153</data>
    </node>
    <node id="指令寄存器">
      <data key="d0">指令寄存器</data>
      <data key="d1">artifact</data>
      <data key="d2">The instruction register stores the machine instruction fetched from main memory after execution of the fetch microprogram.</data>
      <data key="d3">chunk-7b1e3d6a0816b7c4daa74cc9c66df994</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736153</data>
    </node>
    <node id="取指微程序">
      <data key="d0">取指微程序</data>
      <data key="d1">method</data>
      <data key="d2">The fetch microprogram is a standardized microprogram responsible for fetching machine instructions from main memory and loading them into the instruction register.</data>
      <data key="d3">chunk-7b1e3d6a0816b7c4daa74cc9c66df994</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736156</data>
    </node>
    <node id="间址周期微程序">
      <data key="d0">间址周期微程序</data>
      <data key="d1">method</data>
      <data key="d2">The indirect addressing cycle microprogram handles the specific microcommands required during the indirect addressing phase of instruction execution.</data>
      <data key="d3">chunk-7b1e3d6a0816b7c4daa74cc9c66df994</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736156</data>
    </node>
    <node id="中断周期微程序">
      <data key="d0">中断周期微程序</data>
      <data key="d1">method</data>
      <data key="d2">The interrupt cycle microprogram manages the microcommands needed during the interrupt handling phase of execution.</data>
      <data key="d3">chunk-7b1e3d6a0816b7c4daa74cc9c66df994</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736156</data>
    </node>
    <node id="机器指令">
      <data key="d0">机器指令</data>
      <data key="d1">concept</data>
      <data key="d2">A machine instruction is a low-level command executed directly by a computer's processor, each corresponding to a specific microprogram.</data>
      <data key="d3">chunk-7b1e3d6a0816b7c4daa74cc9c66df994</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736156</data>
    </node>
    <node id="微程序">
      <data key="d0">微程序</data>
      <data key="d1">concept</data>
      <data key="d2">A microprogram is a sequence of microinstructions that collectively implement a single machine instruction.</data>
      <data key="d3">chunk-7b1e3d6a0816b7c4daa74cc9c66df994</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736156</data>
    </node>
    <node id="μIR">
      <data key="d0">μIR</data>
      <data key="d1">artifact</data>
      <data key="d2">μIR (Microinstruction Register) is the component that receives and holds the microinstruction read from the control memory during execution.</data>
      <data key="d3">chunk-7b1e3d6a0816b7c4daa74cc9c66df994</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736156</data>
    </node>
    <node id="Instruction Pipeline">
      <data key="d0">Instruction Pipeline</data>
      <data key="d1">concept</data>
      <data key="d2">The instruction pipeline is a technique in computer architecture that allows multiple instructions to be processed at different stages simultaneously, but can experience stalls due to various types of hazards.</data>
      <data key="d3">chunk-951a0e05d8d102dbb38963722260d96a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736217</data>
    </node>
    <node id="Pipeline Hazard">
      <data key="d0">Pipeline Hazard</data>
      <data key="d1">concept</data>
      <data key="d2">Pipeline hazard refers to a situation in which subsequent instructions cannot execute correctly, causing a stall in the instruction pipeline.</data>
      <data key="d3">chunk-951a0e05d8d102dbb38963722260d96a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736217</data>
    </node>
    <node id="Structural Hazard">
      <data key="d0">Structural Hazard</data>
      <data key="d1">concept</data>
      <data key="d2">Structural hazard occurs when multiple instructions attempt to use the same hardware resource at the same time, also known as resource conflict.</data>
      <data key="d3">chunk-951a0e05d8d102dbb38963722260d96a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736217</data>
    </node>
    <node id="Data Hazard">
      <data key="d0">Data Hazard</data>
      <data key="d1">concept</data>
      <data key="d2">Data hazard arises when a later instruction depends on the result of an earlier instruction that has not yet been produced.</data>
      <data key="d3">chunk-951a0e05d8d102dbb38963722260d96a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736217</data>
    </node>
    <node id="Read After Write Conflict">
      <data key="d0">Read After Write Conflict</data>
      <data key="d1">concept</data>
      <data key="d2">Read After Write (RAW) conflict is a type of data hazard where a subsequent instruction attempts to read a register before the preceding instruction has written to it.</data>
      <data key="d3">chunk-951a0e05d8d102dbb38963722260d96a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736217</data>
    </node>
    <node id="Memory Access Conflict">
      <data key="d0">Memory Access Conflict</data>
      <data key="d1">concept</data>
      <data key="d2">Memory access conflict occurs when two instructions attempt to access the same memory unit simultaneously, such as during instruction fetch and data load.</data>
      <data key="d3">chunk-951a0e05d8d102dbb38963722260d96a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736217</data>
    </node>
    <node id="Load Instruction">
      <data key="d0">Load Instruction</data>
      <data key="d1">instruction</data>
      <data key="d2">A load instruction retrieves data from memory and stores it in a register, commonly causing data hazards if followed by an instruction that uses the loaded value.</data>
      <data key="d3">chunk-951a0e05d8d102dbb38963722260d96a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736217</data>
    </node>
    <node id="Add Instruction">
      <data key="d0">Add Instruction</data>
      <data key="d1">instruction</data>
      <data key="d2">An add instruction performs addition between two registers and stores the result in a destination register, often subject to data hazards.</data>
      <data key="d3">chunk-951a0e05d8d102dbb38963722260d96a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736220</data>
    </node>
    <node id="L1 Cache">
      <data key="d0">L1 Cache</data>
      <data key="d1">artifact</data>
      <data key="d2">L1 Cache is the first-level on-chip cache in a processor, often split into separate instruction and data caches to avoid resource conflicts.</data>
      <data key="d3">chunk-951a0e05d8d102dbb38963722260d96a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736220</data>
    </node>
    <node id="Instruction Memory">
      <data key="d0">Instruction Memory</data>
      <data key="d1">artifact</data>
      <data key="d2">Instruction memory stores the program instructions and is accessed during the instruction fetch stage of the pipeline.</data>
      <data key="d3">chunk-951a0e05d8d102dbb38963722260d96a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736220</data>
    </node>
    <node id="Data Memory">
      <data key="d0">Data Memory</data>
      <data key="d1">artifact</data>
      <data key="d2">Data memory stores data and is used during the memory access stage of the pipeline.</data>
      <data key="d3">chunk-951a0e05d8d102dbb38963722260d96a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736220</data>
    </node>
    <node id="Register Read Port">
      <data key="d0">Register Read Port</data>
      <data key="d1">artifact</data>
      <data key="d2">The register read port is a component used to read values from registers during instruction execution.</data>
      <data key="d3">chunk-951a0e05d8d102dbb38963722260d96a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736220</data>
    </node>
    <node id="Register Write Port">
      <data key="d0">Register Write Port</data>
      <data key="d1">artifact</data>
      <data key="d2">The register write port is a component used to write results back to registers during the write-back stage.</data>
      <data key="d3">chunk-951a0e05d8d102dbb38963722260d96a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736220</data>
    </node>
    <node id="Forwarding Path">
      <data key="d0">Forwarding Path</data>
      <data key="d1">artifact</data>
      <data key="d2">A forwarding path, or bypass path, is a dedicated circuit in a processor that forwards results directly from one stage to another, avoiding delays due to data hazards.</data>
      <data key="d3">chunk-951a0e05d8d102dbb38963722260d96a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736220</data>
    </node>
    <node id="Compiler Optimization">
      <data key="d0">Compiler Optimization</data>
      <data key="d1">method</data>
      <data key="d2">Compiler optimization is a technique used to rearrange instructions during compilation to avoid hazards like load-use conflicts.</data>
      <data key="d3">chunk-951a0e05d8d102dbb38963722260d96a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736223</data>
    </node>
    <node id="Load-Use Data Hazard">
      <data key="d0">Load-Use Data Hazard</data>
      <data key="d1">concept</data>
      <data key="d2">A load-use data hazard occurs when a load instruction is immediately followed by an instruction that uses the loaded value, and the data is not yet available.</data>
      <data key="d3">chunk-951a0e05d8d102dbb38963722260d96a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736223</data>
    </node>
    <node id="Memory Stage">
      <data key="d0">Memory Stage</data>
      <data key="d1">stage</data>
      <data key="d2">The memory stage (MEM) is the phase in a pipeline where data is accessed from memory or stored back to memory.</data>
      <data key="d3">chunk-951a0e05d8d102dbb38963722260d96a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736223</data>
    </node>
    <node id="Write-Back Stage">
      <data key="d0">Write-Back Stage</data>
      <data key="d1">concept</data>
      <data key="d2">The write-back stage (WB) is the final phase in a pipelined processor where the result of an instruction is written back to a register.&lt;SEP&gt;Write-Back Stage is the fifth stage in the instruction pipeline, responsible for writing the result back to a register.</data>
      <data key="d3">chunk-951a0e05d8d102dbb38963722260d96a&lt;SEP&gt;chunk-5ea0f23d1c767bafc743ff484eb189e1</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736485</data>
    </node>
    <node id="Instruction Fetch Stage">
      <data key="d0">Instruction Fetch Stage</data>
      <data key="d1">stage</data>
      <data key="d2">The instruction fetch stage (IF) is the first phase in a pipeline, where the next instruction is fetched from memory.</data>
      <data key="d3">chunk-951a0e05d8d102dbb38963722260d96a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736223</data>
    </node>
    <node id="Execute Stage">
      <data key="d0">Execute Stage</data>
      <data key="d1">concept</data>
      <data key="d2">The execute stage (EX) is the phase where arithmetic and logical operations are performed.&lt;SEP&gt;Execute Stage is the third stage in the instruction pipeline, responsible for performing arithmetic or logical operations.</data>
      <data key="d3">chunk-951a0e05d8d102dbb38963722260d96a&lt;SEP&gt;chunk-5ea0f23d1c767bafc743ff484eb189e1</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736485</data>
    </node>
    <node id="Register File">
      <data key="d0">Register File</data>
      <data key="d1">artifact</data>
      <data key="d2">The register file is a small, fast storage unit that holds processor registers and provides read/write ports.</data>
      <data key="d3">chunk-951a0e05d8d102dbb38963722260d96a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736223</data>
    </node>
    <node id="Non-OutOfOrder Execution">
      <data key="d0">Non-OutOfOrder Execution</data>
      <data key="d1">concept</data>
      <data key="d2">Non-out-of-order execution refers to a pipelining model where instructions are executed strictly in program order, preventing speculation and limiting data hazard types to only Read After Write (RAW) conflicts.</data>
      <data key="d3">chunk-951a0e05d8d102dbb38963722260d96a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736225</data>
    </node>
    <node id="Resource Conflict">
      <data key="d0">Resource Conflict</data>
      <data key="d3">chunk-951a0e05d8d102dbb38963722260d96a</data>
      <data key="d2">Structural hazards are also referred to as resource conflicts caused by limited hardware components being accessed by multiple instructions at once.</data>
      <data key="d1">UNKNOWN</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736228</data>
    </node>
    <node id="Execution Stage">
      <data key="d0">Execution Stage</data>
      <data key="d3">chunk-951a0e05d8d102dbb38963722260d96a</data>
      <data key="d2">The execute stage produces results that may be forwarded to the write-back stage for register update.</data>
      <data key="d1">UNKNOWN</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736231</data>
    </node>
    <node id="Hard Fault Interrupt">
      <data key="d0">Hard Fault Interrupt</data>
      <data key="d1">concept</data>
      <data key="d2">Hard fault interrupt is an exception caused by hardware-level issues such as memory parity errors or bus errors.</data>
      <data key="d3">chunk-62d730248fb05de6d5c2902d76480b63</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736278</data>
    </node>
    <node id="Programmable Exception">
      <data key="d0">Programmable Exception</data>
      <data key="d1">concept</data>
      <data key="d2">Programmable exception, also known as software interrupt, is an exception triggered by the execution of specific instructions within the CPU.</data>
      <data key="d3">chunk-62d730248fb05de6d5c2902d76480b63</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736278</data>
    </node>
    <node id="Division By Zero">
      <data key="d0">Division By Zero</data>
      <data key="d1">concept</data>
      <data key="d2">Division by zero is a type of programmatic exception that occurs when an integer division operation has a divisor of zero.</data>
      <data key="d3">chunk-62d730248fb05de6d5c2902d76480b63</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736278</data>
    </node>
    <node id="Overflow">
      <data key="d0">Overflow</data>
      <data key="d1">concept</data>
      <data key="d2">Overflow is a programmatic exception that occurs when a calculation exceeds the maximum value representable in a given data format.</data>
      <data key="d3">chunk-62d730248fb05de6d5c2902d76480b63</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736278</data>
    </node>
    <node id="Single Step Tracking">
      <data key="d0">Single Step Tracking</data>
      <data key="d1">concept</data>
      <data key="d2">Single step tracking is a debugging technique where the CPU executes one instruction at a time, often using a trap mechanism.</data>
      <data key="d3">chunk-62d730248fb05de6d5c2902d76480b63</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736278</data>
    </node>
    <node id="Illegal Instruction">
      <data key="d0">Illegal Instruction</data>
      <data key="d1">concept</data>
      <data key="d2">An illegal instruction is a programmatic exception that occurs when the CPU attempts to execute an unrecognized or invalid instruction.</data>
      <data key="d3">chunk-62d730248fb05de6d5c2902d76480b63</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736278</data>
    </node>
    <node id="Stack Overflow">
      <data key="d0">Stack Overflow</data>
      <data key="d1">concept</data>
      <data key="d2">Stack overflow is a programmatic exception caused by excessive use of the call stack.</data>
      <data key="d3">chunk-62d730248fb05de6d5c2902d76480b63</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736281</data>
    </node>
    <node id="Address Out Of Bounds">
      <data key="d0">Address Out Of Bounds</data>
      <data key="d1">concept</data>
      <data key="d2">Address out of bounds is a programmatic exception that occurs when memory access exceeds valid address limits.</data>
      <data key="d3">chunk-62d730248fb05de6d5c2902d76480b63</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736281</data>
    </node>
    <node id="Page Fault">
      <data key="d0">Page Fault</data>
      <data key="d1">concept</data>
      <data key="d2">A page fault is a programmatic exception indicating that required memory pages are not currently in main memory.</data>
      <data key="d3">chunk-62d730248fb05de6d5c2902d76480b63</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736281</data>
    </node>
    <node id="Segment Fault">
      <data key="d0">Segment Fault</data>
      <data key="d1">concept</data>
      <data key="d2">A segment fault is a programmatic exception caused by an invalid memory segment access.</data>
      <data key="d3">chunk-62d730248fb05de6d5c2902d76480b63</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736281</data>
    </node>
    <node id="Fault">
      <data key="d0">Fault</data>
      <data key="d1">concept</data>
      <data key="d2">A fault is a type of exception detected before an instruction completes, allowing potential recovery by restarting the instruction.</data>
      <data key="d3">chunk-62d730248fb05de6d5c2902d76480b63</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736281</data>
    </node>
    <node id="Trap">
      <data key="d0">Trap</data>
      <data key="d1">concept</data>
      <data key="d2">A trap is a prearranged exception triggered by a specific instruction, used for system calls or debugging.</data>
      <data key="d3">chunk-62d730248fb05de6d5c2902d76480b63</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736281</data>
    </node>
    <node id="Abort">
      <data key="d0">Abort</data>
      <data key="d1">concept</data>
      <data key="d2">An abort is a type of exception caused by serious hardware faults that prevent program execution and require system restart.</data>
      <data key="d3">chunk-62d730248fb05de6d5c2902d76480b63</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736281</data>
    </node>
    <node id="System Call">
      <data key="d0">System Call</data>
      <data key="d1">concept</data>
      <data key="d2">A system call is a mechanism enabling user programs to request services from the operating system kernel.</data>
      <data key="d3">chunk-62d730248fb05de6d5c2902d76480b63</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736283</data>
    </node>
    <node id="x86 Machine">
      <data key="d0">x86 Machine</data>
      <data key="d1">artifact</data>
      <data key="d2">The x86 machine is a processor architecture that implements debugging features such as breakpoints and single-step tracking via trap mechanism.</data>
      <data key="d3">chunk-62d730248fb05de6d5c2902d76480b63</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736283</data>
    </node>
    <node id="MIPS Architecture">
      <data key="d0">MIPS Architecture</data>
      <data key="d1">artifact</data>
      <data key="d2">The MIPS architecture is a processor architecture that includes conditional trap instructions such as teq, teqi, tne, and tnei.</data>
      <data key="d3">chunk-62d730248fb05de6d5c2902d76480b63</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736283</data>
    </node>
    <node id="Memory Parity Error">
      <data key="d0">Memory Parity Error</data>
      <data key="d1">naturalobject</data>
      <data key="d2">Memory parity error is a hardware-level fault indicating data corruption in memory.</data>
      <data key="d3">chunk-62d730248fb05de6d5c2902d76480b63</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736283</data>
    </node>
    <node id="Bus Error">
      <data key="d0">Bus Error</data>
      <data key="d1">naturalobject</data>
      <data key="d2">A bus error is a hardware fault caused by abnormal communication on the computer's data bus.</data>
      <data key="d3">chunk-62d730248fb05de6d5c2902d76480b63</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736283</data>
    </node>
    <node id="Controller Error">
      <data key="d0">Controller Error</data>
      <data key="d1">naturalobject</data>
      <data key="d2">A controller error is a hardware fault in a system controller that prevents normal operation.</data>
      <data key="d3">chunk-62d730248fb05de6d5c2902d76480b63</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736283</data>
    </node>
    <node id="Page">
      <data key="d0">Page</data>
      <data key="d1">artifact</data>
      <data key="d2">A page is a fixed-size block of memory used in virtual memory management.</data>
      <data key="d3">chunk-62d730248fb05de6d5c2902d76480b63</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736283</data>
    </node>
    <node id="Segment">
      <data key="d0">Segment</data>
      <data key="d1">artifact</data>
      <data key="d2">A segment is a block of memory with defined boundaries, used in segmented memory systems.</data>
      <data key="d3">chunk-62d730248fb05de6d5c2902d76480b63</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736285</data>
    </node>
    <node id="Disk">
      <data key="d0">Disk</data>
      <data key="d1">naturalobject</data>
      <data key="d2">Disk refers to secondary storage, such as hard drives or SSDs, used to store data persistently.</data>
      <data key="d3">chunk-62d730248fb05de6d5c2902d76480b63</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736285</data>
    </node>
    <node id="Operating System Kernel">
      <data key="d0">Operating System Kernel</data>
      <data key="d1">organization</data>
      <data key="d2">The operating system kernel is the core component of an operating system responsible for managing system resources and hardware interactions.</data>
      <data key="d3">chunk-62d730248fb05de6d5c2902d76480b63</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736285</data>
    </node>
    <node id="Exception Service Routine">
      <data key="d0">Exception Service Routine</data>
      <data key="d1">concept</data>
      <data key="d2">An exception service routine is a piece of code executed in response to an exception to handle or recover from it.</data>
      <data key="d3">chunk-62d730248fb05de6d5c2902d76480b63</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736285</data>
    </node>
    <node id="Advanced Pipeline Technology">
      <data key="d0">Advanced Pipeline Technology</data>
      <data key="d1">method</data>
      <data key="d2">Advanced Pipeline Technology refers to techniques for increasing instruction-level parallelism in processors, including superscalar, very long instruction word, and superpipeline methods.</data>
      <data key="d3">chunk-3ac380505fdc239a4da36a89716b6444</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736306</data>
    </node>
    <node id="Multiple Issuance Technology">
      <data key="d0">Multiple Issuance Technology</data>
      <data key="d1">method</data>
      <data key="d2">Multiple Issuance Technology enables simultaneous processing of multiple instructions by utilizing multiple internal functional units, allowing multiple instructions to be issued into the pipeline in a single clock cycle.</data>
      <data key="d3">chunk-3ac380505fdc239a4da36a89716b6444</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736306</data>
    </node>
    <node id="Superpipeline Technology">
      <data key="d0">Superpipeline Technology</data>
      <data key="d1">method</data>
      <data key="d2">Superpipeline Technology increases the number of pipeline stages to allow more instructions to overlap in execution, enhancing instruction throughput by reducing the clock cycle duration.</data>
      <data key="d3">chunk-3ac380505fdc239a4da36a89716b6444</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736306</data>
    </node>
    <node id="Superscalar Pipeline Technology">
      <data key="d0">Superscalar Pipeline Technology</data>
      <data key="d1">method</data>
      <data key="d2">Superscalar Pipeline Technology, also known as dynamic multiple issuance, executes two or more independent instructions per clock cycle through parallel operation, requiring multiple functional units and often employing dynamic scheduling and out-of-order execution.</data>
      <data key="d3">chunk-3ac380505fdc239a4da36a89716b6444</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736306</data>
    </node>
    <node id="Very Long Instruction Word Technology">
      <data key="d0">Very Long Instruction Word Technology</data>
      <data key="d1">method</data>
      <data key="d2">Very Long Instruction Word Technology, also known as static multiple issuance, uses a compiler to identify parallel instruction opportunities and combines them into a single, extended instruction word containing multiple operation fields, requiring multiple processing units.</data>
      <data key="d3">chunk-3ac380505fdc239a4da36a89716b6444</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736306</data>
    </node>
    <node id="Dynamic Pipeline Scheduling">
      <data key="d0">Dynamic Pipeline Scheduling</data>
      <data key="d1">method</data>
      <data key="d2">Dynamic Pipeline Scheduling enables out-of-order execution by applying techniques such as dynamic branch prediction to optimize instruction scheduling and improve parallelism.</data>
      <data key="d3">chunk-3ac380505fdc239a4da36a89716b6444</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736306</data>
    </node>
    <node id="Out-of-Order Execution">
      <data key="d0">Out-of-Order Execution</data>
      <data key="d1">method</data>
      <data key="d2">Out-of-Order Execution is a technique where instructions are executed not strictly in program order, but based on data availability and execution readiness, enhancing processing efficiency and throughput.</data>
      <data key="d3">chunk-3ac380505fdc239a4da36a89716b6444</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736306</data>
    </node>
    <node id="Instruction Throughput">
      <data key="d0">Instruction Throughput</data>
      <data key="d1">concept</data>
      <data key="d2">Instruction throughput refers to the number of instructions executed per unit of time, a key metric for measuring processor performance.</data>
      <data key="d3">chunk-3ac380505fdc239a4da36a89716b6444</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736308</data>
    </node>
    <node id="CPI">
      <data key="d0">CPI</data>
      <data key="d1">concept</data>
      <data key="d2">CPI (Cycles Per Instruction) measures the average number of clock cycles required to execute one instruction, with lower values indicating higher efficiency.&lt;SEP&gt;CPI (Cycles Per Instruction) measures the average number of clock cycles required to execute an instruction, with CPI=1 indicating optimal performance per instruction.</data>
      <data key="d3">chunk-3ac380505fdc239a4da36a89716b6444&lt;SEP&gt;chunk-3c7856616d478c58fdce251c9a2b68ac</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736780</data>
    </node>
    <node id="Pipeline Register Overhead">
      <data key="d0">Pipeline Register Overhead</data>
      <data key="d1">concept</data>
      <data key="d2">Pipeline Register Overhead refers to the resource cost associated with maintaining registers between pipeline stages, which increases with the number of pipeline stages.</data>
      <data key="d3">chunk-3ac380505fdc239a4da36a89716b6444</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736309</data>
    </node>
    <node id="Functional Unit">
      <data key="d0">Functional Unit</data>
      <data key="d1">artifact</data>
      <data key="d2">A Functional Unit is a hardware component within a processor responsible for performing specific operations such as arithmetic or logic calculations.&lt;SEP&gt;A functional unit is a hardware component within a processor that performs specific operations, such as arithmetic or logic calculations.</data>
      <data key="d3">chunk-f67ff7c347b613bc05733f64a51c9c17&lt;SEP&gt;chunk-3ac380505fdc239a4da36a89716b6444</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736741</data>
    </node>
    <node id="Compiler">
      <data key="d0">Compiler</data>
      <data key="d1">artifact</data>
      <data key="d2">A Compiler is a software tool that translates high-level programming code into machine code, enabling the extraction of parallelism in Very Long Instruction Word technology.</data>
      <data key="d3">chunk-3ac380505fdc239a4da36a89716b6444</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736309</data>
    </node>
    <node id="Figure 5.19">
      <data key="d0">Figure 5.19</data>
      <data key="d1">content</data>
      <data key="d2">Figure 5.19 is a diagram illustrating the configuration of multiple functional units in a simple superscalar CPU.</data>
      <data key="d3">chunk-3ac380505fdc239a4da36a89716b6444</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736309</data>
    </node>
    <node id="Instruction-Level Parallelism">
      <data key="d0">Instruction-Level Parallelism</data>
      <data key="d1">concept</data>
      <data key="d2">Instruction-Level Parallelism refers to the ability of a processor to execute multiple instructions simultaneously, improving overall performance.&lt;SEP&gt;Instruction-level parallelism refers to the ability of a processor to execute multiple instructions simultaneously within a single thread.</data>
      <data key="d3">chunk-f67ff7c347b613bc05733f64a51c9c17&lt;SEP&gt;chunk-3ac380505fdc239a4da36a89716b6444</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736741</data>
    </node>
    <node id="Simple Superscalar CPU">
      <data key="d0">Simple Superscalar CPU</data>
      <data key="d1">artifact</data>
      <data key="d2">A Simple Superscalar CPU is a type of processor where instructions are issued and executed in program order, serving as a baseline model before advanced scheduling techniques are applied.</data>
      <data key="d3">chunk-3ac380505fdc239a4da36a89716b6444</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736309</data>
    </node>
    <node id="微指令的编码方式">
      <data key="d0">微指令的编码方式</data>
      <data key="d1">concept</data>
      <data key="d2">Microinstruction encoding method refers to the technique used to encode control fields in microinstructions to generate control signals.</data>
      <data key="d3">chunk-96defdcda60eaf79fff26bdc712404aa</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736376</data>
    </node>
    <node id="直接编码方式">
      <data key="d0">直接编码方式</data>
      <data key="d1">method</data>
      <data key="d2">Direct encoding method involves setting each bit in the control field to directly represent a microcommand without requiring decoding.</data>
      <data key="d3">chunk-96defdcda60eaf79fff26bdc712404aa</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736376</data>
    </node>
    <node id="字段直接编码方式">
      <data key="d0">字段直接编码方式</data>
      <data key="d1">method</data>
      <data key="d2">Field direct encoding method divides the control field into smaller fields, grouping mutually exclusive microcommands in the same field and compatible ones in different fields, with independent encoding for each field.</data>
      <data key="d3">chunk-96defdcda60eaf79fff26bdc712404aa</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736376</data>
    </node>
    <node id="字段间接编码方式">
      <data key="d0">字段间接编码方式</data>
      <data key="d1">method</data>
      <data key="d2">Field indirect encoding method allows some microcommands in one field to be interpreted by microcommands in another field, resulting in implicit or hidden decoding.</data>
      <data key="d3">chunk-96defdcda60eaf79fff26bdc712404aa</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736376</data>
    </node>
    <node id="微指令的操作控制字段">
      <data key="d0">微指令的操作控制字段</data>
      <data key="d1">artifact</data>
      <data key="d2">The operation control field of a microinstruction is the part responsible for specifying control signals and microcommands.</data>
      <data key="d3">chunk-96defdcda60eaf79fff26bdc712404aa</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736376</data>
    </node>
    <node id="微命令">
      <data key="d0">微命令</data>
      <data key="d1">concept</data>
      <data key="d2">A microcommand is a signal that controls a specific microoperation in the data path.</data>
      <data key="d3">chunk-96defdcda60eaf79fff26bdc712404aa</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736376</data>
    </node>
    <node id="微操作">
      <data key="d0">微操作</data>
      <data key="d1">concept</data>
      <data key="d2">A microoperation is a fundamental operation executed in the data path of a processor.</data>
      <data key="d3">chunk-96defdcda60eaf79fff26bdc712404aa</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736376</data>
    </node>
    <node id="译码电路">
      <data key="d0">译码电路</data>
      <data key="d1">artifact</data>
      <data key="d2">Decoding circuitry converts encoded field signals into actual microcommands.</data>
      <data key="d3">chunk-96defdcda60eaf79fff26bdc712404aa</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736378</data>
    </node>
    <node id="互斥性微命令">
      <data key="d0">互斥性微命令</data>
      <data key="d1">concept</data>
      <data key="d2">Mutually exclusive microcommands are those that cannot be executed simultaneously and are grouped within the same field in field direct encoding.</data>
      <data key="d3">chunk-96defdcda60eaf79fff26bdc712404aa</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736379</data>
    </node>
    <node id="相容性微命令">
      <data key="d0">相容性微命令</data>
      <data key="d1">concept</data>
      <data key="d2">Compatible microcommands are those that can be executed simultaneously and are placed in different fields in field direct encoding.</data>
      <data key="d3">chunk-96defdcda60eaf79fff26bdc712404aa</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736379</data>
    </node>
    <node id="小段">
      <data key="d0">小段</data>
      <data key="d1">concept</data>
      <data key="d2">A small segment refers to a subdivided portion of the operation control field in field direct encoding.</data>
      <data key="d3">chunk-96defdcda60eaf79fff26bdc712404aa</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736379</data>
    </node>
    <node id="操作并行性">
      <data key="d0">操作并行性</data>
      <data key="d1">concept</data>
      <data key="d2">Operation parallelism refers to the ability of multiple microoperations to execute simultaneously.</data>
      <data key="d3">chunk-96defdcda60eaf79fff26bdc712404aa</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736379</data>
    </node>
    <node id="微指令字长">
      <data key="d0">微指令字长</data>
      <data key="d1">concept</data>
      <data key="d2">Microinstruction word length is the number of bits used to represent a microinstruction.</data>
      <data key="d3">chunk-96defdcda60eaf79fff26bdc712404aa</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736379</data>
    </node>
    <node id="控制存储器容量">
      <data key="d0">控制存储器容量</data>
      <data key="d1">concept</data>
      <data key="d2">Control memory capacity refers to the storage size required for storing microinstructions, which is significantly increased in direct encoding due to long microinstruction word lengths.</data>
      <data key="d3">chunk-96defdcda60eaf79fff26bdc712404aa</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736379</data>
    </node>
    <node id="3位字段">
      <data key="d0">3位字段</data>
      <data key="d1">artifact</data>
      <data key="d2">A 3-bit field can represent up to 7 distinct microcommands, with 000 reserved for indicating no operation.</data>
      <data key="d3">chunk-96defdcda60eaf79fff26bdc712404aa</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736379</data>
    </node>
    <node id="Data Path">
      <data key="d0">Data Path</data>
      <data key="d1">concept</data>
      <data key="d2">A data path is a component in computing systems that facilitates the movement and processing of data, consisting of combination and sequential logic elements.&lt;SEP&gt;Data Path is the collection of functional units and connections through which data flows in a processor.&lt;SEP&gt;The Data Path is the functional unit within the CPU responsible for data flow and manipulation, including the ALU and registers.&lt;SEP&gt;The Data Path is the component of a CPU that handles the flow of data during instruction execution, encompassing the routes and functional units data passes through.</data>
      <data key="d3">chunk-cf0a63e25f70bb6e12f2ee7720496542&lt;SEP&gt;chunk-2459f394250f45963236273137f4db0c&lt;SEP&gt;chunk-de401d6e0254effcba3f6fcd81cefe60&lt;SEP&gt;chunk-5ea0f23d1c767bafc743ff484eb189e1</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736549</data>
    </node>
    <node id="Combinational Logic Element">
      <data key="d0">Combinational Logic Element</data>
      <data key="d1">concept</data>
      <data key="d2">A combinational logic element is a type of circuit whose output depends solely on current inputs, with no memory or clock control, and features unidirectional signal flow.</data>
      <data key="d3">chunk-2459f394250f45963236273137f4db0c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736385</data>
    </node>
    <node id="Sequential Logic Element">
      <data key="d0">Sequential Logic Element</data>
      <data key="d1">concept</data>
      <data key="d2">A sequential logic element is a circuit whose output depends on current inputs and previous states, requiring memory units and clock signals for operation.</data>
      <data key="d3">chunk-2459f394250f45963236273137f4db0c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736385</data>
    </node>
    <node id="Adder">
      <data key="d0">Adder</data>
      <data key="d1">artifact</data>
      <data key="d2">An adder is a digital circuit used to perform addition of binary numbers and is a common combinational logic element in data paths.</data>
      <data key="d3">chunk-2459f394250f45963236273137f4db0c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736385</data>
    </node>
    <node id="Decoder">
      <data key="d0">Decoder</data>
      <data key="d1">artifact</data>
      <data key="d2">A decoder is a combinational logic circuit that converts binary information into a set of output signals, used in data paths for control and selection.</data>
      <data key="d3">chunk-2459f394250f45963236273137f4db0c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736385</data>
    </node>
    <node id="Multiplexer">
      <data key="d0">Multiplexer</data>
      <data key="d1">artifact</data>
      <data key="d2">A multiplexer is a combinational logic circuit that selects one of several input signals and forwards it to a single output line, commonly used in data paths.</data>
      <data key="d3">chunk-2459f394250f45963236273137f4db0c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736385</data>
    </node>
    <node id="Three-State Gate">
      <data key="d0">Three-State Gate</data>
      <data key="d1">artifact</data>
      <data key="d2">A three-state gate is a combinational logic element that can output high, low, or high-impedance states, aiding in bus control within data paths.</data>
      <data key="d3">chunk-2459f394250f45963236273137f4db0c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736385</data>
    </node>
    <node id="Status Register">
      <data key="d0">Status Register</data>
      <data key="d1">artifact</data>
      <data key="d2">A status register stores the current state of a processor, including flags like zero, carry, and overflow.&lt;SEP&gt;The Status Register is a component of the Data Path that stores flags or status indicators resulting from arithmetic and logical operations.</data>
      <data key="d3">chunk-cf0a63e25f70bb6e12f2ee7720496542&lt;SEP&gt;chunk-2459f394250f45963236273137f4db0c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736549</data>
    </node>
    <node id="Latch">
      <data key="d0">Latch</data>
      <data key="d1">artifact</data>
      <data key="d2">A latch is a type of sequential logic element that stores data based on input signals and is level-sensitive rather than edge-triggered.</data>
      <data key="d3">chunk-2459f394250f45963236273137f4db0c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736388</data>
    </node>
    <node id="Clock Signal">
      <data key="d0">Clock Signal</data>
      <data key="d1">concept</data>
      <data key="d2">A clock signal is a periodic signal used to synchronize operations in sequential logic circuits, ensuring timing control.</data>
      <data key="d3">chunk-2459f394250f45963236273137f4db0c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736388</data>
    </node>
    <node id="Output Feedback">
      <data key="d0">Output Feedback</data>
      <data key="d1">concept</data>
      <data key="d2">Output feedback refers to the condition where output signals influence input behavior, which is absent in combinational logic elements.</data>
      <data key="d3">chunk-2459f394250f45963236273137f4db0c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736390</data>
    </node>
    <node id="No Feedback">
      <data key="d0">No Feedback</data>
      <data key="d3">chunk-2459f394250f45963236273137f4db0c</data>
      <data key="d2">Combinational logic elements do not have feedback paths, ensuring output depends only on immediate inputs.</data>
      <data key="d1">UNKNOWN</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736396</data>
    </node>
    <node id="Single Cycle Implementation">
      <data key="d0">Single Cycle Implementation</data>
      <data key="d1">concept</data>
      <data key="d2">Single Cycle Implementation is a CPU design approach where each instruction completes in one clock cycle, with the clock period determined by the slowest stage in the data path.</data>
      <data key="d3">chunk-5ea0f23d1c767bafc743ff484eb189e1</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736482</data>
    </node>
    <node id="Pipeline Design Principle">
      <data key="d0">Pipeline Design Principle</data>
      <data key="d1">concept</data>
      <data key="d2">Pipeline Design Principle refers to the guidelines for structuring instruction pipelines, including segment count and stage duration based on the most complex instruction.</data>
      <data key="d3">chunk-5ea0f23d1c767bafc743ff484eb189e1</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736482</data>
    </node>
    <node id="Instruction Pipeline Stages">
      <data key="d0">Instruction Pipeline Stages</data>
      <data key="d1">concept</data>
      <data key="d2">Instruction Pipeline Stages are the sequential steps an instruction passes through in a processor, including fetch, decode, execute, memory access, and write-back.</data>
      <data key="d3">chunk-5ea0f23d1c767bafc743ff484eb189e1</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736482</data>
    </node>
    <node id="Clock Frequency">
      <data key="d0">Clock Frequency</data>
      <data key="d1">concept</data>
      <data key="d2">Clock Frequency is the rate at which a processor executes clock cycles, inversely proportional to the clock cycle duration.</data>
      <data key="d3">chunk-5ea0f23d1c767bafc743ff484eb189e1</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736482</data>
    </node>
    <node id="Instruction Execution Time">
      <data key="d0">Instruction Execution Time</data>
      <data key="d1">concept</data>
      <data key="d2">Instruction Execution Time is the total time taken to complete a single instruction in a processor.</data>
      <data key="d3">chunk-5ea0f23d1c767bafc743ff484eb189e1</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736482</data>
    </node>
    <node id="5-Stage Pipeline">
      <data key="d0">5-Stage Pipeline</data>
      <data key="d1">concept</data>
      <data key="d2">Five-Stage Pipeline is a common instruction pipeline model consisting of fetch, decode, execute, memory access, and write-back stages.</data>
      <data key="d3">chunk-5ea0f23d1c767bafc743ff484eb189e1</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736482</data>
    </node>
    <node id="Fetch Stage">
      <data key="d0">Fetch Stage</data>
      <data key="d1">concept</data>
      <data key="d2">Fetch Stage is the first stage in the instruction pipeline, responsible for retrieving the instruction from memory.</data>
      <data key="d3">chunk-5ea0f23d1c767bafc743ff484eb189e1</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736485</data>
    </node>
    <node id="Decode Stage">
      <data key="d0">Decode Stage</data>
      <data key="d1">concept</data>
      <data key="d2">Decode Stage is the second stage in the instruction pipeline, responsible for interpreting the instruction and preparing operands.</data>
      <data key="d3">chunk-5ea0f23d1c767bafc743ff484eb189e1</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736485</data>
    </node>
    <node id="Memory Access Stage">
      <data key="d0">Memory Access Stage</data>
      <data key="d1">concept</data>
      <data key="d2">Memory Access Stage is the fourth stage in the instruction pipeline, responsible for reading from or writing to memory.</data>
      <data key="d3">chunk-5ea0f23d1c767bafc743ff484eb189e1</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736485</data>
    </node>
    <node id="200ps">
      <data key="d0">200ps</data>
      <data key="d1">data</data>
      <data key="d2">200ps is the time duration of the longest individual stage in the pipeline, used to set the clock cycle for the processor.</data>
      <data key="d3">chunk-5ea0f23d1c767bafc743ff484eb189e1</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736485</data>
    </node>
    <node id="100ps">
      <data key="d0">100ps</data>
      <data key="d1">data</data>
      <data key="d2">100ps is the time duration of the decode and write-back stages.</data>
      <data key="d3">chunk-5ea0f23d1c767bafc743ff484eb189e1</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736485</data>
    </node>
    <node id="150ps">
      <data key="d0">150ps</data>
      <data key="d1">data</data>
      <data key="d2">150ps is the time duration of the execute stage.</data>
      <data key="d3">chunk-5ea0f23d1c767bafc743ff484eb189e1</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736485</data>
    </node>
    <node id="750ps">
      <data key="d0">750ps</data>
      <data key="d1">data</data>
      <data key="d2">750ps is the total execution time of an instruction in a single-cycle processor.</data>
      <data key="d3">chunk-5ea0f23d1c767bafc743ff484eb189e1</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736487</data>
    </node>
    <node id="1ns">
      <data key="d0">1ns</data>
      <data key="d1">data</data>
      <data key="d2">1ns is the execution time per instruction in a pipeline processor, calculated as 5 stages × 200ps.</data>
      <data key="d3">chunk-5ea0f23d1c767bafc743ff484eb189e1</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736488</data>
    </node>
    <node id="N">
      <data key="d0">N</data>
      <data key="d1">data</data>
      <data key="d2">N represents the number of instructions in a given program.</data>
      <data key="d3">chunk-5ea0f23d1c767bafc743ff484eb189e1</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736488</data>
    </node>
    <node id="Single Cycle Processor Time">
      <data key="d0">Single Cycle Processor Time</data>
      <data key="d1">data</data>
      <data key="d2">Single Cycle Processor Time is computed as N × 750ps, representing total time to execute N instructions in single-cycle mode.</data>
      <data key="d3">chunk-5ea0f23d1c767bafc743ff484eb189e1</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736488</data>
    </node>
    <node id="Pipeline Processor Time">
      <data key="d0">Pipeline Processor Time</data>
      <data key="d1">data</data>
      <data key="d2">Pipeline Processor Time is computed as (N + 4) × 200ps, reflecting the latency overhead of pipeline initiation.</data>
      <data key="d3">chunk-5ea0f23d1c767bafc743ff484eb189e1</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736488</data>
    </node>
    <node id="Performance Efficiency">
      <data key="d0">Performance Efficiency</data>
      <data key="d1">concept</data>
      <data key="d2">Performance Efficiency refers to the improvement in processing throughput achieved by using pipelining over sequential execution for multiple instructions.</data>
      <data key="d3">chunk-5ea0f23d1c767bafc743ff484eb189e1</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736488</data>
    </node>
    <node id="Stage Length">
      <data key="d0">Stage Length</data>
      <data key="d3">chunk-5ea0f23d1c767bafc743ff484eb189e1</data>
      <data key="d2">The length of each pipeline stage must be set to match the longest individual operation to maintain synchronization.</data>
      <data key="d1">UNKNOWN</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736491</data>
    </node>
    <node id="Accumulator Register">
      <data key="d0">Accumulator Register</data>
      <data key="d1">artifact</data>
      <data key="d2">The Accumulator Register (ACC) is a special-purpose register used for storing intermediate results during arithmetic and logic operations.</data>
      <data key="d3">chunk-de401d6e0254effcba3f6fcd81cefe60</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736495</data>
    </node>
    <node id="Shifter Register">
      <data key="d0">Shifter Register</data>
      <data key="d1">artifact</data>
      <data key="d2">The Shifter Register performs bit shifting operations, such as left or right shifts, used in data manipulation.</data>
      <data key="d3">chunk-de401d6e0254effcba3f6fcd81cefe60</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736495</data>
    </node>
    <node id="Counter">
      <data key="d0">Counter</data>
      <data key="d1">artifact</data>
      <data key="d2">The Counter (CT) is a register used for counting operations, such as instruction execution cycles or memory addresses.</data>
      <data key="d3">chunk-de401d6e0254effcba3f6fcd81cefe60</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736495</data>
    </node>
    <node id="Timing Circuit">
      <data key="d0">Timing Circuit</data>
      <data key="d1">artifact</data>
      <data key="d2">The Timing Circuit generates clock signals used to synchronize operations within the CPU.</data>
      <data key="d3">chunk-de401d6e0254effcba3f6fcd81cefe60</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736499</data>
    </node>
    <node id="Microoperation Signal Generator">
      <data key="d0">Microoperation Signal Generator</data>
      <data key="d1">artifact</data>
      <data key="d2">The Microoperation Signal Generator produces control signals to execute microcommands during instruction execution.</data>
      <data key="d3">chunk-de401d6e0254effcba3f6fcd81cefe60</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736499</data>
    </node>
    <node id="Computational Core">
      <data key="d0">Computational Core</data>
      <data key="d1">concept</data>
      <data key="d2">The Computational Core is the central functional unit of the CPU that performs arithmetic, logical, and conditional operations.</data>
      <data key="d3">chunk-de401d6e0254effcba3f6fcd81cefe60</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736499</data>
    </node>
    <node id="Microcommand Sequence">
      <data key="d0">Microcommand Sequence</data>
      <data key="d1">concept</data>
      <data key="d2">A Microcommand Sequence is a series of low-level control signals used to execute a single instruction.</data>
      <data key="d3">chunk-de401d6e0254effcba3f6fcd81cefe60</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736501</data>
    </node>
    <node id="Control Signal">
      <data key="d0">Control Signal</data>
      <data key="d1">concept</data>
      <data key="d2">A Control Signal is an electrical signal generated by the controller to manage the operation of various CPU components.</data>
      <data key="d3">chunk-de401d6e0254effcba3f6fcd81cefe60</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736501</data>
    </node>
    <node id="Operation Code">
      <data key="d0">Operation Code</data>
      <data key="d1">concept</data>
      <data key="d2">The Operation Code is the portion of an instruction that specifies the type of operation to be performed by the CPU.</data>
      <data key="d3">chunk-de401d6e0254effcba3f6fcd81cefe60</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736501</data>
    </node>
    <node id="Conditional Test">
      <data key="d0">Conditional Test</data>
      <data key="d1">concept</data>
      <data key="d2">The Conditional Test is a function performed by the运算器to evaluate conditions and set status flags such as ZF, SF, OF, and CF for decision-making.</data>
      <data key="d3">chunk-de401d6e0254effcba3f6fcd81cefe60</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736501</data>
    </node>
    <node id="Hardware Synchronization">
      <data key="d0">Hardware Synchronization</data>
      <data key="d1">concept</data>
      <data key="d2">Hardware Synchronization refers to the coordination of various CPU components through timing signals to ensure correct execution order.</data>
      <data key="d3">chunk-de401d6e0254effcba3f6fcd81cefe60</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736501</data>
    </node>
    <node id="运算器">
      <data key="d0">运算器</data>
      <data key="d3">chunk-de401d6e0254effcba3f6fcd81cefe60</data>
      <data key="d2">The运算器performs Conditional Test operations to set status flags (ZF, SF, OF, CF) based on arithmetic and logical results.</data>
      <data key="d1">UNKNOWN</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736508</data>
    </node>
    <node id="General Purpose Registers">
      <data key="d0">General Purpose Registers</data>
      <data key="d1">artifact</data>
      <data key="d2">General purpose registers are storage units within the Data Path used to hold data temporarily during instruction execution.</data>
      <data key="d3">chunk-cf0a63e25f70bb6e12f2ee7720496542</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736549</data>
    </node>
    <node id="Exception and Interrupt Handling Logic">
      <data key="d0">Exception and Interrupt Handling Logic</data>
      <data key="d1">artifact</data>
      <data key="d2">The exception and interrupt handling logic is part of the Data Path responsible for managing exceptional events and interrupts during instruction execution.</data>
      <data key="d3">chunk-cf0a63e25f70bb6e12f2ee7720496542</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736549</data>
    </node>
    <node id="Control Signals">
      <data key="d0">Control Signals</data>
      <data key="d1">data</data>
      <data key="d2">Control Signals are generated by the Control Unit to regulate the behavior and operation of the Data Path components.</data>
      <data key="d3">chunk-cf0a63e25f70bb6e12f2ee7720496542</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736549</data>
    </node>
    <node id="指令流水线">
      <data key="d0">指令流水线</data>
      <data key="d1">concept</data>
      <data key="d2">The instruction pipeline is a technique that improves processor parallelism by breaking the execution of instructions into multiple stages that are executed in a pipelined fashion.</data>
      <data key="d3">chunk-48932a772d41e90269193af10a0bbbb3</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736551</data>
    </node>
    <node id="时间上的并行技术">
      <data key="d0">时间上的并行技术</data>
      <data key="d1">concept</data>
      <data key="d2">Time-based parallelism splits a task into sub-stages executed in parallel on different functional units, allowing multiple tasks to be processed simultaneously.</data>
      <data key="d3">chunk-48932a772d41e90269193af10a0bbbb3</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736551</data>
    </node>
    <node id="空间上的并行技术">
      <data key="d0">空间上的并行技术</data>
      <data key="d1">concept</data>
      <data key="d2">Space-based parallelism involves placing multiple identical functional units in a processor to execute the same task in parallel, often seen in superscalar processors.</data>
      <data key="d3">chunk-48932a772d41e90269193af10a0bbbb3</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736551</data>
    </node>
    <node id="超标量处理机">
      <data key="d0">超标量处理机</data>
      <data key="d1">concept</data>
      <data key="d2">A superscalar processor is a type of processor that can execute multiple instructions per clock cycle by using several functional units working in parallel.</data>
      <data key="d3">chunk-48932a772d41e90269193af10a0bbbb3</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736551</data>
    </node>
    <node id="取指">
      <data key="d0">取指</data>
      <data key="d1">function</data>
      <data key="d2">The fetch stage retrieves the instruction from the instruction memory or cache.</data>
      <data key="d3">chunk-48932a772d41e90269193af10a0bbbb3</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736551</data>
    </node>
    <node id="译码/读寄存器">
      <data key="d0">译码/读寄存器</data>
      <data key="d1">function</data>
      <data key="d2">The decode/Read Register stage decodes the instruction and reads operand values from the register file.</data>
      <data key="d3">chunk-48932a772d41e90269193af10a0bbbb3</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736551</data>
    </node>
    <node id="执行/计算地址">
      <data key="d0">执行/计算地址</data>
      <data key="d1">function</data>
      <data key="d2">The execute/calculate address stage performs arithmetic or logical operations or calculates memory addresses.</data>
      <data key="d3">chunk-48932a772d41e90269193af10a0bbbb3</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736551</data>
    </node>
    <node id="访存">
      <data key="d0">访存</data>
      <data key="d1">function</data>
      <data key="d2">The memory access stage performs read or write operations on the memory.</data>
      <data key="d3">chunk-48932a772d41e90269193af10a0bbbb3</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736551</data>
    </node>
    <node id="写回">
      <data key="d0">写回</data>
      <data key="d1">function</data>
      <data key="d2">The write back stage writes the result of the instruction execution back to the register file.</data>
      <data key="d3">chunk-48932a772d41e90269193af10a0bbbb3</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736554</data>
    </node>
    <node id="指令集">
      <data key="d0">指令集</data>
      <data key="d1">artifact</data>
      <data key="d2">The instruction set is a collection of commands that a processor can understand and execute, which influences pipeline efficiency.</data>
      <data key="d3">chunk-48932a772d41e90269193af10a0bbbb3</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736555</data>
    </node>
    <node id="指令长度">
      <data key="d0">指令长度</data>
      <data key="d1">concept</data>
      <data key="d2">Instruction length refers to the uniformity of instruction size, which affects the complexity of fetch and decode operations.</data>
      <data key="d3">chunk-48932a772d41e90269193af10a0bbbb3</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736555</data>
    </node>
    <node id="指令格式">
      <data key="d0">指令格式</data>
      <data key="d1">concept</data>
      <data key="d2">Instruction format defines the structure of instructions, with consistent layout being beneficial for pipeline efficiency.</data>
      <data key="d3">chunk-48932a772d41e90269193af10a0bbbb3</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736555</data>
    </node>
    <node id="源寄存器">
      <data key="d0">源寄存器</data>
      <data key="d1">concept</data>
      <data key="d2">Source registers are locations in the register file that hold operand data for operations, with consistent placement being preferred.</data>
      <data key="d3">chunk-48932a772d41e90269193af10a0bbbb3</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736555</data>
    </node>
    <node id="LOAD/STORE型指令">
      <data key="d0">LOAD/STORE型指令</data>
      <data key="d1">artifact</data>
      <data key="d2">LOAD/STORE instructions are a type of instruction that can access memory only through specific load and store operations, enabling efficient pipeline scheduling.</data>
      <data key="d3">chunk-48932a772d41e90269193af10a0bbbb3</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736555</data>
    </node>
    <node id="数据和指令在存储器中按边界对齐">
      <data key="d0">数据和指令在存储器中按边界对齐</data>
      <data key="d1">concept</data>
      <data key="d2">Data and instructions stored in memory are aligned to boundaries, reducing memory access times and improving pipeline performance.</data>
      <data key="d3">chunk-48932a772d41e90269193af10a0bbbb3</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736555</data>
    </node>
    <node id="每条指令的时钟周期数">
      <data key="d0">每条指令的时钟周期数</data>
      <data key="d1">concept</data>
      <data key="d2">CPI (Cycles Per Instruction) is a metric for processor efficiency, with an ideal value of 1 in a fully pipelined system.</data>
      <data key="d3">chunk-48932a772d41e90269193af10a0bbbb3</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736557</data>
    </node>
    <node id="流水段">
      <data key="d0">流水段</data>
      <data key="d1">concept</data>
      <data key="d2">A pipeline stage is a phase in the instruction execution process, corresponding to a functional unit or step.</data>
      <data key="d3">chunk-48932a772d41e90269193af10a0bbbb3</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736558</data>
    </node>
    <node id="功能部件">
      <data key="d0">功能部件</data>
      <data key="d1">artifact</data>
      <data key="d2">Functional units are hardware components responsible for executing specific operations in the processor.</data>
      <data key="d3">chunk-48932a772d41e90269193af10a0bbbb3</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736558</data>
    </node>
    <node id="微指令的地址形成方式">
      <data key="d0">微指令的地址形成方式</data>
      <data key="d1">concept</data>
      <data key="d2">Microinstruction address formation refers to the methods used to determine the address of the next microinstruction in a microprogrammed control unit.</data>
      <data key="d3">chunk-7c0597dc102c9fca5be6ec61fc5d051b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736647</data>
    </node>
    <node id="后继微地址">
      <data key="d0">后继微地址</data>
      <data key="d1">concept</data>
      <data key="d2">The successor microinstruction address is the address of the next microinstruction to be executed in the microprogram.</data>
      <data key="d3">chunk-7c0597dc102c9fca5be6ec61fc5d051b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736647</data>
    </node>
    <node id="微指令的后继地址字段">
      <data key="d0">微指令的后继地址字段</data>
      <data key="d1">artifact</data>
      <data key="d2">The successor address field in a microinstruction directly specifies the address of the next microinstruction, also known as the determined method.</data>
      <data key="d3">chunk-7c0597dc102c9fca5be6ec61fc5d051b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736647</data>
    </node>
    <node id="断定方式">
      <data key="d0">断定方式</data>
      <data key="d1">method</data>
      <data key="d2">The determined method is a technique where the next microinstruction address is directly indicated by the successor address field in the microinstruction.</data>
      <data key="d3">chunk-7c0597dc102c9fca5be6ec61fc5d051b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736647</data>
    </node>
    <node id="机器指令的操作码">
      <data key="d0">机器指令的操作码</data>
      <data key="d1">artifact</data>
      <data key="d2">The operation code of a machine instruction determines the starting address of the microprogram for that instruction.</data>
      <data key="d3">chunk-7c0597dc102c9fca5be6ec61fc5d051b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736647</data>
    </node>
    <node id="增量计数器法">
      <data key="d0">增量计数器法</data>
      <data key="d1">method</data>
      <data key="d2">The increment counter method uses the formula (μPC)+1→μPC to generate the next microinstruction address when addresses are sequential.</data>
      <data key="d3">chunk-7c0597dc102c9fca5be6ec61fc5d051b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736647</data>
    </node>
    <node id="标志">
      <data key="d0">标志</data>
      <data key="d1">concept</data>
      <data key="d2">Flags in the control unit are used to determine the branch target address of the next microinstruction.</data>
      <data key="d3">chunk-7c0597dc102c9fca5be6ec61fc5d051b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736647</data>
    </node>
    <node id="硬件直接产生微程序入口地址">
      <data key="d0">硬件直接产生微程序入口地址</data>
      <data key="d1">method</data>
      <data key="d2">Hardware directly generates the entry address of the microprogram upon power-up, which is used as the fetch cycle microinstruction address.</data>
      <data key="d3">chunk-7c0597dc102c9fca5be6ec61fc5d051b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736650</data>
    </node>
    <node id="电源加电后">
      <data key="d0">电源加电后</data>
      <data key="d1">event</data>
      <data key="d2">The event of power-up initializes the microprogram control unit and sets the first microinstruction address.</data>
      <data key="d3">chunk-7c0597dc102c9fca5be6ec61fc5d051b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736650</data>
    </node>
    <node id="微指令的格式">
      <data key="d0">微指令的格式</data>
      <data key="d1">concept</data>
      <data key="d2">The format of a microinstruction refers to the layout and structure of its fields in a microprogrammed control unit.</data>
      <data key="d3">chunk-7c0597dc102c9fca5be6ec61fc5d051b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736650</data>
    </node>
    <node id="水平型微指令">
      <data key="d0">水平型微指令</data>
      <data key="d1">artifact</data>
      <data key="d2">Horizontal microinstructions use direct encoding where each bit in the instruction corresponds to one control signal.</data>
      <data key="d3">chunk-7c0597dc102c9fca5be6ec61fc5d051b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736650</data>
    </node>
    <node id="垂直型微指令">
      <data key="d0">垂直型微指令</data>
      <data key="d1">artifact</data>
      <data key="d2">Vertical microinstructions use an operation code-like field to specify a single microcommand per instruction.</data>
      <data key="d3">chunk-7c0597dc102c9fca5be6ec61fc5d051b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736650</data>
    </node>
    <node id="直接编码">
      <data key="d0">直接编码</data>
      <data key="d1">method</data>
      <data key="d2">Direct encoding assigns one bit in the microinstruction to control each individual control signal.</data>
      <data key="d3">chunk-7c0597dc102c9fca5be6ec61fc5d051b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736650</data>
    </node>
    <node id="字段直接编码">
      <data key="d0">字段直接编码</data>
      <data key="d1">method</data>
      <data key="d2">Field direct encoding divides the control field into subfields, each directly signaling a group of control signals.</data>
      <data key="d3">chunk-7c0597dc102c9fca5be6ec61fc5d051b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736650</data>
    </node>
    <node id="字段间接编码">
      <data key="d0">字段间接编码</data>
      <data key="d1">method</data>
      <data key="d2">Field indirect encoding uses a subfield to select from a set of control signal patterns, allowing compact representation.</data>
      <data key="d3">chunk-7c0597dc102c9fca5be6ec61fc5d051b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736650</data>
    </node>
    <node id="取指周期微程序">
      <data key="d0">取指周期微程序</data>
      <data key="d1">concept</data>
      <data key="d2">The fetch cycle microprogram is the sequence of microinstructions executed during the instruction fetch phase.</data>
      <data key="d3">chunk-7c0597dc102c9fca5be6ec61fc5d051b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736653</data>
    </node>
    <node id="I/O Interrupt">
      <data key="d0">I/O Interrupt</data>
      <data key="d1">concept</data>
      <data key="d2">An I/O interrupt is triggered by input/output devices, such as keyboard input or printer paper shortage, and is signaled via a dedicated interrupt request line.</data>
      <data key="d3">chunk-56dad084d2f83de29d62a2ae33cfc843</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736653</data>
    </node>
    <node id="Special Event">
      <data key="d0">Special Event</data>
      <data key="d1">concept</data>
      <data key="d2">A special event refers to user actions (e.g., pressing Esc) or timer expirations that generate interrupt signals.</data>
      <data key="d3">chunk-56dad084d2f83de29d62a2ae33cfc843</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736653</data>
    </node>
    <node id="Interrupt Request Signal Line">
      <data key="d0">Interrupt Request Signal Line</data>
      <data key="d1">artifact</data>
      <data key="d2">The interrupt request signal line is a hardware connection through which external I/O devices send interrupt requests to the CPU.</data>
      <data key="d3">chunk-56dad084d2f83de29d62a2ae33cfc843</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736653</data>
    </node>
    <node id="Interrupt Response Cycle">
      <data key="d0">Interrupt Response Cycle</data>
      <data key="d1">concept</data>
      <data key="d2">The interrupt response cycle is the process the CPU enters upon detecting an interrupt request, during which it prepares to handle the interrupt.</data>
      <data key="d3">chunk-56dad084d2f83de29d62a2ae33cfc843</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736653</data>
    </node>
    <node id="Maskable Interrupt">
      <data key="d0">Maskable Interrupt</data>
      <data key="d1">concept</data>
      <data key="d2">A maskable interrupt is a type of interrupt signaled through the INTR line, which can be disabled or enabled by setting a mask in the interrupt controller.</data>
      <data key="d3">chunk-56dad084d2f83de29d62a2ae33cfc843</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736653</data>
    </node>
    <node id="Maskable Interrupt Request Line INTR">
      <data key="d0">Maskable Interrupt Request Line INTR</data>
      <data key="d1">artifact</data>
      <data key="d2">The INTR line is a specific hardware line used to send maskable interrupts to the CPU.</data>
      <data key="d3">chunk-56dad084d2f83de29d62a2ae33cfc843</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736653</data>
    </node>
    <node id="Non-Maskable Interrupt">
      <data key="d0">Non-Maskable Interrupt</data>
      <data key="d1">concept</data>
      <data key="d2">A non-maskable interrupt is a high-priority interrupt sent via the NMI line and cannot be disabled; used for critical hardware failures like power loss.</data>
      <data key="d3">chunk-56dad084d2f83de29d62a2ae33cfc843</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736656</data>
    </node>
    <node id="Non-Maskable Interrupt Request Line NMI">
      <data key="d0">Non-Maskable Interrupt Request Line NMI</data>
      <data key="d1">artifact</data>
      <data key="d2">The NMI line is a dedicated hardware line for sending non-maskable interrupts, ensuring immediate CPU response.</data>
      <data key="d3">chunk-56dad084d2f83de29d62a2ae33cfc843</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736656</data>
    </node>
    <node id="Hardware Fault">
      <data key="d0">Hardware Fault</data>
      <data key="d1">concept</data>
      <data key="d2">A hardware fault, such as power failure, triggers a non-maskable interrupt to ensure rapid system response.</data>
      <data key="d3">chunk-56dad084d2f83de29d62a2ae33cfc843</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736656</data>
    </node>
    <node id="Vector Interrupt">
      <data key="d0">Vector Interrupt</data>
      <data key="d1">concept</data>
      <data key="d2">A vector interrupt is a type of interrupt where the service routine address is determined by a vector number, enabling rapid identification of the handler.</data>
      <data key="d3">chunk-56dad084d2f83de29d62a2ae33cfc843</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736656</data>
    </node>
    <node id="Non-Vector Interrupt">
      <data key="d0">Non-Vector Interrupt</data>
      <data key="d1">concept</data>
      <data key="d2">A non-vector interrupt requires software or polling methods to identify the interrupt source and service routine address.</data>
      <data key="d3">chunk-56dad084d2f83de29d62a2ae33cfc843</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736656</data>
    </node>
    <node id="Single Interrupt">
      <data key="d0">Single Interrupt</data>
      <data key="d1">concept</data>
      <data key="d2">A single interrupt refers to a system where interrupt handling cannot be interrupted by another interrupt.</data>
      <data key="d3">chunk-56dad084d2f83de29d62a2ae33cfc843</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736656</data>
    </node>
    <node id="Multiple Interrupt">
      <data key="d0">Multiple Interrupt</data>
      <data key="d1">concept</data>
      <data key="d2">A multiple interrupt allows the CPU to respond to a new interrupt while handling an ongoing one, enabling higher responsiveness.</data>
      <data key="d3">chunk-56dad084d2f83de29d62a2ae33cfc843</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736657</data>
    </node>
    <node id="Interrupt Controller">
      <data key="d0">Interrupt Controller</data>
      <data key="d1">artifact</data>
      <data key="d2">The interrupt controller is a hardware component that manages interrupt requests and allows CPU to set masks for maskable interrupts.</data>
      <data key="d3">chunk-56dad084d2f83de29d62a2ae33cfc843</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736657</data>
    </node>
    <node id="Hardware Detection">
      <data key="d0">Hardware Detection</data>
      <data key="d1">concept</data>
      <data key="d2">Hardware detection is the mechanism by which all interrupt and exception events are identified and signaled by hardware.</data>
      <data key="d3">chunk-56dad084d2f83de29d62a2ae33cfc843</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736658</data>
    </node>
    <node id="INTR">
      <data key="d0">INTR</data>
      <data key="d3">chunk-56dad084d2f83de29d62a2ae33cfc843</data>
      <data key="d2">The maskable interrupt is transmitted via the INTR signal line and can be controlled by the interrupt controller.</data>
      <data key="d1">UNKNOWN</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736659</data>
    </node>
    <node id="NMI">
      <data key="d0">NMI</data>
      <data key="d3">chunk-56dad084d2f83de29d62a2ae33cfc843</data>
      <data key="d2">The non-maskable interrupt is transmitted via the NMI signal line and cannot be disabled.</data>
      <data key="d1">UNKNOWN</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736659</data>
    </node>
    <node id="Hardware Multithreading">
      <data key="d0">Hardware Multithreading</data>
      <data key="d1">concept</data>
      <data key="d2">Hardware multithreading is a technique that reduces thread switching overhead by providing dedicated resources for each thread in a CPU.</data>
      <data key="d3">chunk-f67ff7c347b613bc05733f64a51c9c17</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736740</data>
    </node>
    <node id="Thread Switching">
      <data key="d0">Thread Switching</data>
      <data key="d1">concept</data>
      <data key="d2">Thread switching refers to the process of changing execution from one thread to another, which incurs overhead in traditional CPUs.</data>
      <data key="d3">chunk-f67ff7c347b613bc05733f64a51c9c17</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736740</data>
    </node>
    <node id="Fine-Grained Multithreading">
      <data key="d0">Fine-Grained Multithreading</data>
      <data key="d1">method</data>
      <data key="d2">Fine-grained multithreading allows threads to alternate instruction execution on a per-clock-cycle basis, enabling interleaved execution without dependence on instruction dependency or pipeline state.</data>
      <data key="d3">chunk-f67ff7c347b613bc05733f64a51c9c17</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736740</data>
    </node>
    <node id="Coarse-Grained Multithreading">
      <data key="d0">Coarse-Grained Multithreading</data>
      <data key="d1">method</data>
      <data key="d2">Coarse-grained multithreading executes a thread’s instructions for multiple clock cycles before switching, only switching when a significant stall, such as a cache miss, occurs.</data>
      <data key="d3">chunk-f67ff7c347b613bc05733f64a51c9c17</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736740</data>
    </node>
    <node id="Simultaneous Multithreading">
      <data key="d0">Simultaneous Multithreading</data>
      <data key="d1">method</data>
      <data key="d2">Simultaneous multithreading (SMT) enables the execution of multiple instructions from different threads within a single clock cycle, achieving both instruction-level and thread-level parallelism.</data>
      <data key="d3">chunk-f67ff7c347b613bc05733f64a51c9c17</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736740</data>
    </node>
    <node id="Intel Hyper-Threading">
      <data key="d0">Intel Hyper-Threading</data>
      <data key="d1">method</data>
      <data key="d2">Intel Hyper-Threading is a form of SMT that implements two logical threads per physical core, sharing cache and functional units.</data>
      <data key="d3">chunk-f67ff7c347b613bc05733f64a51c9c17</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736740</data>
    </node>
    <node id="High-Speed Cache">
      <data key="d0">High-Speed Cache</data>
      <data key="d1">artifact</data>
      <data key="d2">High-speed cache is a fast memory component shared among threads in a multithreaded processor to reduce memory latency.</data>
      <data key="d3">chunk-f67ff7c347b613bc05733f64a51c9c17</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736741</data>
    </node>
    <node id="Instruction Execution Cycle">
      <data key="d0">Instruction Execution Cycle</data>
      <data key="d1">concept</data>
      <data key="d2">The instruction execution cycle refers to the sequence of steps a processor follows to execute a single instruction, typically involving multiple stages.</data>
      <data key="d3">chunk-3c7856616d478c58fdce251c9a2b68ac</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736780</data>
    </node>
    <node id="Multi Cycle Processor">
      <data key="d0">Multi Cycle Processor</data>
      <data key="d1">method</data>
      <data key="d2">The multi cycle processor assigns different numbers of clock cycles to different instructions based on their complexity, allowing for more efficient execution but maintaining serial execution.</data>
      <data key="d3">chunk-3c7856616d478c58fdce251c9a2b68ac</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736780</data>
    </node>
    <node id="Pipeline Processor">
      <data key="d0">Pipeline Processor</data>
      <data key="d1">method</data>
      <data key="d2">The pipeline processor enables parallel execution of instructions by having multiple instructions in different stages simultaneously, aiming to complete one instruction per clock cycle in ideal conditions.</data>
      <data key="d3">chunk-3c7856616d478c58fdce251c9a2b68ac</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736780</data>
    </node>
    <node id="Instruction Serial Execution">
      <data key="d0">Instruction Serial Execution</data>
      <data key="d1">concept</data>
      <data key="d2">Instruction serial execution refers to the execution of instructions one after another, without overlap, characteristic of single and multi cycle processors.</data>
      <data key="d3">chunk-3c7856616d478c58fdce251c9a2b68ac</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736780</data>
    </node>
    <node id="Instruction Parallel Execution">
      <data key="d0">Instruction Parallel Execution</data>
      <data key="d1">concept</data>
      <data key="d2">Instruction parallel execution allows multiple instructions to be processed simultaneously in different stages, a key feature of pipeline processors.</data>
      <data key="d3">chunk-3c7856616d478c58fdce251c9a2b68ac</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736780</data>
    </node>
    <node id="Execution Step">
      <data key="d0">Execution Step</data>
      <data key="d1">concept</data>
      <data key="d2">An execution step is a specific phase in the instruction execution cycle, such as fetch, decode, execute, memory access, and write back.</data>
      <data key="d3">chunk-3c7856616d478c58fdce251c9a2b68ac</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736782</data>
    </node>
    <node id="Single Bus Data Path">
      <data key="d0">Single Bus Data Path</data>
      <data key="d1">concept</data>
      <data key="d2">The single bus data path is a system architecture where a single shared bus is used for data transmission between components, with only one component able to use the bus at any given time.</data>
      <data key="d3">chunk-0efa36a872f0b1511a047f0591cba52c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736797</data>
    </node>
    <node id="Bus">
      <data key="d0">Bus</data>
      <data key="d1">artifact</data>
      <data key="d2">The bus is a shared set of transmission signal lines that do not store information and allow only one device to transmit at a time.</data>
      <data key="d3">chunk-0efa36a872f0b1511a047f0591cba52c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736797</data>
    </node>
    <node id="General Purpose Register">
      <data key="d0">General Purpose Register</data>
      <data key="d1">artifact</data>
      <data key="d2">General purpose registers are storage elements that hold data and can transfer information to or from the bus via control signals.</data>
      <data key="d3">chunk-0efa36a872f0b1511a047f0591cba52c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736797</data>
    </node>
    <node id="Temporary Register Y">
      <data key="d0">Temporary Register Y</data>
      <data key="d1">artifact</data>
      <data key="d2">Temporary register Y stores one operand in a computation sequence and keeps its value active at the ALU’s left input.</data>
      <data key="d3">chunk-0efa36a872f0b1511a047f0591cba52c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736798</data>
    </node>
    <node id="Temporary Register Z">
      <data key="d0">Temporary Register Z</data>
      <data key="d1">artifact</data>
      <data key="d2">Temporary register Z holds the result output from the ALU before it is written to the destination register.</data>
      <data key="d3">chunk-0efa36a872f0b1511a047f0591cba52c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736798</data>
    </node>
    <node id="Read Operation">
      <data key="d0">Read Operation</data>
      <data key="d1">method</data>
      <data key="d2">The read operation involves sending a memory address via the program counter to the memory address register, then issuing a read command to transfer data to the memory data register.</data>
      <data key="d3">chunk-0efa36a872f0b1511a047f0591cba52c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736798</data>
    </node>
    <node id="Write Operation">
      <data key="d0">Write Operation</data>
      <data key="d1">method</data>
      <data key="d2">The write operation involves sending the desired data to the memory data register and the target address to the memory address register, then issuing a write command.</data>
      <data key="d3">chunk-0efa36a872f0b1511a047f0591cba52c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736798</data>
    </node>
    <node id="Arithmetic Operation">
      <data key="d0">Arithmetic Operation</data>
      <data key="d1">method</data>
      <data key="d2">The arithmetic operation involves transferring one operand to temporary register Y, the second to ALU input, computing the result in ALU, and storing it in temporary register Z.</data>
      <data key="d3">chunk-0efa36a872f0b1511a047f0591cba52c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736798</data>
    </node>
    <node id="Instruction Fetch">
      <data key="d0">Instruction Fetch</data>
      <data key="d1">method</data>
      <data key="d2">The instruction fetch method involves transferring the program counter value to the memory address register, reading the instruction from memory into the memory data register, and loading the instruction into the instruction register.</data>
      <data key="d3">chunk-0efa36a872f0b1511a047f0591cba52c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736798</data>
    </node>
    <node id="Program Counter Update">
      <data key="d0">Program Counter Update</data>
      <data key="d1">method</data>
      <data key="d2">The program counter update method increments the program counter value to prepare for the next instruction after fetching the current instruction.</data>
      <data key="d3">chunk-0efa36a872f0b1511a047f0591cba52c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736800</data>
    </node>
    <node id="Transfer Operation">
      <data key="d0">Transfer Operation</data>
      <data key="d1">method</data>
      <data key="d2">The transfer operation allows updating the program counter with a new address from the instruction register, enabling branching or jump instructions.</data>
      <data key="d3">chunk-0efa36a872f0b1511a047f0591cba52c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736800</data>
    </node>
    <node id="Control Signal Rin">
      <data key="d0">Control Signal Rin</data>
      <data key="d1">artifact</data>
      <data key="d2">Control signal Rin enables the transfer of data from the bus into a register.</data>
      <data key="d3">chunk-0efa36a872f0b1511a047f0591cba52c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736800</data>
    </node>
    <node id="Control Signal Rout">
      <data key="d0">Control Signal Rout</data>
      <data key="d1">artifact</data>
      <data key="d2">Control signal Rout enables the transfer of data from a register to the bus.</data>
      <data key="d3">chunk-0efa36a872f0b1511a047f0591cba52c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736800</data>
    </node>
    <node id="Control Signal PCout">
      <data key="d0">Control Signal PCout</data>
      <data key="d1">artifact</data>
      <data key="d2">Control signal PCout enables the program counter to output its value to the bus.</data>
      <data key="d3">chunk-0efa36a872f0b1511a047f0591cba52c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736800</data>
    </node>
    <node id="Control Signal MARin">
      <data key="d0">Control Signal MARin</data>
      <data key="d1">artifact</data>
      <data key="d2">Control signal MARin enables the memory address register to accept data from the bus.</data>
      <data key="d3">chunk-0efa36a872f0b1511a047f0591cba52c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736800</data>
    </node>
    <node id="Control Signal MDRin">
      <data key="d0">Control Signal MDRin</data>
      <data key="d1">artifact</data>
      <data key="d2">Control signal MDRin enables the memory data register to accept data from the bus.</data>
      <data key="d3">chunk-0efa36a872f0b1511a047f0591cba52c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736800</data>
    </node>
    <node id="Control Signal MDRout">
      <data key="d0">Control Signal MDRout</data>
      <data key="d1">artifact</data>
      <data key="d2">Control signal MDRout enables the memory data register to output its value to the bus.</data>
      <data key="d3">chunk-0efa36a872f0b1511a047f0591cba52c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736800</data>
    </node>
    <node id="Control Signal IRin">
      <data key="d0">Control Signal IRin</data>
      <data key="d1">artifact</data>
      <data key="d2">Control signal IRin enables the instruction register to accept data from the bus.</data>
      <data key="d3">chunk-0efa36a872f0b1511a047f0591cba52c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736800</data>
    </node>
    <node id="Control Signal ACCin">
      <data key="d0">Control Signal ACCin</data>
      <data key="d1">artifact</data>
      <data key="d2">Control signal ACCin enables the accumulator to accept data from the bus.</data>
      <data key="d3">chunk-0efa36a872f0b1511a047f0591cba52c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736801</data>
    </node>
    <node id="Control Signal Zout">
      <data key="d0">Control Signal Zout</data>
      <data key="d1">artifact</data>
      <data key="d2">Control signal Zout enables the temporary register Z to output its value to the bus.</data>
      <data key="d3">chunk-0efa36a872f0b1511a047f0591cba52c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736801</data>
    </node>
    <node id="Control Signal Yin">
      <data key="d0">Control Signal Yin</data>
      <data key="d1">artifact</data>
      <data key="d2">Control signal Yin enables the temporary register Y to accept data from the bus.</data>
      <data key="d3">chunk-0efa36a872f0b1511a047f0591cba52c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736802</data>
    </node>
    <node id="Control Signal ALUin">
      <data key="d0">Control Signal ALUin</data>
      <data key="d1">artifact</data>
      <data key="d2">Control signal ALUin enables the arithmetic logic unit to receive data from the bus.</data>
      <data key="d3">chunk-0efa36a872f0b1511a047f0591cba52c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736802</data>
    </node>
    <node id="Memory Cycle">
      <data key="d0">Memory Cycle</data>
      <data key="d1">concept</data>
      <data key="d2">A memory cycle is the time required to perform a read or write operation with main memory.</data>
      <data key="d3">chunk-0efa36a872f0b1511a047f0591cba52c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736802</data>
    </node>
    <node id="Address Field">
      <data key="d0">Address Field</data>
      <data key="d1">artifact</data>
      <data key="d2">The address field is a component of the instruction register that contains the target address for a jump or transfer instruction.</data>
      <data key="d3">chunk-0efa36a872f0b1511a047f0591cba52c</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736802</data>
    </node>
    <node id="Control Signal PCin">
      <data key="d0">Control Signal PCin</data>
      <data key="d3">chunk-0efa36a872f0b1511a047f0591cba52c</data>
      <data key="d2">Control signal PCin enables the program counter to accept a new address from the bus during a transfer operation.</data>
      <data key="d1">UNKNOWN</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736814</data>
    </node>
    <node id="Shared Memory Multiprocessor">
      <data key="d0">Shared Memory Multiprocessor</data>
      <data key="d1">concept</data>
      <data key="d2">Shared Memory Multiprocessor (SMP) is a multi-processor system with a single physical address space where processors communicate through shared variables and can access any memory location using load/store instructions.</data>
      <data key="d3">chunk-514f22df13c84be41bf310afe9ba497b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736821</data>
    </node>
    <node id="Unified Memory Access">
      <data key="d0">Unified Memory Access</data>
      <data key="d1">concept</data>
      <data key="d2">Unified Memory Access (UMA) is a type of shared memory multiprocessor where all processors have approximately equal access time to any memory unit, regardless of the requesting processor or accessed memory word.</data>
      <data key="d3">chunk-514f22df13c84be41bf310afe9ba497b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736821</data>
    </node>
    <node id="Non-Uniform Memory Access">
      <data key="d0">Non-Uniform Memory Access</data>
      <data key="d1">concept</data>
      <data key="d2">Non-Uniform Memory Access (NUMA) is a type of shared memory multiprocessor where memory access time depends on the processor requesting access and the memory location, due to memory being partitioned among processors.</data>
      <data key="d3">chunk-514f22df13c84be41bf310afe9ba497b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736821</data>
    </node>
    <node id="Memory Controller">
      <data key="d0">Memory Controller</data>
      <data key="d1">artifact</data>
      <data key="d2">The memory controller manages data flow between the processor and system memory; it was initially located in the northbridge chip and later integrated into the CPU.</data>
      <data key="d3">chunk-514f22df13c84be41bf310afe9ba497b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736821</data>
    </node>
    <node id="Northbridge Chip">
      <data key="d0">Northbridge Chip</data>
      <data key="d1">artifact</data>
      <data key="d2">The northbridge chip is a component that integrated the memory controller and connected the CPU to main memory via the front-side bus.</data>
      <data key="d3">chunk-514f22df13c84be41bf310afe9ba497b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736821</data>
    </node>
    <node id="Front-Side Bus">
      <data key="d0">Front-Side Bus</data>
      <data key="d1">artifact</data>
      <data key="d2">The front-side bus is a communication interface connecting the CPU to the northbridge chip, creating a bottleneck under high CPU demand.</data>
      <data key="d3">chunk-514f22df13c84be41bf310afe9ba497b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736821</data>
    </node>
    <node id="QPI Bus">
      <data key="d0">QPI Bus</data>
      <data key="d1">artifact</data>
      <data key="d2">The QPI (QuickPath Interconnect) bus is a high-speed point-to-point interconnect used by CPUs to communicate with each other and access remote memory in NUMA systems.</data>
      <data key="d3">chunk-514f22df13c84be41bf310afe9ba497b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736821</data>
    </node>
    <node id="Local Memory">
      <data key="d0">Local Memory</data>
      <data key="d1">artifact</data>
      <data key="d2">Local memory refers to the portion of memory directly connected to a CPU, which provides faster access compared to remote memory in NUMA systems.</data>
      <data key="d3">chunk-514f22df13c84be41bf310afe9ba497b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736821</data>
    </node>
    <node id="Remote Memory">
      <data key="d0">Remote Memory</data>
      <data key="d1">artifact</data>
      <data key="d2">Remote memory is the portion of system memory connected to a different CPU, accessed via QPI bus and subject to higher latency in NUMA architectures.</data>
      <data key="d3">chunk-514f22df13c84be41bf310afe9ba497b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736822</data>
    </node>
    <node id="Shared Variable">
      <data key="d0">Shared Variable</data>
      <data key="d1">concept</data>
      <data key="d2">A shared variable is a memory location accessed by multiple processors in a shared memory system, requiring synchronization to prevent race conditions.</data>
      <data key="d3">chunk-514f22df13c84be41bf310afe9ba497b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736822</data>
    </node>
    <node id="Lock Mechanism">
      <data key="d0">Lock Mechanism</data>
      <data key="d1">method</data>
      <data key="d2">A lock mechanism is a synchronization method used to ensure exclusive access to a shared variable, allowing only one processor to modify it at a time.</data>
      <data key="d3">chunk-514f22df13c84be41bf310afe9ba497b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736822</data>
    </node>
    <node id="Processor Synchronization">
      <data key="d0">Processor Synchronization</data>
      <data key="d1">concept</data>
      <data key="d2">Processor synchronization is the process of coordinating access to shared resources to prevent inconsistent or incorrect execution in multi-processor systems.</data>
      <data key="d3">chunk-514f22df13c84be41bf310afe9ba497b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736822</data>
    </node>
    <node id="Race Condition">
      <data key="d0">Race Condition</data>
      <data key="d1">concept</data>
      <data key="d2">A race condition occurs when multiple processors access a shared variable simultaneously without proper synchronization, leading to unpredictable results.</data>
      <data key="d3">chunk-514f22df13c84be41bf310afe9ba497b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761736822</data>
    </node>
    <edge source="Throughput Rate" target="Maximum Throughput Rate">
      <data key="d6">1.0</data>
      <data key="d7">The throughput rate reaches its maximum value (TPmax) under ideal conditions as the number of tasks approaches infinity.</data>
      <data key="d8">performance ceiling,theoretical limit</data>
      <data key="d9">chunk-d2fd5e9039a63352ee73f215fc8aeb15</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735534</data>
    </edge>
    <edge source="Pipeline Throughput Rate" target="Task Count">
      <data key="d6">1.0</data>
      <data key="d7">Pipeline throughput rate is calculated using the total number of tasks and the total time to complete them.</data>
      <data key="d8">mathematical relationship,performance calculation</data>
      <data key="d9">chunk-d2fd5e9039a63352ee73f215fc8aeb15</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735532</data>
    </edge>
    <edge source="Pipeline Throughput Rate" target="Clock Cycle">
      <data key="d6">1.0</data>
      <data key="d7">The maximum throughput rate is inversely proportional to the clock cycle duration.</data>
      <data key="d8">inverse relationship,performance limit</data>
      <data key="d9">chunk-d2fd5e9039a63352ee73f215fc8aeb15</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735533</data>
    </edge>
    <edge source="Pipeline Throughput Rate" target="Maximum Throughput Rate">
      <data key="d6">1.0</data>
      <data key="d7">The pipeline throughput rate approaches the maximum throughput rate as the task count increases indefinitely.</data>
      <data key="d8">asymptotic behavior,ideal case</data>
      <data key="d9">chunk-d2fd5e9039a63352ee73f215fc8aeb15</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735534</data>
    </edge>
    <edge source="Task Count" target="Non-Pipelined Total Time">
      <data key="d6">1.0</data>
      <data key="d7">The total time for sequential execution is proportional to the product of the number of tasks, the number of stages, and the clock cycle.</data>
      <data key="d8">sequential execution,time complexity</data>
      <data key="d9">chunk-d2fd5e9039a63352ee73f215fc8aeb15</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735533</data>
    </edge>
    <edge source="Task Count" target="Pipelined Total Time">
      <data key="d6">1.0</data>
      <data key="d7">The total time in a pipeline increases linearly with the number of tasks (n) after the initial setup phase.</data>
      <data key="d8">execution duration,time dependency</data>
      <data key="d9">chunk-d2fd5e9039a63352ee73f215fc8aeb15</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735534</data>
    </edge>
    <edge source="Number of Pipeline Stages" target="Maximum Speedup Ratio">
      <data key="d6">1.0</data>
      <data key="d7">The maximum speedup ratio (Smax) is equal to the number of pipeline stages (k), representing the upper bound of performance improvement.</data>
      <data key="d8">direct proportionality,theoretical maximum</data>
      <data key="d9">chunk-d2fd5e9039a63352ee73f215fc8aeb15</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735532</data>
    </edge>
    <edge source="Number of Pipeline Stages" target="Pipelined Total Time">
      <data key="d6">1.0</data>
      <data key="d7">The total time in a pipeline increases with the number of stages (k), but grows sublinearly with task count.</data>
      <data key="d8">execution duration,time dependency</data>
      <data key="d9">chunk-d2fd5e9039a63352ee73f215fc8aeb15</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735534</data>
    </edge>
    <edge source="Number of Pipeline Stages" target="Speedup Ratio">
      <data key="d6">1.0</data>
      <data key="d7">The speedup ratio increases linearly with the number of pipeline stages, reaching its maximum at Smax = k.</data>
      <data key="d8">direct proportionality,performance upper bound</data>
      <data key="d9">chunk-d2fd5e9039a63352ee73f215fc8aeb15</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735535</data>
    </edge>
    <edge source="Clock Cycle" target="Maximum Throughput Rate">
      <data key="d6">1.0</data>
      <data key="d7">The maximum throughput rate (TPmax) is determined by the reciprocal of the clock cycle (1/Δt).</data>
      <data key="d8">inverse proportionality,theoretical limit</data>
      <data key="d9">chunk-d2fd5e9039a63352ee73f215fc8aeb15</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735534</data>
    </edge>
    <edge source="Clock Cycle" target="CPU">
      <data key="d6">1.0</data>
      <data key="d7">In modern systems, the clock cycle serves as the primary timing reference, replacing the older machine cycle structure.</data>
      <data key="d8">modern synchronization,timing mechanism</data>
      <data key="d9">chunk-643c2ebb8e3d3384d19f217865cc3b8f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735901</data>
    </edge>
    <edge source="Clock Cycle" target="Superpipeline Technology">
      <data key="d6">1.0</data>
      <data key="d7">Superpipeline Technology reduces clock cycle duration by increasing pipeline stages, thereby improving throughput.</data>
      <data key="d8">performance trade-off,timing mechanism</data>
      <data key="d9">chunk-3ac380505fdc239a4da36a89716b6444</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736311</data>
    </edge>
    <edge source="Clock Cycle" target="Data Path">
      <data key="d6">1.0</data>
      <data key="d7">The clock cycle in a processor is determined by the longest path in the data path, affecting overall performance.</data>
      <data key="d8">critical path,timing dependency</data>
      <data key="d9">chunk-5ea0f23d1c767bafc743ff484eb189e1</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736490</data>
    </edge>
    <edge source="Clock Cycle" target="Fetch Stage">
      <data key="d6">1.0</data>
      <data key="d7">The fetch stage takes 200ps, which is the longest time among all stages and determines the clock cycle length.</data>
      <data key="d8">pipeline stage,timing constraint</data>
      <data key="d9">chunk-5ea0f23d1c767bafc743ff484eb189e1</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736491</data>
    </edge>
    <edge source="Clock Cycle" target="Memory Access Stage">
      <data key="d6">1.0</data>
      <data key="d7">The memory access stage takes 200ps, matching the longest stage and setting the clock cycle duration.</data>
      <data key="d8">pipeline stage,timing constraint</data>
      <data key="d9">chunk-5ea0f23d1c767bafc743ff484eb189e1</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736492</data>
    </edge>
    <edge source="Clock Cycle" target="Fine-Grained Multithreading">
      <data key="d6">1.0</data>
      <data key="d7">Fine-grained multithreading switches threads every clock cycle, allowing interleaved execution of instructions.</data>
      <data key="d8">execution timing,interleaved execution</data>
      <data key="d9">chunk-f67ff7c347b613bc05733f64a51c9c17</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736743</data>
    </edge>
    <edge source="Clock Cycle" target="Instruction Fetch">
      <data key="d6">1.0</data>
      <data key="d7">Instruction fetch requires three clock cycles for its sequence: address transfer, memory read, and instruction load.</data>
      <data key="d8">operation execution,timing</data>
      <data key="d9">chunk-0efa36a872f0b1511a047f0591cba52c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736813</data>
    </edge>
    <edge source="Clock Cycle" target="Arithmetic Operation">
      <data key="d6">1.0</data>
      <data key="d7">The arithmetic operation requires three sequential clock cycles due to operand loading, computation, and result writing stages.</data>
      <data key="d8">sequential execution,timing</data>
      <data key="d9">chunk-0efa36a872f0b1511a047f0591cba52c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736814</data>
    </edge>
    <edge source="Maximum Throughput Rate" target="Ideal Continuous Input">
      <data key="d6">1.0</data>
      <data key="d7">The maximum throughput rate is achieved under ideal continuous input when the number of tasks approaches infinity.</data>
      <data key="d8">condition for theoretical maximum,performance optimization</data>
      <data key="d9">chunk-d2fd5e9039a63352ee73f215fc8aeb15</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735533</data>
    </edge>
    <edge source="Speedup Ratio" target="Non-Pipelined Total Time">
      <data key="d6">1.0</data>
      <data key="d7">The speedup ratio is derived by dividing the non-pipelined total time by the pipelined total time.</data>
      <data key="d8">efficiency measure,ratio calculation</data>
      <data key="d9">chunk-d2fd5e9039a63352ee73f215fc8aeb15</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735532</data>
    </edge>
    <edge source="Speedup Ratio" target="Pipelined Total Time">
      <data key="d6">1.0</data>
      <data key="d7">The speedup ratio depends on the time saved by using a pipeline compared to sequential execution.</data>
      <data key="d8">efficiency measure,ratio calculation</data>
      <data key="d9">chunk-d2fd5e9039a63352ee73f215fc8aeb15</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735533</data>
    </edge>
    <edge source="Speedup Ratio" target="Maximum Speedup Ratio">
      <data key="d6">1.0</data>
      <data key="d7">The speedup ratio reaches its maximum value (Smax) when the number of tasks is infinitely large, equaling the number of pipeline stages.</data>
      <data key="d8">performance ceiling,theoretical limit</data>
      <data key="d9">chunk-d2fd5e9039a63352ee73f215fc8aeb15</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735534</data>
    </edge>
    <edge source="Instruction Cycle" target="Fetch Cycle">
      <data key="d6">1.0</data>
      <data key="d7">The Fetch Cycle is the first phase of the Instruction Cycle.</data>
      <data key="d8">execution phase,sequence completion</data>
      <data key="d9">chunk-06dc541c0ea968720bb78e8c162eb159</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735552</data>
    </edge>
    <edge source="Instruction Cycle" target="Indirect Addressing Cycle">
      <data key="d6">2.0</data>
      <data key="d7">The Indirect Addressing Cycle is the second phase of the Instruction Cycle.&lt;SEP&gt;The indirect addressing cycle is an optional phase occurring between the fetch and execute phases when indirect addressing is used.</data>
      <data key="d8">conditional phase,execution phase,phase sequence,sequence completion</data>
      <data key="d9">chunk-06dc541c0ea968720bb78e8c162eb159&lt;SEP&gt;chunk-643c2ebb8e3d3384d19f217865cc3b8f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735899</data>
    </edge>
    <edge source="Instruction Cycle" target="Execution Cycle">
      <data key="d6">1.0</data>
      <data key="d7">The Execution Cycle is the third phase of the Instruction Cycle.</data>
      <data key="d8">execution phase,sequence completion</data>
      <data key="d9">chunk-06dc541c0ea968720bb78e8c162eb159</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735553</data>
    </edge>
    <edge source="Instruction Cycle" target="Interrupt Cycle">
      <data key="d6">2.0</data>
      <data key="d7">The Interrupt Cycle is the fourth phase of the Instruction Cycle.&lt;SEP&gt;The interrupt cycle is triggered at the end of execution if an interrupt is detected, enabling system response to external events.</data>
      <data key="d8">exception handling,execution phase,phase sequence,sequence completion</data>
      <data key="d9">chunk-06dc541c0ea968720bb78e8c162eb159&lt;SEP&gt;chunk-643c2ebb8e3d3384d19f217865cc3b8f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735899</data>
    </edge>
    <edge source="Instruction Cycle" target="Fetch Phase">
      <data key="d6">1.0</data>
      <data key="d7">The instruction cycle begins with the fetch phase, which retrieves and analyzes the instruction.</data>
      <data key="d8">execution flow,phase sequence</data>
      <data key="d9">chunk-643c2ebb8e3d3384d19f217865cc3b8f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735897</data>
    </edge>
    <edge source="Instruction Cycle" target="Execute Phase">
      <data key="d6">1.0</data>
      <data key="d7">Following the fetch phase, the instruction cycle proceeds to the execute phase for operational execution.</data>
      <data key="d8">execution flow,phase sequence</data>
      <data key="d9">chunk-643c2ebb8e3d3384d19f217865cc3b8f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735898</data>
    </edge>
    <edge source="Instruction Cycle" target="CPU">
      <data key="d6">1.0</data>
      <data key="d7">The CPU manages the entire instruction cycle, dividing it into multiple phases for instruction processing.</data>
      <data key="d8">execution unit,processor operation</data>
      <data key="d9">chunk-643c2ebb8e3d3384d19f217865cc3b8f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735900</data>
    </edge>
    <edge source="Data Flow" target="Data Path">
      <data key="d6">1.0</data>
      <data key="d7">Data Flow is described by the structure and operation of the Data Path, defining how data moves from source to destination.</data>
      <data key="d8">information movement,structural description</data>
      <data key="d9">chunk-cf0a63e25f70bb6e12f2ee7720496542</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736564</data>
    </edge>
    <edge source="PC" target="Fetch Cycle">
      <data key="d6">1.0</data>
      <data key="d7">The fetch cycle uses the PC to determine the address of the next instruction to fetch.</data>
      <data key="d8">address source,data access</data>
      <data key="d9">chunk-06dc541c0ea968720bb78e8c162eb159</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735553</data>
    </edge>
    <edge source="PC" target="Interrupt Cycle">
      <data key="d6">1.0</data>
      <data key="d7">The interrupt cycle updates PC with the entry address of the interrupt service routine.</data>
      <data key="d8">instruction pointer update,service routine transfer</data>
      <data key="d9">chunk-06dc541c0ea968720bb78e8c162eb159</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735557</data>
    </edge>
    <edge source="PC" target="控制器">
      <data key="d6">1.0</data>
      <data key="d7">PC是控制器中用于保存当前指令地址并指向下一条指令位置的重要寄存器。</data>
      <data key="d8">instruction sequencing,program counter function</data>
      <data key="d9">chunk-7c0bc146aeae05e551f80c74f57bf6cc</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735666</data>
    </edge>
    <edge source="IR" target="Indirect Addressing Cycle">
      <data key="d6">1.0</data>
      <data key="d7">The indirect addressing cycle reads the address field from IR.</data>
      <data key="d8">address extraction,instruction access</data>
      <data key="d9">chunk-06dc541c0ea968720bb78e8c162eb159</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735554</data>
    </edge>
    <edge source="IR" target="Fetch Cycle">
      <data key="d6">1.0</data>
      <data key="d7">The fetch cycle transfers the instruction from MDR to IR for processing.</data>
      <data key="d8">instruction storage</data>
      <data key="d9">chunk-06dc541c0ea968720bb78e8c162eb159</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735555</data>
    </edge>
    <edge source="IR" target="Execution Cycle">
      <data key="d6">1.0</data>
      <data key="d7">The execution cycle reads the opcode from IR to determine the required operation.</data>
      <data key="d8">instruction access,opcode decoding</data>
      <data key="d9">chunk-06dc541c0ea968720bb78e8c162eb159</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735556</data>
    </edge>
    <edge source="IR" target="控制器">
      <data key="d6">1.0</data>
      <data key="d7">IR是控制器中用于保存当前正在执行的指令的寄存器。</data>
      <data key="d8">instruction register function,instruction storage</data>
      <data key="d9">chunk-7c0bc146aeae05e551f80c74f57bf6cc</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735668</data>
    </edge>
    <edge source="MAR" target="Fetch Cycle">
      <data key="d6">1.0</data>
      <data key="d7">The fetch cycle uses MAR to transmit the address over the address bus.</data>
      <data key="d8">address transmission</data>
      <data key="d9">chunk-06dc541c0ea968720bb78e8c162eb159</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735554</data>
    </edge>
    <edge source="MAR" target="Indirect Addressing Cycle">
      <data key="d6">1.0</data>
      <data key="d7">The indirect addressing cycle uses MAR to send the base address to the memory.</data>
      <data key="d8">address transmission</data>
      <data key="d9">chunk-06dc541c0ea968720bb78e8c162eb159</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735555</data>
    </edge>
    <edge source="MAR" target="Interrupt Cycle">
      <data key="d6">1.0</data>
      <data key="d7">The interrupt cycle uses MAR to transmit the stack address.</data>
      <data key="d8">address transmission</data>
      <data key="d9">chunk-06dc541c0ea968720bb78e8c162eb159</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735556</data>
    </edge>
    <edge source="MDR" target="Indirect Addressing Cycle">
      <data key="d6">1.0</data>
      <data key="d7">The indirect addressing cycle stores the effective address in MDR.</data>
      <data key="d8">address storage</data>
      <data key="d9">chunk-06dc541c0ea968720bb78e8c162eb159</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735554</data>
    </edge>
    <edge source="MDR" target="Fetch Cycle">
      <data key="d6">1.0</data>
      <data key="d7">The fetch cycle stores the retrieved instruction in the MDR.</data>
      <data key="d8">data storage</data>
      <data key="d9">chunk-06dc541c0ea968720bb78e8c162eb159</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735555</data>
    </edge>
    <edge source="CU" target="Fetch Cycle">
      <data key="d6">1.0</data>
      <data key="d7">The fetch cycle relies on the CU to control the PC increment.</data>
      <data key="d8">control coordination</data>
      <data key="d9">chunk-06dc541c0ea968720bb78e8c162eb159</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735556</data>
    </edge>
    <edge source="ALU" target="Execution Cycle">
      <data key="d6">1.0</data>
      <data key="d7">The execution cycle uses the ALU to perform operations based on the instruction opcode.</data>
      <data key="d8">data processing,operation execution</data>
      <data key="d9">chunk-06dc541c0ea968720bb78e8c162eb159</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735555</data>
    </edge>
    <edge source="ALU" target="Vector Processor">
      <data key="d6">1.0</data>
      <data key="d7">Vector processors use multiple ALUs to perform arithmetic operations on vector data simultaneously.</data>
      <data key="d8">computation,functional unit</data>
      <data key="d9">chunk-cc56d9863e6de5d5a6e95e87766d0742</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735675</data>
    </edge>
    <edge source="ALU" target="Single Bus Structure Data Path">
      <data key="d6">1.0</data>
      <data key="d7">The ALU is connected to the single bus structure data path via the internal bus.</data>
      <data key="d8">connection point,functional component</data>
      <data key="d9">chunk-2a63536239036e36be43b7e72d560b24</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735986</data>
    </edge>
    <edge source="ALU" target="Dedicated Data Path">
      <data key="d6">1.0</data>
      <data key="d7">In the dedicated data path, the ALU is directly connected to data flow paths, avoiding shared bus contention.</data>
      <data key="d8">direct connection,functional component</data>
      <data key="d9">chunk-2a63536239036e36be43b7e72d560b24</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735987</data>
    </edge>
    <edge source="ALU" target="Data Path">
      <data key="d6">1.0</data>
      <data key="d7">The ALU is a functional component of the Data Path responsible for executing arithmetic and logical operations.</data>
      <data key="d8">data processing,functional component</data>
      <data key="d9">chunk-cf0a63e25f70bb6e12f2ee7720496542</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736560</data>
    </edge>
    <edge source="SP" target="Interrupt Cycle">
      <data key="d6">1.0</data>
      <data key="d7">The interrupt cycle modifies the SP to point to the new stack top.</data>
      <data key="d8">stack operation,stack pointer management</data>
      <data key="d9">chunk-06dc541c0ea968720bb78e8c162eb159</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735555</data>
    </edge>
    <edge source="Main Memory" target="Fetch Cycle">
      <data key="d6">1.0</data>
      <data key="d7">The fetch cycle retrieves the instruction from main memory.</data>
      <data key="d8">data source,instruction retrieval</data>
      <data key="d9">chunk-06dc541c0ea968720bb78e8c162eb159</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735553</data>
    </edge>
    <edge source="Main Memory" target="Indirect Addressing Cycle">
      <data key="d6">2.0</data>
      <data key="d7">The indirect addressing cycle retrieves the effective address from main memory.&lt;SEP&gt;During indirect addressing, the main memory is accessed twice: once to fetch the effective address and once to fetch the operand.</data>
      <data key="d8">data access,data source,effective address retrieval,operand retrieval</data>
      <data key="d9">chunk-06dc541c0ea968720bb78e8c162eb159&lt;SEP&gt;chunk-643c2ebb8e3d3384d19f217865cc3b8f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735900</data>
    </edge>
    <edge source="Main Memory" target="Interrupt Cycle">
      <data key="d6">1.0</data>
      <data key="d7">The interrupt cycle stores the program breakpoint into main memory.</data>
      <data key="d8">data storage,state saving</data>
      <data key="d9">chunk-06dc541c0ea968720bb78e8c162eb159</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735557</data>
    </edge>
    <edge source="Main Memory" target="RAM">
      <data key="d6">1.0</data>
      <data key="d7">Main memory uses RAM to store programs and data externally within the CPU.</data>
      <data key="d8">external memory implementation,program and data storage</data>
      <data key="d9">chunk-fe06e06cd53b2ace66af32c5e482dce9</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735814</data>
    </edge>
    <edge source="Main Memory" target="Instruction Register">
      <data key="d6">1.0</data>
      <data key="d7">The instruction register fetches instructions from main memory for execution.</data>
      <data key="d8">instruction fetching,program execution</data>
      <data key="d9">chunk-fe06e06cd53b2ace66af32c5e482dce9</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735815</data>
    </edge>
    <edge source="Main Memory" target="Address Register">
      <data key="d6">1.0</data>
      <data key="d7">The address register specifies the memory address for reading or writing data in main memory.</data>
      <data key="d8">address control,memory access</data>
      <data key="d9">chunk-fe06e06cd53b2ace66af32c5e482dce9</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735816</data>
    </edge>
    <edge source="Main Memory" target="Program Counter">
      <data key="d6">2.0</data>
      <data key="d7">The program counter provides the address to access the main memory for instruction retrieval.&lt;SEP&gt;The Program Counter provides the address for fetching the next instruction from Main Memory.</data>
      <data key="d8">address referencing,data access,instruction address,instruction fetching</data>
      <data key="d9">chunk-acb6520440fa5141fe4d034f3e5e6edf&lt;SEP&gt;chunk-643c2ebb8e3d3384d19f217865cc3b8f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735998</data>
    </edge>
    <edge source="Main Memory" target="Multi-Core Processor">
      <data key="d6">1.0</data>
      <data key="d7">All cores within a multi-core processor share access to the main memory.</data>
      <data key="d8">shared resource,system architecture</data>
      <data key="d9">chunk-ea027e504c6e7bd731aebc2b71512e1c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736027</data>
    </edge>
    <edge source="Main Memory" target="Page Fault">
      <data key="d6">1.0</data>
      <data key="d7">Page faults occur when required pages are missing from main memory and must be loaded from the disk.</data>
      <data key="d8">memory management,page loading</data>
      <data key="d9">chunk-62d730248fb05de6d5c2902d76480b63</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736299</data>
    </edge>
    <edge source="Main Memory" target="Segment Fault">
      <data key="d6">1.0</data>
      <data key="d7">Segment faults occur when required segments are not present in main memory and must be loaded.</data>
      <data key="d8">memory management,segment loading</data>
      <data key="d9">chunk-62d730248fb05de6d5c2902d76480b63</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736300</data>
    </edge>
    <edge source="Address Bus" target="Fetch Cycle">
      <data key="d6">1.0</data>
      <data key="d7">The fetch cycle sends the instruction address through the address bus.</data>
      <data key="d8">address transmission</data>
      <data key="d9">chunk-06dc541c0ea968720bb78e8c162eb159</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735554</data>
    </edge>
    <edge source="Address Bus" target="Indirect Addressing Cycle">
      <data key="d6">1.0</data>
      <data key="d7">The indirect addressing cycle uses the address bus to send the memory address.</data>
      <data key="d8">address transmission</data>
      <data key="d9">chunk-06dc541c0ea968720bb78e8c162eb159</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735555</data>
    </edge>
    <edge source="Address Bus" target="Interrupt Cycle">
      <data key="d6">1.0</data>
      <data key="d7">The interrupt cycle uses the address bus to send the stack location address.</data>
      <data key="d8">address transmission</data>
      <data key="d9">chunk-06dc541c0ea968720bb78e8c162eb159</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735557</data>
    </edge>
    <edge source="Data Bus" target="Temporary Register">
      <data key="d6">1.0</data>
      <data key="d7">The Data Bus transfers data to the Temporary Register for processing.</data>
      <data key="d8">buffering,data input</data>
      <data key="d9">chunk-acb6520440fa5141fe4d034f3e5e6edf</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735998</data>
    </edge>
    <edge source="Control Bus" target="Fetch Cycle">
      <data key="d6">1.0</data>
      <data key="d7">The fetch cycle uses the control bus to issue a read command.</data>
      <data key="d8">command transmission</data>
      <data key="d9">chunk-06dc541c0ea968720bb78e8c162eb159</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735555</data>
    </edge>
    <edge source="Control Bus" target="Indirect Addressing Cycle">
      <data key="d6">1.0</data>
      <data key="d7">The indirect addressing cycle uses the control bus to issue a read command.</data>
      <data key="d8">command transmission</data>
      <data key="d9">chunk-06dc541c0ea968720bb78e8c162eb159</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735556</data>
    </edge>
    <edge source="Control Bus" target="Interrupt Cycle">
      <data key="d6">1.0</data>
      <data key="d7">The interrupt cycle uses the control bus to issue a write command for saving the breakpoint.</data>
      <data key="d8">command transmission,write operation</data>
      <data key="d9">chunk-06dc541c0ea968720bb78e8c162eb159</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735558</data>
    </edge>
    <edge source="Indirect Addressing Cycle" target="Execution Phase">
      <data key="d6">1.0</data>
      <data key="d7">The execution phase follows the indirect addressing cycle only when indirect addressing is used.</data>
      <data key="d8">operation dependency</data>
      <data key="d9">chunk-643c2ebb8e3d3384d19f217865cc3b8f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735899</data>
    </edge>
    <edge source="Interrupt Cycle" target="Stack">
      <data key="d6">1.0</data>
      <data key="d7">The interrupt cycle saves the program state onto the stack.</data>
      <data key="d8">data storage,state preservation</data>
      <data key="d9">chunk-06dc541c0ea968720bb78e8c162eb159</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735558</data>
    </edge>
    <edge source="Interrupt Cycle" target="Stack Pointer">
      <data key="d6">1.0</data>
      <data key="d7">During interrupt handling, the stack pointer is decremented to perform a stack push operation, as the stack grows toward low addresses.</data>
      <data key="d8">stack behavior,state preservation</data>
      <data key="d9">chunk-643c2ebb8e3d3384d19f217865cc3b8f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735900</data>
    </edge>
    <edge source="Stack" target="Breakpoint">
      <data key="d6">1.0</data>
      <data key="d7">The breakpoint is stored in the stack to support the nesting of exceptions and interrupts.</data>
      <data key="d8">nesting support,storage location</data>
      <data key="d9">chunk-d405a4a8ff3786f94e93e3a9b7786551</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736116</data>
    </edge>
    <edge source="Stack" target="Program Status Word (PSW)">
      <data key="d6">1.0</data>
      <data key="d7">The PSW is saved in the stack to ensure correct processor state restoration after handling.</data>
      <data key="d8">restoration,state storage</data>
      <data key="d9">chunk-d405a4a8ff3786f94e93e3a9b7786551</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736118</data>
    </edge>
    <edge source="控制器" target="数据总线">
      <data key="d6">1.0</data>
      <data key="d7">控制器从数据总线接收指令信息，并向系统中的部件发送控制信号。</data>
      <data key="d8">control signal delivery,instruction fetching</data>
      <data key="d9">chunk-7c0bc146aeae05e551f80c74f57bf6cc</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735660</data>
    </edge>
    <edge source="控制器" target="运算器部件">
      <data key="d6">1.0</data>
      <data key="d7">控制器从运算器部件接收指令转移地址，并协调其运行。</data>
      <data key="d8">control coordination,instruction address transfer</data>
      <data key="d9">chunk-7c0bc146aeae05e551f80c74f57bf6cc</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735661</data>
    </edge>
    <edge source="控制器" target="地址总线">
      <data key="d6">1.0</data>
      <data key="d7">控制器向地址总线发送指令地址，以激活目标部件。</data>
      <data key="d8">address transmission,command routing</data>
      <data key="d9">chunk-7c0bc146aeae05e551f80c74f57bf6cc</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735661</data>
    </edge>
    <edge source="控制器" target="控制总线">
      <data key="d6">1.0</data>
      <data key="d7">控制器通过控制总线向系统部件提供运行所需的控制信号。</data>
      <data key="d8">control signal broadcasting,system coordination</data>
      <data key="d9">chunk-7c0bc146aeae05e551f80c74f57bf6cc</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735661</data>
    </edge>
    <edge source="控制器" target="主存">
      <data key="d6">1.0</data>
      <data key="d7">控制器从主存中取出指令，并管理下一条指令的位置。</data>
      <data key="d8">instruction fetching,program flow control</data>
      <data key="d9">chunk-7c0bc146aeae05e551f80c74f57bf6cc</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735662</data>
    </edge>
    <edge source="控制器" target="输入设备">
      <data key="d6">1.0</data>
      <data key="d7">控制器协调输入设备与主存和CPU之间的数据流动，并提供必要的控制信号。</data>
      <data key="d8">control signal delivery,data transmission coordination</data>
      <data key="d9">chunk-7c0bc146aeae05e551f80c74f57bf6cc</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735664</data>
    </edge>
    <edge source="控制器" target="输出设备">
      <data key="d6">1.0</data>
      <data key="d7">控制器协调输出设备与主存和CPU之间的数据流动，并提供必要的控制信号。</data>
      <data key="d8">control signal delivery,data transmission coordination</data>
      <data key="d9">chunk-7c0bc146aeae05e551f80c74f57bf6cc</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735665</data>
    </edge>
    <edge source="运算器部件" target="数据总线">
      <data key="d6">1.0</data>
      <data key="d7">运算器部件通过数据总线与内存储器、输入设备和输出设备交换数据，完成计算任务。</data>
      <data key="d8">arithmetic operations,data transmission</data>
      <data key="d9">chunk-7c0bc146aeae05e551f80c74f57bf6cc</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735660</data>
    </edge>
    <edge source="内存储器" target="地址总线">
      <data key="d6">1.0</data>
      <data key="d7">内存储器从地址总线接收地址信息以定位存储单元。</data>
      <data key="d8">address access,memory addressing</data>
      <data key="d9">chunk-7c0bc146aeae05e551f80c74f57bf6cc</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735661</data>
    </edge>
    <edge source="内存储器" target="控制总线">
      <data key="d6">1.0</data>
      <data key="d7">内存储器从控制总线接收控制信号以执行读写操作。</data>
      <data key="d8">control signal reception,memory operation</data>
      <data key="d9">chunk-7c0bc146aeae05e551f80c74f57bf6cc</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735662</data>
    </edge>
    <edge source="内存储器" target="数据总线">
      <data key="d6">1.0</data>
      <data key="d7">内存储器通过数据总线与运算器、输入设备、输出设备交换数据。</data>
      <data key="d8">data exchange,memory access</data>
      <data key="d9">chunk-7c0bc146aeae05e551f80c74f57bf6cc</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735663</data>
    </edge>
    <edge source="输入设备" target="接口电路">
      <data key="d6">1.0</data>
      <data key="d7">输入设备通过接口电路与总线连接，实现数据与总线间传输。</data>
      <data key="d8">connection,data transfer interface</data>
      <data key="d9">chunk-7c0bc146aeae05e551f80c74f57bf6cc</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735661</data>
    </edge>
    <edge source="输入设备" target="地址总线">
      <data key="d6">1.0</data>
      <data key="d7">输入设备从地址总线接收地址信息以识别操作目标。</data>
      <data key="d8">address access,device identification</data>
      <data key="d9">chunk-7c0bc146aeae05e551f80c74f57bf6cc</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735663</data>
    </edge>
    <edge source="输入设备" target="控制总线">
      <data key="d6">1.0</data>
      <data key="d7">输入设备从控制总线接收控制信号以启动或控制其工作。</data>
      <data key="d8">control signal reception,operation execution</data>
      <data key="d9">chunk-7c0bc146aeae05e551f80c74f57bf6cc</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735663</data>
    </edge>
    <edge source="输入设备" target="数据总线">
      <data key="d6">1.0</data>
      <data key="d7">输入设备通过数据总线将数据传送到其他部件。</data>
      <data key="d8">data transmission,input processing</data>
      <data key="d9">chunk-7c0bc146aeae05e551f80c74f57bf6cc</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735665</data>
    </edge>
    <edge source="输出设备" target="接口电路">
      <data key="d6">1.0</data>
      <data key="d7">输出设备通过接口电路与总线连接，实现数据与总线间传输。</data>
      <data key="d8">connection,data transfer interface</data>
      <data key="d9">chunk-7c0bc146aeae05e551f80c74f57bf6cc</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735663</data>
    </edge>
    <edge source="输出设备" target="地址总线">
      <data key="d6">1.0</data>
      <data key="d7">输出设备从地址总线接收地址信息以识别目标地址。</data>
      <data key="d8">address access,device identification</data>
      <data key="d9">chunk-7c0bc146aeae05e551f80c74f57bf6cc</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735663</data>
    </edge>
    <edge source="输出设备" target="控制总线">
      <data key="d6">1.0</data>
      <data key="d7">输出设备从控制总线接收控制信号以启动或控制其工作。</data>
      <data key="d8">control signal reception,operation execution</data>
      <data key="d9">chunk-7c0bc146aeae05e551f80c74f57bf6cc</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735664</data>
    </edge>
    <edge source="输出设备" target="数据总线">
      <data key="d6">1.0</data>
      <data key="d7">输出设备通过数据总线接收数据以进行输出处理。</data>
      <data key="d8">data reception,output processing</data>
      <data key="d9">chunk-7c0bc146aeae05e551f80c74f57bf6cc</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735666</data>
    </edge>
    <edge source="硬布线控制器" target="微程序控制器">
      <data key="d6">1.0</data>
      <data key="d7">两类控制器根据控制信号生成方式不同而区分为硬布线与微程序两种类型，但PC和IR功能相同。</data>
      <data key="d8">controller design,implementation method</data>
      <data key="d9">chunk-7c0bc146aeae05e551f80c74f57bf6cc</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735664</data>
    </edge>
    <edge source="微程序控制器" target="微地址形成部件">
      <data key="d6">1.0</data>
      <data key="d7">The microaddress formation component is a key part of the microprogram controller responsible for generating addresses for microinstruction execution.</data>
      <data key="d8">component,control flow</data>
      <data key="d9">chunk-7b1e3d6a0816b7c4daa74cc9c66df994</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736158</data>
    </edge>
    <edge source="微程序控制器" target="微指令地址寄存器">
      <data key="d6">1.0</data>
      <data key="d7">The microinstruction address register receives microaddresses from the microaddress formation component to prepare for microinstruction fetch.</data>
      <data key="d8">address routing,component</data>
      <data key="d9">chunk-7b1e3d6a0816b7c4daa74cc9c66df994</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736159</data>
    </edge>
    <edge source="微程序控制器" target="控制存储器">
      <data key="d6">1.0</data>
      <data key="d7">The control memory is the central storage unit in the microprogram controller, holding all microprograms.</data>
      <data key="d8">core component,instruction storage</data>
      <data key="d9">chunk-7b1e3d6a0816b7c4daa74cc9c66df994</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736159</data>
    </edge>
    <edge source="微程序控制器" target="微指令寄存器">
      <data key="d6">1.0</data>
      <data key="d7">The microinstruction register holds the current microinstruction being executed and aligns with the microinstruction word length.</data>
      <data key="d8">component,instruction processing</data>
      <data key="d9">chunk-7b1e3d6a0816b7c4daa74cc9c66df994</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736159</data>
    </edge>
    <edge source="微程序控制器" target="μPC">
      <data key="d6">1.0</data>
      <data key="d7">μPC directly manages the current microinstruction address during execution.</data>
      <data key="d8">component,execution control</data>
      <data key="d9">chunk-7b1e3d6a0816b7c4daa74cc9c66df994</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736160</data>
    </edge>
    <edge source="微程序控制器" target="CM">
      <data key="d6">1.0</data>
      <data key="d7">CM stores the microprograms that define the behavior of the microprogram controller.</data>
      <data key="d8">component,data storage</data>
      <data key="d9">chunk-7b1e3d6a0816b7c4daa74cc9c66df994</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736161</data>
    </edge>
    <edge source="微程序控制器" target="指令寄存器">
      <data key="d6">1.0</data>
      <data key="d7">The instruction register is a component of the microprogram controller's functional chain, holding fetched machine instructions.</data>
      <data key="d8">component,instruction storage</data>
      <data key="d9">chunk-7b1e3d6a0816b7c4daa74cc9c66df994</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736162</data>
    </edge>
    <edge source="微程序控制器" target="取指微程序">
      <data key="d6">1.0</data>
      <data key="d7">The microprogram controller begins execution by activating the fetch microprogram to retrieve the machine instruction.</data>
      <data key="d8">execution sequence,initialization</data>
      <data key="d9">chunk-7b1e3d6a0816b7c4daa74cc9c66df994</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736162</data>
    </edge>
    <edge source="微程序控制器" target="机器指令">
      <data key="d6">1.0</data>
      <data key="d7">Each machine instruction is mapped to a unique microprogram controlled by the microprogram controller.</data>
      <data key="d8">execution fidelity,instruction mapping</data>
      <data key="d9">chunk-7b1e3d6a0816b7c4daa74cc9c66df994</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736163</data>
    </edge>
    <edge source="微程序控制器" target="间址周期微程序">
      <data key="d6">1.0</data>
      <data key="d7">The indirect addressing cycle microprogram is executed by the microprogram controller when handling indirect addressing.</data>
      <data key="d8">control support,cycle-specific execution</data>
      <data key="d9">chunk-7b1e3d6a0816b7c4daa74cc9c66df994</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736163</data>
    </edge>
    <edge source="微程序控制器" target="中断周期微程序">
      <data key="d6">1.0</data>
      <data key="d7">The interrupt cycle microprogram is executed by the microprogram controller during interrupt processing.</data>
      <data key="d8">event-driven execution,interrupt handling</data>
      <data key="d9">chunk-7b1e3d6a0816b7c4daa74cc9c66df994</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736164</data>
    </edge>
    <edge source="CPU" target="Controller">
      <data key="d6">1.0</data>
      <data key="d7">The controller is a core functional component of the CPU, responsible for managing instruction flow.</data>
      <data key="d8">component relationship,functional integration</data>
      <data key="d9">chunk-7e297f32d868dbd2d51d7a047e223119</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735892</data>
    </edge>
    <edge source="CPU" target="Arithmetic Logic Unit">
      <data key="d6">2.0</data>
      <data key="d7">The Arithmetic Logic Unit is a core functional component of the CPU tasked with data processing.&lt;SEP&gt;The Arithmetic Logic Unit is a fundamental component of the CPU responsible for arithmetic and logic operations.</data>
      <data key="d8">component relationship,core component,functional integration,primary function</data>
      <data key="d9">chunk-7e297f32d868dbd2d51d7a047e223119&lt;SEP&gt;chunk-de401d6e0254effcba3f6fcd81cefe60</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736503</data>
    </edge>
    <edge source="CPU" target="Instruction Control">
      <data key="d6">1.0</data>
      <data key="d7">The CPU performs instruction control as a fundamental function in managing program execution.</data>
      <data key="d8">functional capability,primary role</data>
      <data key="d9">chunk-7e297f32d868dbd2d51d7a047e223119</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735893</data>
    </edge>
    <edge source="CPU" target="Operation Control">
      <data key="d6">1.0</data>
      <data key="d7">The CPU executes operation control to coordinate operations across hardware components.</data>
      <data key="d8">functional capability,primary role</data>
      <data key="d9">chunk-7e297f32d868dbd2d51d7a047e223119</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735893</data>
    </edge>
    <edge source="CPU" target="Time Control">
      <data key="d6">1.0</data>
      <data key="d7">The CPU uses time control to regulate signal timing and sequence during execution.</data>
      <data key="d8">functional capability,primary role</data>
      <data key="d9">chunk-7e297f32d868dbd2d51d7a047e223119</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735894</data>
    </edge>
    <edge source="CPU" target="Data Processing">
      <data key="d6">1.0</data>
      <data key="d7">The CPU performs data processing through arithmetic and logical operations.</data>
      <data key="d8">functional capability,primary role</data>
      <data key="d9">chunk-7e297f32d868dbd2d51d7a047e223119</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735896</data>
    </edge>
    <edge source="CPU" target="Interrupt Handling">
      <data key="d6">1.0</data>
      <data key="d7">The CPU manages interrupt handling to respond to unexpected events during execution.</data>
      <data key="d8">functional capability,primary role</data>
      <data key="d9">chunk-7e297f32d868dbd2d51d7a047e223119</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735896</data>
    </edge>
    <edge source="CPU" target="Register">
      <data key="d6">1.0</data>
      <data key="d7">The CPU contains multiple registers that serve as internal storage units for data and instructions during execution.</data>
      <data key="d8">data handling,internal component</data>
      <data key="d9">chunk-acb6520440fa5141fe4d034f3e5e6edf</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735994</data>
    </edge>
    <edge source="CPU" target="User Visible Register">
      <data key="d6">1.0</data>
      <data key="d7">User visible registers are accessible to programmers and help reduce the need for main memory access.</data>
      <data key="d8">memory access optimization,programmable storage</data>
      <data key="d9">chunk-acb6520440fa5141fe4d034f3e5e6edf</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735995</data>
    </edge>
    <edge source="CPU" target="User Invisible Register">
      <data key="d6">1.0</data>
      <data key="d7">User invisible registers are used by the control unit and are transparent to the programmer.</data>
      <data key="d8">control unit function,operational transparency</data>
      <data key="d9">chunk-acb6520440fa5141fe4d034f3e5e6edf</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735995</data>
    </edge>
    <edge source="CPU" target="General Purpose Register Group">
      <data key="d6">2.0</data>
      <data key="d7">The General Purpose Register Group holds operands and addresses during execution.&lt;SEP&gt;The General Purpose Register Group is a key component of the CPU used for temporary data storage.</data>
      <data key="d8">data storage,functional component,operand management</data>
      <data key="d9">chunk-acb6520440fa5141fe4d034f3e5e6edf&lt;SEP&gt;chunk-de401d6e0254effcba3f6fcd81cefe60</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736504</data>
    </edge>
    <edge source="CPU" target="Program Status Word Register">
      <data key="d6">2.0</data>
      <data key="d7">The Program Status Word Register stores execution status flags for conditional operations.&lt;SEP&gt;The Program Status Word Register stores condition flags used in decision-making during instruction execution.</data>
      <data key="d8">condition encoding,flag storage,status management,status tracking</data>
      <data key="d9">chunk-acb6520440fa5141fe4d034f3e5e6edf&lt;SEP&gt;chunk-de401d6e0254effcba3f6fcd81cefe60</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736505</data>
    </edge>
    <edge source="CPU" target="Program Counter">
      <data key="d6">2.0</data>
      <data key="d7">The Program Counter tracks the address of the next instruction to be executed.&lt;SEP&gt;The Program Counter holds the address of the next instruction to be executed, enabling sequential instruction flow.</data>
      <data key="d8">address tracking,control flow,instruction sequencing</data>
      <data key="d9">chunk-acb6520440fa5141fe4d034f3e5e6edf&lt;SEP&gt;chunk-de401d6e0254effcba3f6fcd81cefe60</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736506</data>
    </edge>
    <edge source="CPU" target="Instruction Register">
      <data key="d6">2.0</data>
      <data key="d7">The Instruction Register holds the current instruction being executed by the CPU.&lt;SEP&gt;The Instruction Register holds the current instruction being decoded and executed.</data>
      <data key="d8">execution control,instruction holding,instruction storage,processing</data>
      <data key="d9">chunk-acb6520440fa5141fe4d034f3e5e6edf&lt;SEP&gt;chunk-de401d6e0254effcba3f6fcd81cefe60</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736506</data>
    </edge>
    <edge source="CPU" target="Memory Address Register">
      <data key="d6">1.0</data>
      <data key="d7">The Memory Address Register holds the address of a memory location to be accessed.</data>
      <data key="d8">address storage,memory access management</data>
      <data key="d9">chunk-acb6520440fa5141fe4d034f3e5e6edf</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735998</data>
    </edge>
    <edge source="CPU" target="Memory Data Register">
      <data key="d6">1.0</data>
      <data key="d7">The Memory Data Register temporarily holds data being sent to or retrieved from memory.</data>
      <data key="d8">data transfer,memory interface</data>
      <data key="d9">chunk-acb6520440fa5141fe4d034f3e5e6edf</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735998</data>
    </edge>
    <edge source="CPU" target="Temporary Register">
      <data key="d6">1.0</data>
      <data key="d7">The Temporary Register buffers data from the data bus or general-purpose registers before ALU processing.</data>
      <data key="d8">ALU input preparation,data buffering</data>
      <data key="d9">chunk-acb6520440fa5141fe4d034f3e5e6edf</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735998</data>
    </edge>
    <edge source="CPU" target="Accumulator">
      <data key="d6">1.0</data>
      <data key="d7">The Accumulator stores intermediate results from ALU operations.</data>
      <data key="d8">ALU support,intermediate result storage</data>
      <data key="d9">chunk-acb6520440fa5141fe4d034f3e5e6edf</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735999</data>
    </edge>
    <edge source="CPU" target="Shift Register">
      <data key="d6">1.0</data>
      <data key="d7">The Shift Register supports bit-level operations through left or right shifting.</data>
      <data key="d8">bit manipulation,data shifting</data>
      <data key="d9">chunk-acb6520440fa5141fe4d034f3e5e6edf</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735999</data>
    </edge>
    <edge source="CPU" target="Stack Pointer">
      <data key="d6">1.0</data>
      <data key="d7">The Stack Pointer manages the top of the stack in memory for function calls and local storage.</data>
      <data key="d8">memory organization,stack management</data>
      <data key="d9">chunk-acb6520440fa5141fe4d034f3e5e6edf</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736000</data>
    </edge>
    <edge source="CPU" target="Exception">
      <data key="d6">1.0</data>
      <data key="d7">The CPU detects an exception synchronously during the execution of a specific instruction.</data>
      <data key="d8">internal event detection,synchronization</data>
      <data key="d9">chunk-53c573d4212b8c79ccafbdbdcd65d8e9</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736067</data>
    </edge>
    <edge source="CPU" target="Interrupt">
      <data key="d6">1.0</data>
      <data key="d7">The CPU handles an interrupt asynchronously, triggered by an external device.</data>
      <data key="d8">asynchrony,external event handling</data>
      <data key="d9">chunk-53c573d4212b8c79ccafbdbdcd65d8e9</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736068</data>
    </edge>
    <edge source="CPU" target="User Program">
      <data key="d6">1.0</data>
      <data key="d7">The CPU may interrupt the execution of the user program to handle an exception or interrupt.</data>
      <data key="d8">context switching,execution interruption</data>
      <data key="d9">chunk-53c573d4212b8c79ccafbdbdcd65d8e9</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736069</data>
    </edge>
    <edge source="CPU" target="Exception Response Process">
      <data key="d6">1.0</data>
      <data key="d7">The CPU performs the exception response process when an exception occurs during instruction execution.</data>
      <data key="d8">execution,handling</data>
      <data key="d9">chunk-d405a4a8ff3786f94e93e3a9b7786551</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736116</data>
    </edge>
    <edge source="CPU" target="Interrupt Response Process">
      <data key="d6">1.0</data>
      <data key="d7">The CPU initiates the interrupt response process in response to an interrupt request.</data>
      <data key="d8">execution,handling</data>
      <data key="d9">chunk-d405a4a8ff3786f94e93e3a9b7786551</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736117</data>
    </edge>
    <edge source="CPU" target="Disable Interrupts">
      <data key="d6">1.0</data>
      <data key="d7">The CPU disables interrupts during critical stages to prevent interference with current processing.</data>
      <data key="d8">control mechanism,safety</data>
      <data key="d9">chunk-d405a4a8ff3786f94e93e3a9b7786551</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736118</data>
    </edge>
    <edge source="CPU" target="Save Breakpoint and Program State">
      <data key="d6">1.0</data>
      <data key="d7">The CPU saves the breakpoint and PSW to allow correct resumption of the interrupted program.</data>
      <data key="d8">recovery,state preservation</data>
      <data key="d9">chunk-d405a4a8ff3786f94e93e3a9b7786551</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736120</data>
    </edge>
    <edge source="CPU" target="Identify Exception and Interrupt and Transfer to Handler">
      <data key="d6">1.0</data>
      <data key="d7">The CPU identifies the source of the exception or interrupt and transfers control to the appropriate handler.</data>
      <data key="d8">identification,routing</data>
      <data key="d9">chunk-d405a4a8ff3786f94e93e3a9b7786551</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736120</data>
    </edge>
    <edge source="CPU" target="Single Interrupt or Exception Handling">
      <data key="d6">1.0</data>
      <data key="d7">The response process must be completed without interruption to ensure system integrity.</data>
      <data key="d8">atomicity,sequence</data>
      <data key="d9">chunk-d405a4a8ff3786f94e93e3a9b7786551</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736121</data>
    </edge>
    <edge source="CPU" target="Hard Fault Interrupt">
      <data key="d6">1.0</data>
      <data key="d7">Hard fault interrupts are generated by the CPU due to hardware-level anomalies such as memory parity errors and bus errors.</data>
      <data key="d8">hardware fault source,interruption type</data>
      <data key="d9">chunk-62d730248fb05de6d5c2902d76480b63</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736291</data>
    </edge>
    <edge source="CPU" target="Programmable Exception">
      <data key="d6">1.0</data>
      <data key="d7">Programmable exceptions arise within the CPU when executing instructions that trigger specific exception conditions.</data>
      <data key="d8">instruction-driven exception,software interrupt</data>
      <data key="d9">chunk-62d730248fb05de6d5c2902d76480b63</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736294</data>
    </edge>
    <edge source="CPU" target="Fault">
      <data key="d6">1.0</data>
      <data key="d7">Faults are a category of exceptions that occur during instruction execution and are detected before completion.</data>
      <data key="d8">exception handling,exception type</data>
      <data key="d9">chunk-62d730248fb05de6d5c2902d76480b63</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736300</data>
    </edge>
    <edge source="CPU" target="Trap">
      <data key="d6">1.0</data>
      <data key="d7">Traps are a category of exceptions triggered by specific instructions and handled by the CPU.</data>
      <data key="d8">exception handling,exception type</data>
      <data key="d9">chunk-62d730248fb05de6d5c2902d76480b63</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736301</data>
    </edge>
    <edge source="CPU" target="Abort">
      <data key="d6">1.0</data>
      <data key="d7">Aborts are a category of exceptions caused by serious hardware faults and handled by the CPU.</data>
      <data key="d8">exception handling,exception type</data>
      <data key="d9">chunk-62d730248fb05de6d5c2902d76480b63</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736302</data>
    </edge>
    <edge source="CPU" target="Instruction Decoder">
      <data key="d6">1.0</data>
      <data key="d7">The Instruction Decoder translates instruction opcodes into control signals for execution.</data>
      <data key="d8">instruction interpretation,signal generation</data>
      <data key="d9">chunk-de401d6e0254effcba3f6fcd81cefe60</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736508</data>
    </edge>
    <edge source="CPU" target="Timing Circuit">
      <data key="d6">1.0</data>
      <data key="d7">The Timing Circuit provides clock signals that coordinate the timing of CPU operations.</data>
      <data key="d8">clock management,synchronization</data>
      <data key="d9">chunk-de401d6e0254effcba3f6fcd81cefe60</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736509</data>
    </edge>
    <edge source="CPU" target="Microoperation Signal Generator">
      <data key="d6">1.0</data>
      <data key="d7">The Microoperation Signal Generator produces the control signals that drive the execution of microcommands.</data>
      <data key="d8">control signal generation,execution coordination</data>
      <data key="d9">chunk-de401d6e0254effcba3f6fcd81cefe60</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736510</data>
    </edge>
    <edge source="CPU" target="Data Path">
      <data key="d6">1.0</data>
      <data key="d7">The Data Path is a core component of the CPU, essential to its operation and processing capabilities.</data>
      <data key="d8">architectural core,component relationship</data>
      <data key="d9">chunk-cf0a63e25f70bb6e12f2ee7720496542</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736559</data>
    </edge>
    <edge source="CPU" target="Interrupt Request Signal Line">
      <data key="d6">1.0</data>
      <data key="d7">The interrupt request signal line is used by external devices to send interrupt signals to the CPU.</data>
      <data key="d8">communication channel,hardware signaling</data>
      <data key="d9">chunk-56dad084d2f83de29d62a2ae33cfc843</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736659</data>
    </edge>
    <edge source="CPU" target="Interrupt Response Cycle">
      <data key="d6">1.0</data>
      <data key="d7">After completing an instruction, the CPU enters the interrupt response cycle upon detecting an interrupt.</data>
      <data key="d8">execution phase,system state</data>
      <data key="d9">chunk-56dad084d2f83de29d62a2ae33cfc843</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736660</data>
    </edge>
    <edge source="主存" target="指令寄存器">
      <data key="d6">1.0</data>
      <data key="d7">Main memory supplies machine instructions that are loaded into the instruction register after being fetched via the fetch microprogram.</data>
      <data key="d8">data transfer,instruction fetch</data>
      <data key="d9">chunk-7b1e3d6a0816b7c4daa74cc9c66df994</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736161</data>
    </edge>
    <edge source="SISD" target="Traditional Serial Computer Architecture">
      <data key="d6">1.0</data>
      <data key="d7">SISD is the foundational model of serial, single-processor systems with a single instruction and data stream.</data>
      <data key="d8">computer architecture classification,sequential processing</data>
      <data key="d9">chunk-cc56d9863e6de5d5a6e95e87766d0742</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735672</data>
    </edge>
    <edge source="SISD" target="Serial Processor">
      <data key="d6">1.0</data>
      <data key="d7">SISD architecture is implemented in serial processors that execute one instruction at a time.</data>
      <data key="d8">architectural model,processor type</data>
      <data key="d9">chunk-cc56d9863e6de5d5a6e95e87766d0742</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735674</data>
    </edge>
    <edge source="SISD" target="Pipelining">
      <data key="d6">1.0</data>
      <data key="d7">SISD processors may use pipelining to improve instruction throughput through overlapping execution stages.</data>
      <data key="d8">design technique,performance enhancement</data>
      <data key="d9">chunk-cc56d9863e6de5d5a6e95e87766d0742</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735674</data>
    </edge>
    <edge source="SISD" target="Multi-Module Cross-Organization">
      <data key="d6">1.0</data>
      <data key="d7">SISD systems sometimes use multi-module cross-organized memory to increase bandwidth through interleaved access.</data>
      <data key="d8">memory organization,system design</data>
      <data key="d9">chunk-cc56d9863e6de5d5a6e95e87766d0742</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735676</data>
    </edge>
    <edge source="SIMD" target="Data-Level Parallelism">
      <data key="d6">1.0</data>
      <data key="d7">SIMD implements data-level parallelism, where one instruction processes multiple data elements simultaneously.</data>
      <data key="d8">data processing mode,parallelism type</data>
      <data key="d9">chunk-cc56d9863e6de5d5a6e95e87766d0742</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735672</data>
    </edge>
    <edge source="SIMD" target="Vector Processor">
      <data key="d6">1.0</data>
      <data key="d7">Vector processors are a specialized form of SIMD processors optimized for vectorized operations.</data>
      <data key="d8">processor type,variant</data>
      <data key="d9">chunk-cc56d9863e6de5d5a6e95e87766d0742</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735673</data>
    </edge>
    <edge source="SIMD" target="Parallel Hardware">
      <data key="d6">1.0</data>
      <data key="d7">SIMD architectures are implemented in parallel hardware designed to process multiple data with one instruction.</data>
      <data key="d8">execution model,hardware category</data>
      <data key="d9">chunk-cc56d9863e6de5d5a6e95e87766d0742</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735673</data>
    </edge>
    <edge source="SIMD" target="For Loop">
      <data key="d6">1.0</data>
      <data key="d7">SIMD architectures are highly efficient when executing for loops over large arrays.</data>
      <data key="d8">efficient computation,optimization</data>
      <data key="d9">chunk-cc56d9863e6de5d5a6e95e87766d0742</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735674</data>
    </edge>
    <edge source="SIMD" target="Case Statement">
      <data key="d6">1.0</data>
      <data key="d7">SIMD performs poorly with case statements due to divergent data-driven instructions.</data>
      <data key="d8">branching,inefficient execution</data>
      <data key="d9">chunk-cc56d9863e6de5d5a6e95e87766d0742</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735674</data>
    </edge>
    <edge source="SIMD" target="Switch Statement">
      <data key="d6">1.0</data>
      <data key="d7">Switch statements reduce SIMD efficiency because they require different operations per data element.</data>
      <data key="d8">branching,inefficient execution</data>
      <data key="d9">chunk-cc56d9863e6de5d5a6e95e87766d0742</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735676</data>
    </edge>
    <edge source="SIMD" target="Instruction Control Component">
      <data key="d6">1.0</data>
      <data key="d7">The instruction control component manages the distribution of a single instruction across multiple processing units in SIMD systems.</data>
      <data key="d8">architecture feature,control unit</data>
      <data key="d9">chunk-cc56d9863e6de5d5a6e95e87766d0742</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735676</data>
    </edge>
    <edge source="MISD" target="Theoretical Architecture">
      <data key="d6">1.0</data>
      <data key="d7">MISD is a theoretical model with no known practical computer systems.</data>
      <data key="d8">conceptual model,non-existent</data>
      <data key="d9">chunk-cc56d9863e6de5d5a6e95e87766d0742</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735673</data>
    </edge>
    <edge source="MIMD" target="Thread-Level Parallelism">
      <data key="d6">1.0</data>
      <data key="d7">MIMD supports thread-level or higher-level parallelism where multiple instructions operate on different data independently.</data>
      <data key="d8">parallelism type,task execution</data>
      <data key="d9">chunk-cc56d9863e6de5d5a6e95e87766d0742</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735672</data>
    </edge>
    <edge source="MIMD" target="Multicomputer System">
      <data key="d6">1.0</data>
      <data key="d7">MIMD systems can be implemented as multicomputer systems using message passing for inter-node communication.</data>
      <data key="d8">implementation,system type</data>
      <data key="d9">chunk-cc56d9863e6de5d5a6e95e87766d0742</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735673</data>
    </edge>
    <edge source="MIMD" target="Multiprocessor System">
      <data key="d6">1.0</data>
      <data key="d7">MIMD systems can be implemented as multiprocessor systems using shared memory and a single address space.</data>
      <data key="d8">implementation,system type</data>
      <data key="d9">chunk-cc56d9863e6de5d5a6e95e87766d0742</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735674</data>
    </edge>
    <edge source="Vector Processor" target="Numerical Simulation">
      <data key="d6">1.0</data>
      <data key="d7">Vector processors significantly improve performance in numerical simulations by exploiting data-level parallelism.</data>
      <data key="d8">application domain,performance boost</data>
      <data key="d9">chunk-cc56d9863e6de5d5a6e95e87766d0742</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735674</data>
    </edge>
    <edge source="Vector Processor" target="Vector Register">
      <data key="d6">1.0</data>
      <data key="d7">Vector processors rely on vector registers to hold multiple data elements during vector operations.</data>
      <data key="d8">data storage,hardware component</data>
      <data key="d9">chunk-cc56d9863e6de5d5a6e95e87766d0742</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735674</data>
    </edge>
    <edge source="Vector Processor" target="Vectorized Instruction Set">
      <data key="d6">1.0</data>
      <data key="d7">Vector processors are designed to execute vectorized instruction sets efficiently.</data>
      <data key="d8">instruction support,performance enhancement</data>
      <data key="d9">chunk-cc56d9863e6de5d5a6e95e87766d0742</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735676</data>
    </edge>
    <edge source="Processor" target="Single Cycle Processor">
      <data key="d6">1.0</data>
      <data key="d7">The single cycle processor is a design variant of a processor that executes all instructions in one clock cycle.</data>
      <data key="d8">processor type,system design</data>
      <data key="d9">chunk-3c7856616d478c58fdce251c9a2b68ac</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736783</data>
    </edge>
    <edge source="Processor" target="Pipeline Processor">
      <data key="d6">1.0</data>
      <data key="d7">The pipeline processor is a design variant of a processor that enables overlapping execution of instructions across multiple stages.</data>
      <data key="d8">processor type,system design</data>
      <data key="d9">chunk-3c7856616d478c58fdce251c9a2b68ac</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736783</data>
    </edge>
    <edge source="Processor" target="Multi Cycle Processor">
      <data key="d6">1.0</data>
      <data key="d7">The multi cycle processor is a design variant of a processor that allows variable cycle counts per instruction.</data>
      <data key="d8">processor type,system design</data>
      <data key="d9">chunk-3c7856616d478c58fdce251c9a2b68ac</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736783</data>
    </edge>
    <edge source="Memory" target="Sequential Logic Element">
      <data key="d6">1.0</data>
      <data key="d7">Memory is a sequential logic element used for storing large data sets and is clock-dependent.</data>
      <data key="d8">function,type</data>
      <data key="d9">chunk-2459f394250f45963236273137f4db0c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736396</data>
    </edge>
    <edge source="Memory" target="Memory Address Register">
      <data key="d6">1.0</data>
      <data key="d7">The memory address register holds the address used to access a specific location in memory.</data>
      <data key="d8">addressing,memory access</data>
      <data key="d9">chunk-0efa36a872f0b1511a047f0591cba52c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736811</data>
    </edge>
    <edge source="Memory" target="Memory Data Register">
      <data key="d6">1.0</data>
      <data key="d7">The memory data register receives data from memory during a read operation.</data>
      <data key="d8">data transfer,read operation</data>
      <data key="d9">chunk-0efa36a872f0b1511a047f0591cba52c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736813</data>
    </edge>
    <edge source="Memory" target="Instruction Fetch">
      <data key="d6">1.0</data>
      <data key="d7">The instruction fetch process involves accessing the memory to retrieve the next instruction for execution.</data>
      <data key="d8">instruction retrieval,memory access</data>
      <data key="d9">chunk-0efa36a872f0b1511a047f0591cba52c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736815</data>
    </edge>
    <edge source="Shared Memory" target="Multiprocessor System">
      <data key="d6">1.0</data>
      <data key="d7">Multiprocessor systems use shared memory to allow all processors to access a unified memory space.</data>
      <data key="d8">memory architecture,system design</data>
      <data key="d9">chunk-cc56d9863e6de5d5a6e95e87766d0742</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735674</data>
    </edge>
    <edge source="Private Memory" target="Multicomputer System">
      <data key="d6">1.0</data>
      <data key="d7">Multicomputer systems use private memory per node, requiring message passing for inter-node data exchange.</data>
      <data key="d8">memory architecture,system design</data>
      <data key="d9">chunk-cc56d9863e6de5d5a6e95e87766d0742</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735674</data>
    </edge>
    <edge source="Message Passing" target="Multicomputer System">
      <data key="d6">1.0</data>
      <data key="d7">Message passing is the standard method used in multicomputer systems for data transfer between nodes.</data>
      <data key="d8">communication method,system protocol</data>
      <data key="d9">chunk-cc56d9863e6de5d5a6e95e87766d0742</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735676</data>
    </edge>
    <edge source="Thread-Level Parallelism" target="Simultaneous Multithreading">
      <data key="d6">1.0</data>
      <data key="d7">Simultaneous multithreading achieves thread-level parallelism by issuing instructions from different threads in the same clock cycle.</data>
      <data key="d8">parallelism type,performance enhancement</data>
      <data key="d9">chunk-f67ff7c347b613bc05733f64a51c9c17</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736744</data>
    </edge>
    <edge source="Single Address Space" target="Multiprocessor System">
      <data key="d6">1.0</data>
      <data key="d7">Multiprocessor systems employ a single address space to unify memory access across all processors.</data>
      <data key="d8">memory model,system architecture</data>
      <data key="d9">chunk-cc56d9863e6de5d5a6e95e87766d0742</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735675</data>
    </edge>
    <edge source="流水线的逻辑结构" target="流水段寄存器">
      <data key="d6">1.0</data>
      <data key="d7">The pipeline's logical structure requires a pipeline segment register after each stage to store processed data.</data>
      <data key="d8">data storage,stage synchronization</data>
      <data key="d9">chunk-062a2e851dd9b26735dc96a7d8a4b551</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735721</data>
    </edge>
    <edge source="流水线的逻辑结构" target="时钟周期">
      <data key="d6">1.0</data>
      <data key="d7">The pipeline's logical structure operates synchronously based on each clock cycle.</data>
      <data key="d8">pipeline operation,timing synchronization</data>
      <data key="d9">chunk-062a2e851dd9b26735dc96a7d8a4b551</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735722</data>
    </edge>
    <edge source="流水线的逻辑结构" target="流水线中将同时存在5条不同的指令并行执行">
      <data key="d6">1.0</data>
      <data key="d7">The logical structure of the pipeline enables five different instructions to be processed simultaneously across the five stages.</data>
      <data key="d8">parallel execution,pipeline efficiency</data>
      <data key="d9">chunk-062a2e851dd9b26735dc96a7d8a4b551</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735723</data>
    </edge>
    <edge source="流水段寄存器" target="统一时钟CLK">
      <data key="d6">1.0</data>
      <data key="d7">Each pipeline register is synchronized with the unified clock CLK to latch data on each clock edge.</data>
      <data key="d8">clock synchronization,data latching</data>
      <data key="d9">chunk-062a2e851dd9b26735dc96a7d8a4b551</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735722</data>
    </edge>
    <edge source="IF" target="ID">
      <data key="d6">1.0</data>
      <data key="d7">The IF stage forwards fetched instructions to the ID stage for decoding.</data>
      <data key="d8">data forwarding,sequential processing</data>
      <data key="d9">chunk-062a2e851dd9b26735dc96a7d8a4b551</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735721</data>
    </edge>
    <edge source="IF" target="指令">
      <data key="d6">1.0</data>
      <data key="d7">An instruction enters the pipeline at the IF stage to begin processing.</data>
      <data key="d8">entry point,processing initiation</data>
      <data key="d9">chunk-062a2e851dd9b26735dc96a7d8a4b551</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735722</data>
    </edge>
    <edge source="ID" target="EX">
      <data key="d6">1.0</data>
      <data key="d7">The ID stage passes decoded instructions and operands to the EX stage for execution.</data>
      <data key="d8">data forwarding,sequential processing</data>
      <data key="d9">chunk-062a2e851dd9b26735dc96a7d8a4b551</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735722</data>
    </edge>
    <edge source="EX" target="MEM">
      <data key="d6">1.0</data>
      <data key="d7">The EX stage sends execution results to the MEM stage for memory access.</data>
      <data key="d8">data forwarding,sequential processing</data>
      <data key="d9">chunk-062a2e851dd9b26735dc96a7d8a4b551</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735722</data>
    </edge>
    <edge source="MEM" target="WB">
      <data key="d6">1.0</data>
      <data key="d7">The MEM stage provides memory access results to the WB stage for write-back.</data>
      <data key="d8">data forwarding,sequential processing</data>
      <data key="d9">chunk-062a2e851dd9b26735dc96a7d8a4b551</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735721</data>
    </edge>
    <edge source="时钟周期" target="数据存储器">
      <data key="d6">1.0</data>
      <data key="d7">On each clock cycle, data stored in the data storage units is updated and passed forward.</data>
      <data key="d8">data update,timing control</data>
      <data key="d9">chunk-062a2e851dd9b26735dc96a7d8a4b551</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735721</data>
    </edge>
    <edge source="Hardwired Controller" target="Control Unit">
      <data key="d6">1.0</data>
      <data key="d7">The hardwired controller is a type of control unit implemented using combinational logic and flip-flops rather than microcode.</data>
      <data key="d8">design architecture,implementation approach</data>
      <data key="d9">chunk-cc2d0105e935d9886fe36f0b3286af0f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735738</data>
    </edge>
    <edge source="Hardwired Controller" target="Instruction Opcode">
      <data key="d6">1.0</data>
      <data key="d7">The control signals produced by the hardwired controller are directly influenced by the decoded instruction opcode.</data>
      <data key="d8">control signal generation,instruction dependency</data>
      <data key="d9">chunk-cc2d0105e935d9886fe36f0b3286af0f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735738</data>
    </edge>
    <edge source="Hardwired Controller" target="Timing Generator">
      <data key="d6">1.0</data>
      <data key="d7">The timing generator provides the clocked timing signals that regulate when control signals are issued by the hardwired controller.</data>
      <data key="d8">signal sequencing,timing coordination</data>
      <data key="d9">chunk-cc2d0105e935d9886fe36f0b3286af0f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735739</data>
    </edge>
    <edge source="Hardwired Controller" target="Flag">
      <data key="d6">1.0</data>
      <data key="d7">The hardwired controller may use flag signals from the execution unit to conditionally alter the sequence of micro-operations.</data>
      <data key="d8">conditional control,status dependency</data>
      <data key="d9">chunk-cc2d0105e935d9886fe36f0b3286af0f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735739</data>
    </edge>
    <edge source="Hardwired Controller" target="RISC">
      <data key="d6">1.0</data>
      <data key="d7">RISC architectures commonly use hardwired controllers due to their speed and efficiency for simple, regular instruction sets.</data>
      <data key="d8">architecture preference,performance optimization</data>
      <data key="d9">chunk-cc2d0105e935d9886fe36f0b3286af0f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735739</data>
    </edge>
    <edge source="Hardwired Controller" target="Microprogramming Method">
      <data key="d6">1.0</data>
      <data key="d7">The microprogramming method was developed to overcome the inflexibility and complexity of hardwired controllers by offering a more modular and maintainable approach.</data>
      <data key="d8">alternative solution,design evolution</data>
      <data key="d9">chunk-cc2d0105e935d9886fe36f0b3286af0f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735740</data>
    </edge>
    <edge source="Hardwired Controller" target="Speed">
      <data key="d6">1.0</data>
      <data key="d7">The hardwired controller achieves high speed due to its use of combinational logic circuits with minimal delay.</data>
      <data key="d8">design characteristic,performance</data>
      <data key="d9">chunk-91a81db4ce70f9dbc729e1840db41cff</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735799</data>
    </edge>
    <edge source="Hardwired Controller" target="Functionality">
      <data key="d6">1.0</data>
      <data key="d7">Once designed, the hardwired controller cannot be easily modified to add new functionality.</data>
      <data key="d8">design limitation,rigidity</data>
      <data key="d9">chunk-91a81db4ce70f9dbc729e1840db41cff</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735800</data>
    </edge>
    <edge source="Hardwired Controller" target="Combinational Logic Circuits">
      <data key="d6">1.0</data>
      <data key="d7">The hardwired controller uses combinational logic circuits to directly generate control signals.</data>
      <data key="d8">hardware implementation,signal generation</data>
      <data key="d9">chunk-91a81db4ce70f9dbc729e1840db41cff</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735800</data>
    </edge>
    <edge source="Hardwired Controller" target="Control Signal Generation">
      <data key="d6">1.0</data>
      <data key="d7">The hardwired controller generates control signals through fixed combinational logic, without requiring memory access.</data>
      <data key="d8">logic-based,signal production</data>
      <data key="d9">chunk-91a81db4ce70f9dbc729e1840db41cff</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735800</data>
    </edge>
    <edge source="Hardwired Controller" target="Combination Logic Controller">
      <data key="d6">1.0</data>
      <data key="d7">The hardwired controller is also known as the combination logic controller, referring to the same design approach using combinational logic.</data>
      <data key="d8">equivalent design,synonym</data>
      <data key="d9">chunk-91a81db4ce70f9dbc729e1840db41cff</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735801</data>
    </edge>
    <edge source="Control Unit" target="Instruction Decoder">
      <data key="d6">1.0</data>
      <data key="d7">The control unit receives decoded instruction signals from the instruction decoder to determine the required operations.</data>
      <data key="d8">instruction processing,signal input</data>
      <data key="d9">chunk-cc2d0105e935d9886fe36f0b3286af0f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735738</data>
    </edge>
    <edge source="Control Unit" target="Clock Pulse">
      <data key="d6">1.0</data>
      <data key="d7">The control unit uses clock pulses to time its response and dispatch control signals at precise intervals.</data>
      <data key="d8">operational timing,synchronization</data>
      <data key="d9">chunk-cc2d0105e935d9886fe36f0b3286af0f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735739</data>
    </edge>
    <edge source="Control Unit" target="Flag">
      <data key="d6">1.0</data>
      <data key="d7">The control unit incorporates flag feedback to adapt its control signal generation based on CPU status.</data>
      <data key="d8">feedback mechanism,state dependency</data>
      <data key="d9">chunk-cc2d0105e935d9886fe36f0b3286af0f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735739</data>
    </edge>
    <edge source="Control Unit" target="Micro-operation Command">
      <data key="d6">1.0</data>
      <data key="d7">The control unit generates micro-operation commands and sends them to internal or external control buses for execution.</data>
      <data key="d8">output function,signal distribution</data>
      <data key="d9">chunk-cc2d0105e935d9886fe36f0b3286af0f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735740</data>
    </edge>
    <edge source="Control Unit" target="Microcommand Sequence">
      <data key="d6">1.0</data>
      <data key="d7">The Control Unit manages the sequence of microcommands required to execute a single instruction.</data>
      <data key="d8">instruction execution,microoperation management</data>
      <data key="d9">chunk-de401d6e0254effcba3f6fcd81cefe60</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736504</data>
    </edge>
    <edge source="Control Unit" target="Control Signal">
      <data key="d6">1.0</data>
      <data key="d7">The Control Unit generates control signals that direct the operation of other CPU components.</data>
      <data key="d8">hardware coordination,signal generation</data>
      <data key="d9">chunk-de401d6e0254effcba3f6fcd81cefe60</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736504</data>
    </edge>
    <edge source="Control Unit" target="Instruction Execution">
      <data key="d6">1.0</data>
      <data key="d7">The Control Unit governs the execution of instructions in the CPU.</data>
      <data key="d8">instruction control,process management</data>
      <data key="d9">chunk-de401d6e0254effcba3f6fcd81cefe60</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736508</data>
    </edge>
    <edge source="Control Unit" target="Hardware Synchronization">
      <data key="d6">1.0</data>
      <data key="d7">The Control Unit ensures Hardware Synchronization by managing timing circuits and coordinating component operations.</data>
      <data key="d8">system control,timing coordination</data>
      <data key="d9">chunk-de401d6e0254effcba3f6fcd81cefe60</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736509</data>
    </edge>
    <edge source="Control Unit" target="Control Signal Generation">
      <data key="d6">1.0</data>
      <data key="d7">The Control Unit is responsible for Control Signal Generation to regulate the behavior of data path and other components.</data>
      <data key="d8">execution coordination,signal production</data>
      <data key="d9">chunk-de401d6e0254effcba3f6fcd81cefe60</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736510</data>
    </edge>
    <edge source="Control Unit" target="Data Path">
      <data key="d6">1.0</data>
      <data key="d7">The Data Path and Control Unit are fundamental components of the CPU, with the Control Unit directing the operations of the Data Path.</data>
      <data key="d8">component relationship,coordination</data>
      <data key="d9">chunk-cf0a63e25f70bb6e12f2ee7720496542</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736557</data>
    </edge>
    <edge source="Control Unit" target="Control Signals">
      <data key="d6">1.0</data>
      <data key="d7">The Control Unit generates Control Signals that regulate the behavior of components within the Data Path.</data>
      <data key="d8">operational management,signal generation</data>
      <data key="d9">chunk-cf0a63e25f70bb6e12f2ee7720496542</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736558</data>
    </edge>
    <edge source="Control Unit" target="Program Counter">
      <data key="d6">1.0</data>
      <data key="d7">The control unit relies on the program counter to manage instruction flow and timing.</data>
      <data key="d8">instruction sequencing,timing control</data>
      <data key="d9">chunk-0efa36a872f0b1511a047f0591cba52c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736811</data>
    </edge>
    <edge source="Control Unit" target="Read Operation">
      <data key="d6">1.0</data>
      <data key="d7">The control unit issues a read command to memory during the read operation.</data>
      <data key="d8">command generation,control sequencing</data>
      <data key="d9">chunk-0efa36a872f0b1511a047f0591cba52c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736814</data>
    </edge>
    <edge source="Control Unit" target="Write Operation">
      <data key="d6">1.0</data>
      <data key="d7">The control unit issues a write command to memory during the write operation.</data>
      <data key="d8">command generation,control sequencing</data>
      <data key="d9">chunk-0efa36a872f0b1511a047f0591cba52c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736815</data>
    </edge>
    <edge source="Instruction Decoder" target="Operation Code">
      <data key="d6">1.0</data>
      <data key="d7">The Instruction Decoder analyzes the Operation Code to determine the required microoperations and generate corresponding control signals.</data>
      <data key="d8">instruction analysis,signal derivation</data>
      <data key="d9">chunk-de401d6e0254effcba3f6fcd81cefe60</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736509</data>
    </edge>
    <edge source="Instruction Register" target="Program Counter">
      <data key="d6">3.0</data>
      <data key="d7">The program counter supplies the memory address to fetch the instruction, which is then loaded into the instruction register.&lt;SEP&gt;The Instruction Register receives instructions from Main Memory based on the Program Counter's address.&lt;SEP&gt;The instruction register provides the new address for the program counter during a jump or transfer operation.</data>
      <data key="d8">branching,control logic,data flow,instruction fetching,instruction flow,instruction update</data>
      <data key="d9">chunk-acb6520440fa5141fe4d034f3e5e6edf&lt;SEP&gt;chunk-0efa36a872f0b1511a047f0591cba52c&lt;SEP&gt;chunk-643c2ebb8e3d3384d19f217865cc3b8f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736812</data>
    </edge>
    <edge source="Instruction Register" target="Memory Data Register">
      <data key="d6">1.0</data>
      <data key="d7">The memory data register sends instruction data to the instruction register for execution.</data>
      <data key="d8">instruction fetching,instruction transfer</data>
      <data key="d9">chunk-0efa36a872f0b1511a047f0591cba52c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736810</data>
    </edge>
    <edge source="Instruction Register" target="Address Field">
      <data key="d6">1.0</data>
      <data key="d7">The address field is part of the instruction register and is used to extract the destination address for a transfer instruction.</data>
      <data key="d8">data component,instruction parsing</data>
      <data key="d9">chunk-0efa36a872f0b1511a047f0591cba52c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736813</data>
    </edge>
    <edge source="Instruction Register" target="Control Signal IRin">
      <data key="d6">1.0</data>
      <data key="d7">Control signal IRin enables the instruction register to accept data from the bus during instruction loading.</data>
      <data key="d8">control activation,instruction input</data>
      <data key="d9">chunk-0efa36a872f0b1511a047f0591cba52c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736814</data>
    </edge>
    <edge source="Microprogrammed Controller" target="Flexibility">
      <data key="d6">1.0</data>
      <data key="d7">The microprogrammed controller supports flexibility by allowing updates through changes in microcode.</data>
      <data key="d8">adaptability,design advantage</data>
      <data key="d9">chunk-91a81db4ce70f9dbc729e1840db41cff</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735799</data>
    </edge>
    <edge source="Microprogrammed Controller" target="Maintainability">
      <data key="d6">1.0</data>
      <data key="d7">The microprogrammed controller is easier to maintain due to its modular and software-like structure.</data>
      <data key="d8">design advantage,ease of update</data>
      <data key="d9">chunk-91a81db4ce70f9dbc729e1840db41cff</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735800</data>
    </edge>
    <edge source="Microprogrammed Controller" target="Regularity">
      <data key="d6">1.0</data>
      <data key="d7">The microprogrammed controller exhibits regularity in its design, making it consistent and predictable.</data>
      <data key="d8">design advantage,standardization</data>
      <data key="d9">chunk-91a81db4ce70f9dbc729e1840db41cff</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735800</data>
    </edge>
    <edge source="Microprogrammed Controller" target="Control Storage Unit">
      <data key="d6">1.0</data>
      <data key="d7">The microprogrammed controller relies on the control storage unit to store microinstructions for execution.</data>
      <data key="d8">hardware component,instruction storage</data>
      <data key="d9">chunk-91a81db4ce70f9dbc729e1840db41cff</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735801</data>
    </edge>
    <edge source="Microprogrammed Controller" target="Instruction Execution">
      <data key="d6">1.0</data>
      <data key="d7">The microprogrammed controller performs instruction execution by retrieving microinstructions from control storage.</data>
      <data key="d8">dependency on microcode,execution process</data>
      <data key="d9">chunk-91a81db4ce70f9dbc729e1840db41cff</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735801</data>
    </edge>
    <edge source="Microprogrammed Controller" target="Speed">
      <data key="d6">1.0</data>
      <data key="d7">The microprogrammed controller is slower than the hardwired controller due to the need to access control storage for each instruction.</data>
      <data key="d8">delay,performance trade-off</data>
      <data key="d9">chunk-91a81db4ce70f9dbc729e1840db41cff</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735801</data>
    </edge>
    <edge source="Instruction Execution" target="Microcommand Sequence">
      <data key="d6">1.0</data>
      <data key="d7">The process of Instruction Execution relies on a sequence of microcommands.</data>
      <data key="d8">control steps,execution process</data>
      <data key="d9">chunk-de401d6e0254effcba3f6fcd81cefe60</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736507</data>
    </edge>
    <edge source="Instruction Execution" target="Control Signal">
      <data key="d6">1.0</data>
      <data key="d7">Control signals are essential for directing the operations during instruction execution.</data>
      <data key="d8">execution control,system coordination</data>
      <data key="d9">chunk-de401d6e0254effcba3f6fcd81cefe60</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736509</data>
    </edge>
    <edge source="Instruction Execution" target="Data Path">
      <data key="d6">1.0</data>
      <data key="d7">The Data Path is the physical and logical pathway through which data moves during instruction execution in a CPU.</data>
      <data key="d8">execution pathway,information processing</data>
      <data key="d9">chunk-cf0a63e25f70bb6e12f2ee7720496542</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736558</data>
    </edge>
    <edge source="Instruction Execution" target="Exception">
      <data key="d6">1.0</data>
      <data key="d7">Exceptions are generated by specific instructions during their execution.</data>
      <data key="d8">execution context,timing</data>
      <data key="d9">chunk-56dad084d2f83de29d62a2ae33cfc843</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736661</data>
    </edge>
    <edge source="Microprogram Controller" target="Control Storage">
      <data key="d6">1.0</data>
      <data key="d7">The microprogram controller stores microprograms in the control storage, which is implemented using ROM.</data>
      <data key="d8">control logic implementation,stored program</data>
      <data key="d9">chunk-fe06e06cd53b2ace66af32c5e482dce9</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735814</data>
    </edge>
    <edge source="Microprogram Controller" target="Microinstruction">
      <data key="d6">1.0</data>
      <data key="d7">The microprogram controller executes microinstructions as part of the process of carrying out a machine instruction.</data>
      <data key="d8">instruction execution,program sequencing</data>
      <data key="d9">chunk-fe06e06cd53b2ace66af32c5e482dce9</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735815</data>
    </edge>
    <edge source="Control Storage" target="ROM">
      <data key="d6">1.0</data>
      <data key="d7">Control storage is implemented using ROM to permanently hold microprograms.</data>
      <data key="d8">microprogram storage,non-volatile memory</data>
      <data key="d9">chunk-fe06e06cd53b2ace66af32c5e482dce9</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735815</data>
    </edge>
    <edge source="Control Storage" target="Microinstruction Address Register">
      <data key="d6">1.0</data>
      <data key="d7">The microinstruction address register holds the address in control storage from which the next microinstruction is read.</data>
      <data key="d8">addressing,microinstruction retrieval</data>
      <data key="d9">chunk-fe06e06cd53b2ace66af32c5e482dce9</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735816</data>
    </edge>
    <edge source="Control Storage" target="Microinstruction Register">
      <data key="d6">1.0</data>
      <data key="d7">The microinstruction register stores the microinstruction read from control storage before it is executed.</data>
      <data key="d8">execution staging,microinstruction loading</data>
      <data key="d9">chunk-fe06e06cd53b2ace66af32c5e482dce9</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735816</data>
    </edge>
    <edge source="Microinstruction" target="Operation Control Field">
      <data key="d6">1.0</data>
      <data key="d7">The operation control field within a microinstruction generates the necessary control signals for a single step of execution.</data>
      <data key="d8">control signal generation,instruction step specification</data>
      <data key="d9">chunk-fe06e06cd53b2ace66af32c5e482dce9</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735815</data>
    </edge>
    <edge source="Microinstruction" target="Sequence Control Field">
      <data key="d6">1.0</data>
      <data key="d7">The sequence control field in a microinstruction determines the address of the next microinstruction to execute.</data>
      <data key="d8">microcycle sequencing,next instruction address control</data>
      <data key="d9">chunk-fe06e06cd53b2ace66af32c5e482dce9</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735816</data>
    </edge>
    <edge source="Microinstruction" target="Microcycle">
      <data key="d6">1.0</data>
      <data key="d7">A microcycle is the duration required to fetch and execute a single microinstruction.</data>
      <data key="d8">execution time,processing cycle</data>
      <data key="d9">chunk-fe06e06cd53b2ace66af32c5e482dce9</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735816</data>
    </edge>
    <edge source="Microinstruction" target="Microprogram">
      <data key="d6">1.0</data>
      <data key="d7">A microprogram is a sequence of microinstructions that define the steps for executing a single machine instruction.</data>
      <data key="d8">execution sequence,ordered collection</data>
      <data key="d9">chunk-fe06e06cd53b2ace66af32c5e482dce9</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735817</data>
    </edge>
    <edge source="Microoperation" target="Microcommand">
      <data key="d6">1.0</data>
      <data key="d7">Each microcommand triggers a corresponding microoperation in the execution unit.</data>
      <data key="d8">control signal,execution action</data>
      <data key="d9">chunk-fe06e06cd53b2ace66af32c5e482dce9</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735816</data>
    </edge>
    <edge source="Microcommand" target="Microcommand Compatibility">
      <data key="d6">1.0</data>
      <data key="d7">Incompatible microcommands cannot be executed simultaneously, while compatible ones can.</data>
      <data key="d8">instruction timing,parallel execution</data>
      <data key="d9">chunk-fe06e06cd53b2ace66af32c5e482dce9</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735816</data>
    </edge>
    <edge source="Microcommand" target="Microcommand Mutual Exclusivity">
      <data key="d6">1.0</data>
      <data key="d7">Mutually exclusive microcommands are designed to prevent simultaneous execution that could cause hardware conflicts.</data>
      <data key="d8">conflict prevention,hardware control</data>
      <data key="d9">chunk-fe06e06cd53b2ace66af32c5e482dce9</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735817</data>
    </edge>
    <edge source="Microprogram" target="Machine Instruction">
      <data key="d6">1.0</data>
      <data key="d7">Each machine instruction is implemented by a sequence of microinstructions within a microprogram.</data>
      <data key="d8">functional implementation,instruction translation</data>
      <data key="d9">chunk-fe06e06cd53b2ace66af32c5e482dce9</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735814</data>
    </edge>
    <edge source="Control Hazard" target="Program Counter">
      <data key="d6">1.0</data>
      <data key="d7">The control hazard changes the value of the Program Counter, altering the flow of instruction execution.</data>
      <data key="d8">execution disruptio,flow control</data>
      <data key="d9">chunk-01427518a698286307aa6708cae3234c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735851</data>
    </edge>
    <edge source="Control Hazard" target="Branch Instruction">
      <data key="d6">1.0</data>
      <data key="d7">A branch instruction can trigger a control hazard by altering the expected execution order.</data>
      <data key="d8">causation,pipeline disruption</data>
      <data key="d9">chunk-01427518a698286307aa6708cae3234c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735852</data>
    </edge>
    <edge source="Control Hazard" target="Branch Prediction">
      <data key="d6">1.0</data>
      <data key="d7">Branch prediction is a hardware technique used to anticipate and mitigate the effects of control hazards.</data>
      <data key="d8">performance optimization,preventive method</data>
      <data key="d9">chunk-01427518a698286307aa6708cae3234c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735852</data>
    </edge>
    <edge source="Program Counter" target="Stack Pointer">
      <data key="d6">1.0</data>
      <data key="d7">The stack pointer is updated during interrupt handling, which may involve saving the program counter's value.</data>
      <data key="d8">stack interaction,state management</data>
      <data key="d9">chunk-643c2ebb8e3d3384d19f217865cc3b8f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735898</data>
    </edge>
    <edge source="Program Counter" target="Sequential Logic Element">
      <data key="d6">1.0</data>
      <data key="d7">The program counter is a sequential logic element that tracks instruction addresses.</data>
      <data key="d8">function,type</data>
      <data key="d9">chunk-2459f394250f45963236273137f4db0c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736394</data>
    </edge>
    <edge source="Program Counter" target="Hardware Multithreading">
      <data key="d6">1.0</data>
      <data key="d7">Each thread has its own program counter to track instruction execution independently.</data>
      <data key="d8">resource allocation,thread isolation</data>
      <data key="d9">chunk-f67ff7c347b613bc05733f64a51c9c17</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736744</data>
    </edge>
    <edge source="Program Counter" target="Memory Address Register">
      <data key="d6">1.0</data>
      <data key="d7">The program counter sends its value to the memory address register to set the address for memory access.</data>
      <data key="d8">address routing,data transfer</data>
      <data key="d9">chunk-0efa36a872f0b1511a047f0591cba52c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736810</data>
    </edge>
    <edge source="Program Counter" target="Control Signal PCout">
      <data key="d6">1.0</data>
      <data key="d7">Control signal PCout activates the program counter to send its value to the bus.</data>
      <data key="d8">control activation,data output</data>
      <data key="d9">chunk-0efa36a872f0b1511a047f0591cba52c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736813</data>
    </edge>
    <edge source="Program Counter" target="Control Signal PCin">
      <data key="d6">1.0</data>
      <data key="d7">Control signal PCin enables the program counter to accept a new address from the bus during a transfer operation.</data>
      <data key="d8">address input,control activation</data>
      <data key="d9">chunk-0efa36a872f0b1511a047f0591cba52c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736814</data>
    </edge>
    <edge source="Program Counter" target="Transfer Operation">
      <data key="d6">1.0</data>
      <data key="d7">The transfer operation updates the program counter with a new address from the instruction register to facilitate program branching.</data>
      <data key="d8">address update,branching</data>
      <data key="d9">chunk-0efa36a872f0b1511a047f0591cba52c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736816</data>
    </edge>
    <edge source="Pipeline Stall" target="Delay Loss Time Slot C">
      <data key="d6">1.0</data>
      <data key="d7">The number of clock cycles delayed due to pipeline stall is quantified as the delay loss time slot C.</data>
      <data key="d8">cycle delay,timing impact</data>
      <data key="d9">chunk-01427518a698286307aa6708cae3234c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735851</data>
    </edge>
    <edge source="Pipeline Stall" target="NOP Instruction">
      <data key="d6">1.0</data>
      <data key="d7">NOP instructions are inserted in software to artificially delay execution and resolve pipeline stalls caused by control hazards.</data>
      <data key="d8">delay insertion,software mitigation</data>
      <data key="d9">chunk-01427518a698286307aa6708cae3234c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735852</data>
    </edge>
    <edge source="Pipeline Stall" target="Cache Miss">
      <data key="d6">1.0</data>
      <data key="d7">Cache misses can cause pipeline stalls when data must be fetched from slower memory.</data>
      <data key="d8">execution block,resource access</data>
      <data key="d9">chunk-01427518a698286307aa6708cae3234c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735852</data>
    </edge>
    <edge source="Pipeline Stall" target="Coarse-Grained Multithreading">
      <data key="d6">1.0</data>
      <data key="d7">Coarse-grained multithreading switches threads only when a pipeline stall occurs, such as after a cache miss.</data>
      <data key="d8">execution discontinuity,trigger condition</data>
      <data key="d9">chunk-f67ff7c347b613bc05733f64a51c9c17</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736743</data>
    </edge>
    <edge source="NOP Instruction" target="Load-Use Data Hazard">
      <data key="d6">1.0</data>
      <data key="d7">Inserting a NOP instruction delays the subsequent instruction to allow time for the load result to be available.</data>
      <data key="d8">delay resolution,hazard mitigation</data>
      <data key="d9">chunk-951a0e05d8d102dbb38963722260d96a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736230</data>
    </edge>
    <edge source="Branch Prediction" target="Static Branch Prediction">
      <data key="d6">1.0</data>
      <data key="d7">Static branch prediction is a basic variant of branch prediction that relies on fixed rules.</data>
      <data key="d8">fixed rule,static method</data>
      <data key="d9">chunk-01427518a698286307aa6708cae3234c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735852</data>
    </edge>
    <edge source="Branch Prediction" target="Dynamic Branch Prediction">
      <data key="d6">1.0</data>
      <data key="d7">Dynamic branch prediction dynamically adjusts predictions based on past branch outcomes.</data>
      <data key="d8">adaptive method,historical analysis</data>
      <data key="d9">chunk-01427518a698286307aa6708cae3234c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735852</data>
    </edge>
    <edge source="Dynamic Branch Prediction" target="Dynamic Pipeline Scheduling">
      <data key="d6">1.0</data>
      <data key="d7">Dynamic Branch Prediction supports Dynamic Pipeline Scheduling by enabling accurate prediction of branch outcomes, improving instruction flow and execution efficiency.</data>
      <data key="d8">execution technique,performance optimization</data>
      <data key="d9">chunk-3ac380505fdc239a4da36a89716b6444</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736315</data>
    </edge>
    <edge source="Controller" target="Operation Control">
      <data key="d6">1.0</data>
      <data key="d7">The controller is responsible for implementing operation control by generating and directing operation signals to the appropriate components.</data>
      <data key="d8">control mechanism,functional relationship</data>
      <data key="d9">chunk-7e297f32d868dbd2d51d7a047e223119</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735892</data>
    </edge>
    <edge source="Arithmetic Logic Unit" target="Shift Register">
      <data key="d6">1.0</data>
      <data key="d7">The Arithmetic Logic Unit utilizes the Shift Register for performing bit shifting operations.</data>
      <data key="d8">bit manipulation,logical operations</data>
      <data key="d9">chunk-acb6520440fa5141fe4d034f3e5e6edf</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735998</data>
    </edge>
    <edge source="Arithmetic Logic Unit" target="Accumulator">
      <data key="d6">2.0</data>
      <data key="d7">The Arithmetic Logic Unit uses the Accumulator to store intermediate operation results.&lt;SEP&gt;The accumulator receives data from the arithmetic logic unit as input for computations and stores the result.</data>
      <data key="d8">computation destination,operand input,operand processing,result storage</data>
      <data key="d9">chunk-acb6520440fa5141fe4d034f3e5e6edf&lt;SEP&gt;chunk-0efa36a872f0b1511a047f0591cba52c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736814</data>
    </edge>
    <edge source="Arithmetic Logic Unit" target="Combinational Logic Element">
      <data key="d6">1.0</data>
      <data key="d7">An Arithmetic Logic Unit (ALU) is a combinational logic element that performs arithmetic and logical operations.</data>
      <data key="d8">function,type</data>
      <data key="d9">chunk-2459f394250f45963236273137f4db0c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736393</data>
    </edge>
    <edge source="Arithmetic Logic Unit" target="Data Path">
      <data key="d6">1.0</data>
      <data key="d7">The Data Path includes the Arithmetic Logic Unit as a core component for data manipulation.</data>
      <data key="d8">computational unit,data processing</data>
      <data key="d9">chunk-de401d6e0254effcba3f6fcd81cefe60</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736505</data>
    </edge>
    <edge source="Arithmetic Logic Unit" target="Computational Core">
      <data key="d6">1.0</data>
      <data key="d7">The Computational Core performs operations through the Arithmetic Logic Unit.</data>
      <data key="d8">computational function,operation execution</data>
      <data key="d9">chunk-de401d6e0254effcba3f6fcd81cefe60</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736506</data>
    </edge>
    <edge source="Arithmetic Logic Unit" target="Temporary Register Y">
      <data key="d6">1.0</data>
      <data key="d7">The arithmetic logic unit receives one operand from temporary register Y, which holds it during computation.</data>
      <data key="d8">computation input,operand storage</data>
      <data key="d9">chunk-0efa36a872f0b1511a047f0591cba52c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736810</data>
    </edge>
    <edge source="Arithmetic Logic Unit" target="Temporary Register Z">
      <data key="d6">1.0</data>
      <data key="d7">The arithmetic logic unit sends its result to temporary register Z to prevent feedback and enable safe transfer.</data>
      <data key="d8">output handling,result storage</data>
      <data key="d9">chunk-0efa36a872f0b1511a047f0591cba52c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736812</data>
    </edge>
    <edge source="Arithmetic Logic Unit" target="Control Signal ALUin">
      <data key="d6">1.0</data>
      <data key="d7">Control signal ALUin enables the arithmetic logic unit to receive data from the bus.</data>
      <data key="d8">control activation,input data supply</data>
      <data key="d9">chunk-0efa36a872f0b1511a047f0591cba52c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736812</data>
    </edge>
    <edge source="Fetch Phase" target="JMPX Instruction">
      <data key="d6">1.0</data>
      <data key="d7">The JMPX instruction only uses the fetch and execute phases, bypassing the indirect addressing and interrupt cycles.</data>
      <data key="d8">instruction cycle,minimal phases</data>
      <data key="d9">chunk-643c2ebb8e3d3384d19f217865cc3b8f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735898</data>
    </edge>
    <edge source="Execute Phase" target="JMPX Instruction">
      <data key="d6">1.0</data>
      <data key="d7">The execute phase of JMPX completes control transfer without accessing memory for operands.</data>
      <data key="d8">instruction cycle,minimal phases</data>
      <data key="d9">chunk-643c2ebb8e3d3384d19f217865cc3b8f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735899</data>
    </edge>
    <edge source="Machine Cycle" target="Beat">
      <data key="d6">1.0</data>
      <data key="d7">A machine cycle is divided into multiple beats to facilitate precise timing control in older systems.</data>
      <data key="d8">operational subdivision,timing hierarchy</data>
      <data key="d9">chunk-643c2ebb8e3d3384d19f217865cc3b8f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735899</data>
    </edge>
    <edge source="Beat" target="Pulse">
      <data key="d6">1.0</data>
      <data key="d7">A beat is composed of one or more pulses, providing the finest degree of timing granularity.</data>
      <data key="d8">synchronization,timing unit hierarchy</data>
      <data key="d9">chunk-643c2ebb8e3d3384d19f217865cc3b8f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735899</data>
    </edge>
    <edge source="CPU Internal Single Bus Architecture" target="Single Bus Structure Data Path">
      <data key="d6">1.0</data>
      <data key="d7">The single bus structure data path is implemented using the CPU internal single bus architecture.</data>
      <data key="d8">internal configuration,method design</data>
      <data key="d9">chunk-2a63536239036e36be43b7e72d560b24</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735984</data>
    </edge>
    <edge source="CPU Internal Single Bus Architecture" target="Internal Bus">
      <data key="d6">1.0</data>
      <data key="d7">The internal bus is a key structural component of the CPU internal single bus architecture.</data>
      <data key="d8">component connection,structural element</data>
      <data key="d9">chunk-2a63536239036e36be43b7e72d560b24</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735985</data>
    </edge>
    <edge source="Single Bus Structure Data Path" target="Single Cycle Processor">
      <data key="d6">1.0</data>
      <data key="d7">The single cycle processor cannot use the single bus structure due to its need to execute multiple operations within one clock cycle.</data>
      <data key="d8">incompatibility,timing constraint</data>
      <data key="d9">chunk-2a63536239036e36be43b7e72d560b24</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735985</data>
    </edge>
    <edge source="Single Bus Structure Data Path" target="Registers">
      <data key="d6">1.0</data>
      <data key="d7">Registers are connected to the single bus structure data path through the shared internal bus.</data>
      <data key="d8">connection point,functional component</data>
      <data key="d9">chunk-2a63536239036e36be43b7e72d560b24</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735986</data>
    </edge>
    <edge source="Single Bus Structure Data Path" target="Performance">
      <data key="d6">1.0</data>
      <data key="d7">The single bus structure data path suffers from low performance due to frequent data transfer conflicts.</data>
      <data key="d8">conflict impact,performance limitation</data>
      <data key="d9">chunk-2a63536239036e36be43b7e72d560b24</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735986</data>
    </edge>
    <edge source="Single Cycle Processor" target="CPI">
      <data key="d6">1.0</data>
      <data key="d7">The single cycle processor uses CPI=1, meaning all instructions take one clock cycle, but performance is limited by the longest instruction.</data>
      <data key="d8">execution efficiency,performance metric</data>
      <data key="d9">chunk-3c7856616d478c58fdce251c9a2b68ac</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736782</data>
    </edge>
    <edge source="CPU Internal Multi Bus Architecture" target="Multi Bus Structure Data Path">
      <data key="d6">1.0</data>
      <data key="d7">The multi bus structure data path is implemented using the CPU internal multi bus architecture.</data>
      <data key="d8">internal configuration,method design</data>
      <data key="d9">chunk-2a63536239036e36be43b7e72d560b24</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735984</data>
    </edge>
    <edge source="CPU Internal Multi Bus Architecture" target="Dedicated Data Path">
      <data key="d6">1.0</data>
      <data key="d7">The dedicated data path is an alternative to the multi bus architecture, offering higher performance despite increased hardware complexity.</data>
      <data key="d8">alternative design,performance comparison</data>
      <data key="d9">chunk-2a63536239036e36be43b7e72d560b24</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735985</data>
    </edge>
    <edge source="CPU Internal Multi Bus Architecture" target="Internal Bus">
      <data key="d6">1.0</data>
      <data key="d7">The internal bus is a structural element in CPU internal multi bus architecture, where multiple buses are used.</data>
      <data key="d8">component connection,structural element</data>
      <data key="d9">chunk-2a63536239036e36be43b7e72d560b24</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735986</data>
    </edge>
    <edge source="Multi Bus Structure Data Path" target="Registers">
      <data key="d6">1.0</data>
      <data key="d7">Registers are connected to multiple buses in the multi bus structure data path for parallel data transfer.</data>
      <data key="d8">connection point,functional component</data>
      <data key="d9">chunk-2a63536239036e36be43b7e72d560b24</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735986</data>
    </edge>
    <edge source="Multi Bus Structure Data Path" target="Instruction Execution Efficiency">
      <data key="d6">1.0</data>
      <data key="d7">The multi bus structure data path improves instruction execution efficiency by enabling simultaneous data transfers across multiple buses.</data>
      <data key="d8">efficiency improvement,parallelism</data>
      <data key="d9">chunk-2a63536239036e36be43b7e72d560b24</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735987</data>
    </edge>
    <edge source="Dedicated Data Path" target="Registers">
      <data key="d6">1.0</data>
      <data key="d7">Registers are directly linked to dedicated data flow circuits in the dedicated data path, eliminating the need for shared bus access.</data>
      <data key="d8">direct connection,functional component</data>
      <data key="d9">chunk-2a63536239036e36be43b7e72d560b24</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735987</data>
    </edge>
    <edge source="Dedicated Data Path" target="Hardware Complexity">
      <data key="d6">1.0</data>
      <data key="d7">The dedicated data path offers high performance but requires higher hardware complexity due to custom circuit connections.</data>
      <data key="d8">cost vs performance,design trade-off</data>
      <data key="d9">chunk-2a63536239036e36be43b7e72d560b24</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735988</data>
    </edge>
    <edge source="Internal Bus" target="System Bus">
      <data key="d6">1.0</data>
      <data key="d7">The system bus differs from the internal bus in that it connects different system components, while the internal bus connects components within a single unit like the CPU.</data>
      <data key="d8">distinction,system level</data>
      <data key="d9">chunk-2a63536239036e36be43b7e72d560b24</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735984</data>
    </edge>
    <edge source="Register" target="Sequential Logic Element">
      <data key="d6">1.0</data>
      <data key="d7">A register is a sequential logic element that stores data and is synchronized with a clock.</data>
      <data key="d8">function,type</data>
      <data key="d9">chunk-2459f394250f45963236273137f4db0c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736391</data>
    </edge>
    <edge source="Register" target="Data Path">
      <data key="d6">1.0</data>
      <data key="d7">The Data Path contains registers for temporary data storage during data processing.</data>
      <data key="d8">data storage,temporary holding</data>
      <data key="d9">chunk-de401d6e0254effcba3f6fcd81cefe60</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736506</data>
    </edge>
    <edge source="User Visible Register" target="Assembly Language">
      <data key="d6">1.0</data>
      <data key="d7">Assembly Language allows direct programming of user visible registers.</data>
      <data key="d8">direct manipulation,programming interface</data>
      <data key="d9">chunk-acb6520440fa5141fe4d034f3e5e6edf</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735997</data>
    </edge>
    <edge source="User Visible Register" target="Machine Language">
      <data key="d6">1.0</data>
      <data key="d7">Machine Language directly accesses user visible registers for CPU execution.</data>
      <data key="d8">low-level execution,register access</data>
      <data key="d9">chunk-acb6520440fa5141fe4d034f3e5e6edf</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735998</data>
    </edge>
    <edge source="General Purpose Register Group" target="Base Index Register">
      <data key="d6">1.0</data>
      <data key="d7">The Base Index Register is a part of the General Purpose Register Group used for address calculations.</data>
      <data key="d8">address calculation,register subset</data>
      <data key="d9">chunk-acb6520440fa5141fe4d034f3e5e6edf</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735994</data>
    </edge>
    <edge source="General Purpose Register Group" target="Sequential Logic Element">
      <data key="d6">1.0</data>
      <data key="d7">A general purpose register group is a collection of registers and belongs to sequential logic elements.</data>
      <data key="d8">function,type</data>
      <data key="d9">chunk-2459f394250f45963236273137f4db0c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736393</data>
    </edge>
    <edge source="General Purpose Register Group" target="Hardware Multithreading">
      <data key="d6">1.0</data>
      <data key="d7">Each thread in hardware multithreading requires a dedicated general purpose register group to maintain its state.</data>
      <data key="d8">resource allocation,thread isolation</data>
      <data key="d9">chunk-f67ff7c347b613bc05733f64a51c9c17</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736744</data>
    </edge>
    <edge source="Program Status Word Register" target="Overflow Flag">
      <data key="d6">1.0</data>
      <data key="d7">The Overflow Flag is a bit within the Program Status Word Register indicating overflow in arithmetic operations.</data>
      <data key="d8">arithmetic result indication,status flag</data>
      <data key="d9">chunk-acb6520440fa5141fe4d034f3e5e6edf</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735994</data>
    </edge>
    <edge source="Program Status Word Register" target="Sign Flag">
      <data key="d6">1.0</data>
      <data key="d7">The Sign Flag is a bit in the Program Status Word Register indicating whether the result is negative.</data>
      <data key="d8">result sign indication,status flag</data>
      <data key="d9">chunk-acb6520440fa5141fe4d034f3e5e6edf</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735995</data>
    </edge>
    <edge source="Program Status Word Register" target="Zero Flag">
      <data key="d6">1.0</data>
      <data key="d7">The Zero Flag is a bit in the Program Status Word Register indicating whether the result is zero.</data>
      <data key="d8">result zero detection,status flag</data>
      <data key="d9">chunk-acb6520440fa5141fe4d034f3e5e6edf</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735996</data>
    </edge>
    <edge source="Program Status Word Register" target="Carry Flag">
      <data key="d6">1.0</data>
      <data key="d7">The Carry Flag is a bit in the Program Status Word Register indicating carry out or borrow in arithmetic.</data>
      <data key="d8">carry/borrow detection,status flag</data>
      <data key="d9">chunk-acb6520440fa5141fe4d034f3e5e6edf</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761735996</data>
    </edge>
    <edge source="Program Status Word Register" target="Computational Core">
      <data key="d6">1.0</data>
      <data key="d7">The Computational Core uses the Program Status Word Register to track status flags for conditional branching.</data>
      <data key="d8">conditional execution,status tracking</data>
      <data key="d9">chunk-de401d6e0254effcba3f6fcd81cefe60</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736507</data>
    </edge>
    <edge source="Memory Address Register" target="Control Signal MARin">
      <data key="d6">1.0</data>
      <data key="d7">Control signal MARin activates the memory address register to accept an address from the bus.</data>
      <data key="d8">address input,control activation</data>
      <data key="d9">chunk-0efa36a872f0b1511a047f0591cba52c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736812</data>
    </edge>
    <edge source="Memory Data Register" target="Control Signal MDRin">
      <data key="d6">1.0</data>
      <data key="d7">Control signal MDRin activates the memory data register to receive data from the bus.</data>
      <data key="d8">control activation,data input</data>
      <data key="d9">chunk-0efa36a872f0b1511a047f0591cba52c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736812</data>
    </edge>
    <edge source="Memory Data Register" target="Control Signal MDRout">
      <data key="d6">1.0</data>
      <data key="d7">Control signal MDRout activates the memory data register to send data to the bus.</data>
      <data key="d8">control activation,data output</data>
      <data key="d9">chunk-0efa36a872f0b1511a047f0591cba52c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736812</data>
    </edge>
    <edge source="Accumulator" target="Temporary Register Z">
      <data key="d6">2.0</data>
      <data key="d7">The content of temporary register Z is transferred to the accumulator to update its value.&lt;SEP&gt;The accumulator is updated with the result stored in temporary register Z after an arithmetic operation.</data>
      <data key="d8">data transfer,data writing,result transfer,result update</data>
      <data key="d9">chunk-0efa36a872f0b1511a047f0591cba52c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736811</data>
    </edge>
    <edge source="Accumulator" target="Control Signal ACCin">
      <data key="d6">1.0</data>
      <data key="d7">Control signal ACCin enables the accumulator to accept data from the bus during result writing.</data>
      <data key="d8">control activation,data input</data>
      <data key="d9">chunk-0efa36a872f0b1511a047f0591cba52c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736815</data>
    </edge>
    <edge source="Shift Register" target="Sequential Logic Element">
      <data key="d6">1.0</data>
      <data key="d7">A shift register is a sequential logic element that moves data bits serially.</data>
      <data key="d8">function,type</data>
      <data key="d9">chunk-2459f394250f45963236273137f4db0c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736395</data>
    </edge>
    <edge source="Multi-Core Processor" target="Core">
      <data key="d6">1.0</data>
      <data key="d7">A multi-core processor consists of multiple cores integrated into a single CPU.</data>
      <data key="d8">architectural design,component integration</data>
      <data key="d9">chunk-ea027e504c6e7bd731aebc2b71512e1c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736027</data>
    </edge>
    <edge source="Multi-Core Processor" target="Multi-Threaded Execution">
      <data key="d6">1.0</data>
      <data key="d7">Multi-threaded execution is necessary to fully utilize the parallel processing capabilities of a multi-core processor.</data>
      <data key="d8">execution model,performance optimization</data>
      <data key="d9">chunk-ea027e504c6e7bd731aebc2b71512e1c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736028</data>
    </edge>
    <edge source="Multi-Core Processor" target="Parallel Execution">
      <data key="d6">1.0</data>
      <data key="d7">Parallel execution is achieved on multi-core processors when multiple threads run simultaneously on different cores.</data>
      <data key="d8">hardware capability,true parallelism</data>
      <data key="d9">chunk-ea027e504c6e7bd731aebc2b71512e1c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736028</data>
    </edge>
    <edge source="Core" target="Cache">
      <data key="d6">1.0</data>
      <data key="d7">Each core can have its own cache or share a common cache with other cores.</data>
      <data key="d8">cache assignment,memory hierarchy</data>
      <data key="d9">chunk-ea027e504c6e7bd731aebc2b71512e1c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736027</data>
    </edge>
    <edge source="Interleaved Execution" target="Single-Core System">
      <data key="d6">1.0</data>
      <data key="d7">On a single-core system, multi-threading occurs through interleaved execution, where threads alternate without true simultaneous execution.</data>
      <data key="d8">execution model,thread management</data>
      <data key="d9">chunk-ea027e504c6e7bd731aebc2b71512e1c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736027</data>
    </edge>
    <edge source="Exception" target="Instruction i">
      <data key="d6">1.0</data>
      <data key="d7">An exception is directly related to the execution of instruction i and is detected during its processing.</data>
      <data key="d8">instruction context,synchronous dependency</data>
      <data key="d9">chunk-53c573d4212b8c79ccafbdbdcd65d8e9</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736068</data>
    </edge>
    <edge source="Exception" target="Synchronous Event">
      <data key="d6">1.0</data>
      <data key="d7">An exception is classified as a synchronous event because it is tied to the execution of a specific instruction.</data>
      <data key="d8">execution alignment,timing relationship</data>
      <data key="d9">chunk-53c573d4212b8c79ccafbdbdcd65d8e9</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736069</data>
    </edge>
    <edge source="Exception" target="Interrupt">
      <data key="d6">1.0</data>
      <data key="d7">Exceptions and interrupts are similar in mechanism but differ in origin and timing.</data>
      <data key="d8">contrast,related concept</data>
      <data key="d9">chunk-56dad084d2f83de29d62a2ae33cfc843</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736661</data>
    </edge>
    <edge source="Exception" target="Hardware Detection">
      <data key="d6">1.0</data>
      <data key="d7">All exception events are detected and signaled by hardware.</data>
      <data key="d8">detection mechanism,event source</data>
      <data key="d9">chunk-56dad084d2f83de29d62a2ae33cfc843</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736662</data>
    </edge>
    <edge source="Interrupt" target="Interrupt Request Signal">
      <data key="d6">1.0</data>
      <data key="d7">An interrupt is triggered by the arrival of an interrupt request signal from an external device.</data>
      <data key="d8">asynchronous event,external trigger</data>
      <data key="d9">chunk-53c573d4212b8c79ccafbdbdcd65d8e9</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736067</data>
    </edge>
    <edge source="Interrupt" target="Asynchronous Event">
      <data key="d6">1.0</data>
      <data key="d7">An interrupt is classified as an asynchronous event because it is not tied to the current instruction execution.</data>
      <data key="d8">independent triggering,timing relationship</data>
      <data key="d9">chunk-53c573d4212b8c79ccafbdbdcd65d8e9</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736069</data>
    </edge>
    <edge source="Interrupt" target="I/O Interrupt">
      <data key="d6">1.0</data>
      <data key="d7">An I/O interrupt is a type of interrupt caused by input/output device activities.</data>
      <data key="d8">event classification,type of</data>
      <data key="d9">chunk-56dad084d2f83de29d62a2ae33cfc843</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736659</data>
    </edge>
    <edge source="Interrupt" target="Special Event">
      <data key="d6">1.0</data>
      <data key="d7">A special event is a classification of interrupt triggered by user actions or timers.</data>
      <data key="d8">event classification,type of</data>
      <data key="d9">chunk-56dad084d2f83de29d62a2ae33cfc843</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736660</data>
    </edge>
    <edge source="Interrupt" target="Hardware Detection">
      <data key="d6">1.0</data>
      <data key="d7">All interrupt events are detected and signaled by hardware.</data>
      <data key="d8">detection mechanism,event source</data>
      <data key="d9">chunk-56dad084d2f83de29d62a2ae33cfc843</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736661</data>
    </edge>
    <edge source="User Program" target="Instruction i">
      <data key="d6">1.0</data>
      <data key="d7">Instruction i is part of the user program currently being executed by the CPU.</data>
      <data key="d8">execution context,program state</data>
      <data key="d9">chunk-53c573d4212b8c79ccafbdbdcd65d8e9</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736067</data>
    </edge>
    <edge source="User Program" target="Instruction i+1">
      <data key="d6">1.0</data>
      <data key="d7">After handling an interrupt, the CPU resumes execution at the next instruction after the interrupted one.</data>
      <data key="d8">execution flow,program continuation</data>
      <data key="d9">chunk-53c573d4212b8c79ccafbdbdcd65d8e9</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736069</data>
    </edge>
    <edge source="Exception Handling Procedure" target="Operating System">
      <data key="d6">1.0</data>
      <data key="d7">The operating system, along with device drivers, manages the exception handling procedure.</data>
      <data key="d8">software execution,system-level management</data>
      <data key="d9">chunk-53c573d4212b8c79ccafbdbdcd65d8e9</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736067</data>
    </edge>
    <edge source="Exception Handling Procedure" target="Exception Return Instruction">
      <data key="d6">1.0</data>
      <data key="d7">After handling an exception, the CPU returns to the user program using the exception return instruction.</data>
      <data key="d8">execution resumption,flow control</data>
      <data key="d9">chunk-53c573d4212b8c79ccafbdbdcd65d8e9</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736068</data>
    </edge>
    <edge source="Exception Handling Procedure" target="Fatal Error">
      <data key="d6">1.0</data>
      <data key="d7">If a fatal error is detected during exception handling, the user program is terminated.</data>
      <data key="d8">error detection,program termination</data>
      <data key="d9">chunk-53c573d4212b8c79ccafbdbdcd65d8e9</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736070</data>
    </edge>
    <edge source="Interrupt Handling Procedure" target="Operating System">
      <data key="d6">1.0</data>
      <data key="d7">The operating system, along with device drivers, manages the interrupt handling procedure.</data>
      <data key="d8">software execution,system-level management</data>
      <data key="d9">chunk-53c573d4212b8c79ccafbdbdcd65d8e9</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736068</data>
    </edge>
    <edge source="Interrupt Handling Procedure" target="Interrupt Return Instruction">
      <data key="d6">1.0</data>
      <data key="d7">After handling an interrupt, the CPU returns to the user program using the interrupt return instruction.</data>
      <data key="d8">execution resumption,flow control</data>
      <data key="d9">chunk-53c573d4212b8c79ccafbdbdcd65d8e9</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736069</data>
    </edge>
    <edge source="Interrupt Handling Procedure" target="Fatal Error">
      <data key="d6">1.0</data>
      <data key="d7">If a fatal error is detected during interrupt handling, the user program is terminated.</data>
      <data key="d8">error detection,program termination</data>
      <data key="d9">chunk-53c573d4212b8c79ccafbdbdcd65d8e9</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736069</data>
    </edge>
    <edge source="Disable Interrupts" target="Interrupt Allowance (IF) Trigger">
      <data key="d6">1.0</data>
      <data key="d7">The IF trigger is used to enable or disable interrupt responses by the CPU.</data>
      <data key="d8">control functionality</data>
      <data key="d9">chunk-d405a4a8ff3786f94e93e3a9b7786551</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736116</data>
    </edge>
    <edge source="Breakpoint" target="Programmable Exception">
      <data key="d6">1.0</data>
      <data key="d7">Breakpoints are implemented as programmable exceptions to suspend execution for debugging.</data>
      <data key="d8">debugging mechanism,software trap</data>
      <data key="d9">chunk-62d730248fb05de6d5c2902d76480b63</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736292</data>
    </edge>
    <edge source="Breakpoint" target="Trap">
      <data key="d6">1.0</data>
      <data key="d7">Breakpoints are implemented using trap mechanisms that suspend execution for inspection.</data>
      <data key="d8">debugging tool,trap mechanism</data>
      <data key="d9">chunk-62d730248fb05de6d5c2902d76480b63</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736295</data>
    </edge>
    <edge source="Exception Status Register" target="Software Identification">
      <data key="d6">1.0</data>
      <data key="d7">The exception status register provides input for software-based identification of exceptions.</data>
      <data key="d8">detection,status recording</data>
      <data key="d9">chunk-d405a4a8ff3786f94e93e3a9b7786551</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736117</data>
    </edge>
    <edge source="Unified Exception or Interrupt Query Program" target="Software Identification">
      <data key="d6">1.0</data>
      <data key="d7">The query program checks the exception status register in priority order to identify the first pending exception or interrupt.</data>
      <data key="d8">detection algorithm,priority handling</data>
      <data key="d9">chunk-d405a4a8ff3786f94e93e3a9b7786551</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736118</data>
    </edge>
    <edge source="Hardware Identification" target="Interrupt Vector Table">
      <data key="d6">1.0</data>
      <data key="d7">Hardware identification uses the interrupt vector table to map type numbers to handler addresses.</data>
      <data key="d8">lookup,mapping</data>
      <data key="d9">chunk-d405a4a8ff3786f94e93e3a9b7786551</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736118</data>
    </edge>
    <edge source="Interrupt Vector" target="Interrupt Service Program">
      <data key="d6">1.0</data>
      <data key="d7">The interrupt vector points to the first instruction of the interrupt service program.</data>
      <data key="d8">execution target,routing</data>
      <data key="d9">chunk-d405a4a8ff3786f94e93e3a9b7786551</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736118</data>
    </edge>
    <edge source="Interrupt Vector Table" target="Interrupt Type Number">
      <data key="d6">1.0</data>
      <data key="d7">Each interrupt type number corresponds to a unique entry in the interrupt vector table.</data>
      <data key="d8">indexing,mapping key</data>
      <data key="d9">chunk-d405a4a8ff3786f94e93e3a9b7786551</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736119</data>
    </edge>
    <edge source="Interrupt Vector Table" target="Interrupt Service Program">
      <data key="d6">1.0</data>
      <data key="d7">The interrupt vector table contains references to the interrupt service programs used during handling.</data>
      <data key="d8">routing,storage and access</data>
      <data key="d9">chunk-d405a4a8ff3786f94e93e3a9b7786551</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736120</data>
    </edge>
    <edge source="微地址形成部件" target="μPC">
      <data key="d6">1.0</data>
      <data key="d7">The microaddress formation component generates the address for the next microinstruction and sends it to μPC.</data>
      <data key="d8">address generation,control flow</data>
      <data key="d9">chunk-7b1e3d6a0816b7c4daa74cc9c66df994</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736161</data>
    </edge>
    <edge source="微地址形成部件" target="机器指令的操作码">
      <data key="d6">1.0</data>
      <data key="d7">The operation code of a machine instruction is input to the microaddress formation unit to compute the starting address of the microprogram.</data>
      <data key="d8">address computation,control signal generation</data>
      <data key="d9">chunk-7c0597dc102c9fca5be6ec61fc5d051b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736655</data>
    </edge>
    <edge source="控制存储器" target="微程序">
      <data key="d6">1.0</data>
      <data key="d7">Each microprogram is stored in the control memory, accessed via the microinstruction address.</data>
      <data key="d8">program persistence,storage location</data>
      <data key="d9">chunk-7b1e3d6a0816b7c4daa74cc9c66df994</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736159</data>
    </edge>
    <edge source="控制存储器" target="μPC">
      <data key="d6">1.0</data>
      <data key="d7">The control memory inputs microinstructions into μIR based on the address held in μPC.</data>
      <data key="d8">address access,instruction fetching</data>
      <data key="d9">chunk-7b1e3d6a0816b7c4daa74cc9c66df994</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736162</data>
    </edge>
    <edge source="控制存储器" target="μIR">
      <data key="d6">1.0</data>
      <data key="d7">The control memory sends the microinstruction to μIR for execution after address resolution by μPC.</data>
      <data key="d8">data transfer,instruction loading</data>
      <data key="d9">chunk-7b1e3d6a0816b7c4daa74cc9c66df994</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736162</data>
    </edge>
    <edge source="控制存储器" target="直接编码方式">
      <data key="d6">1.0</data>
      <data key="d7">Direct encoding results in longer microinstruction words and larger control memory requirements due to the high number of control bits.</data>
      <data key="d8">memory footprint,storage overhead</data>
      <data key="d9">chunk-96defdcda60eaf79fff26bdc712404aa</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736382</data>
    </edge>
    <edge source="μPC" target="增量计数器法">
      <data key="d6">1.0</data>
      <data key="d7">The increment counter method updates μPC by adding one to the current address, suitable for sequential microinstructions.</data>
      <data key="d8">increment logic,sequential execution</data>
      <data key="d9">chunk-7c0597dc102c9fca5be6ec61fc5d051b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736655</data>
    </edge>
    <edge source="μPC" target="取指周期微程序">
      <data key="d6">1.0</data>
      <data key="d7">μPC holds the address of the control sequence executed during the fetch cycle of a machine instruction.</data>
      <data key="d8">control unit operation,instruction fetch</data>
      <data key="d9">chunk-7c0597dc102c9fca5be6ec61fc5d051b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736657</data>
    </edge>
    <edge source="取指微程序" target="机器指令">
      <data key="d6">1.0</data>
      <data key="d7">All machine instructions begin with the same fetch microprogram to retrieve the instruction from main memory.</data>
      <data key="d8">common operation,execution phase</data>
      <data key="d9">chunk-7b1e3d6a0816b7c4daa74cc9c66df994</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736163</data>
    </edge>
    <edge source="Instruction Pipeline" target="Pipeline Hazard">
      <data key="d6">1.0</data>
      <data key="d7">The instruction pipeline can experience pipeline hazards that cause execution to stall due to conflicts in resource usage or data dependencies.</data>
      <data key="d8">execution stall,pipeline blocking</data>
      <data key="d9">chunk-951a0e05d8d102dbb38963722260d96a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736225</data>
    </edge>
    <edge source="Instruction Pipeline" target="Read After Write Conflict">
      <data key="d6">1.0</data>
      <data key="d7">Read After Write conflicts are a common data hazard in instruction pipelines where the result of one instruction is not yet available for use by a subsequent one.</data>
      <data key="d8">data dependency,timing hazard</data>
      <data key="d9">chunk-951a0e05d8d102dbb38963722260d96a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736228</data>
    </edge>
    <edge source="Structural Hazard" target="Memory Access Conflict">
      <data key="d6">1.0</data>
      <data key="d7">Structural hazards occur due to memory access conflicts when multiple operations compete for the same memory resource simultaneously.</data>
      <data key="d8">hardware conflict,resource contention</data>
      <data key="d9">chunk-951a0e05d8d102dbb38963722260d96a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736225</data>
    </edge>
    <edge source="Structural Hazard" target="Resource Conflict">
      <data key="d6">1.0</data>
      <data key="d7">Structural hazards are also referred to as resource conflicts caused by limited hardware components being accessed by multiple instructions at once.</data>
      <data key="d8">competition,hardware limitation</data>
      <data key="d9">chunk-951a0e05d8d102dbb38963722260d96a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736228</data>
    </edge>
    <edge source="Data Hazard" target="Read After Write Conflict">
      <data key="d6">1.0</data>
      <data key="d7">Data hazards include Read After Write (RAW) conflicts where an instruction reads a register before a prior instruction has written to it.</data>
      <data key="d8">data dependency,result timing</data>
      <data key="d9">chunk-951a0e05d8d102dbb38963722260d96a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736225</data>
    </edge>
    <edge source="Read After Write Conflict" target="Non-OutOfOrder Execution">
      <data key="d6">1.0</data>
      <data key="d7">In a non-out-of-order execution pipeline, only Read After Write (RAW) conflicts occur because instructions are processed in strict program order, and no reordering is allowed to resolve dependencies.</data>
      <data key="d8">execution model,hazard limitation</data>
      <data key="d9">chunk-951a0e05d8d102dbb38963722260d96a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736230</data>
    </edge>
    <edge source="Memory Access Conflict" target="Instruction Fetch Stage">
      <data key="d6">1.0</data>
      <data key="d7">The instruction fetch stage can cause a memory access conflict if a load instruction is accessed simultaneously.</data>
      <data key="d8">access contention,instruction timing</data>
      <data key="d9">chunk-951a0e05d8d102dbb38963722260d96a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736229</data>
    </edge>
    <edge source="Load Instruction" target="Add Instruction">
      <data key="d6">1.0</data>
      <data key="d7">The load instruction and add instruction can create a data dependency where the add instruction requires the result of a load, causing a load-use hazard.</data>
      <data key="d8">data dependency,pipeline conflict</data>
      <data key="d9">chunk-951a0e05d8d102dbb38963722260d96a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736225</data>
    </edge>
    <edge source="Load Instruction" target="Memory Stage">
      <data key="d6">1.0</data>
      <data key="d7">A load instruction is processed during the memory stage, where it accesses data from memory.</data>
      <data key="d8">data fetch,execution phase</data>
      <data key="d9">chunk-951a0e05d8d102dbb38963722260d96a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736227</data>
    </edge>
    <edge source="Load Instruction" target="Load-Use Data Hazard">
      <data key="d6">1.0</data>
      <data key="d7">A load-use data hazard occurs specifically when an instruction immediately following a load attempts to read the result before it is available.</data>
      <data key="d8">data timing problem,dependency</data>
      <data key="d9">chunk-951a0e05d8d102dbb38963722260d96a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736228</data>
    </edge>
    <edge source="Add Instruction" target="Execute Stage">
      <data key="d6">1.0</data>
      <data key="d7">An add instruction performs its operation during the execute stage.</data>
      <data key="d8">execution phase,operation</data>
      <data key="d9">chunk-951a0e05d8d102dbb38963722260d96a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736227</data>
    </edge>
    <edge source="Add Instruction" target="Forwarding Path">
      <data key="d6">1.0</data>
      <data key="d7">A forwarding path enables the add instruction to receive the result directly from a prior instruction’s execution stage without waiting for write-back.</data>
      <data key="d8">data forwarding,performance optimization</data>
      <data key="d9">chunk-951a0e05d8d102dbb38963722260d96a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736228</data>
    </edge>
    <edge source="L1 Cache" target="Instruction Memory">
      <data key="d6">1.0</data>
      <data key="d7">L1 cache uses separate instruction and data caches to avoid conflicts between instruction fetch and data access.</data>
      <data key="d8">cache separation,resource isolation</data>
      <data key="d9">chunk-951a0e05d8d102dbb38963722260d96a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736228</data>
    </edge>
    <edge source="L1 Cache" target="Data Memory">
      <data key="d6">1.0</data>
      <data key="d7">The separation of instruction and data caches in L1 helps prevent access conflicts with data memory.</data>
      <data key="d8">cache separation,memory access optimization</data>
      <data key="d9">chunk-951a0e05d8d102dbb38963722260d96a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736229</data>
    </edge>
    <edge source="Register Read Port" target="Register Write Port">
      <data key="d6">1.0</data>
      <data key="d7">Separating the register write port from the read port allows simultaneous read and write operations without conflict.</data>
      <data key="d8">port separation,register access control</data>
      <data key="d9">chunk-951a0e05d8d102dbb38963722260d96a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736227</data>
    </edge>
    <edge source="Compiler Optimization" target="Load-Use Data Hazard">
      <data key="d6">1.0</data>
      <data key="d7">Compiler optimization can reorganize instructions to eliminate load-use hazards by avoiding dependencies.</data>
      <data key="d8">hazard avoidance,instruction scheduling</data>
      <data key="d9">chunk-951a0e05d8d102dbb38963722260d96a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736231</data>
    </edge>
    <edge source="Memory Stage" target="Write-Back Stage">
      <data key="d6">1.0</data>
      <data key="d7">The memory stage occurs before the write-back stage, and the result from memory must be stored in the register file at write-back.</data>
      <data key="d8">data propagation,pipeline timing</data>
      <data key="d9">chunk-951a0e05d8d102dbb38963722260d96a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736229</data>
    </edge>
    <edge source="Write-Back Stage" target="Execution Stage">
      <data key="d6">1.0</data>
      <data key="d7">The execute stage produces results that may be forwarded to the write-back stage for register update.</data>
      <data key="d8">data forwarding,pipeline stage dependency</data>
      <data key="d9">chunk-951a0e05d8d102dbb38963722260d96a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736231</data>
    </edge>
    <edge source="Programmable Exception" target="Division By Zero">
      <data key="d6">1.0</data>
      <data key="d7">Division by zero is a type of programmable exception caused by executing an invalid arithmetic instruction.</data>
      <data key="d8">exception type,instruction failure</data>
      <data key="d9">chunk-62d730248fb05de6d5c2902d76480b63</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736291</data>
    </edge>
    <edge source="Programmable Exception" target="Overflow">
      <data key="d6">1.0</data>
      <data key="d7">Overflow is a programmable exception that occurs when arithmetic results exceed representable limits.</data>
      <data key="d8">exception type,instruction failure</data>
      <data key="d9">chunk-62d730248fb05de6d5c2902d76480b63</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736292</data>
    </edge>
    <edge source="Programmable Exception" target="Single Step Tracking">
      <data key="d6">1.0</data>
      <data key="d7">Single step tracking uses programmable exceptions to execute one instruction at a time.</data>
      <data key="d8">debugging mechanism,software trap</data>
      <data key="d9">chunk-62d730248fb05de6d5c2902d76480b63</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736293</data>
    </edge>
    <edge source="Programmable Exception" target="Illegal Instruction">
      <data key="d6">1.0</data>
      <data key="d7">Illegal instructions trigger a programmable exception due to invalid opcodes.</data>
      <data key="d8">exception type,instruction failure</data>
      <data key="d9">chunk-62d730248fb05de6d5c2902d76480b63</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736294</data>
    </edge>
    <edge source="Programmable Exception" target="Stack Overflow">
      <data key="d6">1.0</data>
      <data key="d7">Stack overflow is a programmable exception resulting from excessive stack usage.</data>
      <data key="d8">exception type,overflow condition</data>
      <data key="d9">chunk-62d730248fb05de6d5c2902d76480b63</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736294</data>
    </edge>
    <edge source="Programmable Exception" target="Address Out Of Bounds">
      <data key="d6">1.0</data>
      <data key="d7">Address out of bounds triggers a programmable exception when invalid memory addresses are accessed.</data>
      <data key="d8">exception type,memory access error</data>
      <data key="d9">chunk-62d730248fb05de6d5c2902d76480b63</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736295</data>
    </edge>
    <edge source="Programmable Exception" target="Page Fault">
      <data key="d6">1.0</data>
      <data key="d7">Page faults are programmable exceptions that occur when a required page is not in main memory.</data>
      <data key="d8">memory management exception,virtual memory</data>
      <data key="d9">chunk-62d730248fb05de6d5c2902d76480b63</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736296</data>
    </edge>
    <edge source="Programmable Exception" target="Segment Fault">
      <data key="d6">1.0</data>
      <data key="d7">Segment faults are programmable exceptions caused by invalid access to memory segments.</data>
      <data key="d8">memory management exception,virtual memory</data>
      <data key="d9">chunk-62d730248fb05de6d5c2902d76480b63</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736296</data>
    </edge>
    <edge source="Division By Zero" target="Fault">
      <data key="d6">1.0</data>
      <data key="d7">Division by zero is a fault that cannot be recovered from, requiring process termination.</data>
      <data key="d8">instruction termination,unrecoverable exception</data>
      <data key="d9">chunk-62d730248fb05de6d5c2902d76480b63</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736298</data>
    </edge>
    <edge source="Single Step Tracking" target="Trap">
      <data key="d6">1.0</data>
      <data key="d7">Single step tracking uses traps to execute code one instruction at a time.</data>
      <data key="d8">debugging tool,trap mechanism</data>
      <data key="d9">chunk-62d730248fb05de6d5c2902d76480b63</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736297</data>
    </edge>
    <edge source="Illegal Instruction" target="Fault">
      <data key="d6">1.0</data>
      <data key="d7">Illegal instruction faults cannot be resolved via recovery and lead to process termination.</data>
      <data key="d8">instruction termination,unrecoverable exception</data>
      <data key="d9">chunk-62d730248fb05de6d5c2902d76480b63</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736299</data>
    </edge>
    <edge source="Page Fault" target="Fault">
      <data key="d6">1.0</data>
      <data key="d7">Page faults are classified as faults because they can be resolved by loading the required page into main memory and restarting the instruction.</data>
      <data key="d8">instruction re-execution,recoverable exception</data>
      <data key="d9">chunk-62d730248fb05de6d5c2902d76480b63</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736296</data>
    </edge>
    <edge source="Segment Fault" target="Fault">
      <data key="d6">1.0</data>
      <data key="d7">Segment faults are faults as they can be resolved by bringing the missing segment into memory.</data>
      <data key="d8">instruction re-execution,recoverable exception</data>
      <data key="d9">chunk-62d730248fb05de6d5c2902d76480b63</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736297</data>
    </edge>
    <edge source="Trap" target="System Call">
      <data key="d6">1.0</data>
      <data key="d7">System calls are initiated via trap instructions to invoke kernel services.</data>
      <data key="d8">kernel access,software interface</data>
      <data key="d9">chunk-62d730248fb05de6d5c2902d76480b63</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736296</data>
    </edge>
    <edge source="Trap" target="MIPS Architecture">
      <data key="d6">1.0</data>
      <data key="d7">The MIPS architecture supports trap instructions such as teq, teqi, tne, and tnei for conditional debugging.</data>
      <data key="d8">conditional trap,instruction set support</data>
      <data key="d9">chunk-62d730248fb05de6d5c2902d76480b63</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736298</data>
    </edge>
    <edge source="Trap" target="x86 Machine">
      <data key="d6">1.0</data>
      <data key="d7">The x86 machine uses traps to implement breakpoints and single-step tracking.</data>
      <data key="d8">debugging feature,instruction set support</data>
      <data key="d9">chunk-62d730248fb05de6d5c2902d76480b63</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736298</data>
    </edge>
    <edge source="Abort" target="Memory Parity Error">
      <data key="d6">1.0</data>
      <data key="d7">Memory parity errors trigger aborts because they cannot be corrected, requiring system restart.</data>
      <data key="d8">system restart,unrecoverable hardware fault</data>
      <data key="d9">chunk-62d730248fb05de6d5c2902d76480b63</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736297</data>
    </edge>
    <edge source="Abort" target="Bus Error">
      <data key="d6">1.0</data>
      <data key="d7">Bus errors are aborts that prevent execution and require system restart.</data>
      <data key="d8">system restart,unrecoverable hardware fault</data>
      <data key="d9">chunk-62d730248fb05de6d5c2902d76480b63</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736298</data>
    </edge>
    <edge source="Abort" target="Controller Error">
      <data key="d6">1.0</data>
      <data key="d7">Controller errors are aborts that halt execution and necessitate system reboot.</data>
      <data key="d8">system restart,unrecoverable hardware fault</data>
      <data key="d9">chunk-62d730248fb05de6d5c2902d76480b63</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736299</data>
    </edge>
    <edge source="Page" target="Disk">
      <data key="d6">1.0</data>
      <data key="d7">Pages are stored on disk when not in main memory for later retrieval.</data>
      <data key="d8">persistence,virtual memory storage</data>
      <data key="d9">chunk-62d730248fb05de6d5c2902d76480b63</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736300</data>
    </edge>
    <edge source="Segment" target="Disk">
      <data key="d6">1.0</data>
      <data key="d7">Segments are stored on disk to be loaded into main memory when needed.</data>
      <data key="d8">persistence,virtual memory storage</data>
      <data key="d9">chunk-62d730248fb05de6d5c2902d76480b63</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736301</data>
    </edge>
    <edge source="Operating System Kernel" target="Exception Service Routine">
      <data key="d6">1.0</data>
      <data key="d7">The operating system kernel runs the exception service routine to process and handle exceptions.</data>
      <data key="d8">exception handling,kernel service</data>
      <data key="d9">chunk-62d730248fb05de6d5c2902d76480b63</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736300</data>
    </edge>
    <edge source="Advanced Pipeline Technology" target="Multiple Issuance Technology">
      <data key="d6">1.0</data>
      <data key="d7">Multiple Issuance Technology is a strategy within Advanced Pipeline Technology used to increase instruction-level parallelism.</data>
      <data key="d8">methodological classification,performance enhancement</data>
      <data key="d9">chunk-3ac380505fdc239a4da36a89716b6444</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736311</data>
    </edge>
    <edge source="Advanced Pipeline Technology" target="Superpipeline Technology">
      <data key="d6">1.0</data>
      <data key="d7">Superpipeline Technology is a strategy within Advanced Pipeline Technology used to improve instruction throughput by increasing pipeline stages.</data>
      <data key="d8">methodological classification,performance enhancement</data>
      <data key="d9">chunk-3ac380505fdc239a4da36a89716b6444</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736315</data>
    </edge>
    <edge source="Advanced Pipeline Technology" target="Superscalar Pipeline Technology">
      <data key="d6">1.0</data>
      <data key="d7">Superscalar Pipeline Technology is a form of Advanced Pipeline Technology that enables parallel execution of multiple instructions per cycle.</data>
      <data key="d8">methodological classification,performance enhancement</data>
      <data key="d9">chunk-3ac380505fdc239a4da36a89716b6444</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736315</data>
    </edge>
    <edge source="Advanced Pipeline Technology" target="Very Long Instruction Word Technology">
      <data key="d6">1.0</data>
      <data key="d7">Very Long Instruction Word Technology is a form of Advanced Pipeline Technology that exploits parallelism through compiler-generated long instruction words.</data>
      <data key="d8">methodological classification,performance enhancement</data>
      <data key="d9">chunk-3ac380505fdc239a4da36a89716b6444</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736316</data>
    </edge>
    <edge source="Advanced Pipeline Technology" target="Instruction-Level Parallelism">
      <data key="d6">1.0</data>
      <data key="d7">The primary goal of Advanced Pipeline Technology is to achieve higher instruction-level parallelism in processor design.</data>
      <data key="d8">core objective,parallelism achievement</data>
      <data key="d9">chunk-3ac380505fdc239a4da36a89716b6444</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736317</data>
    </edge>
    <edge source="Multiple Issuance Technology" target="Functional Unit">
      <data key="d6">1.0</data>
      <data key="d7">Multiple Issuance Technology requires multiple functional units to allow parallel execution of multiple instructions.</data>
      <data key="d8">hardware requirement,parallel execution</data>
      <data key="d9">chunk-3ac380505fdc239a4da36a89716b6444</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736313</data>
    </edge>
    <edge source="Superpipeline Technology" target="Instruction Throughput">
      <data key="d6">1.0</data>
      <data key="d7">Superpipeline Technology increases instruction throughput by reducing the time required per pipeline stage.</data>
      <data key="d8">performance metric,throughput improvement</data>
      <data key="d9">chunk-3ac380505fdc239a4da36a89716b6444</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736313</data>
    </edge>
    <edge source="Superpipeline Technology" target="Pipeline Register Overhead">
      <data key="d6">1.0</data>
      <data key="d7">The increase in pipeline stages in Superpipeline Technology leads to higher pipeline register overhead.</data>
      <data key="d8">design limitation,resource cost</data>
      <data key="d9">chunk-3ac380505fdc239a4da36a89716b6444</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736314</data>
    </edge>
    <edge source="Superpipeline Technology" target="CPI">
      <data key="d6">1.0</data>
      <data key="d7">Superpipeline Technology maintains CPI = 1, meaning one instruction is executed per cycle, even though the clock frequency is higher.</data>
      <data key="d8">efficiency measurement,performance metric</data>
      <data key="d9">chunk-3ac380505fdc239a4da36a89716b6444</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736315</data>
    </edge>
    <edge source="Superscalar Pipeline Technology" target="Dynamic Pipeline Scheduling">
      <data key="d6">1.0</data>
      <data key="d7">Dynamic Pipeline Scheduling is used in most superscalar CPUs to enhance parallel performance through dynamic execution ordering.</data>
      <data key="d8">control mechanism,performance optimization</data>
      <data key="d9">chunk-3ac380505fdc239a4da36a89716b6444</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736311</data>
    </edge>
    <edge source="Superscalar Pipeline Technology" target="Out-of-Order Execution">
      <data key="d6">1.0</data>
      <data key="d7">Out-of-Order Execution is a key feature of superscalar CPUs that allows instructions to be executed out of program order for improved efficiency.</data>
      <data key="d8">execution model,performance optimization</data>
      <data key="d9">chunk-3ac380505fdc239a4da36a89716b6444</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736313</data>
    </edge>
    <edge source="Superscalar Pipeline Technology" target="CPI">
      <data key="d6">1.0</data>
      <data key="d7">Superscalar Pipeline Technology achieves CPI &lt; 1, indicating more than one instruction is executed per cycle on average.</data>
      <data key="d8">efficiency measurement,performance metric</data>
      <data key="d9">chunk-3ac380505fdc239a4da36a89716b6444</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736313</data>
    </edge>
    <edge source="Superscalar Pipeline Technology" target="Simple Superscalar CPU">
      <data key="d6">1.0</data>
      <data key="d7">The Simple Superscalar CPU is a basic configuration of Superscalar Pipeline Technology where instructions execute in order, forming a foundational design.</data>
      <data key="d8">architectural model,implementation variant</data>
      <data key="d9">chunk-3ac380505fdc239a4da36a89716b6444</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736314</data>
    </edge>
    <edge source="Very Long Instruction Word Technology" target="Compiler">
      <data key="d6">1.0</data>
      <data key="d7">The Very Long Instruction Word Technology depends on the compiler to extract and combine parallelizable instructions into a single extended instruction word.</data>
      <data key="d8">parallelism extraction,software dependency</data>
      <data key="d9">chunk-3ac380505fdc239a4da36a89716b6444</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736311</data>
    </edge>
    <edge source="Very Long Instruction Word Technology" target="Functional Unit">
      <data key="d6">1.0</data>
      <data key="d7">Very Long Instruction Word Technology requires multiple processing units to execute the combined operations in a single long instruction word.</data>
      <data key="d8">hardware requirement,parallel execution</data>
      <data key="d9">chunk-3ac380505fdc239a4da36a89716b6444</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736314</data>
    </edge>
    <edge source="CPI" target="Pipeline Processor">
      <data key="d6">1.0</data>
      <data key="d7">In ideal conditions, the pipeline processor achieves CPI=1 by completing one instruction per clock cycle.</data>
      <data key="d8">ideal performance,throughput</data>
      <data key="d9">chunk-3c7856616d478c58fdce251c9a2b68ac</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736783</data>
    </edge>
    <edge source="Functional Unit" target="Intel Hyper-Threading">
      <data key="d6">1.0</data>
      <data key="d7">Intel Hyper-Threading allows multiple logical threads to share functional units to improve utilization.</data>
      <data key="d8">performance optimization,resource sharing</data>
      <data key="d9">chunk-f67ff7c347b613bc05733f64a51c9c17</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736745</data>
    </edge>
    <edge source="Instruction-Level Parallelism" target="Simultaneous Multithreading">
      <data key="d6">1.0</data>
      <data key="d7">Simultaneous multithreading enables instruction-level parallelism by executing multiple instructions per clock cycle.</data>
      <data key="d8">parallelism type,performance enhancement</data>
      <data key="d9">chunk-f67ff7c347b613bc05733f64a51c9c17</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736743</data>
    </edge>
    <edge source="微指令的编码方式" target="微指令的操作控制字段">
      <data key="d6">1.0</data>
      <data key="d7">The microinstruction encoding method determines how the control fields of a microinstruction are structured and used.</data>
      <data key="d8">control signal generation,encoding mechanism</data>
      <data key="d9">chunk-96defdcda60eaf79fff26bdc712404aa</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736381</data>
    </edge>
    <edge source="微指令的编码方式" target="微指令字长">
      <data key="d6">1.0</data>
      <data key="d7">The encoding method directly impacts the length of the microinstruction word, aiming to minimize length while maintaining performance.</data>
      <data key="d8">design trade-off,length optimization</data>
      <data key="d9">chunk-96defdcda60eaf79fff26bdc712404aa</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736383</data>
    </edge>
    <edge source="直接编码方式" target="微命令">
      <data key="d6">1.0</data>
      <data key="d7">In direct encoding, each bit in the control field directly represents a microcommand, enabling immediate execution.</data>
      <data key="d8">bit-level activation,direct control</data>
      <data key="d9">chunk-96defdcda60eaf79fff26bdc712404aa</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736381</data>
    </edge>
    <edge source="直接编码方式" target="控制存储器容量">
      <data key="d6">1.0</data>
      <data key="d7">Direct encoding increases control memory capacity due to the long microinstruction word length required for each microcommand.</data>
      <data key="d8">design inefficiency,memory overhead</data>
      <data key="d9">chunk-96defdcda60eaf79fff26bdc712404aa</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736384</data>
    </edge>
    <edge source="字段直接编码方式" target="互斥性微命令">
      <data key="d6">1.0</data>
      <data key="d7">Mutually exclusive microcommands are grouped in the same field to reduce field size and improve efficiency.</data>
      <data key="d8">field segmentation,grouping principle</data>
      <data key="d9">chunk-96defdcda60eaf79fff26bdc712404aa</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736381</data>
    </edge>
    <edge source="字段直接编码方式" target="相容性微命令">
      <data key="d6">1.0</data>
      <data key="d7">Compatible microcommands are separated into different fields to allow concurrent execution.</data>
      <data key="d8">parallel execution,separation principle</data>
      <data key="d9">chunk-96defdcda60eaf79fff26bdc712404aa</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736383</data>
    </edge>
    <edge source="字段直接编码方式" target="译码电路">
      <data key="d6">1.0</data>
      <data key="d7">Field direct encoding requires decoding circuits to interpret the encoded values before issuing microcommands.</data>
      <data key="d8">control signal generation,indirect decoding</data>
      <data key="d9">chunk-96defdcda60eaf79fff26bdc712404aa</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736384</data>
    </edge>
    <edge source="字段直接编码方式" target="字段间接编码方式">
      <data key="d6">1.0</data>
      <data key="d7">Field indirect encoding is typically used as a supplementary method to further reduce microinstruction word length in conjunction with field direct encoding.</data>
      <data key="d8">auxiliary technique,encoding optimization</data>
      <data key="d9">chunk-96defdcda60eaf79fff26bdc712404aa</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736384</data>
    </edge>
    <edge source="字段直接编码方式" target="操作并行性">
      <data key="d6">1.0</data>
      <data key="d7">Field direct encoding supports better parallelism by allowing compatible microcommands to execute simultaneously in different fields.</data>
      <data key="d8">efficiency improvement,parallel execution</data>
      <data key="d9">chunk-96defdcda60eaf79fff26bdc712404aa</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736385</data>
    </edge>
    <edge source="字段直接编码方式" target="3位字段">
      <data key="d6">1.0</data>
      <data key="d7">A 3-bit field is limited to representing a maximum of 7 microcommands, requiring one bit for a "no operation" state.</data>
      <data key="d8">encoding limitation,field size constraint</data>
      <data key="d9">chunk-96defdcda60eaf79fff26bdc712404aa</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736387</data>
    </edge>
    <edge source="微命令" target="微操作">
      <data key="d6">1.0</data>
      <data key="d7">Each microcommand controls a specific microoperation in the data path of the processor.</data>
      <data key="d8">control signal,execution level</data>
      <data key="d9">chunk-96defdcda60eaf79fff26bdc712404aa</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736382</data>
    </edge>
    <edge source="Data Path" target="Combinational Logic Element">
      <data key="d6">1.0</data>
      <data key="d7">The data path is composed of combinational logic elements that process data based on current inputs.</data>
      <data key="d8">circuit type,composition</data>
      <data key="d9">chunk-2459f394250f45963236273137f4db0c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736391</data>
    </edge>
    <edge source="Data Path" target="Sequential Logic Element">
      <data key="d6">1.0</data>
      <data key="d7">The data path includes sequential logic elements that maintain state and rely on clock signals.</data>
      <data key="d8">circuit type,composition</data>
      <data key="d9">chunk-2459f394250f45963236273137f4db0c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736392</data>
    </edge>
    <edge source="Data Path" target="Counter">
      <data key="d6">1.0</data>
      <data key="d7">The Data Path includes the Counter for managing counts and address generation during instruction cycles.</data>
      <data key="d8">address generation,counting</data>
      <data key="d9">chunk-de401d6e0254effcba3f6fcd81cefe60</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736507</data>
    </edge>
    <edge source="Data Path" target="General Purpose Registers">
      <data key="d6">1.0</data>
      <data key="d7">General purpose registers are storage units integrated into the Data Path for temporary data retention.</data>
      <data key="d8">data holding,storage component</data>
      <data key="d9">chunk-cf0a63e25f70bb6e12f2ee7720496542</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736561</data>
    </edge>
    <edge source="Data Path" target="Status Register">
      <data key="d6">1.0</data>
      <data key="d7">The Status Register is a component within the Data Path that records the results of operations, such as zero or overflow flags.</data>
      <data key="d8">outcome recording,status tracking</data>
      <data key="d9">chunk-cf0a63e25f70bb6e12f2ee7720496542</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736562</data>
    </edge>
    <edge source="Data Path" target="Exception and Interrupt Handling Logic">
      <data key="d6">1.0</data>
      <data key="d7">This logic is a part of the Data Path that manages exceptions and interrupts, ensuring system integrity during irregular events.</data>
      <data key="d8">event management,system response</data>
      <data key="d9">chunk-cf0a63e25f70bb6e12f2ee7720496542</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736563</data>
    </edge>
    <edge source="Combinational Logic Element" target="Adder">
      <data key="d6">1.0</data>
      <data key="d7">An adder is a specific instance of a combinational logic element used for binary addition.</data>
      <data key="d8">function,type</data>
      <data key="d9">chunk-2459f394250f45963236273137f4db0c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736392</data>
    </edge>
    <edge source="Combinational Logic Element" target="Decoder">
      <data key="d6">1.0</data>
      <data key="d7">A decoder is a combinational logic element that converts binary inputs into specific output signals.</data>
      <data key="d8">function,type</data>
      <data key="d9">chunk-2459f394250f45963236273137f4db0c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736394</data>
    </edge>
    <edge source="Combinational Logic Element" target="Multiplexer">
      <data key="d6">1.0</data>
      <data key="d7">A multiplexer is a combinational logic element used to select one of multiple input signals for output.</data>
      <data key="d8">function,type</data>
      <data key="d9">chunk-2459f394250f45963236273137f4db0c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736395</data>
    </edge>
    <edge source="Combinational Logic Element" target="Three-State Gate">
      <data key="d6">1.0</data>
      <data key="d7">A three-state gate is a combinational logic element that enables control of signal flow on shared buses.</data>
      <data key="d8">function,type</data>
      <data key="d9">chunk-2459f394250f45963236273137f4db0c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736395</data>
    </edge>
    <edge source="Combinational Logic Element" target="No Feedback">
      <data key="d6">1.0</data>
      <data key="d7">Combinational logic elements do not have feedback paths, ensuring output depends only on immediate inputs.</data>
      <data key="d8">architecture,signal flow</data>
      <data key="d9">chunk-2459f394250f45963236273137f4db0c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736396</data>
    </edge>
    <edge source="Sequential Logic Element" target="Status Register">
      <data key="d6">1.0</data>
      <data key="d7">A status register is a sequential logic element that stores processor status flags.</data>
      <data key="d8">function,type</data>
      <data key="d9">chunk-2459f394250f45963236273137f4db0c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736394</data>
    </edge>
    <edge source="Sequential Logic Element" target="Latch">
      <data key="d6">1.0</data>
      <data key="d7">A latch is a sequential logic element that stores data based on input levels.</data>
      <data key="d8">function,type</data>
      <data key="d9">chunk-2459f394250f45963236273137f4db0c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736395</data>
    </edge>
    <edge source="Sequential Logic Element" target="Clock Signal">
      <data key="d6">1.0</data>
      <data key="d7">Sequential logic elements require a clock signal to coordinate state changes and operations.</data>
      <data key="d8">synchronization,timing control</data>
      <data key="d9">chunk-2459f394250f45963236273137f4db0c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736397</data>
    </edge>
    <edge source="Single Cycle Implementation" target="Instruction Execution Time">
      <data key="d6">1.0</data>
      <data key="d7">In single cycle implementation, each instruction takes 750ps to complete, with all stages executed in sequence.</data>
      <data key="d8">execution model,performance characteristic</data>
      <data key="d9">chunk-5ea0f23d1c767bafc743ff484eb189e1</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736490</data>
    </edge>
    <edge source="Single Cycle Implementation" target="Pipeline Design Principle">
      <data key="d6">1.0</data>
      <data key="d7">Pipeline design principles contrast with single-cycle implementation by enabling higher throughput at the expense of increased latency per instruction.</data>
      <data key="d8">architectural comparison,design implication</data>
      <data key="d9">chunk-5ea0f23d1c767bafc743ff484eb189e1</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736492</data>
    </edge>
    <edge source="Pipeline Design Principle" target="Instruction Pipeline Stages">
      <data key="d6">1.0</data>
      <data key="d7">Pipeline Design Principle dictates that the number of pipeline stages should match the number of functional stages required by the most complex instruction.</data>
      <data key="d8">design standard,optimization</data>
      <data key="d9">chunk-5ea0f23d1c767bafc743ff484eb189e1</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736490</data>
    </edge>
    <edge source="Pipeline Design Principle" target="Stage Length">
      <data key="d6">1.0</data>
      <data key="d7">The length of each pipeline stage must be set to match the longest individual operation to maintain synchronization.</data>
      <data key="d8">synchronization,timing alignment</data>
      <data key="d9">chunk-5ea0f23d1c767bafc743ff484eb189e1</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736491</data>
    </edge>
    <edge source="Pipeline Design Principle" target="5-Stage Pipeline">
      <data key="d6">1.0</data>
      <data key="d7">The 5-stage pipeline is the practical realization of the pipeline design principle, structured to handle standard instruction sequences.</data>
      <data key="d8">design model,implementation framework</data>
      <data key="d9">chunk-5ea0f23d1c767bafc743ff484eb189e1</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736493</data>
    </edge>
    <edge source="Single Cycle Processor Time" target="Pipeline Processor Time">
      <data key="d6">1.0</data>
      <data key="d7">For a program with N instructions, pipeline processor time (N+4)×200ps is less than single-cycle time N×750ps when N is sufficiently large, demonstrating throughput improvement.</data>
      <data key="d8">execution efficiency,parallelism benefit</data>
      <data key="d9">chunk-5ea0f23d1c767bafc743ff484eb189e1</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736491</data>
    </edge>
    <edge source="Pipeline Processor Time" target="Performance Efficiency">
      <data key="d6">1.0</data>
      <data key="d7">Pipelining increases performance efficiency by enabling multiple instructions to be processed simultaneously, despite no reduction in per-instruction time.</data>
      <data key="d8">execution optimization,throughput improvement</data>
      <data key="d9">chunk-5ea0f23d1c767bafc743ff484eb189e1</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736491</data>
    </edge>
    <edge source="Conditional Test" target="运算器">
      <data key="d6">1.0</data>
      <data key="d7">The运算器performs Conditional Test operations to set status flags (ZF, SF, OF, CF) based on arithmetic and logical results.</data>
      <data key="d8">function execution,status flag management</data>
      <data key="d9">chunk-de401d6e0254effcba3f6fcd81cefe60</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736508</data>
    </edge>
    <edge source="指令流水线" target="时间上的并行技术">
      <data key="d6">1.0</data>
      <data key="d7">The instruction pipeline implements time-based parallelism by dividing instruction execution into sequential stages that operate in parallel.</data>
      <data key="d8">technique implementation,temporal parallelism</data>
      <data key="d9">chunk-48932a772d41e90269193af10a0bbbb3</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736559</data>
    </edge>
    <edge source="指令流水线" target="空间上的并行技术">
      <data key="d6">1.0</data>
      <data key="d7">The instruction pipeline benefits from spatial parallelism when multiple functional units in a superscalar processor execute instructions simultaneously.</data>
      <data key="d8">spatial parallelism,technique implementation</data>
      <data key="d9">chunk-48932a772d41e90269193af10a0bbbb3</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736560</data>
    </edge>
    <edge source="指令流水线" target="取指">
      <data key="d6">1.0</data>
      <data key="d7">The fetch stage is the first phase in the instruction pipeline, responsible for retrieving instructions from memory.</data>
      <data key="d8">instruction flow,pipeline stage</data>
      <data key="d9">chunk-48932a772d41e90269193af10a0bbbb3</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736561</data>
    </edge>
    <edge source="指令流水线" target="译码/读寄存器">
      <data key="d6">1.0</data>
      <data key="d7">The decode/read register stage is the second phase in the instruction pipeline, decoding instructions and reading operands.</data>
      <data key="d8">instruction flow,pipeline stage</data>
      <data key="d9">chunk-48932a772d41e90269193af10a0bbbb3</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736562</data>
    </edge>
    <edge source="指令流水线" target="执行/计算地址">
      <data key="d6">1.0</data>
      <data key="d7">The execute/calculate address stage is the third phase in the instruction pipeline, performing operations or address calculations.</data>
      <data key="d8">instruction flow,pipeline stage</data>
      <data key="d9">chunk-48932a772d41e90269193af10a0bbbb3</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736563</data>
    </edge>
    <edge source="指令流水线" target="访存">
      <data key="d6">1.0</data>
      <data key="d7">The memory access stage is the fourth phase in the instruction pipeline, handling memory reads or writes.</data>
      <data key="d8">instruction flow,pipeline stage</data>
      <data key="d9">chunk-48932a772d41e90269193af10a0bbbb3</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736564</data>
    </edge>
    <edge source="指令流水线" target="写回">
      <data key="d6">1.0</data>
      <data key="d7">The write back stage is the final phase in the instruction pipeline, writing results to the register file.</data>
      <data key="d8">instruction flow,pipeline stage</data>
      <data key="d9">chunk-48932a772d41e90269193af10a0bbbb3</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736564</data>
    </edge>
    <edge source="空间上的并行技术" target="超标量处理机">
      <data key="d6">1.0</data>
      <data key="d7">A superscalar processor uses spatial parallelism to execute multiple instructions in parallel through multiple functional units.</data>
      <data key="d8">parallel execution,processor design</data>
      <data key="d9">chunk-48932a772d41e90269193af10a0bbbb3</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736559</data>
    </edge>
    <edge source="指令集" target="指令长度">
      <data key="d6">1.0</data>
      <data key="d7">The instruction set should have consistent instruction lengths to simplify the fetch and decode stages.</data>
      <data key="d8">design requirement,uniformity</data>
      <data key="d9">chunk-48932a772d41e90269193af10a0bbbb3</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736560</data>
    </edge>
    <edge source="指令集" target="指令格式">
      <data key="d6">1.0</data>
      <data key="d7">The instruction set should have a regular format with consistent source register positions for faster decode.</data>
      <data key="d8">design requirement,regularity</data>
      <data key="d9">chunk-48932a772d41e90269193af10a0bbbb3</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736561</data>
    </edge>
    <edge source="指令集" target="LOAD/STORE型指令">
      <data key="d6">1.0</data>
      <data key="d7">The instruction set should use LOAD/STORE architecture to restrict memory access to specific instructions.</data>
      <data key="d8">design requirement,memory access model</data>
      <data key="d9">chunk-48932a772d41e90269193af10a0bbbb3</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736562</data>
    </edge>
    <edge source="指令集" target="数据和指令在存储器中按边界对齐">
      <data key="d6">1.0</data>
      <data key="d7">The instruction set should support memory alignment to reduce memory access latency and improve pipeline efficiency.</data>
      <data key="d8">design requirement,memory alignment</data>
      <data key="d9">chunk-48932a772d41e90269193af10a0bbbb3</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736563</data>
    </edge>
    <edge source="微指令的地址形成方式" target="后继微地址">
      <data key="d6">1.0</data>
      <data key="d7">The method of microinstruction address formation determines the next microinstruction address to be executed.</data>
      <data key="d8">address determination,microprogram control</data>
      <data key="d9">chunk-7c0597dc102c9fca5be6ec61fc5d051b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736655</data>
    </edge>
    <edge source="微指令的地址形成方式" target="标志">
      <data key="d6">1.0</data>
      <data key="d7">The value of flags determines the next microinstruction address through conditional branching.</data>
      <data key="d8">branching control,conditional execution</data>
      <data key="d9">chunk-7c0597dc102c9fca5be6ec61fc5d051b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736657</data>
    </edge>
    <edge source="微指令的后继地址字段" target="断定方式">
      <data key="d6">1.0</data>
      <data key="d7">The successor address field is used in the determined method to directly specify the next microinstruction address.</data>
      <data key="d8">direct addressing,encoding method</data>
      <data key="d9">chunk-7c0597dc102c9fca5be6ec61fc5d051b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736655</data>
    </edge>
    <edge source="硬件直接产生微程序入口地址" target="电源加电后">
      <data key="d6">1.0</data>
      <data key="d7">Upon power-up, hardware initializes the microprogram entry address and loads it into μPC.</data>
      <data key="d8">power-on sequence,system initialization</data>
      <data key="d9">chunk-7c0597dc102c9fca5be6ec61fc5d051b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736655</data>
    </edge>
    <edge source="微指令的格式" target="水平型微指令">
      <data key="d6">1.0</data>
      <data key="d7">Horizontal microinstruction format uses direct bit-level control signal assignment.</data>
      <data key="d8">control signal assignment,instruction encoding</data>
      <data key="d9">chunk-7c0597dc102c9fca5be6ec61fc5d051b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736655</data>
    </edge>
    <edge source="微指令的格式" target="垂直型微指令">
      <data key="d6">1.0</data>
      <data key="d7">Vertical microinstruction format uses operation code-like encoding to minimize instruction width.</data>
      <data key="d8">compact control,instruction encoding</data>
      <data key="d9">chunk-7c0597dc102c9fca5be6ec61fc5d051b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736657</data>
    </edge>
    <edge source="水平型微指令" target="直接编码">
      <data key="d6">1.0</data>
      <data key="d7">Direct encoding is a type of horizontal microinstruction encoding where each bit corresponds to one control signal.</data>
      <data key="d8">encoding style,parallel controls</data>
      <data key="d9">chunk-7c0597dc102c9fca5be6ec61fc5d051b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736657</data>
    </edge>
    <edge source="水平型微指令" target="字段直接编码">
      <data key="d6">1.0</data>
      <data key="d7">Field direct encoding is a horizontal microinstruction method that groups signals into subfields.</data>
      <data key="d8">encoding style,group control signaling</data>
      <data key="d9">chunk-7c0597dc102c9fca5be6ec61fc5d051b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736660</data>
    </edge>
    <edge source="水平型微指令" target="字段间接编码">
      <data key="d6">1.0</data>
      <data key="d7">Field indirect encoding is a horizontal microinstruction method that uses a selector to define control signal patterns.</data>
      <data key="d8">encoding style,indirect control selection</data>
      <data key="d9">chunk-7c0597dc102c9fca5be6ec61fc5d051b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736660</data>
    </edge>
    <edge source="Interrupt Request Signal Line" target="Interrupt Controller">
      <data key="d6">1.0</data>
      <data key="d7">The interrupt controller oversees interrupt request signals and prioritizes or masks them.</data>
      <data key="d8">management,signal handling</data>
      <data key="d9">chunk-56dad084d2f83de29d62a2ae33cfc843</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736662</data>
    </edge>
    <edge source="Maskable Interrupt" target="INTR">
      <data key="d6">1.0</data>
      <data key="d7">The maskable interrupt is transmitted via the INTR signal line and can be controlled by the interrupt controller.</data>
      <data key="d8">hardware interface,signal line</data>
      <data key="d9">chunk-56dad084d2f83de29d62a2ae33cfc843</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736659</data>
    </edge>
    <edge source="Maskable Interrupt" target="Interrupt Controller">
      <data key="d6">1.0</data>
      <data key="d7">The interrupt controller manages maskable interrupts by allowing masking via a mask setting.</data>
      <data key="d8">control mechanism,interrupt management</data>
      <data key="d9">chunk-56dad084d2f83de29d62a2ae33cfc843</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736661</data>
    </edge>
    <edge source="Non-Maskable Interrupt" target="NMI">
      <data key="d6">1.0</data>
      <data key="d7">The non-maskable interrupt is transmitted via the NMI signal line and cannot be disabled.</data>
      <data key="d8">hardware interface,signal line</data>
      <data key="d9">chunk-56dad084d2f83de29d62a2ae33cfc843</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736659</data>
    </edge>
    <edge source="Non-Maskable Interrupt" target="Hardware Fault">
      <data key="d6">1.0</data>
      <data key="d7">Hardware faults such as power loss trigger non-maskable interrupts.</data>
      <data key="d8">cause,trigger</data>
      <data key="d9">chunk-56dad084d2f83de29d62a2ae33cfc843</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736661</data>
    </edge>
    <edge source="Vector Interrupt" target="Non-Vector Interrupt">
      <data key="d6">1.0</data>
      <data key="d7">Vector and non-vector interrupts differ in how the interrupt service routine address is identified.</data>
      <data key="d8">classification type,interrupt handling</data>
      <data key="d9">chunk-56dad084d2f83de29d62a2ae33cfc843</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736661</data>
    </edge>
    <edge source="Single Interrupt" target="Multiple Interrupt">
      <data key="d6">1.0</data>
      <data key="d7">Single and multiple interrupts represent two modes of interrupt processing based on reentrancy.</data>
      <data key="d8">classification type,interrupt handling</data>
      <data key="d9">chunk-56dad084d2f83de29d62a2ae33cfc843</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736661</data>
    </edge>
    <edge source="Hardware Multithreading" target="Thread Switching">
      <data key="d6">1.0</data>
      <data key="d7">Hardware multithreading reduces the overhead associated with thread switching by avoiding memory data exchange.</data>
      <data key="d8">overhead reduction,performance optimization</data>
      <data key="d9">chunk-f67ff7c347b613bc05733f64a51c9c17</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736743</data>
    </edge>
    <edge source="Hardware Multithreading" target="Simultaneous Multithreading">
      <data key="d6">1.0</data>
      <data key="d7">Simultaneous multithreading represents an advanced evolution of hardware multithreading techniques.</data>
      <data key="d8">advanced implementation,technological evolution</data>
      <data key="d9">chunk-f67ff7c347b613bc05733f64a51c9c17</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736745</data>
    </edge>
    <edge source="Fine-Grained Multithreading" target="Coarse-Grained Multithreading">
      <data key="d6">1.0</data>
      <data key="d7">Fine-grained and coarse-grained multithreading differ in their thread switching frequency and dependency on pipeline state.</data>
      <data key="d8">execution strategy,method comparison</data>
      <data key="d9">chunk-f67ff7c347b613bc05733f64a51c9c17</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736744</data>
    </edge>
    <edge source="Simultaneous Multithreading" target="Intel Hyper-Threading">
      <data key="d6">1.0</data>
      <data key="d7">Intel Hyper-Threading is a specific implementation of simultaneous multithreading technology.</data>
      <data key="d8">implementation,technology variant</data>
      <data key="d9">chunk-f67ff7c347b613bc05733f64a51c9c17</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736744</data>
    </edge>
    <edge source="Intel Hyper-Threading" target="High-Speed Cache">
      <data key="d6">1.0</data>
      <data key="d7">Intel Hyper-Threading shares high-speed cache between logical threads to improve data access efficiency.</data>
      <data key="d8">performance optimization,resource sharing</data>
      <data key="d9">chunk-f67ff7c347b613bc05733f64a51c9c17</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736745</data>
    </edge>
    <edge source="Instruction Execution Cycle" target="Execution Step">
      <data key="d6">1.0</data>
      <data key="d7">The instruction execution cycle is broken down into several execution steps that collectively complete one instruction.</data>
      <data key="d8">instruction lifecycle,processing stages</data>
      <data key="d9">chunk-3c7856616d478c58fdce251c9a2b68ac</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736782</data>
    </edge>
    <edge source="Multi Cycle Processor" target="Instruction Serial Execution">
      <data key="d6">1.0</data>
      <data key="d7">The multi cycle processor uses serial execution and assigns varying clock cycles per instruction based on complexity.</data>
      <data key="d8">execution model,timing flexibility</data>
      <data key="d9">chunk-3c7856616d478c58fdce251c9a2b68ac</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736782</data>
    </edge>
    <edge source="Pipeline Processor" target="Instruction Parallel Execution">
      <data key="d6">1.0</data>
      <data key="d7">The pipeline processor enables parallel instruction execution, allowing multiple instructions to be processed at different stages simultaneously.</data>
      <data key="d8">execution model,performance optimization</data>
      <data key="d9">chunk-3c7856616d478c58fdce251c9a2b68ac</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736782</data>
    </edge>
    <edge source="Single Bus Data Path" target="Bus">
      <data key="d6">1.0</data>
      <data key="d7">The single bus data path utilizes a shared bus to enable data flow between components, with the bus serving as the central transmission medium.</data>
      <data key="d8">architecture,signal transmission</data>
      <data key="d9">chunk-0efa36a872f0b1511a047f0591cba52c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736810</data>
    </edge>
    <edge source="Temporary Register Y" target="Control Signal Yin">
      <data key="d6">1.0</data>
      <data key="d7">Control signal Yin activates temporary register Y to load an operand from the bus.</data>
      <data key="d8">control activation,operand loading</data>
      <data key="d9">chunk-0efa36a872f0b1511a047f0591cba52c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736812</data>
    </edge>
    <edge source="Temporary Register Z" target="Control Signal Zout">
      <data key="d6">1.0</data>
      <data key="d7">Control signal Zout activates temporary register Z to output its result to the bus.</data>
      <data key="d8">control activation,result output</data>
      <data key="d9">chunk-0efa36a872f0b1511a047f0591cba52c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736812</data>
    </edge>
    <edge source="Read Operation" target="Memory Cycle">
      <data key="d6">1.0</data>
      <data key="d7">The read operation requires one memory cycle to complete a data retrieval from main memory.</data>
      <data key="d8">memory access,timing</data>
      <data key="d9">chunk-0efa36a872f0b1511a047f0591cba52c</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736813</data>
    </edge>
    <edge source="Shared Memory Multiprocessor" target="Unified Memory Access">
      <data key="d6">1.0</data>
      <data key="d7">Unified Memory Access is a type of shared memory multiprocessor system.</data>
      <data key="d8">architectural variant,system type</data>
      <data key="d9">chunk-514f22df13c84be41bf310afe9ba497b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736823</data>
    </edge>
    <edge source="Shared Memory Multiprocessor" target="Non-Uniform Memory Access">
      <data key="d6">1.0</data>
      <data key="d7">Non-Uniform Memory Access is a type of shared memory multiprocessor system.</data>
      <data key="d8">architectural variant,system type</data>
      <data key="d9">chunk-514f22df13c84be41bf310afe9ba497b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736824</data>
    </edge>
    <edge source="Unified Memory Access" target="Northbridge Chip">
      <data key="d6">1.0</data>
      <data key="d7">UMA architecture traditionally used a northbridge chip with integrated memory controller and front-side bus.</data>
      <data key="d8">hardware architecture,historical implementation</data>
      <data key="d9">chunk-514f22df13c84be41bf310afe9ba497b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736824</data>
    </edge>
    <edge source="Unified Memory Access" target="Front-Side Bus">
      <data key="d6">1.0</data>
      <data key="d7">High CPU utilization led to contention on the front-side bus, creating a performance bottleneck in UMA systems.</data>
      <data key="d8">performance limitation,system bottleneck</data>
      <data key="d9">chunk-514f22df13c84be41bf310afe9ba497b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736825</data>
    </edge>
    <edge source="Non-Uniform Memory Access" target="Memory Controller">
      <data key="d6">1.0</data>
      <data key="d7">NUMA architecture improved performance by integrating memory controllers into each CPU, reducing reliance on the front-side bus.</data>
      <data key="d8">architectural improvement,hardware innovation</data>
      <data key="d9">chunk-514f22df13c84be41bf310afe9ba497b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736824</data>
    </edge>
    <edge source="Non-Uniform Memory Access" target="QPI Bus">
      <data key="d6">1.0</data>
      <data key="d7">NUMA systems use the QPI bus to enable CPUs to access remote memory from other CPUs.</data>
      <data key="d8">communication path,interconnection technology</data>
      <data key="d9">chunk-514f22df13c84be41bf310afe9ba497b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736825</data>
    </edge>
    <edge source="Non-Uniform Memory Access" target="Local Memory">
      <data key="d6">1.0</data>
      <data key="d7">In NUMA systems, each CPU has direct access to its own local memory, resulting in faster access times.</data>
      <data key="d8">access optimization,memory organization</data>
      <data key="d9">chunk-514f22df13c84be41bf310afe9ba497b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736825</data>
    </edge>
    <edge source="Non-Uniform Memory Access" target="Remote Memory">
      <data key="d6">1.0</data>
      <data key="d7">In NUMA systems, memory not directly connected to a CPU is considered remote and access is slower.</data>
      <data key="d8">access performance,memory organization</data>
      <data key="d9">chunk-514f22df13c84be41bf310afe9ba497b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736825</data>
    </edge>
    <edge source="Northbridge Chip" target="Front-Side Bus">
      <data key="d6">1.0</data>
      <data key="d7">The front-side bus connects the CPU to the northbridge chip for memory access.</data>
      <data key="d8">data path,system interconnect</data>
      <data key="d9">chunk-514f22df13c84be41bf310afe9ba497b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736824</data>
    </edge>
    <edge source="Shared Variable" target="Lock Mechanism">
      <data key="d6">1.0</data>
      <data key="d7">A lock mechanism is used to control exclusive access to a shared variable, preventing race conditions.</data>
      <data key="d8">access control,synchronization method</data>
      <data key="d9">chunk-514f22df13c84be41bf310afe9ba497b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736824</data>
    </edge>
    <edge source="Processor Synchronization" target="Race Condition">
      <data key="d6">1.0</data>
      <data key="d7">Processor synchronization is required to prevent race conditions during shared variable access.</data>
      <data key="d8">coordination necessity,risk</data>
      <data key="d9">chunk-514f22df13c84be41bf310afe9ba497b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761736824</data>
    </edge>
  </graph>
</graphml>
