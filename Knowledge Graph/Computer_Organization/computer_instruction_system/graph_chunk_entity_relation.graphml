<?xml version='1.0' encoding='utf-8'?>
<graphml xmlns="http://graphml.graphdrawing.org/xmlns" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://graphml.graphdrawing.org/xmlns http://graphml.graphdrawing.org/xmlns/1.0/graphml.xsd">
  <key id="d11" for="edge" attr.name="created_at" attr.type="long" />
  <key id="d10" for="edge" attr.name="file_path" attr.type="string" />
  <key id="d9" for="edge" attr.name="source_id" attr.type="string" />
  <key id="d8" for="edge" attr.name="keywords" attr.type="string" />
  <key id="d7" for="edge" attr.name="description" attr.type="string" />
  <key id="d6" for="edge" attr.name="weight" attr.type="double" />
  <key id="d5" for="node" attr.name="created_at" attr.type="long" />
  <key id="d4" for="node" attr.name="file_path" attr.type="string" />
  <key id="d3" for="node" attr.name="source_id" attr.type="string" />
  <key id="d2" for="node" attr.name="description" attr.type="string" />
  <key id="d1" for="node" attr.name="entity_type" attr.type="string" />
  <key id="d0" for="node" attr.name="entity_id" attr.type="string" />
  <graph edgedefault="undirected">
    <node id="Complex Instruction Set Computer">
      <data key="d0">Complex Instruction Set Computer</data>
      <data key="d1">concept</data>
      <data key="d2">Complex Instruction Set Computer (CISC) is a computer architecture that features a large and complex instruction set, with instructions designed to perform multiple low-level operations in a single instruction.</data>
      <data key="d3">chunk-3da8377b70a3bce3bffec6cc41a145bb</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469042</data>
    </node>
    <node id="Integrated Circuit Technology">
      <data key="d0">Integrated Circuit Technology</data>
      <data key="d1">method</data>
      <data key="d2">Integrated Circuit Technology refers to the advancement of semiconductor fabrication processes enabling higher levels of integration and performance in electronic systems.</data>
      <data key="d3">chunk-3da8377b70a3bce3bffec6cc41a145bb</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469042</data>
    </node>
    <node id="Software Cost">
      <data key="d0">Software Cost</data>
      <data key="d1">concept</data>
      <data key="d2">Software Cost represents the increasing expenses associated with developing and maintaining software, which influenced the evolution of instruction set design.</data>
      <data key="d3">chunk-3da8377b70a3bce3bffec6cc41a145bb</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469042</data>
    </node>
    <node id="Instruction System">
      <data key="d0">Instruction System</data>
      <data key="d1">concept</data>
      <data key="d2">Instruction System refers to the set of commands that a processor can execute, including complexity, format, and access rules.&lt;SEP&gt;The instruction system refers to the complete set of instructions available in a given computer, also known as the instruction set, forming the core part of the Instruction Set Architecture.</data>
      <data key="d3">chunk-3da8377b70a3bce3bffec6cc41a145bb&lt;SEP&gt;chunk-986821269f2aa2025221040c595a72be</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469494</data>
    </node>
    <node id="CISC Characteristics">
      <data key="d0">CISC Characteristics</data>
      <data key="d1">concept</data>
      <data key="d2">CISC Characteristics include a large number of instructions, variable instruction length, multiple addressing modes, unrestricted memory access, uneven instruction usage, and lengthy execution times.</data>
      <data key="d3">chunk-3da8377b70a3bce3bffec6cc41a145bb</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469042</data>
    </node>
    <node id="Microprogram Control">
      <data key="d0">Microprogram Control</data>
      <data key="d1">method</data>
      <data key="d2">Microprogram Control is a technique used in CISC processors where instruction execution is implemented through a sequence of microinstructions stored in control memory.&lt;SEP&gt;Microprogram control is a technique used in CISC architectures to implement instruction decoding and execution using a control memory.</data>
      <data key="d3">chunk-3da8377b70a3bce3bffec6cc41a145bb&lt;SEP&gt;chunk-2151538dd57e60dbb6761c6a35ea00c6</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761470014</data>
    </node>
    <node id="Hardwired Control">
      <data key="d0">Hardwired Control</data>
      <data key="d1">concept</data>
      <data key="d2">Hardwired Control is a method of implementing a processor's control logic using dedicated hardware circuits, typically used in simpler or faster control units.&lt;SEP&gt;Hardwired control refers to the method of controlling instruction execution using direct hardware logic instead of microcode.</data>
      <data key="d3">chunk-3da8377b70a3bce3bffec6cc41a145bb&lt;SEP&gt;chunk-d12ab3ee72f1f1a8f72c7e3dece14062</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469401</data>
    </node>
    <node id="RISC">
      <data key="d0">RISC</data>
      <data key="d1">concept</data>
      <data key="d2">RISC (Reduced Instruction Set Computer) is a computer architecture that emphasizes a smaller, simpler, and more efficient instruction set, designed to improve performance.&lt;SEP&gt;RISC stands for Reduced Instruction Set Computer, a design philosophy that emphasizes simplicity and efficiency in instruction set architecture.&lt;SEP&gt;RISC (Reduced Instruction Set Computing) is a processor design architecture emphasizing simplicity, speed, and efficiency through fewer instructions and direct hardware implementation.</data>
      <data key="d3">chunk-3da8377b70a3bce3bffec6cc41a145bb&lt;SEP&gt;chunk-2151538dd57e60dbb6761c6a35ea00c6&lt;SEP&gt;chunk-d12ab3ee72f1f1a8f72c7e3dece14062</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761470014</data>
    </node>
    <node id="20% Simple Instructions">
      <data key="d0">20% Simple Instructions</data>
      <data key="d1">concept</data>
      <data key="d2">20% Simple Instructions refers to the subset of frequently used, basic instructions in programs that account for a large portion of execution time.</data>
      <data key="d3">chunk-3da8377b70a3bce3bffec6cc41a145bb</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469044</data>
    </node>
    <node id="80% Complex Instructions">
      <data key="d0">80% Complex Instructions</data>
      <data key="d1">concept</data>
      <data key="d2">80% Complex Instructions refers to the less frequently used, complicated instructions that constitute the majority of the instruction set but are rarely executed.</data>
      <data key="d3">chunk-3da8377b70a3bce3bffec6cc41a145bb</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469044</data>
    </node>
    <node id="Optimization Compiler">
      <data key="d0">Optimization Compiler</data>
      <data key="d1">method</data>
      <data key="d2">Optimization Compiler is a software tool designed to generate efficient machine code from high-level source code, which faces challenges in CISC architectures due to instruction complexity.</data>
      <data key="d3">chunk-3da8377b70a3bce3bffec6cc41a145bb</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469044</data>
    </node>
    <node id="Instruction Design">
      <data key="d0">Instruction Design</data>
      <data key="d1">method</data>
      <data key="d2">Instruction Design involves creating and structuring processor instructions to balance functionality, efficiency, and performance.</data>
      <data key="d3">chunk-3da8377b70a3bce3bffec6cc41a145bb</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469044</data>
    </node>
    <node id="Research and Development Cycle">
      <data key="d0">Research and Development Cycle</data>
      <data key="d1">concept</data>
      <data key="d2">Research and Development Cycle refers to the lengthy process required to design and implement new instruction sets and processors.</data>
      <data key="d3">chunk-3da8377b70a3bce3bffec6cc41a145bb</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469044</data>
    </node>
    <node id="Do-While Loop">
      <data key="d0">Do-While Loop</data>
      <data key="d1">loop</data>
      <data key="d2">The do-while loop is a control flow statement that executes a block of code at least once, then repeatedly executes the block while a specified condition is true.</data>
      <data key="d3">chunk-28e3e7abf13d472ede4c7ccd1eed0db7</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469068</data>
    </node>
    <node id="While Loop">
      <data key="d0">While Loop</data>
      <data key="d1">loop</data>
      <data key="d2">The while loop is a control flow statement that executes a block of code as long as a specified condition remains true, but it may not execute the loop body at all if the condition is initially false.</data>
      <data key="d3">chunk-28e3e7abf13d472ede4c7ccd1eed0db7</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469068</data>
    </node>
    <node id="For Loop">
      <data key="d0">For Loop</data>
      <data key="d1">loop</data>
      <data key="d2">The for loop is a control flow statement that allows code to be executed repeatedly based on a given Boolean condition, typically used with counter variables.</data>
      <data key="d3">chunk-28e3e7abf13d472ede4c7ccd1eed0db7</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469068</data>
    </node>
    <node id="Conditional Transfer Instruction">
      <data key="d0">Conditional Transfer Instruction</data>
      <data key="d1">method</data>
      <data key="d2">A conditional transfer instruction is a machine-level instruction used to change program execution flow based on a condition's evaluation.</data>
      <data key="d3">chunk-28e3e7abf13d472ede4c7ccd1eed0db7</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469068</data>
    </node>
    <node id="Machine-Level Representation">
      <data key="d0">Machine-Level Representation</data>
      <data key="d1">concept</data>
      <data key="d2">Machine-level representation refers to how high-level programming constructs, such as loops, are translated into low-level assembly code for execution by the processor.</data>
      <data key="d3">chunk-28e3e7abf13d472ede4c7ccd1eed0db7</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469068</data>
    </node>
    <node id="GCC">
      <data key="d0">GCC</data>
      <data key="d1">organization</data>
      <data key="d2">GCC is a compiler that translates high-level source code into machine code, commonly used in systems programming.</data>
      <data key="d3">chunk-28e3e7abf13d472ede4c7ccd1eed0db7</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469068</data>
    </node>
    <node id="Loop Body Statement">
      <data key="d0">Loop Body Statement</data>
      <data key="d1">content</data>
      <data key="d2">The loop body statement refers to the sequence of instructions executed within a loop structure during each iteration.</data>
      <data key="d3">chunk-28e3e7abf13d472ede4c7ccd1eed0db7</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469068</data>
    </node>
    <node id="Test Expression">
      <data key="d0">Test Expression</data>
      <data key="d1">expression</data>
      <data key="d2">The test expression is a condition evaluated to determine whether a loop should continue or terminate.</data>
      <data key="d3">chunk-28e3e7abf13d472ede4c7ccd1eed0db7</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469068</data>
    </node>
    <node id="Init Expression">
      <data key="d0">Init Expression</data>
      <data key="d1">expression</data>
      <data key="d2">The init expression is executed once before the loop starts, typically used to initialize control variables.</data>
      <data key="d3">chunk-28e3e7abf13d472ede4c7ccd1eed0db7</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469069</data>
    </node>
    <node id="Update Expression">
      <data key="d0">Update Expression</data>
      <data key="d1">expression</data>
      <data key="d2">The update expression is executed after each iteration of the loop body, typically used to modify the control variable.</data>
      <data key="d3">chunk-28e3e7abf13d472ede4c7ccd1eed0db7</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469069</data>
    </node>
    <node id="Goto Statement">
      <data key="d0">Goto Statement</data>
      <data key="d1">method</data>
      <data key="d2">The goto statement is an unstructured control transfer instruction in assembly language that transfers program execution to a labeled statement.&lt;SEP&gt;The goto statement transfers control to a labeled statement in the program, often used to represent procedural control flow.</data>
      <data key="d3">chunk-28e3e7abf13d472ede4c7ccd1eed0db7&lt;SEP&gt;chunk-26a06731e273a94d7270550437bc874a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469286</data>
    </node>
    <node id="Call Instruction">
      <data key="d0">Call Instruction</data>
      <data key="d1">method</data>
      <data key="d2">The call instruction is an unconditional transfer instruction used to initiate a procedure call by transferring control to a called procedure.</data>
      <data key="d3">chunk-af4c47630b7183e33e016913942c0781</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469149</data>
    </node>
    <node id="Ret Instruction">
      <data key="d0">Ret Instruction</data>
      <data key="d1">method</data>
      <data key="d2">The ret instruction is used to return control from a called procedure back to the calling procedure by retrieving the return address.</data>
      <data key="d3">chunk-af4c47630b7183e33e016913942c0781</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469149</data>
    </node>
    <node id="Process P">
      <data key="d0">Process P</data>
      <data key="d1">concept</data>
      <data key="d2">Process P refers to the calling procedure that invokes another procedure Q, passing parameters and expecting a return.</data>
      <data key="d3">chunk-af4c47630b7183e33e016913942c0781</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469149</data>
    </node>
    <node id="Process Q">
      <data key="d0">Process Q</data>
      <data key="d1">concept</data>
      <data key="d2">Process Q refers to the called procedure that executes upon being invoked by Process P and returns control after completion.</data>
      <data key="d3">chunk-af4c47630b7183e33e016913942c0781</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469149</data>
    </node>
    <node id="Entry Parameter">
      <data key="d0">Entry Parameter</data>
      <data key="d1">data</data>
      <data key="d2">Entry parameters, or actual arguments, are values passed from the calling procedure to the called procedure for use in execution.</data>
      <data key="d3">chunk-af4c47630b7183e33e016913942c0781</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469149</data>
    </node>
    <node id="Return Address">
      <data key="d0">Return Address</data>
      <data key="d1">data</data>
      <data key="d2">The return address is the memory location to which control must be transferred after the called procedure completes execution.&lt;SEP&gt;The return address is the memory address of the instruction immediately following a call instruction, which is stored on the stack for later retrieval during a return.</data>
      <data key="d3">chunk-dc66410ab81cdb2a13f279e50457a470&lt;SEP&gt;chunk-af4c47630b7183e33e016913942c0781</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469782</data>
    </node>
    <node id="Procedure P's Context">
      <data key="d0">Procedure P's Context</data>
      <data key="d1">data</data>
      <data key="d2">The procedure P's context refers to the state of P's general-purpose registers that must be preserved during a procedure call.</data>
      <data key="d3">chunk-af4c47630b7183e33e016913942c0781</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469149</data>
    </node>
    <node id="Procedure Q's Local Variables">
      <data key="d0">Procedure Q's Local Variables</data>
      <data key="d1">data</data>
      <data key="d2">Procedure Q's local variables are storage locations allocated within the stack frame for use during execution.</data>
      <data key="d3">chunk-af4c47630b7183e33e016913942c0781</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469149</data>
    </node>
    <node id="Return Result">
      <data key="d0">Return Result</data>
      <data key="d1">data</data>
      <data key="d2">The return result is the output generated by the called procedure, made accessible to the calling procedure after execution.</data>
      <data key="d3">chunk-af4c47630b7183e33e016913942c0781</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469151</data>
    </node>
    <node id="EAX Register">
      <data key="d0">EAX Register</data>
      <data key="d1">artifact</data>
      <data key="d2">The EAX register is a general-purpose register classified as a caller-saved register, meaning the calling procedure must preserve its value if needed after a call.</data>
      <data key="d3">chunk-af4c47630b7183e33e016913942c0781</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469151</data>
    </node>
    <node id="ECX Register">
      <data key="d0">ECX Register</data>
      <data key="d1">artifact</data>
      <data key="d2">The ECX register is a general-purpose register classified as a caller-saved register, requiring the calling procedure to save and restore its value upon return.</data>
      <data key="d3">chunk-af4c47630b7183e33e016913942c0781</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469151</data>
    </node>
    <node id="EDX Register">
      <data key="d0">EDX Register</data>
      <data key="d1">artifact</data>
      <data key="d2">The EDX register is a general-purpose register classified as a caller-saved register, where the calling procedure must save and restore its value after a call.</data>
      <data key="d3">chunk-af4c47630b7183e33e016913942c0781</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469151</data>
    </node>
    <node id="EBX Register">
      <data key="d0">EBX Register</data>
      <data key="d1">artifact</data>
      <data key="d2">The EBX register is a general-purpose register classified as a callee-saved register, requiring the called procedure to preserve and restore its value.</data>
      <data key="d3">chunk-af4c47630b7183e33e016913942c0781</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469151</data>
    </node>
    <node id="ESI Register">
      <data key="d0">ESI Register</data>
      <data key="d1">artifact</data>
      <data key="d2">The ESI register is a general-purpose register classified as a callee-saved register, requiring the called procedure to preserve and restore its value.</data>
      <data key="d3">chunk-af4c47630b7183e33e016913942c0781</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469151</data>
    </node>
    <node id="EDI Register">
      <data key="d0">EDI Register</data>
      <data key="d1">artifact</data>
      <data key="d2">The EDI register is a general-purpose register classified as a callee-saved register, requiring the called procedure to preserve and restore its value.</data>
      <data key="d3">chunk-af4c47630b7183e33e016913942c0781</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469151</data>
    </node>
    <node id="Stack Frame">
      <data key="d0">Stack Frame</data>
      <data key="d1">concept</data>
      <data key="d2">A stack frame is the memory region allocated for a single procedure call, containing local variables, saved registers, and return information.</data>
      <data key="d3">chunk-af4c47630b7183e33e016913942c0781</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469151</data>
    </node>
    <node id="EBP Register">
      <data key="d0">EBP Register</data>
      <data key="d1">artifact</data>
      <data key="d2">The EBP register points to the base of the current stack frame and remains fixed during procedure execution.</data>
      <data key="d3">chunk-af4c47630b7183e33e016913942c0781</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469152</data>
    </node>
    <node id="ESP Register">
      <data key="d0">ESP Register</data>
      <data key="d1">artifact</data>
      <data key="d2">The ESP register points to the top of the stack and dynamically changes as data is pushed or popped.</data>
      <data key="d3">chunk-af4c47630b7183e33e016913942c0781</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469152</data>
    </node>
    <node id="Stack">
      <data key="d0">Stack</data>
      <data key="d1">artifact</data>
      <data key="d2">The stack is a region of memory that grows from higher addresses to lower addresses, composed of multiple stack frames.&lt;SEP&gt;The stack is a region of memory used for temporary data storage, especially during function calls and interrupt handling, growing downward in memory.</data>
      <data key="d3">chunk-af4c47630b7183e33e016913942c0781&lt;SEP&gt;chunk-803e04b7ef409476eff2adc07fef14d1</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469376</data>
    </node>
    <node id="Instruction">
      <data key="d0">Instruction</data>
      <data key="d1">artifact</data>
      <data key="d2">An instruction is a single machine language statement consisting of a meaningful sequence of binary code, typically comprising an operation code and address code fields.&lt;SEP&gt;An instruction is a command issued to a computer to perform a specific operation, forming the fundamental unit of machine-level programming.</data>
      <data key="d3">chunk-823091106aa14acd3f766029738eb588&lt;SEP&gt;chunk-986821269f2aa2025221040c595a72be</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469494</data>
    </node>
    <node id="Operation Code">
      <data key="d0">Operation Code</data>
      <data key="d1">concept</data>
      <data key="d2">The operation code specifies the operation to be performed by the instruction, such as arithmetic addition, subtraction, branching, or returning to a previous state, and determines the function and behavior of the instruction.</data>
      <data key="d3">chunk-823091106aa14acd3f766029738eb588</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469217</data>
    </node>
    <node id="Address Code">
      <data key="d0">Address Code</data>
      <data key="d1">concept</data>
      <data key="d2">The address code provides the address of the operand or data involved in the operation, including source and destination addresses for operands, result storage, program transfer targets, or subroutine entry points.</data>
      <data key="d3">chunk-823091106aa14acd3f766029738eb588</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469217</data>
    </node>
    <node id="Instruction Word Length">
      <data key="d0">Instruction Word Length</data>
      <data key="d1">concept</data>
      <data key="d2">The instruction word length is the total number of bits in a binary instruction, determined by the length of the operation code, address code, and the number of address fields.</data>
      <data key="d3">chunk-823091106aa14acd3f766029738eb588</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469217</data>
    </node>
    <node id="Machine Word Length">
      <data key="d0">Machine Word Length</data>
      <data key="d1">concept</data>
      <data key="d2">The machine word length is the number of bits processed by the processor in a single operation; the instruction word length may be equal to, greater than, or less than this value.</data>
      <data key="d3">chunk-823091106aa14acd3f766029738eb588</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469217</data>
    </node>
    <node id="Single-Word Length Instruction">
      <data key="d0">Single-Word Length Instruction</data>
      <data key="d1">concept</data>
      <data key="d2">A single-word length instruction is one whose length matches the machine word length, requiring only one memory access to fetch the entire instruction.</data>
      <data key="d3">chunk-823091106aa14acd3f766029738eb588</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469217</data>
    </node>
    <node id="Half-Word Length Instruction">
      <data key="d0">Half-Word Length Instruction</data>
      <data key="d1">concept</data>
      <data key="d2">A half-word length instruction is one whose length is half the machine word length, requiring one memory access with a smaller than full-word fetch.</data>
      <data key="d3">chunk-823091106aa14acd3f766029738eb588</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469217</data>
    </node>
    <node id="Double-Word Length Instruction">
      <data key="d0">Double-Word Length Instruction</data>
      <data key="d1">concept</data>
      <data key="d2">A double-word length instruction is one whose length is twice the machine word length, requiring two memory accesses to fetch, thus taking two memory cycles.</data>
      <data key="d3">chunk-823091106aa14acd3f766029738eb588</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469217</data>
    </node>
    <node id="Fixed-Length Instruction Structure">
      <data key="d0">Fixed-Length Instruction Structure</data>
      <data key="d1">concept</data>
      <data key="d2">A fixed-length instruction structure is an instruction set architecture where all instructions have the same length, allowing faster execution and simpler control logic.</data>
      <data key="d3">chunk-823091106aa14acd3f766029738eb588</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469218</data>
    </node>
    <node id="Variable-Length Instruction Structure">
      <data key="d0">Variable-Length Instruction Structure</data>
      <data key="d1">concept</data>
      <data key="d2">A variable-length instruction structure is an instruction set where instruction lengths vary based on functionality, often resulting in more complex decoding and control mechanisms.</data>
      <data key="d3">chunk-823091106aa14acd3f766029738eb588</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469218</data>
    </node>
    <node id="Zero-Address Instruction">
      <data key="d0">Zero-Address Instruction</data>
      <data key="d1">concept</data>
      <data key="d2">A zero-address instruction contains only an operation code and no explicit address fields, used in stack-based architectures where operands are implicitly taken from the top and second top of the stack.</data>
      <data key="d3">chunk-823091106aa14acd3f766029738eb588</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469218</data>
    </node>
    <node id="One-Address Instruction">
      <data key="d0">One-Address Instruction</data>
      <data key="d1">concept</data>
      <data key="d2">A one-address instruction uses a single address field, either for a single operand (with result stored back at the same address) or with another operand implicitly provided by a register such as the accumulator.</data>
      <data key="d3">chunk-823091106aa14acd3f766029738eb588</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469218</data>
    </node>
    <node id="Two-Address Instruction">
      <data key="d0">Two-Address Instruction</data>
      <data key="d1">concept</data>
      <data key="d2">A two-address instruction explicitly specifies two address fields: one for a source operand and one for the destination operand, which also stores the result of the operation.</data>
      <data key="d3">chunk-823091106aa14acd3f766029738eb588</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469218</data>
    </node>
    <node id="Three-Address Instruction">
      <data key="d0">Three-Address Instruction</data>
      <data key="d1">concept</data>
      <data key="d2">A three-address instruction specifies three operand addresses: two for source operands and one for the destination where the result is stored, following the format (A1) OP (A2) â†’ A3.</data>
      <data key="d3">chunk-823091106aa14acd3f766029738eb588</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469218</data>
    </node>
    <node id="Four-Address Instruction">
      <data key="d0">Four-Address Instruction</data>
      <data key="d1">concept</data>
      <data key="d2">A four-address instruction specifies four address fields: two source operands, one destination, and one for the next instruction address, enabling direct control of program flow.</data>
      <data key="d3">chunk-823091106aa14acd3f766029738eb588</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469218</data>
    </node>
    <node id="Memory Access">
      <data key="d0">Memory Access</data>
      <data key="d1">concept</data>
      <data key="d2">Memory access refers to the process of reading or writing data to/from main memory; the number of accesses required varies by instruction length and operand count.&lt;SEP&gt;Memory access refers to the process of reading from or writing to main memory during instruction execution, a key factor in determining performance across different addressing modes.</data>
      <data key="d3">chunk-823091106aa14acd3f766029738eb588&lt;SEP&gt;chunk-ee7b048d8f7d4f6a7cdb8bd206b3d9c3</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469931</data>
    </node>
    <node id="Stack Computer">
      <data key="d0">Stack Computer</data>
      <data key="d1">concept</data>
      <data key="d2">A stack computer is a type of processor architecture that performs operations using a stack, where operands are implicitly taken from the stack and results are pushed back.</data>
      <data key="d3">chunk-823091106aa14acd3f766029738eb588</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469219</data>
    </node>
    <node id="Accumulator">
      <data key="d0">Accumulator</data>
      <data key="d1">artifact</data>
      <data key="d2">The accumulator is a register inside the processor used to hold intermediate results of arithmetic and logic operations, particularly in one-address instruction systems.&lt;SEP&gt;The Accumulator (ACC) is a special register used to hold intermediate results and is implicitly used as the second operand in single-address instruction formats.</data>
      <data key="d3">chunk-823091106aa14acd3f766029738eb588&lt;SEP&gt;chunk-ee7b048d8f7d4f6a7cdb8bd206b3d9c3</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469928</data>
    </node>
    <node id="Direct Addressing">
      <data key="d0">Direct Addressing</data>
      <data key="d1">method</data>
      <data key="d2">Direct addressing is a method where the address in the instruction points directly to the memory location of the operand.&lt;SEP&gt;Direct addressing uses the address field as the effective address (EA), where EA equals the form address A, offering simplicity and a single memory access during execution.</data>
      <data key="d3">chunk-823091106aa14acd3f766029738eb588&lt;SEP&gt;chunk-ee7b048d8f7d4f6a7cdb8bd206b3d9c3</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469925</data>
    </node>
    <node id="Bitwise Operation">
      <data key="d0">Bitwise Operation</data>
      <data key="d1">concept</data>
      <data key="d2">A bitwise operation involves manipulating data at the bit level using logical operations such as AND, OR, NOT, and XOR.&lt;SEP&gt;A bitwise operation performs logical operations on individual bits of binary data, used in low-level programming.</data>
      <data key="d3">chunk-823091106aa14acd3f766029738eb588&lt;SEP&gt;chunk-be143027fbd9f62579107c5fcd0f2740</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469695</data>
    </node>
    <node id="Arithmetic Operation">
      <data key="d0">Arithmetic Operation</data>
      <data key="d1">concept</data>
      <data key="d2">An arithmetic operation is a mathematical process such as addition or subtraction performed by a computer's processor, which is indicated by the operation code in an instruction.&lt;SEP&gt;An arithmetic operation involves mathematical computations such as addition, subtraction, multiplication, and division on numerical data.</data>
      <data key="d3">chunk-dc66410ab81cdb2a13f279e50457a470&lt;SEP&gt;chunk-823091106aa14acd3f766029738eb588</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469785</data>
    </node>
    <node id="Control Transfer">
      <data key="d0">Control Transfer</data>
      <data key="d1">concept</data>
      <data key="d2">A control transfer refers to operations that alter the flow of program execution, such as branching, jumping, or returning, and are specified by the operation code field.</data>
      <data key="d3">chunk-823091106aa14acd3f766029738eb588</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469220</data>
    </node>
    <node id="Program Flow">
      <data key="d0">Program Flow</data>
      <data key="d1">concept</data>
      <data key="d2">Program flow describes the sequence in which instructions are executed, which can be altered by instructions with explicit or implicit control transfers.</data>
      <data key="d3">chunk-823091106aa14acd3f766029738eb588</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469220</data>
    </node>
    <node id="Operand">
      <data key="d0">Operand</data>
      <data key="d1">concept</data>
      <data key="d2">An operand is data or a value that is acted upon by an operation code, retrieved from memory or a register during instruction execution.</data>
      <data key="d3">chunk-823091106aa14acd3f766029738eb588</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469220</data>
    </node>
    <node id="Result Storage">
      <data key="d0">Result Storage</data>
      <data key="d1">concept</data>
      <data key="d2">Result storage refers to the process of saving the outcome of an operation, typically in a specified memory location or register designated by the address code.</data>
      <data key="d3">chunk-823091106aa14acd3f766029738eb588</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469220</data>
    </node>
    <node id="Subroutine Call">
      <data key="d0">Subroutine Call</data>
      <data key="d1">concept</data>
      <data key="d2">A subroutine call is a type of control transfer that invokes a separate block of code (a function or procedure), often using a specific instruction with a designated entry address.</data>
      <data key="d3">chunk-823091106aa14acd3f766029738eb588</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469221</data>
    </node>
    <node id="If-Then-Else Statement">
      <data key="d0">If-Then-Else Statement</data>
      <data key="d1">concept</data>
      <data key="d2">The if-then-else statement is a fundamental control flow construct in programming that executes one block of code if a condition is true and another if it is false.</data>
      <data key="d3">chunk-26a06731e273a94d7270550437bc874a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469283</data>
    </node>
    <node id="Condition Code">
      <data key="d0">Condition Code</data>
      <data key="d1">artifact</data>
      <data key="d2">Condition codes, also known as flag bits, represent the outcome of arithmetic or logical operations and are used to determine conditional branching.&lt;SEP&gt;The condition code is a set of flags in a processor that indicate the results of arithmetic or logical operations, such as zero, carry, or overflow.</data>
      <data key="d3">chunk-986821269f2aa2025221040c595a72be&lt;SEP&gt;chunk-26a06731e273a94d7270550437bc874a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469496</data>
    </node>
    <node id="CF">
      <data key="d0">CF</data>
      <data key="d1">concept</data>
      <data key="d2">CF (Carry Flag) is a condition code that indicates whether a carry or borrow occurred in an arithmetic operation.</data>
      <data key="d3">chunk-26a06731e273a94d7270550437bc874a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469283</data>
    </node>
    <node id="ZF">
      <data key="d0">ZF</data>
      <data key="d1">concept</data>
      <data key="d2">ZF (Zero Flag) is a condition code that is set when the result of an operation is zero.</data>
      <data key="d3">chunk-26a06731e273a94d7270550437bc874a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469283</data>
    </node>
    <node id="SF">
      <data key="d0">SF</data>
      <data key="d1">concept</data>
      <data key="d2">SF (Sign Flag) is a condition code that indicates the sign of the result of an operation.</data>
      <data key="d3">chunk-26a06731e273a94d7270550437bc874a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469283</data>
    </node>
    <node id="OF">
      <data key="d0">OF</data>
      <data key="d1">concept</data>
      <data key="d2">OF (Overflow Flag) is a condition code that signals that an arithmetic overflow has occurred.</data>
      <data key="d3">chunk-26a06731e273a94d7270550437bc874a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469283</data>
    </node>
    <node id="Add Instruction">
      <data key="d0">Add Instruction</data>
      <data key="d1">method</data>
      <data key="d2">The add instruction performs addition of two operands and sets condition codes based on the result.&lt;SEP&gt;The add instruction performs addition between two operands, storing the result in the first operand, which can be a register or memory location.</data>
      <data key="d3">chunk-26a06731e273a94d7270550437bc874a&lt;SEP&gt;chunk-be143027fbd9f62579107c5fcd0f2740</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469686</data>
    </node>
    <node id="Sub Instruction">
      <data key="d0">Sub Instruction</data>
      <data key="d1">method</data>
      <data key="d2">The sub instruction performs subtraction of two operands and sets condition codes based on the result.&lt;SEP&gt;The sub instruction performs subtraction between two operands, storing the result in the first operand, which can be a register or memory location.</data>
      <data key="d3">chunk-26a06731e273a94d7270550437bc874a&lt;SEP&gt;chunk-be143027fbd9f62579107c5fcd0f2740</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469686</data>
    </node>
    <node id="Imul Instruction">
      <data key="d0">Imul Instruction</data>
      <data key="d1">method</data>
      <data key="d2">The imul instruction performs signed integer multiplication and updates condition codes.&lt;SEP&gt;The imul instruction performs signed integer multiplication; it supports two-operand and three-operand formats, with results stored in a register.</data>
      <data key="d3">chunk-26a06731e273a94d7270550437bc874a&lt;SEP&gt;chunk-be143027fbd9f62579107c5fcd0f2740</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469686</data>
    </node>
    <node id="Or Instruction">
      <data key="d0">Or Instruction</data>
      <data key="d1">method</data>
      <data key="d2">The or instruction performs a bitwise OR operation and updates condition codes.&lt;SEP&gt;The or instruction performs a bitwise logical OR operation between two operands, storing the result in the first operand.</data>
      <data key="d3">chunk-26a06731e273a94d7270550437bc874a&lt;SEP&gt;chunk-be143027fbd9f62579107c5fcd0f2740</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469686</data>
    </node>
    <node id="And Instruction">
      <data key="d0">And Instruction</data>
      <data key="d1">method</data>
      <data key="d2">The and instruction performs a bitwise AND operation and updates condition codes.&lt;SEP&gt;The and instruction performs a bitwise logical AND operation between two operands, storing the result in the first operand.</data>
      <data key="d3">chunk-26a06731e273a94d7270550437bc874a&lt;SEP&gt;chunk-be143027fbd9f62579107c5fcd0f2740</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469686</data>
    </node>
    <node id="Shl Instruction">
      <data key="d0">Shl Instruction</data>
      <data key="d1">method</data>
      <data key="d2">The shl instruction performs a logical left shift and updates condition codes.&lt;SEP&gt;The shl instruction performs a logical left shift on the operand, shifting bits to the left by a specified number of positions.</data>
      <data key="d3">chunk-26a06731e273a94d7270550437bc874a&lt;SEP&gt;chunk-be143027fbd9f62579107c5fcd0f2740</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469689</data>
    </node>
    <node id="Inc Instruction">
      <data key="d0">Inc Instruction</data>
      <data key="d1">method</data>
      <data key="d2">The inc instruction increments a value by one and updates condition codes.&lt;SEP&gt;The inc instruction increments the value of the operand by 1, applicable to both registers and memory locations.</data>
      <data key="d3">chunk-26a06731e273a94d7270550437bc874a&lt;SEP&gt;chunk-be143027fbd9f62579107c5fcd0f2740</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469686</data>
    </node>
    <node id="Dec Instruction">
      <data key="d0">Dec Instruction</data>
      <data key="d1">method</data>
      <data key="d2">The dec instruction decrements a value by one and updates condition codes.&lt;SEP&gt;The dec instruction decrements the value of the operand by 1, applicable to both registers and memory locations.</data>
      <data key="d3">chunk-26a06731e273a94d7270550437bc874a&lt;SEP&gt;chunk-be143027fbd9f62579107c5fcd0f2740</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469686</data>
    </node>
    <node id="Not Instruction">
      <data key="d0">Not Instruction</data>
      <data key="d1">method</data>
      <data key="d2">The not instruction performs a bitwise NOT operation and updates condition codes.&lt;SEP&gt;The not instruction performs bit-level inversion on the operand, flipping each bit from 0 to 1 or 1 to 0.</data>
      <data key="d3">chunk-26a06731e273a94d7270550437bc874a&lt;SEP&gt;chunk-be143027fbd9f62579107c5fcd0f2740</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469689</data>
    </node>
    <node id="Sal Instruction">
      <data key="d0">Sal Instruction</data>
      <data key="d1">method</data>
      <data key="d2">The sal instruction performs a signed arithmetic left shift and updates condition codes.</data>
      <data key="d3">chunk-26a06731e273a94d7270550437bc874a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469284</data>
    </node>
    <node id="Cmp Instruction">
      <data key="d0">Cmp Instruction</data>
      <data key="d1">method</data>
      <data key="d2">The cmp instruction compares two values and sets condition codes without modifying the operands.</data>
      <data key="d3">chunk-26a06731e273a94d7270550437bc874a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469286</data>
    </node>
    <node id="Test Instruction">
      <data key="d0">Test Instruction</data>
      <data key="d1">method</data>
      <data key="d2">The test instruction performs a bitwise AND operation and sets condition codes without changing the operands.</data>
      <data key="d3">chunk-26a06731e273a94d7270550437bc874a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469286</data>
    </node>
    <node id="Jcondition Instruction">
      <data key="d0">Jcondition Instruction</data>
      <data key="d1">method</data>
      <data key="d2">The jcondition instruction is a conditional jump that uses status flags like ZF and SF to determine whether to transfer control.</data>
      <data key="d3">chunk-26a06731e273a94d7270550437bc874a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469286</data>
    </node>
    <node id="Test_Expr">
      <data key="d0">Test_Expr</data>
      <data key="d1">concept</data>
      <data key="d2">Test_Expr is an integer expression used in conditional statements that evaluates to zero (false) or non-zero (true).</data>
      <data key="d3">chunk-26a06731e273a94d7270550437bc874a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469286</data>
    </node>
    <node id="Then_Statement">
      <data key="d0">Then_Statement</data>
      <data key="d1">concept</data>
      <data key="d2">Then_Statement is the block of code executed when the test expression evaluates to true.</data>
      <data key="d3">chunk-26a06731e273a94d7270550437bc874a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469286</data>
    </node>
    <node id="Else_Statement">
      <data key="d0">Else_Statement</data>
      <data key="d1">concept</data>
      <data key="d2">Else_Statement is the block of code executed when the test expression evaluates to false.</data>
      <data key="d3">chunk-26a06731e273a94d7270550437bc874a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469286</data>
    </node>
    <node id="Base Addressing">
      <data key="d0">Base Addressing</data>
      <data key="d1">method</data>
      <data key="d2">Base addressing is a memory addressing technique used by the system to allocate storage space for multiple programs or data, where the base register content is set by the operating system and remains constant during program execution.&lt;SEP&gt;Base addressing computes the effective address by adding the base register (BR) content to the form address (A), used primarily to separate logical and physical addresses for program independence.</data>
      <data key="d3">chunk-9c7da0bf6fbf207039ae9ca67c1e6a9d&lt;SEP&gt;chunk-ee7b048d8f7d4f6a7cdb8bd206b3d9c3</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469925</data>
    </node>
    <node id="Index Addressing">
      <data key="d0">Index Addressing</data>
      <data key="d1">method</data>
      <data key="d2">Index addressing is a user-oriented memory addressing technique used for handling array problems, where the index register content is set by the user and can be modified during program execution.&lt;SEP&gt;Index addressing computes the effective address by adding the index register (IX) content to the form address (A), used effectively in array processing and dynamic data access.</data>
      <data key="d3">chunk-9c7da0bf6fbf207039ae9ca67c1e6a9d&lt;SEP&gt;chunk-ee7b048d8f7d4f6a7cdb8bd206b3d9c3</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469927</data>
    </node>
    <node id="Relative Addressing">
      <data key="d0">Relative Addressing</data>
      <data key="d1">method</data>
      <data key="d2">Relative addressing is a memory addressing method that generates an effective address by adding the contents of a register to a form address, and is closely related to base and index addressing.&lt;SEP&gt;Relative addressing calculates the effective address by adding the form address (A) to the program counter (PC), where A is a signed offset, enabling program mobility.</data>
      <data key="d3">chunk-9c7da0bf6fbf207039ae9ca67c1e6a9d&lt;SEP&gt;chunk-ee7b048d8f7d4f6a7cdb8bd206b3d9c3</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469925</data>
    </node>
    <node id="Effective Address">
      <data key="d0">Effective Address</data>
      <data key="d1">data</data>
      <data key="d2">The effective address is the calculated address of an operand, derived by adding a register's content to a form address in addressing methods like base, index, or relative addressing.&lt;SEP&gt;The Effective Address (EA) is the actual memory address computed from the form address and additional data such as register contents.</data>
      <data key="d3">chunk-9c7da0bf6fbf207039ae9ca67c1e6a9d&lt;SEP&gt;chunk-ee7b048d8f7d4f6a7cdb8bd206b3d9c3</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469928</data>
    </node>
    <node id="Base Register">
      <data key="d0">Base Register</data>
      <data key="d1">artifact</data>
      <data key="d2">The base register stores a fixed address used in base addressing, typically set by the operating system and unchanging during program execution.&lt;SEP&gt;The Base Register (BR) holds a base address and is used in base addressing to map logical addresses to physical memory locations.</data>
      <data key="d3">chunk-9c7da0bf6fbf207039ae9ca67c1e6a9d&lt;SEP&gt;chunk-ee7b048d8f7d4f6a7cdb8bd206b3d9c3</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469928</data>
    </node>
    <node id="Index Register">
      <data key="d0">Index Register</data>
      <data key="d1">artifact</data>
      <data key="d2">The index register holds a variable value used in index addressing, typically set by the user and modifiable during program execution.&lt;SEP&gt;The Index Register (IX) holds a displacement value and is used in index addressing to calculate effective addresses during data array processing.</data>
      <data key="d3">chunk-9c7da0bf6fbf207039ae9ca67c1e6a9d&lt;SEP&gt;chunk-ee7b048d8f7d4f6a7cdb8bd206b3d9c3</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469928</data>
    </node>
    <node id="Form Address">
      <data key="d0">Form Address</data>
      <data key="d1">data</data>
      <data key="d2">The form address is a component in memory addressing that, when combined with a register's value, generates the effective address.&lt;SEP&gt;The Form Address (A) is the address field in an instruction that serves as a component in computing the effective address in various addressing modes.</data>
      <data key="d3">chunk-9c7da0bf6fbf207039ae9ca67c1e6a9d&lt;SEP&gt;chunk-ee7b048d8f7d4f6a7cdb8bd206b3d9c3</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469928</data>
    </node>
    <node id="Offset Addressing">
      <data key="d0">Offset Addressing</data>
      <data key="d1">concept</data>
      <data key="d2">Offset addressing is a generalized term referring to addressing methods such as relative, base, and index addressing that generate effective addresses through a register plus form address addition.</data>
      <data key="d3">chunk-9c7da0bf6fbf207039ae9ca67c1e6a9d</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469294</data>
    </node>
    <node id="Operating System">
      <data key="d0">Operating System</data>
      <data key="d1">organization</data>
      <data key="d2">The operating system manages system resources and determines the base register content in base addressing.</data>
      <data key="d3">chunk-9c7da0bf6fbf207039ae9ca67c1e6a9d</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469295</data>
    </node>
    <node id="Multiple Program Support">
      <data key="d0">Multiple Program Support</data>
      <data key="d1">concept</data>
      <data key="d2">Multiple program support refers to the system capability enabled by base addressing, allowing the operating system to allocate storage space for concurrent programs.</data>
      <data key="d3">chunk-9c7da0bf6fbf207039ae9ca67c1e6a9d</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469296</data>
    </node>
    <node id="Array Processing">
      <data key="d0">Array Processing</data>
      <data key="d1">concept</data>
      <data key="d2">Array processing is a key application of index addressing, enabling efficient access to elements in arrays through variable index values.</data>
      <data key="d3">chunk-9c7da0bf6fbf207039ae9ca67c1e6a9d</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469296</data>
    </node>
    <node id="Instruction Word">
      <data key="d0">Instruction Word</data>
      <data key="d1">artifact</data>
      <data key="d2">The instruction word contains the form address (A) used in addressing modes; its value is variable in base addressing and fixed in index addressing.&lt;SEP&gt;The instruction word is a fixed-length binary pattern that encodes an instruction, including operation code and operand information, used by the processor.</data>
      <data key="d3">chunk-7fa816a9f8d5ac78d7483ae33a74ba7b&lt;SEP&gt;chunk-9c7da0bf6fbf207039ae9ca67c1e6a9d</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469639</data>
    </node>
    <node id="Mov Instruction">
      <data key="d0">Mov Instruction</data>
      <data key="d1">method</data>
      <data key="d2">The Mov Instruction is a data transfer operation in assembly language that copies data from a source operand to a destination operand, supporting registers, memory, and immediate values.</data>
      <data key="d3">chunk-803e04b7ef409476eff2adc07fef14d1</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469376</data>
    </node>
    <node id="Push Instruction">
      <data key="d0">Push Instruction</data>
      <data key="d1">method</data>
      <data key="d2">The Push Instruction is an assembly language operation that stores a value onto the stack, decrementing the stack pointer (ESP) before writing the value.</data>
      <data key="d3">chunk-803e04b7ef409476eff2adc07fef14d1</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469376</data>
    </node>
    <node id="Pop Instruction">
      <data key="d0">Pop Instruction</data>
      <data key="d1">method</data>
      <data key="d2">The Pop Instruction is an assembly language operation that retrieves a value from the top of the stack, updating the stack pointer (ESP) after reading.</data>
      <data key="d3">chunk-803e04b7ef409476eff2adc07fef14d1</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469376</data>
    </node>
    <node id="Register">
      <data key="d0">Register</data>
      <data key="d1">artifact</data>
      <data key="d2">A register is a small, fast storage location within the CPU used to hold data or memory addresses during computation.&lt;SEP&gt;A register is a small, fast storage location within the CPU used to hold data and instructions during processing.&lt;SEP&gt;A register is a small, fast storage location within the processor used to hold data and addresses during instruction execution.&lt;SEP&gt;Register is a small, high-speed storage location within a processor used to hold data temporarily during execution.</data>
      <data key="d3">chunk-3c363f9d809dadcf3a7c0f9008fb810a&lt;SEP&gt;chunk-dc66410ab81cdb2a13f279e50457a470&lt;SEP&gt;chunk-803e04b7ef409476eff2adc07fef14d1&lt;SEP&gt;chunk-be143027fbd9f62579107c5fcd0f2740</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469950</data>
    </node>
    <node id="Memory">
      <data key="d0">Memory</data>
      <data key="d1">artifact</data>
      <data key="d2">Memory refers to the random-access memory (RAM) in a computer system used to store data and instructions.&lt;SEP&gt;Memory refers to the computerâ€™s primary storage where data and instructions are stored, accessible via addresses.&lt;SEP&gt;Memory refers to the storage location in a computer system where data and instructions are held for processing.</data>
      <data key="d3">chunk-3c363f9d809dadcf3a7c0f9008fb810a&lt;SEP&gt;chunk-803e04b7ef409476eff2adc07fef14d1&lt;SEP&gt;chunk-be143027fbd9f62579107c5fcd0f2740</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469950</data>
    </node>
    <node id="Constant Value">
      <data key="d0">Constant Value</data>
      <data key="d1">data</data>
      <data key="d2">A constant value is a fixed numeric or symbolic operand that remains unchanged during program execution.</data>
      <data key="d3">chunk-803e04b7ef409476eff2adc07fef14d1</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469376</data>
    </node>
    <node id="Esp">
      <data key="d0">Esp</data>
      <data key="d1">artifact</data>
      <data key="d2">Esp (Extended Stack Pointer) is a 32-bit register that points to the top of the stack in memory.</data>
      <data key="d3">chunk-803e04b7ef409476eff2adc07fef14d1</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469376</data>
    </node>
    <node id="32-Bit">
      <data key="d0">32-Bit</data>
      <data key="d1">concept</data>
      <data key="d2">32-bit refers to a data size or address width that uses 32 binary digits, typically denoting word size or operand structure in computing.</data>
      <data key="d3">chunk-803e04b7ef409476eff2adc07fef14d1</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469378</data>
    </node>
    <node id="Single Operand">
      <data key="d0">Single Operand</data>
      <data key="d1">concept</data>
      <data key="d2">A single operand refers to a computational instruction that uses only one data input.</data>
      <data key="d3">chunk-803e04b7ef409476eff2adc07fef14d1</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469378</data>
    </node>
    <node id="Two Operands">
      <data key="d0">Two Operands</data>
      <data key="d1">concept</data>
      <data key="d2">A two operands instruction involves two distinct data sources, one for source and one for destination.</data>
      <data key="d3">chunk-803e04b7ef409476eff2adc07fef14d1</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469378</data>
    </node>
    <node id="Data Transfer">
      <data key="d0">Data Transfer</data>
      <data key="d1">concept</data>
      <data key="d2">Data transfer is the process of moving information from one location to another, such as between registers and memory.&lt;SEP&gt;Data transfer refers to the movement of data between components such as registers, memory, and CPU, involving operations like MOV, LOAD, STORE, PUSH, and POP.</data>
      <data key="d3">chunk-1853ae0bf21d6ed553e97992dab0cb73&lt;SEP&gt;chunk-803e04b7ef409476eff2adc07fef14d1</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469590</data>
    </node>
    <node id="Memory to Memory Copy">
      <data key="d0">Memory to Memory Copy</data>
      <data key="d1">concept</data>
      <data key="d2">Memory to memory copy is a data transfer operation that cannot be directly performed by the mov instruction and requires a register as an intermediate step.</data>
      <data key="d3">chunk-803e04b7ef409476eff2adc07fef14d1</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469378</data>
    </node>
    <node id="Register to Memory Copy">
      <data key="d0">Register to Memory Copy</data>
      <data key="d1">concept</data>
      <data key="d2">Register to memory copy is a valid operation supported by the mov instruction for transferring data from a register to a memory location.</data>
      <data key="d3">chunk-803e04b7ef409476eff2adc07fef14d1</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469378</data>
    </node>
    <node id="Immediate Value">
      <data key="d0">Immediate Value</data>
      <data key="d1">data</data>
      <data key="d2">An immediate value is a constant literal value specified directly within an instruction, such as a number.</data>
      <data key="d3">chunk-803e04b7ef409476eff2adc07fef14d1</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469378</data>
    </node>
    <node id="CISC">
      <data key="d0">CISC</data>
      <data key="d1">concept</data>
      <data key="d2">CISC stands for Complex Instruction Set Computer, a design approach that includes a large number of complex instructions and supports software compatibility across different machine levels.&lt;SEP&gt;CISC (Complex Instruction Set Computing) is a processor design architecture characterized by complex instructions and microprogrammed control.</data>
      <data key="d3">chunk-2151538dd57e60dbb6761c6a35ea00c6&lt;SEP&gt;chunk-d12ab3ee72f1f1a8f72c7e3dece14062</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761470014</data>
    </node>
    <node id="Instruction System Simplification">
      <data key="d0">Instruction System Simplification</data>
      <data key="d1">concept</data>
      <data key="d2">Instruction system simplification refers to the core principle of RISC, which focuses on reducing instruction complexity and standardizing formats.</data>
      <data key="d3">chunk-d12ab3ee72f1f1a8f72c7e3dece14062</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469399</data>
    </node>
    <node id="Register-Register Operation">
      <data key="d0">Register-Register Operation</data>
      <data key="d1">concept</data>
      <data key="d2">Register-register operation is a RISC design feature where most operations are performed between registers rather than memory.</data>
      <data key="d3">chunk-d12ab3ee72f1f1a8f72c7e3dece14062</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469399</data>
    </node>
    <node id="Fixed Instruction Length">
      <data key="d0">Fixed Instruction Length</data>
      <data key="d1">concept</data>
      <data key="d2">Fixed instruction length is a characteristic of RISC that ensures all instructions have the same size, simplifying decoding.</data>
      <data key="d3">chunk-d12ab3ee72f1f1a8f72c7e3dece14062</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469399</data>
    </node>
    <node id="Limited Addressing Modes">
      <data key="d0">Limited Addressing Modes</data>
      <data key="d1">concept</data>
      <data key="d2">Limited addressing modes means RISC uses a minimal set of ways to determine operand locations.</data>
      <data key="d3">chunk-d12ab3ee72f1f1a8f72c7e3dece14062</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469399</data>
    </node>
    <node id="Load/Store Architecture">
      <data key="d0">Load/Store Architecture</data>
      <data key="d1">concept</data>
      <data key="d2">Load/store architecture restricts memory access to only LOAD and STORE instructions, keeping other operations in registers.</data>
      <data key="d3">chunk-d12ab3ee72f1f1a8f72c7e3dece14062</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469399</data>
    </node>
    <node id="Large Number of General-Purpose Registers">
      <data key="d0">Large Number of General-Purpose Registers</data>
      <data key="d1">concept</data>
      <data key="d2">RISC employs a large number of general-purpose registers to enhance performance.</data>
      <data key="d3">chunk-d12ab3ee72f1f1a8f72c7e3dece14062</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469399</data>
    </node>
    <node id="Instruction Pipelining">
      <data key="d0">Instruction Pipelining</data>
      <data key="d1">concept</data>
      <data key="d2">Instruction pipelining is a technique used in RISC to execute multiple instructions simultaneously within a single clock cycle.</data>
      <data key="d3">chunk-d12ab3ee72f1f1a8f72c7e3dece14062</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469400</data>
    </node>
    <node id="Compiler Optimization">
      <data key="d0">Compiler Optimization</data>
      <data key="d1">concept</data>
      <data key="d2">Compiler optimization is a critical aspect of RISC, where the compiler plays a key role in improving program efficiency.</data>
      <data key="d3">chunk-d12ab3ee72f1f1a8f72c7e3dece14062</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469401</data>
    </node>
    <node id="Software Compatibility">
      <data key="d0">Software Compatibility</data>
      <data key="d1">concept</data>
      <data key="d2">Software compatibility in CISC allows higher-end machines to support all instructions from lower-end models.</data>
      <data key="d3">chunk-d12ab3ee72f1f1a8f72c7e3dece14062</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469401</data>
    </node>
    <node id="Processor Development Direction">
      <data key="d0">Processor Development Direction</data>
      <data key="d1">concept</data>
      <data key="d2">Processor development direction refers to the belief that RISC represents the future trend in CPU design due to its efficiency and practicality.</data>
      <data key="d3">chunk-d12ab3ee72f1f1a8f72c7e3dece14062</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469401</data>
    </node>
    <node id="Intel">
      <data key="d0">Intel</data>
      <data key="d1">organization</data>
      <data key="d2">Intel is a major semiconductor company that dominates the processor market, particularly using CISC architecture.</data>
      <data key="d3">chunk-d12ab3ee72f1f1a8f72c7e3dece14062</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469401</data>
    </node>
    <node id="Legacy Machine Compatibility">
      <data key="d0">Legacy Machine Compatibility</data>
      <data key="d1">concept</data>
      <data key="d2">Legacy machine compatibility refers to the inability of most RISC machines to run software designed for older CISC systems.</data>
      <data key="d3">chunk-d12ab3ee72f1f1a8f72c7e3dece14062</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469401</data>
    </node>
    <node id="Modern CISC Architecture">
      <data key="d0">Modern CISC Architecture</data>
      <data key="d1">concept</data>
      <data key="d2">Modern CISC architecture incorporates many RISC principles, reducing performance differences between RISC and CISC processors.</data>
      <data key="d3">chunk-d12ab3ee72f1f1a8f72c7e3dece14062</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469401</data>
    </node>
    <node id="100m Sprint Record">
      <data key="d0">100m Sprint Record</data>
      <data key="d1">category</data>
      <data key="d2">The 100m sprint record is a benchmark in athletics, recently broken by Noah Carter.</data>
      <data key="d3">chunk-d12ab3ee72f1f1a8f72c7e3dece14062</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469402</data>
    </node>
    <node id="Carbon-Fiber Spikes">
      <data key="d0">Carbon-Fiber Spikes</data>
      <data key="d1">equipment</data>
      <data key="d2">Carbon-fiber spikes are advanced sprinting shoes that provide enhanced speed and traction.</data>
      <data key="d3">chunk-d12ab3ee72f1f1a8f72c7e3dece14062</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469402</data>
    </node>
    <node id="World Athletics Federation">
      <data key="d0">World Athletics Federation</data>
      <data key="d1">organization</data>
      <data key="d2">The World Athletics Federation is the governing body overseeing the World Athletics Championship and record validations.</data>
      <data key="d3">chunk-d12ab3ee72f1f1a8f72c7e3dece14062</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469402</data>
    </node>
    <node id="Tokyo">
      <data key="d0">Tokyo</data>
      <data key="d3">chunk-d12ab3ee72f1f1a8f72c7e3dece14062</data>
      <data key="d2">The World Athletics Championship is being hosted in Tokyo.</data>
      <data key="d1">UNKNOWN</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469404</data>
    </node>
    <node id="World Athletics Championship">
      <data key="d0">World Athletics Championship</data>
      <data key="d3">chunk-d12ab3ee72f1f1a8f72c7e3dece14062</data>
      <data key="d2">The World Athletics Championship is being hosted in Tokyo.</data>
      <data key="d1">UNKNOWN</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469404</data>
    </node>
    <node id="Noah Carter">
      <data key="d0">Noah Carter</data>
      <data key="d3">chunk-d12ab3ee72f1f1a8f72c7e3dece14062</data>
      <data key="d2">Noah Carter set a new 100m sprint record at the championship.</data>
      <data key="d1">UNKNOWN</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469404</data>
    </node>
    <node id="Instruction Addressing">
      <data key="d0">Instruction Addressing</data>
      <data key="d1">concept</data>
      <data key="d2">Instruction addressing is a method used in computer architecture to determine the address of the next instruction to be executed.</data>
      <data key="d3">chunk-090282a2e59cdb6b6513b1d2f898d3ae</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469453</data>
    </node>
    <node id="Sequential Addressing">
      <data key="d0">Sequential Addressing</data>
      <data key="d1">method</data>
      <data key="d2">Sequential addressing is a mode of instruction addressing where the next instruction address is generated by incrementing the Program Counter (PC) by the length of one instruction.</data>
      <data key="d3">chunk-090282a2e59cdb6b6513b1d2f898d3ae</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469453</data>
    </node>
    <node id="Jump Addressing">
      <data key="d0">Jump Addressing</data>
      <data key="d1">method</data>
      <data key="d2">Jump addressing is a mode of instruction addressing where the next instruction address is determined by a transfer instruction, allowing non-sequential execution.</data>
      <data key="d3">chunk-090282a2e59cdb6b6513b1d2f898d3ae</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469453</data>
    </node>
    <node id="Program Counter">
      <data key="d0">Program Counter</data>
      <data key="d1">artifact</data>
      <data key="d2">The Program Counter (PC) is a register that holds the address of the next instruction to be executed.&lt;SEP&gt;The program counter is a processor register that holds the address of the next instruction to be executed.&lt;SEP&gt;The Program Counter (PC) stores the address of the next instruction to be executed and is used in relative addressing to compute effective addresses.</data>
      <data key="d3">chunk-090282a2e59cdb6b6513b1d2f898d3ae&lt;SEP&gt;chunk-986821269f2aa2025221040c595a72be&lt;SEP&gt;chunk-ee7b048d8f7d4f6a7cdb8bd206b3d9c3</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469928</data>
    </node>
    <node id="Instruction Length">
      <data key="d0">Instruction Length</data>
      <data key="d1">data</data>
      <data key="d2">Instruction length refers to the size of an instruction in bits, which affects how much the PC is incremented during sequential addressing.</data>
      <data key="d3">chunk-090282a2e59cdb6b6513b1d2f898d3ae</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469453</data>
    </node>
    <node id="Byte Addressing">
      <data key="d0">Byte Addressing</data>
      <data key="d1">concept</data>
      <data key="d2">Byte addressing is a memory addressing scheme where each byte in memory has a unique address.</data>
      <data key="d3">chunk-090282a2e59cdb6b6513b1d2f898d3ae</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469453</data>
    </node>
    <node id="16-Bit Instruction">
      <data key="d0">16-Bit Instruction</data>
      <data key="d1">data</data>
      <data key="d2">A 16-bit instruction is a type of instruction that occupies 16 bits of memory space.</data>
      <data key="d3">chunk-090282a2e59cdb6b6513b1d2f898d3ae</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469453</data>
    </node>
    <node id="32-Bit Instruction">
      <data key="d0">32-Bit Instruction</data>
      <data key="d1">data</data>
      <data key="d2">A 32-bit instruction is a type of instruction that occupies 32 bits of memory space.</data>
      <data key="d3">chunk-090282a2e59cdb6b6513b1d2f898d3ae</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469453</data>
    </node>
    <node id="Absolute Transfer">
      <data key="d0">Absolute Transfer</data>
      <data key="d1">method</data>
      <data key="d2">Absolute transfer is a type of jump addressing where the target address is directly specified in the instruction's operand field.</data>
      <data key="d3">chunk-090282a2e59cdb6b6513b1d2f898d3ae</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469455</data>
    </node>
    <node id="Relative Transfer">
      <data key="d0">Relative Transfer</data>
      <data key="d1">method</data>
      <data key="d2">Relative transfer is a type of jump addressing where the target address is specified as an offset from the current value of the Program Counter (PC).</data>
      <data key="d3">chunk-090282a2e59cdb6b6513b1d2f898d3ae</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469455</data>
    </node>
    <node id="Status Register">
      <data key="d0">Status Register</data>
      <data key="d1">artifact</data>
      <data key="d2">The Status Register is a hardware register that stores information about the result of operations, such as flags for zero, carry, or overflow, which can control conditional branching.</data>
      <data key="d3">chunk-090282a2e59cdb6b6513b1d2f898d3ae</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469455</data>
    </node>
    <node id="Main Memory">
      <data key="d0">Main Memory</data>
      <data key="d1">naturalobject</data>
      <data key="d2">Main memory is the primary storage in a computer system where instructions and data are stored for immediate access by the CPU.&lt;SEP&gt;Main memory is the primary storage in a computer system that holds data and instructions currently in use.</data>
      <data key="d3">chunk-090282a2e59cdb6b6513b1d2f898d3ae&lt;SEP&gt;chunk-dc66410ab81cdb2a13f279e50457a470</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469782</data>
    </node>
    <node id="Instruction Set Architecture">
      <data key="d0">Instruction Set Architecture</data>
      <data key="d1">concept</data>
      <data key="d2">Instruction Set Architecture (ISA) is a critical component of a computer's design, defining the interface between software and hardware, and specifying the set of instructions, data formats, and execution control mechanisms for a processor.</data>
      <data key="d3">chunk-986821269f2aa2025221040c595a72be</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469494</data>
    </node>
    <node id="Machine Language">
      <data key="d0">Machine Language</data>
      <data key="d1">content</data>
      <data key="d2">Machine language is a low-level programming language composed of binary codes that a computer's CPU can directly execute.</data>
      <data key="d3">chunk-986821269f2aa2025221040c595a72be</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469494</data>
    </node>
    <node id="Assembly Language">
      <data key="d0">Assembly Language</data>
      <data key="d1">concept</data>
      <data key="d2">Assembly language is a low-level programming language that uses symbolic representations of machine instructions, serving as a human-readable form of machine code.&lt;SEP&gt;Assembly language is a low-level programming language that uses symbolic representations for machine instructions, often involving syntax conventions like those in AT&amp;T and Intel formats.</data>
      <data key="d3">chunk-986821269f2aa2025221040c595a72be&lt;SEP&gt;chunk-53c922e8f9c9847391088bcc3c5430ac</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469808</data>
    </node>
    <node id="High-Level Language">
      <data key="d0">High-Level Language</data>
      <data key="d1">content</data>
      <data key="d2">High-level languages such as C, C++, and Java are designed to be more abstract and easier for human programmers to use, with a higher level of abstraction from hardware details.</data>
      <data key="d3">chunk-986821269f2aa2025221040c595a72be</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469494</data>
    </node>
    <node id="Big Endian">
      <data key="d0">Big Endian</data>
      <data key="d1">concept</data>
      <data key="d2">Big Endian is a data representation format in which the most significant byte of a word is stored at the lowest memory address.</data>
      <data key="d3">chunk-986821269f2aa2025221040c595a72be</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469494</data>
    </node>
    <node id="Little Endian">
      <data key="d0">Little Endian</data>
      <data key="d1">concept</data>
      <data key="d2">Little Endian is a data representation format in which the least significant byte of a word is stored at the lowest memory address.</data>
      <data key="d3">chunk-986821269f2aa2025221040c595a72be</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469494</data>
    </node>
    <node id="Processor Register">
      <data key="d0">Processor Register</data>
      <data key="d1">artifact</data>
      <data key="d2">A processor register is a small, fast storage location within the CPU used to hold data, addresses, or control information during instruction execution.</data>
      <data key="d3">chunk-986821269f2aa2025221040c595a72be</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469496</data>
    </node>
    <node id="Memory Addressing">
      <data key="d0">Memory Addressing</data>
      <data key="d1">concept</data>
      <data key="d2">Memory addressing refers to the method by which a processor accesses memory locations, including techniques like byte addressing or word addressing.</data>
      <data key="d3">chunk-986821269f2aa2025221040c595a72be</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469496</data>
    </node>
    <node id="Instruction Format">
      <data key="d0">Instruction Format</data>
      <data key="d1">concept</data>
      <data key="d2">Instruction format defines the structure of a machine instruction, including opcode and operand fields.</data>
      <data key="d3">chunk-986821269f2aa2025221040c595a72be</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469496</data>
    </node>
    <node id="Operand Addressing Mode">
      <data key="d0">Operand Addressing Mode</data>
      <data key="d1">concept</data>
      <data key="d2">Operand addressing mode specifies how the operands of an instruction are located in memory or registers.</data>
      <data key="d3">chunk-986821269f2aa2025221040c595a72be</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469496</data>
    </node>
    <node id="Data Type">
      <data key="d0">Data Type</data>
      <data key="d1">concept</data>
      <data key="d2">Data type refers to the classification of data values, such as integers, floating-point numbers, or characters, which determines how data is stored and processed.</data>
      <data key="d3">chunk-986821269f2aa2025221040c595a72be</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469496</data>
    </node>
    <node id="Performance Optimization">
      <data key="d0">Performance Optimization</data>
      <data key="d1">method</data>
      <data key="d2">Performance optimization refers to techniques used to improve the speed and efficiency of program execution by understanding and leveraging hardware architecture.</data>
      <data key="d3">chunk-986821269f2aa2025221040c595a72be</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469496</data>
    </node>
    <node id="Arithmetic And Logical Operations">
      <data key="d0">Arithmetic And Logical Operations</data>
      <data key="d1">concept</data>
      <data key="d2">Arithmetic and logical operations include ADD, SUB, MUL, DIV, INC, DEC, AND, OR, NOT, XOR, and are used for mathematical and bit-level data manipulation.</data>
      <data key="d3">chunk-1853ae0bf21d6ed553e97992dab0cb73</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469590</data>
    </node>
    <node id="Shift Operations">
      <data key="d0">Shift Operations</data>
      <data key="d1">concept</data>
      <data key="d2">Shift operations involve moving bits within a binary number, including arithmetic shift, logical shift, and circular shift.</data>
      <data key="d3">chunk-1853ae0bf21d6ed553e97992dab0cb73</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469590</data>
    </node>
    <node id="Branching Operations">
      <data key="d0">Branching Operations</data>
      <data key="d1">concept</data>
      <data key="d2">Branching operations control program flow, including unconditional transfer (JMP), conditional transfer (BRANCH), CALL, RET, and TRAP, based on flag conditions.</data>
      <data key="d3">chunk-1853ae0bf21d6ed553e97992dab0cb73</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469590</data>
    </node>
    <node id="Input Output Operations">
      <data key="d0">Input Output Operations</data>
      <data key="d1">concept</data>
      <data key="d2">Input output operations enable data exchange between the CPU and external devices, including sending commands and receiving status information.</data>
      <data key="d3">chunk-1853ae0bf21d6ed553e97992dab0cb73</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469590</data>
    </node>
    <node id="MOV">
      <data key="d0">MOV</data>
      <data key="d1">method</data>
      <data key="d2">MOV is a data transfer instruction that moves data from one register to another.</data>
      <data key="d3">chunk-1853ae0bf21d6ed553e97992dab0cb73</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469590</data>
    </node>
    <node id="LOAD">
      <data key="d0">LOAD</data>
      <data key="d1">method</data>
      <data key="d2">LOAD is a data transfer instruction that retrieves data from a memory unit into a CPU register.</data>
      <data key="d3">chunk-1853ae0bf21d6ed553e97992dab0cb73</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469590</data>
    </node>
    <node id="STORE">
      <data key="d0">STORE</data>
      <data key="d1">method</data>
      <data key="d2">STORE is a data transfer instruction that writes data from a CPU register to a memory unit.</data>
      <data key="d3">chunk-1853ae0bf21d6ed553e97992dab0cb73</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469590</data>
    </node>
    <node id="PUSH">
      <data key="d0">PUSH</data>
      <data key="d1">method</data>
      <data key="d2">PUSH is a data transfer instruction that places data onto the stack.</data>
      <data key="d3">chunk-1853ae0bf21d6ed553e97992dab0cb73</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469592</data>
    </node>
    <node id="POP">
      <data key="d0">POP</data>
      <data key="d1">method</data>
      <data key="d2">POP is a data transfer instruction that removes data from the stack.</data>
      <data key="d3">chunk-1853ae0bf21d6ed553e97992dab0cb73</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469592</data>
    </node>
    <node id="ADD">
      <data key="d0">ADD</data>
      <data key="d1">method</data>
      <data key="d2">ADD is an arithmetic operation that adds two values.</data>
      <data key="d3">chunk-1853ae0bf21d6ed553e97992dab0cb73</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469592</data>
    </node>
    <node id="SUB">
      <data key="d0">SUB</data>
      <data key="d1">method</data>
      <data key="d2">SUB is an arithmetic operation that subtracts one value from another.</data>
      <data key="d3">chunk-1853ae0bf21d6ed553e97992dab0cb73</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469592</data>
    </node>
    <node id="MUL">
      <data key="d0">MUL</data>
      <data key="d1">method</data>
      <data key="d2">MUL is an arithmetic operation that multiplies two values.</data>
      <data key="d3">chunk-1853ae0bf21d6ed553e97992dab0cb73</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469592</data>
    </node>
    <node id="DIV">
      <data key="d0">DIV</data>
      <data key="d1">method</data>
      <data key="d2">DIV is an arithmetic operation that divides one value by another.</data>
      <data key="d3">chunk-1853ae0bf21d6ed553e97992dab0cb73</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469592</data>
    </node>
    <node id="INC">
      <data key="d0">INC</data>
      <data key="d1">method</data>
      <data key="d2">INC is an arithmetic operation that increments a value by one.</data>
      <data key="d3">chunk-1853ae0bf21d6ed553e97992dab0cb73</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469592</data>
    </node>
    <node id="DEC">
      <data key="d0">DEC</data>
      <data key="d1">method</data>
      <data key="d2">DEC is an arithmetic operation that decrements a value by one.</data>
      <data key="d3">chunk-1853ae0bf21d6ed553e97992dab0cb73</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469592</data>
    </node>
    <node id="AND">
      <data key="d0">AND</data>
      <data key="d1">method</data>
      <data key="d2">AND is a logical operation that performs bitwise AND on two values.</data>
      <data key="d3">chunk-1853ae0bf21d6ed553e97992dab0cb73</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469593</data>
    </node>
    <node id="OR">
      <data key="d0">OR</data>
      <data key="d1">method</data>
      <data key="d2">OR is a logical operation that performs bitwise OR on two values.</data>
      <data key="d3">chunk-1853ae0bf21d6ed553e97992dab0cb73</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469593</data>
    </node>
    <node id="NOT">
      <data key="d0">NOT</data>
      <data key="d1">method</data>
      <data key="d2">NOT is a logical operation that inverts the bits of a value.</data>
      <data key="d3">chunk-1853ae0bf21d6ed553e97992dab0cb73</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469593</data>
    </node>
    <node id="XOR">
      <data key="d0">XOR</data>
      <data key="d1">method</data>
      <data key="d2">XOR is a logical operation that performs bitwise exclusive OR on two values.</data>
      <data key="d3">chunk-1853ae0bf21d6ed553e97992dab0cb73</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469593</data>
    </node>
    <node id="Arithmetic Shift">
      <data key="d0">Arithmetic Shift</data>
      <data key="d1">method</data>
      <data key="d2">Arithmetic shift is a type of shift operation that preserves the sign bit during left or right shifts.</data>
      <data key="d3">chunk-1853ae0bf21d6ed553e97992dab0cb73</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469593</data>
    </node>
    <node id="Logical Shift">
      <data key="d0">Logical Shift</data>
      <data key="d1">concept</data>
      <data key="d2">Logical shift is a type of shift operation that shifts bits without preserving the sign.&lt;SEP&gt;A logical shift moves bits to the left or right without considering the sign, filling with zeros.</data>
      <data key="d3">chunk-1853ae0bf21d6ed553e97992dab0cb73&lt;SEP&gt;chunk-be143027fbd9f62579107c5fcd0f2740</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469695</data>
    </node>
    <node id="Circular Shift">
      <data key="d0">Circular Shift</data>
      <data key="d1">method</data>
      <data key="d2">Circular shift is a type of shift operation that moves bits in a circular manner, wrapping around from end to beginning.</data>
      <data key="d3">chunk-1853ae0bf21d6ed553e97992dab0cb73</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469593</data>
    </node>
    <node id="JMP">
      <data key="d0">JMP</data>
      <data key="d1">method</data>
      <data key="d2">JMP is a branching operation that unconditionally transfers control to a specified address.</data>
      <data key="d3">chunk-1853ae0bf21d6ed553e97992dab0cb73</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469593</data>
    </node>
    <node id="BRANCH">
      <data key="d0">BRANCH</data>
      <data key="d1">method</data>
      <data key="d2">BRANCH is a branching operation that conditionally transfers control based on flag values.</data>
      <data key="d3">chunk-1853ae0bf21d6ed553e97992dab0cb73</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469593</data>
    </node>
    <node id="CALL">
      <data key="d0">CALL</data>
      <data key="d1">method</data>
      <data key="d2">CALL is a branching operation that transfers control to a subroutine while saving the return address.</data>
      <data key="d3">chunk-1853ae0bf21d6ed553e97992dab0cb73</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469594</data>
    </node>
    <node id="RET">
      <data key="d0">RET</data>
      <data key="d1">method</data>
      <data key="d2">RET is a branching operation that returns control to the calling program from a subroutine.</data>
      <data key="d3">chunk-1853ae0bf21d6ed553e97992dab0cb73</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469595</data>
    </node>
    <node id="TRAP">
      <data key="d0">TRAP</data>
      <data key="d1">method</data>
      <data key="d2">TRAP is a branching operation that triggers an exception or interrupt, often used for system calls.</data>
      <data key="d3">chunk-1853ae0bf21d6ed553e97992dab0cb73</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469595</data>
    </node>
    <node id="Fixed-Length Opcode Instruction Format">
      <data key="d0">Fixed-Length Opcode Instruction Format</data>
      <data key="d1">concept</data>
      <data key="d2">The fixed-length opcode instruction format allocates a fixed number of bits in the instruction word's highest-order section to represent the operation code, enabling consistent instruction decoding and recognition in computer architecture.</data>
      <data key="d3">chunk-7fa816a9f8d5ac78d7483ae33a74ba7b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469639</data>
    </node>
    <node id="Opcode Field">
      <data key="d0">Opcode Field</data>
      <data key="d1">data</data>
      <data key="d2">The opcode field is a portion of the instruction word that holds the operation code, and its size determines the maximum number of distinct instructions the system can support.</data>
      <data key="d3">chunk-7fa816a9f8d5ac78d7483ae33a74ba7b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469639</data>
    </node>
    <node id="Computer Hardware Design">
      <data key="d0">Computer Hardware Design</data>
      <data key="d1">concept</data>
      <data key="d2">Computer hardware design refers to the architectural and engineering processes involved in creating processor components, influenced by instruction format choices.</data>
      <data key="d3">chunk-7fa816a9f8d5ac78d7483ae33a74ba7b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469639</data>
    </node>
    <node id="Instruction Decoding">
      <data key="d0">Instruction Decoding</data>
      <data key="d1">method</data>
      <data key="d2">Instruction decoding is the process of interpreting the opcode and operand fields of an instruction word to determine the operation to be executed.</data>
      <data key="d3">chunk-7fa816a9f8d5ac78d7483ae33a74ba7b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469639</data>
    </node>
    <node id="32-Bit Word Length">
      <data key="d0">32-Bit Word Length</data>
      <data key="d1">concept</data>
      <data key="d2">A 32-bit word length is a standard computer word size where instructions are typically 32 bits long, commonly used in modern computing systems.</data>
      <data key="d3">chunk-7fa816a9f8d5ac78d7483ae33a74ba7b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469639</data>
    </node>
    <node id="Maximum Instruction Capacity">
      <data key="d0">Maximum Instruction Capacity</data>
      <data key="d1">concept</data>
      <data key="d2">The maximum instruction capacity refers to the total number of distinct machine instructions that can be represented, calculated as 2^n, where n is the number of bits in the opcode field.</data>
      <data key="d3">chunk-7fa816a9f8d5ac78d7483ae33a74ba7b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469639</data>
    </node>
    <node id="Idiv Instruction">
      <data key="d0">Idiv Instruction</data>
      <data key="d1">method</data>
      <data key="d2">The idiv instruction performs signed integer division using the 64-bit value in edx:eax as the dividend, producing a quotient in eax and remainder in edx.</data>
      <data key="d3">chunk-be143027fbd9f62579107c5fcd0f2740</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469686</data>
    </node>
    <node id="Xor Instruction">
      <data key="d0">Xor Instruction</data>
      <data key="d1">method</data>
      <data key="d2">The xor instruction performs a bitwise logical XOR operation between two operands, storing the result in the first operand.</data>
      <data key="d3">chunk-be143027fbd9f62579107c5fcd0f2740</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469689</data>
    </node>
    <node id="Neg Instruction">
      <data key="d0">Neg Instruction</data>
      <data key="d1">method</data>
      <data key="d2">The neg instruction computes the twoâ€™s complement of the operand, effectively changing its sign.</data>
      <data key="d3">chunk-be143027fbd9f62579107c5fcd0f2740</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469689</data>
    </node>
    <node id="Shr Instruction">
      <data key="d0">Shr Instruction</data>
      <data key="d1">method</data>
      <data key="d2">The shr instruction performs a logical right shift on the operand, shifting bits to the right by a specified number of positions.</data>
      <data key="d3">chunk-be143027fbd9f62579107c5fcd0f2740</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469689</data>
    </node>
    <node id="Constant">
      <data key="d0">Constant</data>
      <data key="d1">data</data>
      <data key="d2">A constant is a fixed value used in operations, such as integers or hexadecimal literals, that remains unchanged during execution.&lt;SEP&gt;Constant is a fixed value used in assembly language instructions, which remains unchanged during program execution.</data>
      <data key="d3">chunk-3c363f9d809dadcf3a7c0f9008fb810a&lt;SEP&gt;chunk-be143027fbd9f62579107c5fcd0f2740</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469950</data>
    </node>
    <node id="Eax Register">
      <data key="d0">Eax Register</data>
      <data key="d1">artifact</data>
      <data key="d2">The eax register is a 32-bit general-purpose register used for arithmetic and data handling in x86 architecture.</data>
      <data key="d3">chunk-be143027fbd9f62579107c5fcd0f2740</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469692</data>
    </node>
    <node id="Esi Register">
      <data key="d0">Esi Register</data>
      <data key="d1">artifact</data>
      <data key="d2">The esi register is a 32-bit general-purpose register used for addressing and data manipulation in x86 architecture.</data>
      <data key="d3">chunk-be143027fbd9f62579107c5fcd0f2740</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469692</data>
    </node>
    <node id="Edx Register">
      <data key="d0">Edx Register</data>
      <data key="d1">artifact</data>
      <data key="d2">The edx register is a 32-bit general-purpose register used in arithmetic operations and for holding the high-order bits of a 64-bit result.</data>
      <data key="d3">chunk-be143027fbd9f62579107c5fcd0f2740</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469692</data>
    </node>
    <node id="Byte Ptr">
      <data key="d0">Byte Ptr</data>
      <data key="d1">artifact</data>
      <data key="d2">Byte ptr is a memory addressing qualifier indicating that the operand refers to a single byte of memory.&lt;SEP&gt;In Intel format, 'byte ptr' is used to explicitly specify a byte-sized operand.</data>
      <data key="d3">chunk-53c922e8f9c9847391088bcc3c5430ac&lt;SEP&gt;chunk-be143027fbd9f62579107c5fcd0f2740</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469807</data>
    </node>
    <node id="Dword Ptr">
      <data key="d0">Dword Ptr</data>
      <data key="d1">artifact</data>
      <data key="d2">Dword ptr is a memory addressing qualifier indicating that the operand refers to a 4-byte (32-bit) value in memory.&lt;SEP&gt;dword ptr is a memory addressing directive in x86 assembly that specifies a 32-bit (4-byte) operand size.&lt;SEP&gt;In Intel format, 'dword ptr' is used to explicitly specify a double-word-sized operand.</data>
      <data key="d3">chunk-dc66410ab81cdb2a13f279e50457a470&lt;SEP&gt;chunk-53c922e8f9c9847391088bcc3c5430ac&lt;SEP&gt;chunk-be143027fbd9f62579107c5fcd0f2740</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469808</data>
    </node>
    <node id="Var">
      <data key="d0">Var</data>
      <data key="d1">data</data>
      <data key="d2">Var is a symbolic reference to a memory location used to store data, typically a variable.</data>
      <data key="d3">chunk-be143027fbd9f62579107c5fcd0f2740</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469692</data>
    </node>
    <node id="0fH">
      <data key="d0">0fH</data>
      <data key="d1">data</data>
      <data key="d2">The value 0fH is a hexadecimal constant used in bitwise operations.</data>
      <data key="d3">chunk-be143027fbd9f62579107c5fcd0f2740</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469692</data>
    </node>
    <node id="32-Bit Integer">
      <data key="d0">32-Bit Integer</data>
      <data key="d1">concept</data>
      <data key="d2">A 32-bit integer is a data type representing signed or unsigned integers using 32 bits of storage.</data>
      <data key="d3">chunk-be143027fbd9f62579107c5fcd0f2740</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469692</data>
    </node>
    <node id="Signed Integer">
      <data key="d0">Signed Integer</data>
      <data key="d1">concept</data>
      <data key="d2">A signed integer is a number that can represent both positive and negative values, typically stored in twoâ€™s complement form.</data>
      <data key="d3">chunk-be143027fbd9f62579107c5fcd0f2740</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469695</data>
    </node>
    <node id="Arithmetic Overflow">
      <data key="d0">Arithmetic Overflow</data>
      <data key="d1">concept</data>
      <data key="d2">Arithmetic overflow occurs when the result of an operation exceeds the maximum representable value in the storage format, causing the overflow flag to be set.</data>
      <data key="d3">chunk-be143027fbd9f62579107c5fcd0f2740</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469695</data>
    </node>
    <node id="Overflow Flag">
      <data key="d0">Overflow Flag</data>
      <data key="d1">artifact</data>
      <data key="d2">The overflow flag (OF) is a status bit in the processor's flag register indicating when an arithmetic operation results in overflow.&lt;SEP&gt;The Overflow Flag is a condition code in the CPU Status Word that is set when an arithmetic operation produces a result that exceeds the range of the data type.</data>
      <data key="d3">chunk-dc66410ab81cdb2a13f279e50457a470&lt;SEP&gt;chunk-be143027fbd9f62579107c5fcd0f2740</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469785</data>
    </node>
    <node id="64-Bit Value">
      <data key="d0">64-Bit Value</data>
      <data key="d1">concept</data>
      <data key="d2">A 64-bit value is a data representation using 64 binary digits, used in operations like division where edx:eax is treated as a single 64-bit operand.</data>
      <data key="d3">chunk-be143027fbd9f62579107c5fcd0f2740</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469695</data>
    </node>
    <node id="Two's Complement">
      <data key="d0">Two's Complement</data>
      <data key="d1">concept</data>
      <data key="d2">Twoâ€™s complement is a method used to represent signed integers in binary, enabling efficient arithmetic operations.&lt;SEP&gt;Two's complement is a binary representation method for signed integers, used to represent negative numbers and immediate values in addressing.</data>
      <data key="d3">chunk-ee7b048d8f7d4f6a7cdb8bd206b3d9c3&lt;SEP&gt;chunk-be143027fbd9f62579107c5fcd0f2740</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469928</data>
    </node>
    <node id="Division Result">
      <data key="d0">Division Result</data>
      <data key="d1">concept</data>
      <data key="d2">The division result consists of two components: the quotient and the remainder, produced by the idiv instruction.</data>
      <data key="d3">chunk-be143027fbd9f62579107c5fcd0f2740</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469695</data>
    </node>
    <node id="Variable">
      <data key="d0">Variable</data>
      <data key="d3">chunk-be143027fbd9f62579107c5fcd0f2740</data>
      <data key="d2">The variable 'var' is a symbolic name representing a memory address used to store data.</data>
      <data key="d1">UNKNOWN</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469706</data>
    </node>
    <node id="Logic Operation">
      <data key="d0">Logic Operation</data>
      <data key="d3">chunk-be143027fbd9f62579107c5fcd0f2740</data>
      <data key="d2">The and instruction implements a logical AND operation between two operands.</data>
      <data key="d1">UNKNOWN</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469707</data>
    </node>
    <node id="Exception Handling">
      <data key="d0">Exception Handling</data>
      <data key="d3">chunk-be143027fbd9f62579107c5fcd0f2740</data>
      <data key="d2">The overflow flag being set triggers an interrupt or exception handler for overflow conditions.</data>
      <data key="d1">UNKNOWN</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469709</data>
    </node>
    <node id="x86 Processor">
      <data key="d0">x86 Processor</data>
      <data key="d1">artifact</data>
      <data key="d2">The x86 processor is a type of central processing unit that manages instruction execution and maintains an instruction pointer (IP) to track the current instruction.</data>
      <data key="d3">chunk-dc66410ab81cdb2a13f279e50457a470</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469779</data>
    </node>
    <node id="Instruction Pointer">
      <data key="d0">Instruction Pointer</data>
      <data key="d1">artifact</data>
      <data key="d2">The Instruction Pointer (IP) is a register in the x86 processor that holds the address of the next instruction to be executed.</data>
      <data key="d3">chunk-dc66410ab81cdb2a13f279e50457a470</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469779</data>
    </node>
    <node id="Label">
      <data key="d0">Label</data>
      <data key="d1">concept</data>
      <data key="d2">A label is a symbolic name used in x86 assembly code to mark a specific instruction address for control flow purposes.</data>
      <data key="d3">chunk-dc66410ab81cdb2a13f279e50457a470</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469779</data>
    </node>
    <node id="jmp Instruction">
      <data key="d0">jmp Instruction</data>
      <data key="d1">method</data>
      <data key="d2">The jmp instruction is a control flow instruction that unconditionally transfers execution to a labeled instruction address.</data>
      <data key="d3">chunk-dc66410ab81cdb2a13f279e50457a470</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469779</data>
    </node>
    <node id="jcondition Instruction">
      <data key="d0">jcondition Instruction</data>
      <data key="d1">method</data>
      <data key="d2">The jcondition instructions are conditional jump instructions that transfer execution based on the condition codes set in the CPU status word.</data>
      <data key="d3">chunk-dc66410ab81cdb2a13f279e50457a470</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469779</data>
    </node>
    <node id="cmp Instruction">
      <data key="d0">cmp Instruction</data>
      <data key="d1">method</data>
      <data key="d2">The cmp instruction compares two operands by performing a subtraction without storing the result, setting CPU status flags for conditional jumps.</data>
      <data key="d3">chunk-dc66410ab81cdb2a13f279e50457a470</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469779</data>
    </node>
    <node id="test Instruction">
      <data key="d0">test Instruction</data>
      <data key="d1">method</data>
      <data key="d2">The test instruction performs a bitwise AND operation on two operands without storing the result, only updating the CPU status flags.</data>
      <data key="d3">chunk-dc66410ab81cdb2a13f279e50457a470</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469779</data>
    </node>
    <node id="call Instruction">
      <data key="d0">call Instruction</data>
      <data key="d1">method</data>
      <data key="d2">The call instruction invokes a subroutine by pushing the return address onto the stack and transferring control to a labeled instruction.</data>
      <data key="d3">chunk-dc66410ab81cdb2a13f279e50457a470</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469779</data>
    </node>
    <node id="ret Instruction">
      <data key="d0">ret Instruction</data>
      <data key="d1">method</data>
      <data key="d2">The ret instruction returns from a subroutine by popping the stored return address from the stack and transferring control to that address.</data>
      <data key="d3">chunk-dc66410ab81cdb2a13f279e50457a470</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469782</data>
    </node>
    <node id="CPU Status Word">
      <data key="d0">CPU Status Word</data>
      <data key="d1">artifact</data>
      <data key="d2">The CPU Status Word is a register that contains condition codes, such as zero flag (ZF), negative flag, and overflow flag, reflecting the results of arithmetic and logical operations.</data>
      <data key="d3">chunk-dc66410ab81cdb2a13f279e50457a470</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469782</data>
    </node>
    <node id="Subroutine">
      <data key="d0">Subroutine</data>
      <data key="d1">concept</data>
      <data key="d2">A subroutine is a sequence of instructions that performs a specific task and can be called and returned from during program execution.</data>
      <data key="d3">chunk-dc66410ab81cdb2a13f279e50457a470</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469782</data>
    </node>
    <node id="x86 Assembly Code">
      <data key="d0">x86 Assembly Code</data>
      <data key="d1">content</data>
      <data key="d2">x86 assembly code is a low-level programming language used to write instructions specific to the x86 processor architecture.</data>
      <data key="d3">chunk-dc66410ab81cdb2a13f279e50457a470</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469782</data>
    </node>
    <node id="Logical Operation">
      <data key="d0">Logical Operation</data>
      <data key="d1">concept</data>
      <data key="d2">A logical operation is a computation on binary data, such as AND, OR, and XOR, that evaluates bits for conditional outcomes.</data>
      <data key="d3">chunk-dc66410ab81cdb2a13f279e50457a470</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469782</data>
    </node>
    <node id="Zero Flag">
      <data key="d0">Zero Flag</data>
      <data key="d1">artifact</data>
      <data key="d2">The Zero Flag (ZF) is a condition code in the CPU Status Word that is set when the result of an arithmetic or logical operation is zero.</data>
      <data key="d3">chunk-dc66410ab81cdb2a13f279e50457a470</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469785</data>
    </node>
    <node id="Negative Flag">
      <data key="d0">Negative Flag</data>
      <data key="d1">artifact</data>
      <data key="d2">The Negative Flag is a condition code in the CPU Status Word that is set when the result of an operation is negative.</data>
      <data key="d3">chunk-dc66410ab81cdb2a13f279e50457a470</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469785</data>
    </node>
    <node id="Conditional Code">
      <data key="d0">Conditional Code</data>
      <data key="d1">concept</data>
      <data key="d2">Conditional codes are status bits in the CPU Status Word that reflect the outcome of previous operations, used to control conditional jumps.</data>
      <data key="d3">chunk-dc66410ab81cdb2a13f279e50457a470</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469785</data>
    </node>
    <node id="Bitwise And Operation">
      <data key="d0">Bitwise And Operation</data>
      <data key="d1">method</data>
      <data key="d2">The bitwise AND operation performs a logical AND on each pair of corresponding bits of two operands, used to test individual bit states.</data>
      <data key="d3">chunk-dc66410ab81cdb2a13f279e50457a470</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469785</data>
    </node>
    <node id="Subtraction Operation">
      <data key="d0">Subtraction Operation</data>
      <data key="d1">method</data>
      <data key="d2">The subtraction operation computes the difference between two operands, used by the cmp instruction to determine relative magnitude.</data>
      <data key="d3">chunk-dc66410ab81cdb2a13f279e50457a470</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469785</data>
    </node>
    <node id="Main Memory Address">
      <data key="d0">Main Memory Address</data>
      <data key="d1">data</data>
      <data key="d2">A Main Memory Address is a numerical identifier assigned to a location in main memory where data or instructions are stored.</data>
      <data key="d3">chunk-dc66410ab81cdb2a13f279e50457a470</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469785</data>
    </node>
    <node id="jz Instruction">
      <data key="d0">jz Instruction</data>
      <data key="d3">chunk-dc66410ab81cdb2a13f279e50457a470</data>
      <data key="d2">The jz instruction jumps when the Zero Flag is set, indicating a zero result from the last operation.</data>
      <data key="d1">UNKNOWN</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469796</data>
    </node>
    <node id="jg Instruction">
      <data key="d0">jg Instruction</data>
      <data key="d3">chunk-dc66410ab81cdb2a13f279e50457a470</data>
      <data key="d2">The jg instruction jumps when the result is greater than, based on the sign and zero flags.</data>
      <data key="d1">UNKNOWN</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469797</data>
    </node>
    <node id="je Instruction">
      <data key="d0">je Instruction</data>
      <data key="d3">chunk-dc66410ab81cdb2a13f279e50457a470</data>
      <data key="d2">The je instruction jumps when the Zero Flag is set, indicating the operands are equal.</data>
      <data key="d1">UNKNOWN</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469798</data>
    </node>
    <node id="jge Instruction">
      <data key="d0">jge Instruction</data>
      <data key="d3">chunk-dc66410ab81cdb2a13f279e50457a470</data>
      <data key="d2">The jge instruction jumps when the result is greater than or equal, utilizing the sign and zero flags.</data>
      <data key="d1">UNKNOWN</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469799</data>
    </node>
    <node id="dword ptr">
      <data key="d0">dword ptr</data>
      <data key="d3">chunk-dc66410ab81cdb2a13f279e50457a470</data>
      <data key="d2">The dword ptr directive specifies a 32-bit memory operand whose address is accessed from main memory.</data>
      <data key="d1">UNKNOWN</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469800</data>
    </node>
    <node id="jne Instruction">
      <data key="d0">jne Instruction</data>
      <data key="d3">chunk-dc66410ab81cdb2a13f279e50457a470</data>
      <data key="d2">The jne instruction jumps when the Zero Flag is not set, indicating the operands are not equal.</data>
      <data key="d1">UNKNOWN</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469800</data>
    </node>
    <node id="jl Instruction">
      <data key="d0">jl Instruction</data>
      <data key="d3">chunk-dc66410ab81cdb2a13f279e50457a470</data>
      <data key="d2">The jl instruction jumps when the result is less than, based on the sign flag.</data>
      <data key="d1">UNKNOWN</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469801</data>
    </node>
    <node id="jle Instruction">
      <data key="d0">jle Instruction</data>
      <data key="d3">chunk-dc66410ab81cdb2a13f279e50457a470</data>
      <data key="d2">The jle instruction jumps when the result is less than or equal, based on sign and zero flags.</data>
      <data key="d1">UNKNOWN</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469802</data>
    </node>
    <node id="AT&amp;T Format">
      <data key="d0">AT&amp;T Format</data>
      <data key="d1">method</data>
      <data key="d2">AT&amp;T format is a style of assembly language syntax that uses lowercase letters, specifies source operand first, and requires prefix symbols like % for registers and $ for immediate values.</data>
      <data key="d3">chunk-53c922e8f9c9847391088bcc3c5430ac</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469805</data>
    </node>
    <node id="Intel Format">
      <data key="d0">Intel Format</data>
      <data key="d1">method</data>
      <data key="d2">Intel format is a style of assembly language syntax that is case-insensitive, specifies destination operand first, and does not require prefix symbols for registers or immediate values.&lt;SEP&gt;Intel Format is a syntax style used to represent assembly instructions, particularly in x86 assembly language.</data>
      <data key="d3">chunk-3c363f9d809dadcf3a7c0f9008fb810a&lt;SEP&gt;chunk-53c922e8f9c9847391088bcc3c5430ac</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469950</data>
    </node>
    <node id="Assembly Instructions">
      <data key="d0">Assembly Instructions</data>
      <data key="d1">concept</data>
      <data key="d2">Assembly instructions are low-level commands used in programming that define operations performed by a computer's processor.</data>
      <data key="d3">chunk-53c922e8f9c9847391088bcc3c5430ac</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469805</data>
    </node>
    <node id="Register Prefix">
      <data key="d0">Register Prefix</data>
      <data key="d1">artifact</data>
      <data key="d2">The register prefix '%' is used in AT&amp;T format to denote register operands.</data>
      <data key="d3">chunk-53c922e8f9c9847391088bcc3c5430ac</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469805</data>
    </node>
    <node id="Immediate Value Prefix">
      <data key="d0">Immediate Value Prefix</data>
      <data key="d1">artifact</data>
      <data key="d2">The immediate value prefix '$' is used in AT&amp;T format to denote immediate values.</data>
      <data key="d3">chunk-53c922e8f9c9847391088bcc3c5430ac</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469805</data>
    </node>
    <node id="Memory Addressing Parentheses">
      <data key="d0">Memory Addressing Parentheses</data>
      <data key="d1">artifact</data>
      <data key="d2">In AT&amp;T format, memory addressing uses parentheses '(' and ')' to denote indirect addressing.</data>
      <data key="d3">chunk-53c922e8f9c9847391088bcc3c5430ac</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469805</data>
    </node>
    <node id="Memory Addressing Brackets">
      <data key="d0">Memory Addressing Brackets</data>
      <data key="d1">artifact</data>
      <data key="d2">In Intel format, memory addressing uses brackets '[' and ']' to denote indirect addressing.</data>
      <data key="d3">chunk-53c922e8f9c9847391088bcc3c5430ac</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469805</data>
    </node>
    <node id="Data Size Suffix">
      <data key="d0">Data Size Suffix</data>
      <data key="d1">artifact</data>
      <data key="d2">In AT&amp;T format, data size is indicated by suffixes like 'b' for byte, 'w' for word, and 'l' for long.</data>
      <data key="d3">chunk-53c922e8f9c9847391088bcc3c5430ac</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469805</data>
    </node>
    <node id="Word Ptr">
      <data key="d0">Word Ptr</data>
      <data key="d1">artifact</data>
      <data key="d2">In Intel format, 'word ptr' is used to explicitly specify a word-sized operand.</data>
      <data key="d3">chunk-53c922e8f9c9847391088bcc3c5430ac</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469808</data>
    </node>
    <node id="Word">
      <data key="d0">Word</data>
      <data key="d1">concept</data>
      <data key="d2">A word is a unit of data size representing 16 bits, historically derived from the 16-bit architecture and used in both 32-bit and 64-bit systems.</data>
      <data key="d3">chunk-53c922e8f9c9847391088bcc3c5430ac</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469808</data>
    </node>
    <node id="32-Bit Architecture">
      <data key="d0">32-Bit Architecture</data>
      <data key="d1">naturalobject</data>
      <data key="d2">The 32-bit architecture is a computing architecture that extends from the 16-bit system, with a word size of 16 bits.</data>
      <data key="d3">chunk-53c922e8f9c9847391088bcc3c5430ac</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469808</data>
    </node>
    <node id="64-Bit Architecture">
      <data key="d0">64-Bit Architecture</data>
      <data key="d1">naturalobject</data>
      <data key="d2">The 64-bit architecture is a computing architecture that extends from the 16-bit system, with a word size of 16 bits, and supports larger data and address spaces.</data>
      <data key="d3">chunk-53c922e8f9c9847391088bcc3c5430ac</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469808</data>
    </node>
    <node id="æ‰©å±•æ“ä½œç æŒ‡ä»¤æ ¼å¼">
      <data key="d0">æ‰©å±•æ“ä½œç æŒ‡ä»¤æ ¼å¼</data>
      <data key="d1">method</data>
      <data key="d2">The extension opcode instruction format is a technique used in instruction set design to allow variable-length opcodes, enabling a rich variety of instructions within a limited instruction word length.</data>
      <data key="d3">chunk-0d36c83754193098d8c62f2f838760fe</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469876</data>
    </node>
    <node id="å¯å˜é•¿åº¦æ“ä½œç ">
      <data key="d0">å¯å˜é•¿åº¦æ“ä½œç </data>
      <data key="d1">concept</data>
      <data key="d2">Variable-length opcode is a method where the opcode field length differs across instructions and is distributed across different positions in the instruction word.</data>
      <data key="d3">chunk-0d36c83754193098d8c62f2f838760fe</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469876</data>
    </node>
    <node id="æŒ‡ä»¤å­—é•¿">
      <data key="d0">æŒ‡ä»¤å­—é•¿</data>
      <data key="d1">concept</data>
      <data key="d2">Instruction word length refers to the fixed size of an instruction that constrains how much information, including opcode and operands, can be encoded within a single instruction.</data>
      <data key="d3">chunk-0d36c83754193098d8c62f2f838760fe</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469876</data>
    </node>
    <node id="æŒ‡ä»¤è¯‘ç ">
      <data key="d0">æŒ‡ä»¤è¯‘ç </data>
      <data key="d1">concept</data>
      <data key="d2">Instruction decoding is the process of interpreting the opcode and operands in an instruction to determine the operation to be performed.</data>
      <data key="d3">chunk-0d36c83754193098d8c62f2f838760fe</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469876</data>
    </node>
    <node id="æŽ§åˆ¶å™¨è®¾è®¡">
      <data key="d0">æŽ§åˆ¶å™¨è®¾è®¡</data>
      <data key="d1">concept</data>
      <data key="d2">Controller design refers to the hardware or logic circuitry responsible for managing instruction execution in a processor.</data>
      <data key="d3">chunk-0d36c83754193098d8c62f2f838760fe</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469876</data>
    </node>
    <node id="æ‰©å±•æ“ä½œç ">
      <data key="d0">æ‰©å±•æ“ä½œç </data>
      <data key="d1">method</data>
      <data key="d2">Extension opcode is the most common method of variable-length opcodes, where opcode length increases as the number of address fields decreases.</data>
      <data key="d3">chunk-0d36c83754193098d8c62f2f838760fe</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469876</data>
    </node>
    <node id="åœ°å€ç ">
      <data key="d0">åœ°å€ç </data>
      <data key="d1">concept</data>
      <data key="d2">Address code refers to the portion of an instruction that specifies operand addresses.</data>
      <data key="d3">chunk-0d36c83754193098d8c62f2f838760fe</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469876</data>
    </node>
    <node id="çŸ­ç ">
      <data key="d0">çŸ­ç </data>
      <data key="d1">concept</data>
      <data key="d2">Short code refers to opcode representations with fewer bits, typically assigned to high-frequency instructions.</data>
      <data key="d3">chunk-0d36c83754193098d8c62f2f838760fe</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469876</data>
    </node>
    <node id="é•¿ç ">
      <data key="d0">é•¿ç </data>
      <data key="d1">concept</data>
      <data key="d2">Long code refers to opcode representations with more bits, typically assigned to low-frequency instructions.</data>
      <data key="d3">chunk-0d36c83754193098d8c62f2f838760fe</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469879</data>
    </node>
    <node id="æ“ä½œç é‡å¤">
      <data key="d0">æ“ä½œç é‡å¤</data>
      <data key="d1">concept</data>
      <data key="d2">Operation code duplication occurs when two or more instructions have identical opcodes, leading to ambiguity in decoding.</data>
      <data key="d3">chunk-0d36c83754193098d8c62f2f838760fe</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469879</data>
    </node>
    <node id="ä½¿ç”¨é¢‘çŽ‡">
      <data key="d0">ä½¿ç”¨é¢‘çŽ‡</data>
      <data key="d1">concept</data>
      <data key="d2">Instruction usage frequency is a metric that indicates how often a particular instruction is executed, influencing opcode assignment.</data>
      <data key="d3">chunk-0d36c83754193098d8c62f2f838760fe</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469879</data>
    </node>
    <node id="æŒ‡ä»¤è¯‘ç å’Œåˆ†æžæ—¶é—´">
      <data key="d0">æŒ‡ä»¤è¯‘ç å’Œåˆ†æžæ—¶é—´</data>
      <data key="d1">concept</data>
      <data key="d2">Instruction decoding and analysis time is the duration required to interpret and process an instruction during execution.</data>
      <data key="d3">chunk-0d36c83754193098d8c62f2f838760fe</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469879</data>
    </node>
    <node id="è®¾è®¡æ‰©å±•æ“ä½œç æŒ‡ä»¤æ ¼å¼">
      <data key="d0">è®¾è®¡æ‰©å±•æ“ä½œç æŒ‡ä»¤æ ¼å¼</data>
      <data key="d1">method</data>
      <data key="d2">The design of the extension opcode instruction format involves strategic allocation of opcode lengths based on operand count and instruction frequency to optimize instruction encoding and minimize decoding complexity.</data>
      <data key="d3">chunk-0d36c83754193098d8c62f2f838760fe</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469879</data>
    </node>
    <node id="ä¸å…è®¸æ˜¯é•¿ç çš„å‰ç¼€">
      <data key="d0">ä¸å…è®¸æ˜¯é•¿ç çš„å‰ç¼€</data>
      <data key="d3">chunk-0d36c83754193098d8c62f2f838760fe</data>
      <data key="d2">Short codes must not be the prefix of longer codes to prevent ambiguity in instruction decoding.</data>
      <data key="d1">UNKNOWN</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469881</data>
    </node>
    <node id="ç¦æ­¢">
      <data key="d0">ç¦æ­¢</data>
      <data key="d3">chunk-0d36c83754193098d8c62f2f838760fe</data>
      <data key="d2">Operational codes must be unique across all instructions to avoid decoding errors.</data>
      <data key="d1">UNKNOWN</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469881</data>
    </node>
    <node id="æ“ä½œç åˆ†é…">
      <data key="d0">æ“ä½œç åˆ†é…</data>
      <data key="d3">chunk-0d36c83754193098d8c62f2f838760fe</data>
      <data key="d2">Higher frequency instructions are assigned shorter opcodes to minimize decoding time.</data>
      <data key="d1">UNKNOWN</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469881</data>
    </node>
    <node id="çŸ­ç åˆ†é…">
      <data key="d0">çŸ­ç åˆ†é…</data>
      <data key="d3">chunk-0d36c83754193098d8c62f2f838760fe</data>
      <data key="d2">Assigning shorter opcodes to frequently used instructions reduces the average time needed for instruction decoding and analysis.</data>
      <data key="d1">UNKNOWN</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469883</data>
    </node>
    <node id="å˜å€å¯„å­˜å™¨">
      <data key="d0">å˜å€å¯„å­˜å™¨</data>
      <data key="d1">artifact</data>
      <data key="d2">å˜å€å¯„å­˜å™¨is a register used by users to modify offset values during program execution, enabling flexible address calculation with a fixed base address.</data>
      <data key="d3">chunk-be1b12c159545a6c843eae8f022b80e2</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469920</data>
    </node>
    <node id="å½¢å¼åœ°å€A">
      <data key="d0">å½¢å¼åœ°å€A</data>
      <data key="d1">data</data>
      <data key="d2">å½¢å¼åœ°å€A is the base address in indexed addressing, which remains unchanged while the index register is modified to access different memory locations.</data>
      <data key="d3">chunk-be1b12c159545a6c843eae8f022b80e2</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469920</data>
    </node>
    <node id="åç§»é‡">
      <data key="d0">åç§»é‡</data>
      <data key="d1">data</data>
      <data key="d2">åç§»é‡refers to the value stored in the index register IX, used to form effective addresses by adding to the base address A.</data>
      <data key="d3">chunk-be1b12c159545a6c843eae8f022b80e2</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469920</data>
    </node>
    <node id="ç¢³çº¤ç»´é’‰">
      <data key="d0">ç¢³çº¤ç»´é’‰</data>
      <data key="d1">artifact</data>
      <data key="d2">Carbon-fiber spikes are advanced athletic footwear designed to improve sprint performance through enhanced traction and speed.</data>
      <data key="d3">chunk-be1b12c159545a6c843eae8f022b80e2</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469920</data>
    </node>
    <node id="æ•°ç»„é¦–åœ°å€">
      <data key="d0">æ•°ç»„é¦–åœ°å€</data>
      <data key="d1">data</data>
      <data key="d2">æ•°ç»„é¦–åœ°å€is the starting memory address of an array, used as a base value in indexed addressing for accessing array elements.</data>
      <data key="d3">chunk-be1b12c159545a6c843eae8f022b80e2</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469920</data>
    </node>
    <node id="å †æ ˆæŒ‡é’ˆSP">
      <data key="d0">å †æ ˆæŒ‡é’ˆSP</data>
      <data key="d1">artifact</data>
      <data key="d2">å †æ ˆæŒ‡é’ˆSP is a specific register that holds the address of the top of the stack, automatically updated during push and pop operations.</data>
      <data key="d3">chunk-be1b12c159545a6c843eae8f022b80e2</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469920</data>
    </node>
    <node id="ç¡¬å †æ ˆ">
      <data key="d0">ç¡¬å †æ ˆ</data>
      <data key="d1">artifact</data>
      <data key="d2">ç¡¬å †æ ˆis a stack implemented using dedicated hardware registers, high cost but fast access, not suitable for large capacity.</data>
      <data key="d3">chunk-be1b12c159545a6c843eae8f022b80e2</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469920</data>
    </node>
    <node id="è½¯å †æ ˆ">
      <data key="d0">è½¯å †æ ˆ</data>
      <data key="d1">artifact</data>
      <data key="d2">è½¯å †æ ˆis a stack implemented in main memory, cost-effective and commonly used, especially for large storage needs.</data>
      <data key="d3">chunk-be1b12c159545a6c843eae8f022b80e2</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469920</data>
    </node>
    <node id="åŽè¿›å…ˆå‡ºåŽŸåˆ™">
      <data key="d0">åŽè¿›å…ˆå‡ºåŽŸåˆ™</data>
      <data key="d1">concept</data>
      <data key="d2">åŽè¿›å…ˆå‡ºåŽŸåˆ™is a data management principle where the last item stored is the first one retrieved, defining stack operations.</data>
      <data key="d3">chunk-be1b12c159545a6c843eae8f022b80e2</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469922</data>
    </node>
    <node id="å¯„å­˜å™¨ç»„">
      <data key="d0">å¯„å­˜å™¨ç»„</data>
      <data key="d1">artifact</data>
      <data key="d2">å¯„å­˜å™¨ç»„is a collection of registers used for fast data access and temporary storage in computer architecture.</data>
      <data key="d3">chunk-be1b12c159545a6c843eae8f022b80e2</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469923</data>
    </node>
    <node id="æ— æ“ä½œæ•°æŒ‡ä»¤">
      <data key="d0">æ— æ“ä½œæ•°æŒ‡ä»¤</data>
      <data key="d1">method</data>
      <data key="d2">æ— æ“ä½œæ•°æŒ‡ä»¤refers to instructions that do not explicitly specify operands, as the operands are implicitly managed via the stack pointer SP.</data>
      <data key="d3">chunk-be1b12c159545a6c843eae8f022b80e2</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469923</data>
    </node>
    <node id="è¯»/å†™å †æ ˆ">
      <data key="d0">è¯»/å†™å †æ ˆ</data>
      <data key="d1">method</data>
      <data key="d2">è¯»/å†™å †æ ˆis an operation that accesses stack memory, automatically adjusting the stack pointer SP during data retrieval or storage.</data>
      <data key="d3">chunk-be1b12c159545a6c843eae8f022b80e2</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469923</data>
    </node>
    <node id="è‡ªåŠ¨å®Œæˆå¯¹SPçš„åŠ å‡æ“ä½œ">
      <data key="d0">è‡ªåŠ¨å®Œæˆå¯¹SPçš„åŠ å‡æ“ä½œ</data>
      <data key="d1">method</data>
      <data key="d2">è‡ªåŠ¨å®Œæˆå¯¹SPçš„åŠ å‡æ“ä½œrefers to the automatic increment or decrement of the stack pointer SP during stack push or pop operations.</data>
      <data key="d3">chunk-be1b12c159545a6c843eae8f022b80e2</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469923</data>
    </node>
    <node id="å¯„å­˜å™¨">
      <data key="d0">å¯„å­˜å™¨</data>
      <data key="d1">artifact</data>
      <data key="d2">å¯„å­˜å™¨is a small, fast storage location in a computer's processor used to hold data temporarily during processing.</data>
      <data key="d3">chunk-be1b12c159545a6c843eae8f022b80e2</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469923</data>
    </node>
    <node id="é€šç”¨å¯„å­˜å™¨">
      <data key="d0">é€šç”¨å¯„å­˜å™¨</data>
      <data key="d1">artifact</data>
      <data key="d2">é€šç”¨å¯„å­˜å™¨is a type of register that can be used for general-purpose operations, including as an index register in addressing modes.&lt;SEP&gt;é€šç”¨å¯„å­˜å™¨are general-purpose registers used for storing data and operands, with the number limited by the form address length in register addressing mode.</data>
      <data key="d3">chunk-aff2d7d8604331c974d095c01133c056&lt;SEP&gt;chunk-be1b12c159545a6c843eae8f022b80e2</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761470004</data>
    </node>
    <node id="å­˜å‚¨ç©ºé—´">
      <data key="d0">å­˜å‚¨ç©ºé—´</data>
      <data key="d1">concept</data>
      <data key="d2">å­˜å‚¨ç©ºé—´refers to the total amount of memory available for data storage and access in a computer system.</data>
      <data key="d3">chunk-be1b12c159545a6c843eae8f022b80e2</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469923</data>
    </node>
    <node id="Implicit Addressing">
      <data key="d0">Implicit Addressing</data>
      <data key="d1">method</data>
      <data key="d2">Implicit addressing is a type of instruction format where the operand address is not explicitly stated but implied, such as using the accumulator (ACC) as the second operand in a single-address instruction.</data>
      <data key="d3">chunk-ee7b048d8f7d4f6a7cdb8bd206b3d9c3</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469925</data>
    </node>
    <node id="Immediate Addressing">
      <data key="d0">Immediate Addressing</data>
      <data key="d1">method</data>
      <data key="d2">Immediate addressing specifies that the address field contains the operand itself (immediate value), represented in twoâ€™s complement form, enabling fast execution without memory access.</data>
      <data key="d3">chunk-ee7b048d8f7d4f6a7cdb8bd206b3d9c3</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469925</data>
    </node>
    <node id="Indirect Addressing">
      <data key="d0">Indirect Addressing</data>
      <data key="d1">method</data>
      <data key="d2">Indirect addressing uses the address field to point to the location containing the effective address of the operand, requiring multiple memory accesses and offering expanded address range.</data>
      <data key="d3">chunk-ee7b048d8f7d4f6a7cdb8bd206b3d9c3</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469925</data>
    </node>
    <node id="Register Addressing">
      <data key="d0">Register Addressing</data>
      <data key="d1">method</data>
      <data key="d2">Register addressing specifies the operandâ€™s location via a register number, where the effective address is the register content (EA = R), enabling fast execution without memory access.</data>
      <data key="d3">chunk-ee7b048d8f7d4f6a7cdb8bd206b3d9c3</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469925</data>
    </node>
    <node id="Register Indirect Addressing">
      <data key="d0">Register Indirect Addressing</data>
      <data key="d1">method</data>
      <data key="d2">Register indirect addressing combines features of indirect and register addressing, where the register holds the effective address of the operand, requiring only one memory access.</data>
      <data key="d3">chunk-ee7b048d8f7d4f6a7cdb8bd206b3d9c3</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469925</data>
    </node>
    <node id="Single-Address Instruction Format">
      <data key="d0">Single-Address Instruction Format</data>
      <data key="d1">method</data>
      <data key="d2">The single-address instruction format is a design where one operand is explicitly specified, and the second operand is implicitly provided by the accumulator (ACC), making ACC a default operand in such operations.</data>
      <data key="d3">chunk-ee7b048d8f7d4f6a7cdb8bd206b3d9c3</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469930</data>
    </node>
    <node id="Data Transfer Instructions">
      <data key="d0">Data Transfer Instructions</data>
      <data key="d1">concept</data>
      <data key="d2">Data Transfer Instructions are a category of assembly language instructions used to move data between registers, memory, and immediate values.</data>
      <data key="d3">chunk-3c363f9d809dadcf3a7c0f9008fb810a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469950</data>
    </node>
    <node id="Arithmetic and Logic Operations Instructions">
      <data key="d0">Arithmetic and Logic Operations Instructions</data>
      <data key="d1">concept</data>
      <data key="d2">Arithmetic and Logic Operations Instructions are a category of assembly language instructions that perform mathematical and logical computations.</data>
      <data key="d3">chunk-3c363f9d809dadcf3a7c0f9008fb810a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469950</data>
    </node>
    <node id="Control Flow Instructions">
      <data key="d0">Control Flow Instructions</data>
      <data key="d1">concept</data>
      <data key="d2">Control Flow Instructions are a category of assembly language instructions that manage the execution sequence, such as jumps and calls.</data>
      <data key="d3">chunk-3c363f9d809dadcf3a7c0f9008fb810a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469950</data>
    </node>
    <node id="Reg32">
      <data key="d0">Reg32</data>
      <data key="d1">artifact</data>
      <data key="d2">Reg32 refers to a 32-bit general-purpose register, such as eax, ebx, ecx, edx, esi, edi, esp, or ebp.</data>
      <data key="d3">chunk-3c363f9d809dadcf3a7c0f9008fb810a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469950</data>
    </node>
    <node id="Reg16">
      <data key="d0">Reg16</data>
      <data key="d1">artifact</data>
      <data key="d2">Reg16 refers to a 16-bit general-purpose register, such as ax, bx, cx, or dx.</data>
      <data key="d3">chunk-3c363f9d809dadcf3a7c0f9008fb810a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469952</data>
    </node>
    <node id="Reg8">
      <data key="d0">Reg8</data>
      <data key="d1">artifact</data>
      <data key="d2">Reg8 refers to an 8-bit general-purpose register, such as ah, al, bh, bl, ch, cl, dh, or dl.</data>
      <data key="d3">chunk-3c363f9d809dadcf3a7c0f9008fb810a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469953</data>
    </node>
    <node id="Mem">
      <data key="d0">Mem</data>
      <data key="d1">artifact</data>
      <data key="d2">Mem is a notation in assembly language representing a memory address, such as [eax], [var+4], or dword ptr [eax+ebx].</data>
      <data key="d3">chunk-3c363f9d809dadcf3a7c0f9008fb810a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469953</data>
    </node>
    <node id="Con8">
      <data key="d0">Con8</data>
      <data key="d1">data</data>
      <data key="d2">Con8 represents an 8-bit constant used in assembly instructions.</data>
      <data key="d3">chunk-3c363f9d809dadcf3a7c0f9008fb810a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469953</data>
    </node>
    <node id="Con16">
      <data key="d0">Con16</data>
      <data key="d1">data</data>
      <data key="d2">Con16 represents a 16-bit constant used in assembly instructions.</data>
      <data key="d3">chunk-3c363f9d809dadcf3a7c0f9008fb810a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469953</data>
    </node>
    <node id="Con32">
      <data key="d0">Con32</data>
      <data key="d1">data</data>
      <data key="d2">Con32 represents a 32-bit constant used in assembly instructions.</data>
      <data key="d3">chunk-3c363f9d809dadcf3a7c0f9008fb810a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761469953</data>
    </node>
    <node id="æ•°æ®å¯»å€">
      <data key="d0">æ•°æ®å¯»å€</data>
      <data key="d1">concept</data>
      <data key="d2">æ•°æ®å¯»å€refers to the method of representing or calculating the address of an operand in an instruction.</data>
      <data key="d3">chunk-aff2d7d8604331c974d095c01133c056</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761470001</data>
    </node>
    <node id="æ“ä½œç ">
      <data key="d0">æ“ä½œç </data>
      <data key="d1">artifact</data>
      <data key="d2">æ“ä½œç is the part of an instruction that specifies the operation to be performed.</data>
      <data key="d3">chunk-aff2d7d8604331c974d095c01133c056</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761470001</data>
    </node>
    <node id="å¯»å€ç‰¹å¾">
      <data key="d0">å¯»å€ç‰¹å¾</data>
      <data key="d1">artifact</data>
      <data key="d2">å¯»å€ç‰¹å¾is a field in the instruction word that indicates the addressing mode used.</data>
      <data key="d3">chunk-aff2d7d8604331c974d095c01133c056</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761470001</data>
    </node>
    <node id="å½¢å¼åœ°å€">
      <data key="d0">å½¢å¼åœ°å€</data>
      <data key="d1">data</data>
      <data key="d2">å½¢å¼åœ°å€is the address specified in the instruction, which is not the actual operand address and is denoted as A.</data>
      <data key="d3">chunk-aff2d7d8604331c974d095c01133c056</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761470001</data>
    </node>
    <node id="æœ‰æ•ˆåœ°å€">
      <data key="d0">æœ‰æ•ˆåœ°å€</data>
      <data key="d1">data</data>
      <data key="d2">æœ‰æ•ˆåœ°å€is the actual address of the operand in memory, calculated by combining the form address with the addressing mode.</data>
      <data key="d3">chunk-aff2d7d8604331c974d095c01133c056</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761470001</data>
    </node>
    <node id="ç«‹å³å¯»å€">
      <data key="d0">ç«‹å³å¯»å€</data>
      <data key="d1">method</data>
      <data key="d2">ç«‹å³å¯»å€is an addressing mode where the operand value is directly included in the instruction, with the value range determined by the form address length.</data>
      <data key="d3">chunk-aff2d7d8604331c974d095c01133c056</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761470001</data>
    </node>
    <node id="ç›´æŽ¥å¯»å€">
      <data key="d0">ç›´æŽ¥å¯»å€</data>
      <data key="d1">method</data>
      <data key="d2">ç›´æŽ¥å¯»å€is an addressing mode where the form address directly gives the operandâ€™s address in memory.</data>
      <data key="d3">chunk-aff2d7d8604331c974d095c01133c056</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761470001</data>
    </node>
    <node id="å¯„å­˜å™¨å¯»å€">
      <data key="d0">å¯„å­˜å™¨å¯»å€</data>
      <data key="d1">method</data>
      <data key="d2">å¯„å­˜å™¨å¯»å€is an addressing mode where the operand is in a register, and the form address determines the number of available general-purpose registers.</data>
      <data key="d3">chunk-aff2d7d8604331c974d095c01133c056</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761470001</data>
    </node>
    <node id="å¯„å­˜å™¨é—´æŽ¥å¯»å€">
      <data key="d0">å¯„å­˜å™¨é—´æŽ¥å¯»å€</data>
      <data key="d1">method</data>
      <data key="d2">å¯„å­˜å™¨é—´æŽ¥å¯»å€is an addressing mode where the register contains the address of the operand, and the register size determines the addressable range.</data>
      <data key="d3">chunk-aff2d7d8604331c974d095c01133c056</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761470003</data>
    </node>
    <node id="å­˜å‚¨å™¨">
      <data key="d0">å­˜å‚¨å™¨</data>
      <data key="d1">artifact</data>
      <data key="d2">å­˜å‚¨å™¨is the memory where operands are stored, and the effective address points to data within it.</data>
      <data key="d3">chunk-aff2d7d8604331c974d095c01133c056</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761470004</data>
    </node>
    <node id="æŒ‡ä»¤å­—">
      <data key="d0">æŒ‡ä»¤å­—</data>
      <data key="d1">artifact</data>
      <data key="d2">æŒ‡ä»¤å­—is the format of an instruction, consisting of operation code, addressing feature, and form address fields.</data>
      <data key="d3">chunk-aff2d7d8604331c974d095c01133c056</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761470004</data>
    </node>
    <node id="VLSI">
      <data key="d0">VLSI</data>
      <data key="d1">concept</data>
      <data key="d2">VLSI (Very Large Scale Integration) refers to the technology of integrating millions of transistors onto a single chip, enabling advanced processor design.</data>
      <data key="d3">chunk-2151538dd57e60dbb6761c6a35ea00c6</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761470014</data>
    </node>
    <node id="Combination Logic Control">
      <data key="d0">Combination Logic Control</data>
      <data key="d1">method</data>
      <data key="d2">Combination logic control is the method used in RISC architectures, implementing control logic through hardwired circuits for faster execution.</data>
      <data key="d3">chunk-2151538dd57e60dbb6761c6a35ea00c6</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761470014</data>
    </node>
    <node id="CPU Chip Area">
      <data key="d0">CPU Chip Area</data>
      <data key="d1">concept</data>
      <data key="d2">CPU chip area refers to the physical space on a processor chip occupied by various components, including control logic.</data>
      <data key="d3">chunk-2151538dd57e60dbb6761c6a35ea00c6</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761470014</data>
    </node>
    <node id="Instruction Set Complexity">
      <data key="d0">Instruction Set Complexity</data>
      <data key="d1">concept</data>
      <data key="d2">Instruction set complexity describes the number of instructions, addressing modes, and instruction formats in a processor architecture.</data>
      <data key="d3">chunk-2151538dd57e60dbb6761c6a35ea00c6</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761470014</data>
    </node>
    <node id="General Purpose Registers">
      <data key="d0">General Purpose Registers</data>
      <data key="d1">artifact</data>
      <data key="d2">General purpose registers are storage units in a processor used to hold data during execution, supporting fast access and efficient computation.</data>
      <data key="d3">chunk-2151538dd57e60dbb6761c6a35ea00c6</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761470014</data>
    </node>
    <node id="Pipeline Technology">
      <data key="d0">Pipeline Technology</data>
      <data key="d1">method</data>
      <data key="d2">Pipeline technology is a technique used in RISC processors that allows multiple instructions to be processed concurrently, improving throughput.</data>
      <data key="d3">chunk-2151538dd57e60dbb6761c6a35ea00c6</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761470017</data>
    </node>
    <node id="Compilation Optimization">
      <data key="d0">Compilation Optimization</data>
      <data key="d1">method</data>
      <data key="d2">Compilation optimization refers to the process of restructuring code to enhance execution efficiency, enabled by simpler instruction sets.</data>
      <data key="d3">chunk-2151538dd57e60dbb6761c6a35ea00c6</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761470017</data>
    </node>
    <edge source="Complex Instruction Set Computer" target="Integrated Circuit Technology">
      <data key="d6">1.0</data>
      <data key="d7">Advances in integrated circuit technology enabled the development of more complex instruction sets in CISC by allowing greater circuit density and functionality.</data>
      <data key="d8">architectural evolution,technological enabler</data>
      <data key="d9">chunk-3da8377b70a3bce3bffec6cc41a145bb</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469045</data>
    </edge>
    <edge source="Complex Instruction Set Computer" target="Software Cost">
      <data key="d6">1.0</data>
      <data key="d7">Rising software costs motivated the development of more complex instructions in CISC to reduce software overhead and adapt to application demands.</data>
      <data key="d8">design motivation,economic driver</data>
      <data key="d9">chunk-3da8377b70a3bce3bffec6cc41a145bb</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469045</data>
    </edge>
    <edge source="Complex Instruction Set Computer" target="CISC Characteristics">
      <data key="d6">1.0</data>
      <data key="d7">The CISC architecture is defined by its characteristics, including a large instruction set, variable-length instructions, multiple addressing modes, and diverse execution times.</data>
      <data key="d8">definition,structural attributes</data>
      <data key="d9">chunk-3da8377b70a3bce3bffec6cc41a145bb</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469046</data>
    </edge>
    <edge source="Complex Instruction Set Computer" target="RISC">
      <data key="d6">1.0</data>
      <data key="d7">RISC emerged as a response to the inefficiencies of CISC, based on observations that only a small fraction of instructions are frequently used.</data>
      <data key="d8">architectural evolution,counterpart</data>
      <data key="d9">chunk-3da8377b70a3bce3bffec6cc41a145bb</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469046</data>
    </edge>
    <edge source="Complex Instruction Set Computer" target="Optimization Compiler">
      <data key="d6">1.0</data>
      <data key="d7">The complexity of CISC instructions makes it difficult for optimization compilers to generate efficient target code.</data>
      <data key="d8">compilation difficulty,software challenge</data>
      <data key="d9">chunk-3da8377b70a3bce3bffec6cc41a145bb</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469047</data>
    </edge>
    <edge source="Complex Instruction Set Computer" target="Instruction Design">
      <data key="d6">1.0</data>
      <data key="d7">Instruction design is a critical process in developing CISC, requiring high precision due to the large and varied instruction set.</data>
      <data key="d8">architectural foundation,design process</data>
      <data key="d9">chunk-3da8377b70a3bce3bffec6cc41a145bb</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469047</data>
    </edge>
    <edge source="Complex Instruction Set Computer" target="Research and Development Cycle">
      <data key="d6">1.0</data>
      <data key="d7">The large size and complexity of CISC instruction sets lead to longer research and development cycles for processor design.</data>
      <data key="d8">development constraint,time overhead</data>
      <data key="d9">chunk-3da8377b70a3bce3bffec6cc41a145bb</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469047</data>
    </edge>
    <edge source="Instruction System" target="Instruction Set Architecture">
      <data key="d6">1.0</data>
      <data key="d7">The instruction system is a core part of the Instruction Set Architecture, representing the aggregate of all available machine-level commands.</data>
      <data key="d8">foundational layer,synonymous definition</data>
      <data key="d9">chunk-986821269f2aa2025221040c595a72be</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469498</data>
    </edge>
    <edge source="Instruction System" target="Data Transfer">
      <data key="d6">1.0</data>
      <data key="d7">Data transfer is a fundamental functional category in the instruction system design.</data>
      <data key="d8">functional category,system design</data>
      <data key="d9">chunk-1853ae0bf21d6ed553e97992dab0cb73</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469598</data>
    </edge>
    <edge source="Instruction System" target="Shift Operations">
      <data key="d6">1.0</data>
      <data key="d7">Shift operations are a categorized functional component of the instruction system.</data>
      <data key="d8">functional category,system design</data>
      <data key="d9">chunk-1853ae0bf21d6ed553e97992dab0cb73</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469599</data>
    </edge>
    <edge source="Instruction System" target="Input Output Operations">
      <data key="d6">1.0</data>
      <data key="d7">Input output operations are integral functional categories in instruction system design for external communication.</data>
      <data key="d8">functional category,system design</data>
      <data key="d9">chunk-1853ae0bf21d6ed553e97992dab0cb73</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469599</data>
    </edge>
    <edge source="Instruction System" target="Arithmetic And Logical Operations">
      <data key="d6">1.0</data>
      <data key="d7">Arithmetic and logical operations are a core functional category in the instruction system.</data>
      <data key="d8">functional category,system design</data>
      <data key="d9">chunk-1853ae0bf21d6ed553e97992dab0cb73</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469600</data>
    </edge>
    <edge source="Instruction System" target="Branching Operations">
      <data key="d6">1.0</data>
      <data key="d7">Branching operations are a key functional category in the instruction system for control flow.</data>
      <data key="d8">functional category,system design</data>
      <data key="d9">chunk-1853ae0bf21d6ed553e97992dab0cb73</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469600</data>
    </edge>
    <edge source="CISC Characteristics" target="Microprogram Control">
      <data key="d6">1.0</data>
      <data key="d7">Microprogram control is commonly used in CISC processors due to the complexity of instructions, which makes hardwired control impractical.</data>
      <data key="d8">control architecture,implementation method</data>
      <data key="d9">chunk-3da8377b70a3bce3bffec6cc41a145bb</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469046</data>
    </edge>
    <edge source="CISC Characteristics" target="Hardwired Control">
      <data key="d6">1.0</data>
      <data key="d7">Certain complex CISC instructions cannot be efficiently implemented with hardwired control due to their complexity and number of required steps.</data>
      <data key="d8">implementation limitation</data>
      <data key="d9">chunk-3da8377b70a3bce3bffec6cc41a145bb</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469046</data>
    </edge>
    <edge source="Microprogram Control" target="CISC">
      <data key="d6">1.0</data>
      <data key="d7">CISC architectures use microprogram control, which occupies a large portion of the CPU chip area.</data>
      <data key="d8">architectural design,control mechanism</data>
      <data key="d9">chunk-2151538dd57e60dbb6761c6a35ea00c6</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761470018</data>
    </edge>
    <edge source="Hardwired Control" target="RISC">
      <data key="d6">1.0</data>
      <data key="d7">RISC relies on hardwired control logic to speed up instruction execution compared to microprogrammed control.</data>
      <data key="d8">control unit design,performance</data>
      <data key="d9">chunk-d12ab3ee72f1f1a8f72c7e3dece14062</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469406</data>
    </edge>
    <edge source="RISC" target="20% Simple Instructions">
      <data key="d6">1.0</data>
      <data key="d7">RISC architecture is based on optimizing the performance of the 20% simple instructions that dominate program execution.</data>
      <data key="d8">design principle,efficiency foundation</data>
      <data key="d9">chunk-3da8377b70a3bce3bffec6cc41a145bb</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469045</data>
    </edge>
    <edge source="RISC" target="80% Complex Instructions">
      <data key="d6">1.0</data>
      <data key="d7">In RISC, the functionality of the 80% complex instructions is either removed or re-implemented using sequences of simple instructions.</data>
      <data key="d8">design simplification,functional replacement</data>
      <data key="d9">chunk-3da8377b70a3bce3bffec6cc41a145bb</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469046</data>
    </edge>
    <edge source="RISC" target="Instruction System Simplification">
      <data key="d6">1.0</data>
      <data key="d7">RISC is fundamentally based on the principle of simplifying the instruction set to improve efficiency and execution speed.</data>
      <data key="d8">core principle,design philosophy</data>
      <data key="d9">chunk-d12ab3ee72f1f1a8f72c7e3dece14062</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469402</data>
    </edge>
    <edge source="RISC" target="Register-Register Operation">
      <data key="d6">1.0</data>
      <data key="d7">RISC emphasizes register-to-register operations to reduce memory access and improve performance.</data>
      <data key="d8">architectural feature,execution model</data>
      <data key="d9">chunk-d12ab3ee72f1f1a8f72c7e3dece14062</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469403</data>
    </edge>
    <edge source="RISC" target="Fixed Instruction Length">
      <data key="d6">1.0</data>
      <data key="d7">RISC uses fixed-length instructions to simplify instruction decoding and support pipelining.</data>
      <data key="d8">instruction format,standardization</data>
      <data key="d9">chunk-d12ab3ee72f1f1a8f72c7e3dece14062</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469403</data>
    </edge>
    <edge source="RISC" target="Limited Addressing Modes">
      <data key="d6">1.0</data>
      <data key="d7">RISC limits addressing modes to reduce complexity and improve execution speed.</data>
      <data key="d8">instruction design,simplicity</data>
      <data key="d9">chunk-d12ab3ee72f1f1a8f72c7e3dece14062</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469404</data>
    </edge>
    <edge source="RISC" target="Load/Store Architecture">
      <data key="d6">1.0</data>
      <data key="d7">RISC restricts memory access to specific LOAD/STORE instructions, enhancing pipeline efficiency.</data>
      <data key="d8">instruction separation,memory access</data>
      <data key="d9">chunk-d12ab3ee72f1f1a8f72c7e3dece14062</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469404</data>
    </edge>
    <edge source="RISC" target="Large Number of General-Purpose Registers">
      <data key="d6">1.0</data>
      <data key="d7">RISC uses a large number of general-purpose registers to reduce memory dependencies.</data>
      <data key="d8">performance,register allocation</data>
      <data key="d9">chunk-d12ab3ee72f1f1a8f72c7e3dece14062</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469404</data>
    </edge>
    <edge source="RISC" target="Instruction Pipelining">
      <data key="d6">1.0</data>
      <data key="d7">RISC employs instruction pipelining to achieve single-cycle execution for most instructions.</data>
      <data key="d8">execution speed,performance optimization</data>
      <data key="d9">chunk-d12ab3ee72f1f1a8f72c7e3dece14062</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469405</data>
    </edge>
    <edge source="RISC" target="Compiler Optimization">
      <data key="d6">1.0</data>
      <data key="d7">RISC places significant emphasis on compiler optimization to compensate for smaller instruction sets.</data>
      <data key="d8">performance,software efficiency</data>
      <data key="d9">chunk-d12ab3ee72f1f1a8f72c7e3dece14062</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469406</data>
    </edge>
    <edge source="RISC" target="Processor Development Direction">
      <data key="d6">1.0</data>
      <data key="d7">RISC is considered the future direction of processor development due to its practical advantages.</data>
      <data key="d8">design outlook,future trend</data>
      <data key="d9">chunk-d12ab3ee72f1f1a8f72c7e3dece14062</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469406</data>
    </edge>
    <edge source="RISC" target="Legacy Machine Compatibility">
      <data key="d6">1.0</data>
      <data key="d7">RISC machines generally lack compatibility with legacy software designed for older CISC machines.</data>
      <data key="d8">incompatibility,software constraint</data>
      <data key="d9">chunk-d12ab3ee72f1f1a8f72c7e3dece14062</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469407</data>
    </edge>
    <edge source="RISC" target="Combination Logic Control">
      <data key="d6">1.0</data>
      <data key="d7">RISC architectures use combination logic control, which minimizes the area required on the CPU chip.</data>
      <data key="d8">architectural design,control mechanism</data>
      <data key="d9">chunk-2151538dd57e60dbb6761c6a35ea00c6</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761470018</data>
    </edge>
    <edge source="RISC" target="CPU Chip Area">
      <data key="d6">1.0</data>
      <data key="d7">RISC's combination logic control uses only around 10% of the CPU chip area, allowing better use of space.</data>
      <data key="d8">area utilization,efficiency</data>
      <data key="d9">chunk-2151538dd57e60dbb6761c6a35ea00c6</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761470018</data>
    </edge>
    <edge source="RISC" target="Pipeline Technology">
      <data key="d6">1.0</data>
      <data key="d7">RISC implements pipeline technology to allow most instructions to execute in a single clock cycle, improving speed.</data>
      <data key="d8">performance enhancement,speed improvement</data>
      <data key="d9">chunk-2151538dd57e60dbb6761c6a35ea00c6</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761470019</data>
    </edge>
    <edge source="RISC" target="General Purpose Registers">
      <data key="d6">1.0</data>
      <data key="d7">RISC uses multiple general purpose registers, reducing memory access and improving computational efficiency.</data>
      <data key="d8">architectural advantage,performance boost</data>
      <data key="d9">chunk-2151538dd57e60dbb6761c6a35ea00c6</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761470019</data>
    </edge>
    <edge source="RISC" target="Instruction Set Complexity">
      <data key="d6">1.0</data>
      <data key="d7">RISC has fewer instructions, addressing modes, and formats, simplifying design and enhancing reliability.</data>
      <data key="d8">design efficiency,simplicity</data>
      <data key="d9">chunk-2151538dd57e60dbb6761c6a35ea00c6</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761470020</data>
    </edge>
    <edge source="RISC" target="Compilation Optimization">
      <data key="d6">1.0</data>
      <data key="d7">RISC's simple instruction set allows compilers to perform more effective code optimization and instruction scheduling.</data>
      <data key="d8">code efficiency,software compatibility</data>
      <data key="d9">chunk-2151538dd57e60dbb6761c6a35ea00c6</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761470020</data>
    </edge>
    <edge source="Do-While Loop" target="Conditional Transfer Instruction">
      <data key="d6">1.0</data>
      <data key="d7">The do-while loop uses conditional transfer instructions to evaluate the test expression and determine whether to continue looping.</data>
      <data key="d8">condition evaluation,control flow</data>
      <data key="d9">chunk-28e3e7abf13d472ede4c7ccd1eed0db7</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469070</data>
    </edge>
    <edge source="Do-While Loop" target="While Loop">
      <data key="d6">1.0</data>
      <data key="d7">The while loop is typically translated by GCC into a do-while loop structure to simplify machine code generation.</data>
      <data key="d8">compiler optimization,translation</data>
      <data key="d9">chunk-28e3e7abf13d472ede4c7ccd1eed0db7</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469071</data>
    </edge>
    <edge source="Do-While Loop" target="For Loop">
      <data key="d6">1.0</data>
      <data key="d7">The for loop is typically converted by compilers into a do-while loop structure for machine-level implementation.</data>
      <data key="d8">compiler optimization,translation</data>
      <data key="d9">chunk-28e3e7abf13d472ede4c7ccd1eed0db7</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469071</data>
    </edge>
    <edge source="Do-While Loop" target="Loop Body Statement">
      <data key="d6">1.0</data>
      <data key="d7">The do-while loop guarantees that the loop body statement is executed at least once before the test expression is evaluated.</data>
      <data key="d8">at-least-once guarantee,ensured execution</data>
      <data key="d9">chunk-28e3e7abf13d472ede4c7ccd1eed0db7</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469072</data>
    </edge>
    <edge source="While Loop" target="Test Expression">
      <data key="d6">1.0</data>
      <data key="d7">The test expression is evaluated before the loop body in a while loop, potentially preventing execution if false.</data>
      <data key="d8">pre-condition check,termination control</data>
      <data key="d9">chunk-28e3e7abf13d472ede4c7ccd1eed0db7</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469071</data>
    </edge>
    <edge source="For Loop" target="Init Expression">
      <data key="d6">1.0</data>
      <data key="d7">The init expression is executed once before the first iteration of the for loop.</data>
      <data key="d8">loop initialization,variable setup</data>
      <data key="d9">chunk-28e3e7abf13d472ede4c7ccd1eed0db7</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469070</data>
    </edge>
    <edge source="For Loop" target="Update Expression">
      <data key="d6">1.0</data>
      <data key="d7">The update expression is executed after each iteration of the for loop body.</data>
      <data key="d8">loop iteration,variable update</data>
      <data key="d9">chunk-28e3e7abf13d472ede4c7ccd1eed0db7</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469071</data>
    </edge>
    <edge source="Conditional Transfer Instruction" target="Goto Statement">
      <data key="d6">1.0</data>
      <data key="d7">The goto statement is a low-level implementation of conditional transfer instructions used in assembly to manage loop flow.</data>
      <data key="d8">low-level branching,program control</data>
      <data key="d9">chunk-28e3e7abf13d472ede4c7ccd1eed0db7</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469071</data>
    </edge>
    <edge source="Machine-Level Representation" target="GCC">
      <data key="d6">1.0</data>
      <data key="d7">GCC generates machine-level code from high-level loops by translating them into assembly constructs like do-while loops and goto statements.</data>
      <data key="d8">code generation,compilation process</data>
      <data key="d9">chunk-28e3e7abf13d472ede4c7ccd1eed0db7</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469070</data>
    </edge>
    <edge source="Loop Body Statement" target="Test Expression">
      <data key="d6">1.0</data>
      <data key="d7">The test expression is evaluated after the loop body statement to determine if the loop should continue.</data>
      <data key="d8">iteration boundary,loop control</data>
      <data key="d9">chunk-28e3e7abf13d472ede4c7ccd1eed0db7</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469070</data>
    </edge>
    <edge source="Goto Statement" target="If-Then-Else Statement">
      <data key="d6">1.0</data>
      <data key="d7">The if-then-else statement can be compiled into a sequence of goto statements for low-level execution.</data>
      <data key="d8">procedural representation,translation</data>
      <data key="d9">chunk-26a06731e273a94d7270550437bc874a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469289</data>
    </edge>
    <edge source="Goto Statement" target="Then_Statement">
      <data key="d6">1.0</data>
      <data key="d7">The goto statement directs execution to the Then_Statement when the condition is met.</data>
      <data key="d8">control flow,execution</data>
      <data key="d9">chunk-26a06731e273a94d7270550437bc874a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469290</data>
    </edge>
    <edge source="Goto Statement" target="Else_Statement">
      <data key="d6">1.0</data>
      <data key="d7">The goto statement directs execution to the Else_Statement when the condition is not met.</data>
      <data key="d8">control flow,execution</data>
      <data key="d9">chunk-26a06731e273a94d7270550437bc874a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469290</data>
    </edge>
    <edge source="Goto Statement" target="Test_Expr">
      <data key="d6">1.0</data>
      <data key="d7">The goto statement is preceded by the evaluation of Test_Expr.</data>
      <data key="d8">evaluation,precondition</data>
      <data key="d9">chunk-26a06731e273a94d7270550437bc874a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469291</data>
    </edge>
    <edge source="Call Instruction" target="Process P">
      <data key="d6">1.0</data>
      <data key="d7">The call instruction is executed by Process P to transfer control to Process Q.</data>
      <data key="d8">control transfer,procedure initiation</data>
      <data key="d9">chunk-af4c47630b7183e33e016913942c0781</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469153</data>
    </edge>
    <edge source="Ret Instruction" target="Process Q">
      <data key="d6">1.0</data>
      <data key="d7">The ret instruction is executed by Process Q to return control to Process P.</data>
      <data key="d8">control return,procedure termination</data>
      <data key="d9">chunk-af4c47630b7183e33e016913942c0781</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469153</data>
    </edge>
    <edge source="Process P" target="Entry Parameter">
      <data key="d6">1.0</data>
      <data key="d7">Process P places entry parameters in a location accessible to Process Q before calling it.</data>
      <data key="d8">argument setup,data passing</data>
      <data key="d9">chunk-af4c47630b7183e33e016913942c0781</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469153</data>
    </edge>
    <edge source="Process P" target="Return Address">
      <data key="d6">1.0</data>
      <data key="d7">Process P stores the return address in a specific memory location before transferring control to Process Q.</data>
      <data key="d8">control preservation,return tracking</data>
      <data key="d9">chunk-af4c47630b7183e33e016913942c0781</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469153</data>
    </edge>
    <edge source="Process P" target="EAX Register">
      <data key="d6">1.0</data>
      <data key="d7">Process P must save the value of the EAX register if it is used by Process Q.</data>
      <data key="d8">caller-saved register usage,value preservation</data>
      <data key="d9">chunk-af4c47630b7183e33e016913942c0781</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469154</data>
    </edge>
    <edge source="Process P" target="ECX Register">
      <data key="d6">1.0</data>
      <data key="d7">Process P must save the value of the ECX register if it is used by Process Q.</data>
      <data key="d8">caller-saved register usage,value preservation</data>
      <data key="d9">chunk-af4c47630b7183e33e016913942c0781</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469154</data>
    </edge>
    <edge source="Process P" target="EDX Register">
      <data key="d6">1.0</data>
      <data key="d7">Process P must save the value of the EDX register if it is used by Process Q.</data>
      <data key="d8">caller-saved register usage,value preservation</data>
      <data key="d9">chunk-af4c47630b7183e33e016913942c0781</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469155</data>
    </edge>
    <edge source="Process Q" target="Procedure P's Context">
      <data key="d6">1.0</data>
      <data key="d7">Process Q saves the context of Process P, including the contents of caller-saved registers, in the stack frame.</data>
      <data key="d8">context preservation,register saving</data>
      <data key="d9">chunk-af4c47630b7183e33e016913942c0781</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469153</data>
    </edge>
    <edge source="Process Q" target="Procedure Q's Local Variables">
      <data key="d6">1.0</data>
      <data key="d7">Process Q allocates space in its stack frame for storing non-static local variables.</data>
      <data key="d8">local memory allocation,variable storage</data>
      <data key="d9">chunk-af4c47630b7183e33e016913942c0781</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469154</data>
    </edge>
    <edge source="Process Q" target="Return Result">
      <data key="d6">1.0</data>
      <data key="d7">Process Q places the return result in a location accessible to Process P after execution.</data>
      <data key="d8">output assembly,result delivery</data>
      <data key="d9">chunk-af4c47630b7183e33e016913942c0781</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469154</data>
    </edge>
    <edge source="Process Q" target="EBX Register">
      <data key="d6">1.0</data>
      <data key="d7">Process Q must save and restore the value of the EBX register before returning.</data>
      <data key="d8">callee-saved register usage,value preservation</data>
      <data key="d9">chunk-af4c47630b7183e33e016913942c0781</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469154</data>
    </edge>
    <edge source="Process Q" target="ESI Register">
      <data key="d6">1.0</data>
      <data key="d7">Process Q must save and restore the value of the ESI register before returning.</data>
      <data key="d8">callee-saved register usage,value preservation</data>
      <data key="d9">chunk-af4c47630b7183e33e016913942c0781</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469155</data>
    </edge>
    <edge source="Process Q" target="EDI Register">
      <data key="d6">1.0</data>
      <data key="d7">Process Q must save and restore the value of the EDI register before returning.</data>
      <data key="d8">callee-saved register usage,value preservation</data>
      <data key="d9">chunk-af4c47630b7183e33e016913942c0781</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469155</data>
    </edge>
    <edge source="Return Address" target="call Instruction">
      <data key="d6">1.0</data>
      <data key="d7">The call instruction pushes the return address onto the stack to enable later return from a subroutine.</data>
      <data key="d8">return mechanism,subroutine call</data>
      <data key="d9">chunk-dc66410ab81cdb2a13f279e50457a470</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469790</data>
    </edge>
    <edge source="Return Address" target="ret Instruction">
      <data key="d6">1.0</data>
      <data key="d7">The ret instruction retrieves the return address from the stack to resume execution after a subroutine completes.</data>
      <data key="d8">address retrieval,subroutine return</data>
      <data key="d9">chunk-dc66410ab81cdb2a13f279e50457a470</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469793</data>
    </edge>
    <edge source="Stack Frame" target="Stack">
      <data key="d6">1.0</data>
      <data key="d7">A stack frame is a component of the stack, allocated for each procedure call and organized sequentially.</data>
      <data key="d8">hierarchical structure,memory organization</data>
      <data key="d9">chunk-af4c47630b7183e33e016913942c0781</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469154</data>
    </edge>
    <edge source="Stack Frame" target="EBP Register">
      <data key="d6">1.0</data>
      <data key="d7">The EBP register serves as a fixed pointer to the base of the current stack frame.</data>
      <data key="d8">fixed reference,frame base pointer</data>
      <data key="d9">chunk-af4c47630b7183e33e016913942c0781</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469154</data>
    </edge>
    <edge source="Stack Frame" target="ESP Register">
      <data key="d6">1.0</data>
      <data key="d7">The ESP register dynamically tracks the top of the stack, changing as data is pushed or popped within the stack frame.</data>
      <data key="d8">dynamic tracking,stack top pointer</data>
      <data key="d9">chunk-af4c47630b7183e33e016913942c0781</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469155</data>
    </edge>
    <edge source="Stack" target="Push Instruction">
      <data key="d6">1.0</data>
      <data key="d7">The Push Instruction stores data onto the stack by decrementing the stack pointer and writing the operand.</data>
      <data key="d8">function call support,stack manipulation</data>
      <data key="d9">chunk-803e04b7ef409476eff2adc07fef14d1</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469379</data>
    </edge>
    <edge source="Stack" target="Pop Instruction">
      <data key="d6">1.0</data>
      <data key="d7">The Pop Instruction retrieves data from the stack by reading the top value and incrementing the stack pointer.</data>
      <data key="d8">function call recovery,stack manipulation</data>
      <data key="d9">chunk-803e04b7ef409476eff2adc07fef14d1</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469380</data>
    </edge>
    <edge source="Instruction" target="Operation Code">
      <data key="d6">1.0</data>
      <data key="d7">The operation code is a core component of an instruction, defining the operation to be executed.</data>
      <data key="d8">functional specification,instruction composition</data>
      <data key="d9">chunk-823091106aa14acd3f766029738eb588</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469221</data>
    </edge>
    <edge source="Instruction" target="Address Code">
      <data key="d6">1.0</data>
      <data key="d7">The address code provides the address of operands, results, or control points within an instruction.</data>
      <data key="d8">data addressing,instruction composition</data>
      <data key="d9">chunk-823091106aa14acd3f766029738eb588</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469222</data>
    </edge>
    <edge source="Instruction" target="Fixed-Length Instruction Structure">
      <data key="d6">1.0</data>
      <data key="d7">In a fixed-length structure, all instructions have identical length, simplifying decoding and control.</data>
      <data key="d8">control simplicity,uniform format</data>
      <data key="d9">chunk-823091106aa14acd3f766029738eb588</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469223</data>
    </edge>
    <edge source="Instruction" target="Variable-Length Instruction Structure">
      <data key="d6">1.0</data>
      <data key="d7">In a variable-length structure, instruction size varies by function, leading to more complex control logic.</data>
      <data key="d8">complex decoding,flexible format</data>
      <data key="d9">chunk-823091106aa14acd3f766029738eb588</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469223</data>
    </edge>
    <edge source="Instruction" target="Two-Address Instruction">
      <data key="d6">1.0</data>
      <data key="d7">Two-address instructions explicitly define source and destination operands, where the result is stored in the destination address.</data>
      <data key="d8">operand specification,result destination</data>
      <data key="d9">chunk-823091106aa14acd3f766029738eb588</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469224</data>
    </edge>
    <edge source="Instruction" target="Three-Address Instruction">
      <data key="d6">1.0</data>
      <data key="d7">Three-address instructions specify two source operands and a separate destination for the operation result.</data>
      <data key="d8">explicit operand addressing,result storage</data>
      <data key="d9">chunk-823091106aa14acd3f766029738eb588</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469224</data>
    </edge>
    <edge source="Instruction" target="Four-Address Instruction">
      <data key="d6">1.0</data>
      <data key="d7">Four-address instructions explicitly include the address of the next instruction to execute, enabling direct program flow control.</data>
      <data key="d8">next instruction address,program control</data>
      <data key="d9">chunk-823091106aa14acd3f766029738eb588</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469225</data>
    </edge>
    <edge source="Instruction" target="Instruction Set Architecture">
      <data key="d6">1.0</data>
      <data key="d7">The Instruction Set Architecture defines the complete set of instructions that a processor can execute.</data>
      <data key="d8">core component,instruction definition</data>
      <data key="d9">chunk-986821269f2aa2025221040c595a72be</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469497</data>
    </edge>
    <edge source="Operation Code" target="Arithmetic Operation">
      <data key="d6">1.0</data>
      <data key="d7">The operation code determines whether the instruction performs an arithmetic operation like addition or subtraction.</data>
      <data key="d8">function specification,operation type</data>
      <data key="d9">chunk-823091106aa14acd3f766029738eb588</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469223</data>
    </edge>
    <edge source="Operation Code" target="Control Transfer">
      <data key="d6">1.0</data>
      <data key="d7">The operation code indicates if the instruction performs a control transfer such as a jump or return.</data>
      <data key="d8">function specification,program flow manipulation</data>
      <data key="d9">chunk-823091106aa14acd3f766029738eb588</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469224</data>
    </edge>
    <edge source="Address Code" target="Direct Addressing">
      <data key="d6">1.0</data>
      <data key="d7">Direct addressing uses the value in the address code as the physical memory address of the operand.</data>
      <data key="d8">memory referencing method,operand location</data>
      <data key="d9">chunk-823091106aa14acd3f766029738eb588</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469223</data>
    </edge>
    <edge source="Address Code" target="Operand">
      <data key="d6">1.0</data>
      <data key="d7">The address code provides the location from which the operand is fetched for processing.</data>
      <data key="d8">data fetching,operand reference</data>
      <data key="d9">chunk-823091106aa14acd3f766029738eb588</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469224</data>
    </edge>
    <edge source="Address Code" target="Result Storage">
      <data key="d6">1.0</data>
      <data key="d7">The address code specifies where the result of an operation should be stored after computation.</data>
      <data key="d8">result destination,write-back mechanism</data>
      <data key="d9">chunk-823091106aa14acd3f766029738eb588</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469224</data>
    </edge>
    <edge source="Address Code" target="Subroutine Call">
      <data key="d6">1.0</data>
      <data key="d7">A subroutine call uses the address code to specify the entry point of the called subroutine.</data>
      <data key="d8">control transfer,entry point reference</data>
      <data key="d9">chunk-823091106aa14acd3f766029738eb588</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469225</data>
    </edge>
    <edge source="Instruction Word Length" target="Machine Word Length">
      <data key="d6">1.0</data>
      <data key="d7">The instruction word length may equal, exceed, or be less than the machine word length, depending on system design.</data>
      <data key="d8">architectural design,relative size</data>
      <data key="d9">chunk-823091106aa14acd3f766029738eb588</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469221</data>
    </edge>
    <edge source="Instruction Word Length" target="Memory Access">
      <data key="d6">1.0</data>
      <data key="d7">The instruction word length directly affects the number of memory accesses required to fetch the instruction, influencing performance.</data>
      <data key="d8">fetch overhead,performance impact</data>
      <data key="d9">chunk-823091106aa14acd3f766029738eb588</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469223</data>
    </edge>
    <edge source="Single-Word Length Instruction" target="Memory Access">
      <data key="d6">1.0</data>
      <data key="d7">A single-word length instruction requires only one memory access to be fully fetched.</data>
      <data key="d8">low overhead,single fetch</data>
      <data key="d9">chunk-823091106aa14acd3f766029738eb588</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469221</data>
    </edge>
    <edge source="Double-Word Length Instruction" target="Memory Access">
      <data key="d6">1.0</data>
      <data key="d7">A double-word length instruction requires two memory accesses, consuming two memory cycles.</data>
      <data key="d8">double fetch,higher overhead</data>
      <data key="d9">chunk-823091106aa14acd3f766029738eb588</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469222</data>
    </edge>
    <edge source="Zero-Address Instruction" target="Stack Computer">
      <data key="d6">1.0</data>
      <data key="d7">Zero-address instructions are primarily used in stack computers, where operands are implicitly retrieved from the stack.</data>
      <data key="d8">architectural compatibility,implicit operands</data>
      <data key="d9">chunk-823091106aa14acd3f766029738eb588</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469222</data>
    </edge>
    <edge source="Zero-Address Instruction" target="Operand">
      <data key="d6">1.0</data>
      <data key="d7">In zero-address instructions, operands are implicitly accessed from the stack, reducing the need for explicit address fields.</data>
      <data key="d8">implicit operand handling</data>
      <data key="d9">chunk-823091106aa14acd3f766029738eb588</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469224</data>
    </edge>
    <edge source="One-Address Instruction" target="Accumulator">
      <data key="d6">1.0</data>
      <data key="d7">One-address instructions often rely on the accumulator as a hidden operand, with results stored back in the same location or in the accumulator.</data>
      <data key="d8">operation context,register dependency</data>
      <data key="d9">chunk-823091106aa14acd3f766029738eb588</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469222</data>
    </edge>
    <edge source="Three-Address Instruction" target="Memory Access">
      <data key="d6">1.0</data>
      <data key="d7">A three-address instruction requires four memory accesses: one to fetch the instruction, two to read operands, and one to store the result.</data>
      <data key="d8">fetch and store,four access cycle</data>
      <data key="d9">chunk-823091106aa14acd3f766029738eb588</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469223</data>
    </edge>
    <edge source="Four-Address Instruction" target="Memory Access">
      <data key="d6">1.0</data>
      <data key="d7">A four-address instruction requires four memory accesses: one to fetch the instruction, two to read operands, one to store the result.</data>
      <data key="d8">fetch and store,four access cycle</data>
      <data key="d9">chunk-823091106aa14acd3f766029738eb588</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469225</data>
    </edge>
    <edge source="Memory Access" target="Immediate Addressing">
      <data key="d6">1.0</data>
      <data key="d7">Immediate addressing avoids memory access during execution, resulting in the fastest instruction execution due to operand being embedded in the instruction.</data>
      <data key="d8">execution speed,performance impact</data>
      <data key="d9">chunk-ee7b048d8f7d4f6a7cdb8bd206b3d9c3</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469937</data>
    </edge>
    <edge source="Memory Access" target="Indirect Addressing">
      <data key="d6">1.0</data>
      <data key="d7">Indirect addressing requires multiple memory accesses (e.g., one to fetch the address and one to fetch the operand), increasing execution time and complexity.</data>
      <data key="d8">execution overhead,multi-access requirement</data>
      <data key="d9">chunk-ee7b048d8f7d4f6a7cdb8bd206b3d9c3</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469939</data>
    </edge>
    <edge source="Memory Access" target="Register Addressing">
      <data key="d6">1.0</data>
      <data key="d7">Register addressing eliminates memory access in the execution phase by using internal registers, significantly improving performance.</data>
      <data key="d8">minimal access,speed optimization</data>
      <data key="d9">chunk-ee7b048d8f7d4f6a7cdb8bd206b3d9c3</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469939</data>
    </edge>
    <edge source="Memory Access" target="Register Indirect Addressing">
      <data key="d6">1.0</data>
      <data key="d7">Register indirect addressing reduces memory access to one read (for the operand), improving performance over pure indirect addressing while maintaining extended addressability.</data>
      <data key="d8">optimized access,reduced memory read count</data>
      <data key="d9">chunk-ee7b048d8f7d4f6a7cdb8bd206b3d9c3</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469939</data>
    </edge>
    <edge source="Memory Access" target="Index Addressing">
      <data key="d6">1.0</data>
      <data key="d7">Index addressing requires memory access to retrieve operand values using the computed effective address, especially useful in array and loop processing.</data>
      <data key="d8">data array processing,dynamic access</data>
      <data key="d9">chunk-ee7b048d8f7d4f6a7cdb8bd206b3d9c3</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469940</data>
    </edge>
    <edge source="Memory Access" target="Base Addressing">
      <data key="d6">1.0</data>
      <data key="d7">Base addressing involves memory access to read data at the calculated effective address, with access times depending on system architecture.</data>
      <data key="d8">address resolution,system-level access</data>
      <data key="d9">chunk-ee7b048d8f7d4f6a7cdb8bd206b3d9c3</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469940</data>
    </edge>
    <edge source="Accumulator" target="Implicit Addressing">
      <data key="d6">1.0</data>
      <data key="d7">Implicit addressing relies on the Accumulator as the default second operand, making ACC a critical component of this addressing mode.</data>
      <data key="d8">operand convention,register dependency</data>
      <data key="d9">chunk-ee7b048d8f7d4f6a7cdb8bd206b3d9c3</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469933</data>
    </edge>
    <edge source="Accumulator" target="Register Addressing">
      <data key="d6">1.0</data>
      <data key="d7">Register addressing, including implicit use, depends on the Accumulator to supply operands in instruction execution.</data>
      <data key="d8">operand access,register usage</data>
      <data key="d9">chunk-ee7b048d8f7d4f6a7cdb8bd206b3d9c3</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469936</data>
    </edge>
    <edge source="Accumulator" target="Single-Address Instruction Format">
      <data key="d6">1.0</data>
      <data key="d7">The single-address instruction format relies on the Accumulator as the implicitly accessed second operand, making ACC an essential component of the instruction model.</data>
      <data key="d8">implicit operand,instruction design</data>
      <data key="d9">chunk-ee7b048d8f7d4f6a7cdb8bd206b3d9c3</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469937</data>
    </edge>
    <edge source="Direct Addressing" target="Form Address">
      <data key="d6">1.0</data>
      <data key="d7">In direct addressing, the form address directly specifies the effective address.</data>
      <data key="d8">address mapping,direct operand referencing</data>
      <data key="d9">chunk-ee7b048d8f7d4f6a7cdb8bd206b3d9c3</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469935</data>
    </edge>
    <edge source="Bitwise Operation" target="Not Instruction">
      <data key="d6">1.0</data>
      <data key="d7">The not instruction performs a bitwise inversion, which is a fundamental operation in bit manipulation.</data>
      <data key="d8">bit inversion,complement</data>
      <data key="d9">chunk-be143027fbd9f62579107c5fcd0f2740</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469711</data>
    </edge>
    <edge source="Operand" target="Memory">
      <data key="d6">1.0</data>
      <data key="d7">Operands can refer to memory locations, accessed via symbolic names like 'var' or qualifiers such as byte ptr/dword ptr.</data>
      <data key="d8">addressing,data access</data>
      <data key="d9">chunk-be143027fbd9f62579107c5fcd0f2740</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469705</data>
    </edge>
    <edge source="Operand" target="Register">
      <data key="d6">1.0</data>
      <data key="d7">Operands can refer to registers, serving as sources or destinations in arithmetic and logic operations.</data>
      <data key="d8">computation,data storage</data>
      <data key="d9">chunk-be143027fbd9f62579107c5fcd0f2740</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469711</data>
    </edge>
    <edge source="If-Then-Else Statement" target="Test_Expr">
      <data key="d6">1.0</data>
      <data key="d7">The if-then-else statement relies on the value of Test_Expr to determine the flow of execution.</data>
      <data key="d8">conditional logic,evaluation</data>
      <data key="d9">chunk-26a06731e273a94d7270550437bc874a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469287</data>
    </edge>
    <edge source="If-Then-Else Statement" target="Then_Statement">
      <data key="d6">1.0</data>
      <data key="d7">The Then_Statement is executed when Test_Expr is non-zero.</data>
      <data key="d8">conditional block,execution path</data>
      <data key="d9">chunk-26a06731e273a94d7270550437bc874a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469288</data>
    </edge>
    <edge source="If-Then-Else Statement" target="Else_Statement">
      <data key="d6">1.0</data>
      <data key="d7">The Else_Statement is executed when Test_Expr is zero.</data>
      <data key="d8">conditional block,execution path</data>
      <data key="d9">chunk-26a06731e273a94d7270550437bc874a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469288</data>
    </edge>
    <edge source="Condition Code" target="Cmp Instruction">
      <data key="d6">1.0</data>
      <data key="d7">The cmp instruction sets condition codes based on the result of a comparison operation.</data>
      <data key="d8">comparison,flag setting</data>
      <data key="d9">chunk-26a06731e273a94d7270550437bc874a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469287</data>
    </edge>
    <edge source="Condition Code" target="Test Instruction">
      <data key="d6">1.0</data>
      <data key="d7">The test instruction sets condition codes based on the result of a bitwise AND operation.</data>
      <data key="d8">bitwise test,flag setting</data>
      <data key="d9">chunk-26a06731e273a94d7270550437bc874a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469288</data>
    </edge>
    <edge source="Condition Code" target="Add Instruction">
      <data key="d6">1.0</data>
      <data key="d7">The add instruction updates condition codes such as CF, ZF, SF, and OF after performing addition.</data>
      <data key="d8">arithmetic,flag updating</data>
      <data key="d9">chunk-26a06731e273a94d7270550437bc874a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469288</data>
    </edge>
    <edge source="Condition Code" target="Sub Instruction">
      <data key="d6">1.0</data>
      <data key="d7">The sub instruction updates condition codes such as CF, ZF, SF, and OF after performing subtraction.</data>
      <data key="d8">arithmetic,flag updating</data>
      <data key="d9">chunk-26a06731e273a94d7270550437bc874a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469288</data>
    </edge>
    <edge source="Condition Code" target="Imul Instruction">
      <data key="d6">1.0</data>
      <data key="d7">The imul instruction updates condition codes after performing signed integer multiplication.</data>
      <data key="d8">flag updating,multiplication</data>
      <data key="d9">chunk-26a06731e273a94d7270550437bc874a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469289</data>
    </edge>
    <edge source="Condition Code" target="Or Instruction">
      <data key="d6">1.0</data>
      <data key="d7">The or instruction updates condition codes based on the result of a bitwise OR operation.</data>
      <data key="d8">bitwise,flag updating</data>
      <data key="d9">chunk-26a06731e273a94d7270550437bc874a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469289</data>
    </edge>
    <edge source="Condition Code" target="And Instruction">
      <data key="d6">1.0</data>
      <data key="d7">The and instruction updates condition codes based on the result of a bitwise AND operation.</data>
      <data key="d8">bitwise,flag updating</data>
      <data key="d9">chunk-26a06731e273a94d7270550437bc874a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469289</data>
    </edge>
    <edge source="Condition Code" target="Shl Instruction">
      <data key="d6">1.0</data>
      <data key="d7">The shl instruction updates condition codes such as CF and ZF during a left shift.</data>
      <data key="d8">flag updating,shift operation</data>
      <data key="d9">chunk-26a06731e273a94d7270550437bc874a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469290</data>
    </edge>
    <edge source="Condition Code" target="Inc Instruction">
      <data key="d6">1.0</data>
      <data key="d7">The inc instruction updates condition codes after incrementing a value.</data>
      <data key="d8">flag updating,increment</data>
      <data key="d9">chunk-26a06731e273a94d7270550437bc874a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469290</data>
    </edge>
    <edge source="Condition Code" target="Dec Instruction">
      <data key="d6">1.0</data>
      <data key="d7">The dec instruction updates condition codes after decrementing a value.</data>
      <data key="d8">decrement,flag updating</data>
      <data key="d9">chunk-26a06731e273a94d7270550437bc874a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469290</data>
    </edge>
    <edge source="Condition Code" target="Not Instruction">
      <data key="d6">1.0</data>
      <data key="d7">The not instruction updates condition codes based on the result of a bitwise NOT operation.</data>
      <data key="d8">bitwise negation,flag updating</data>
      <data key="d9">chunk-26a06731e273a94d7270550437bc874a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469291</data>
    </edge>
    <edge source="Condition Code" target="Sal Instruction">
      <data key="d6">1.0</data>
      <data key="d7">The sal instruction updates condition codes such as CF and ZF during a signed left shift.</data>
      <data key="d8">arithmetic shift,flag updating</data>
      <data key="d9">chunk-26a06731e273a94d7270550437bc874a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469291</data>
    </edge>
    <edge source="Condition Code" target="Processor Register">
      <data key="d6">1.0</data>
      <data key="d7">The condition code is a type of processor register that reflects the outcome of operations, influencing control flow decisions.</data>
      <data key="d8">execution feedback,register function</data>
      <data key="d9">chunk-986821269f2aa2025221040c595a72be</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469498</data>
    </edge>
    <edge source="ZF" target="Jcondition Instruction">
      <data key="d6">1.0</data>
      <data key="d7">The jcondition instruction uses the ZF flag to determine whether to jump.</data>
      <data key="d8">conditional branching,flag dependency</data>
      <data key="d9">chunk-26a06731e273a94d7270550437bc874a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469289</data>
    </edge>
    <edge source="SF" target="Jcondition Instruction">
      <data key="d6">1.0</data>
      <data key="d7">The jcondition instruction uses the SF flag to determine whether to jump.</data>
      <data key="d8">conditional branching,flag dependency</data>
      <data key="d9">chunk-26a06731e273a94d7270550437bc874a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469289</data>
    </edge>
    <edge source="Add Instruction" target="Register">
      <data key="d6">1.0</data>
      <data key="d7">The add instruction operates on a register by adding another register, memory location, or constant, storing the sum in the first operand.</data>
      <data key="d8">arithmetic operation,operand handling</data>
      <data key="d9">chunk-be143027fbd9f62579107c5fcd0f2740</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469698</data>
    </edge>
    <edge source="Add Instruction" target="Memory">
      <data key="d6">1.0</data>
      <data key="d7">The add instruction can update a memory location by adding a register or constant value to it.</data>
      <data key="d8">addition to memory</data>
      <data key="d9">chunk-be143027fbd9f62579107c5fcd0f2740</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469701</data>
    </edge>
    <edge source="Sub Instruction" target="Register">
      <data key="d6">1.0</data>
      <data key="d7">The sub instruction operates on a register by subtracting another register, memory location, or constant, storing the difference in the first operand.</data>
      <data key="d8">arithmetic operation,operand handling</data>
      <data key="d9">chunk-be143027fbd9f62579107c5fcd0f2740</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469698</data>
    </edge>
    <edge source="Sub Instruction" target="Memory">
      <data key="d6">1.0</data>
      <data key="d7">The sub instruction can update a memory location by subtracting a register or constant value from it.</data>
      <data key="d8">subtraction from memory</data>
      <data key="d9">chunk-be143027fbd9f62579107c5fcd0f2740</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469702</data>
    </edge>
    <edge source="Imul Instruction" target="Register">
      <data key="d6">1.0</data>
      <data key="d7">The imul instruction performs multiplication, storing the result in a register, and may set the overflow flag if the result overflows.</data>
      <data key="d8">multiplication operation,operand handling</data>
      <data key="d9">chunk-be143027fbd9f62579107c5fcd0f2740</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469700</data>
    </edge>
    <edge source="Imul Instruction" target="Constant">
      <data key="d6">1.0</data>
      <data key="d7">The imul instruction can use a constant as the second or third operand in a three-operand multiplication.</data>
      <data key="d8">multiplication with constant</data>
      <data key="d9">chunk-be143027fbd9f62579107c5fcd0f2740</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469701</data>
    </edge>
    <edge source="Imul Instruction" target="Overflow Flag">
      <data key="d6">1.0</data>
      <data key="d7">When the result of an imul operation exceeds the representable range of the register, the overflow flag is set to 1.</data>
      <data key="d8">overflow detection</data>
      <data key="d9">chunk-be143027fbd9f62579107c5fcd0f2740</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469703</data>
    </edge>
    <edge source="Imul Instruction" target="Arithmetic Overflow">
      <data key="d6">1.0</data>
      <data key="d7">The imul instruction sets the overflow flag when the result cannot fit in the 32-bit register.</data>
      <data key="d8">exception trigger,overflow detection</data>
      <data key="d9">chunk-be143027fbd9f62579107c5fcd0f2740</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469709</data>
    </edge>
    <edge source="Or Instruction" target="Register">
      <data key="d6">1.0</data>
      <data key="d7">The or instruction performs a bitwise OR operation between two operands, storing the result in a register.</data>
      <data key="d8">bitwise operation,logical OR</data>
      <data key="d9">chunk-be143027fbd9f62579107c5fcd0f2740</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469702</data>
    </edge>
    <edge source="Or Instruction" target="Logic Operation">
      <data key="d6">1.0</data>
      <data key="d7">The or instruction implements a logical OR operation between two operands.</data>
      <data key="d8">bitwise operation,logical OR</data>
      <data key="d9">chunk-be143027fbd9f62579107c5fcd0f2740</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469709</data>
    </edge>
    <edge source="And Instruction" target="Register">
      <data key="d6">1.0</data>
      <data key="d7">The and instruction performs a bitwise AND operation between two operands, storing the result in a register.</data>
      <data key="d8">bitwise operation,logical AND</data>
      <data key="d9">chunk-be143027fbd9f62579107c5fcd0f2740</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469701</data>
    </edge>
    <edge source="And Instruction" target="Constant">
      <data key="d6">1.0</data>
      <data key="d7">The and instruction can apply a constant mask to a register or memory location, zeroing bits as required.</data>
      <data key="d8">bitwise AND with constant</data>
      <data key="d9">chunk-be143027fbd9f62579107c5fcd0f2740</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469702</data>
    </edge>
    <edge source="And Instruction" target="Logic Operation">
      <data key="d6">1.0</data>
      <data key="d7">The and instruction implements a logical AND operation between two operands.</data>
      <data key="d8">bitwise operation,logical AND</data>
      <data key="d9">chunk-be143027fbd9f62579107c5fcd0f2740</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469707</data>
    </edge>
    <edge source="Shl Instruction" target="Constant">
      <data key="d6">1.0</data>
      <data key="d7">The shl instruction uses a constant to specify the number of bits to shift left in a register.</data>
      <data key="d8">shift by constant</data>
      <data key="d9">chunk-be143027fbd9f62579107c5fcd0f2740</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469705</data>
    </edge>
    <edge source="Shl Instruction" target="Register">
      <data key="d6">1.0</data>
      <data key="d7">The shl instruction performs a logical left shift on a register by a specified number of bits.</data>
      <data key="d8">bit shift,left shift</data>
      <data key="d9">chunk-be143027fbd9f62579107c5fcd0f2740</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469706</data>
    </edge>
    <edge source="Inc Instruction" target="Register">
      <data key="d6">1.0</data>
      <data key="d7">The inc instruction increases the value of a register by 1.</data>
      <data key="d8">increment operation,register update</data>
      <data key="d9">chunk-be143027fbd9f62579107c5fcd0f2740</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469699</data>
    </edge>
    <edge source="Inc Instruction" target="Memory">
      <data key="d6">1.0</data>
      <data key="d7">The inc instruction increases the value of a memory location by 1.</data>
      <data key="d8">increment memory</data>
      <data key="d9">chunk-be143027fbd9f62579107c5fcd0f2740</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469702</data>
    </edge>
    <edge source="Dec Instruction" target="Register">
      <data key="d6">1.0</data>
      <data key="d7">The dec instruction decreases the value of a register by 1.</data>
      <data key="d8">decrement operation,register update</data>
      <data key="d9">chunk-be143027fbd9f62579107c5fcd0f2740</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469700</data>
    </edge>
    <edge source="Dec Instruction" target="Memory">
      <data key="d6">1.0</data>
      <data key="d7">The dec instruction decreases the value of a memory location by 1.</data>
      <data key="d8">decrement memory</data>
      <data key="d9">chunk-be143027fbd9f62579107c5fcd0f2740</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469703</data>
    </edge>
    <edge source="Not Instruction" target="Memory">
      <data key="d6">1.0</data>
      <data key="d7">The not instruction inverts all bits in a memory location, using the byte ptr or dword ptr qualifier.</data>
      <data key="d8">bitwise inversion,memory access</data>
      <data key="d9">chunk-be143027fbd9f62579107c5fcd0f2740</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469699</data>
    </edge>
    <edge source="Not Instruction" target="Register">
      <data key="d6">1.0</data>
      <data key="d7">The not instruction flips all bits in a register, producing the bitwise complement.</data>
      <data key="d8">bitwise inversion,register update</data>
      <data key="d9">chunk-be143027fbd9f62579107c5fcd0f2740</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469708</data>
    </edge>
    <edge source="Base Addressing" target="Base Register">
      <data key="d6">2.0</data>
      <data key="d7">Base addressing uses the base register to store a fixed address for system-level storage allocation.&lt;SEP&gt;Base addressing relies on the Base Register to define the starting point for logical-to-physical address translation.</data>
      <data key="d8">address mapping,register usage,system independence,system-level allocation</data>
      <data key="d9">chunk-9c7da0bf6fbf207039ae9ca67c1e6a9d&lt;SEP&gt;chunk-ee7b048d8f7d4f6a7cdb8bd206b3d9c3</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469937</data>
    </edge>
    <edge source="Base Addressing" target="Form Address">
      <data key="d6">1.0</data>
      <data key="d7">In base addressing, the effective address is calculated by adding the form address to the base register's constant value.</data>
      <data key="d8">address calculation,fixed register</data>
      <data key="d9">chunk-9c7da0bf6fbf207039ae9ca67c1e6a9d</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469298</data>
    </edge>
    <edge source="Base Addressing" target="Offset Addressing">
      <data key="d6">1.0</data>
      <data key="d7">Base addressing is classified under offset addressing due to the method of address calculation.</data>
      <data key="d8">addressing category,classification</data>
      <data key="d9">chunk-9c7da0bf6fbf207039ae9ca67c1e6a9d</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469298</data>
    </edge>
    <edge source="Base Addressing" target="Multiple Program Support">
      <data key="d6">1.0</data>
      <data key="d7">Base addressing supports multiple program execution by enabling the allocation of distinct storage spaces for each.</data>
      <data key="d8">program management,system-level function</data>
      <data key="d9">chunk-9c7da0bf6fbf207039ae9ca67c1e6a9d</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469298</data>
    </edge>
    <edge source="Base Addressing" target="Instruction Word">
      <data key="d6">1.0</data>
      <data key="d7">In base addressing, the instruction word's form address (A) is variable while the base register value remains constant.</data>
      <data key="d8">address component,form address variable</data>
      <data key="d9">chunk-9c7da0bf6fbf207039ae9ca67c1e6a9d</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469299</data>
    </edge>
    <edge source="Index Addressing" target="Index Register">
      <data key="d6">2.0</data>
      <data key="d7">Index addressing uses the index register, which is modified by the user during program execution.&lt;SEP&gt;Index addressing uses the Index Register to apply offsets for dynamic access to data structures.</data>
      <data key="d8">array processing,displacement calculation,register usage,user-level modification</data>
      <data key="d9">chunk-9c7da0bf6fbf207039ae9ca67c1e6a9d&lt;SEP&gt;chunk-ee7b048d8f7d4f6a7cdb8bd206b3d9c3</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469937</data>
    </edge>
    <edge source="Index Addressing" target="Form Address">
      <data key="d6">1.0</data>
      <data key="d7">In index addressing, the effective address is calculated by adding the form address to the variable value in the index register.</data>
      <data key="d8">address calculation,variable register</data>
      <data key="d9">chunk-9c7da0bf6fbf207039ae9ca67c1e6a9d</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469297</data>
    </edge>
    <edge source="Index Addressing" target="Offset Addressing">
      <data key="d6">1.0</data>
      <data key="d7">Index addressing is classified under offset addressing as both use register plus form address addition.</data>
      <data key="d8">addressing category,classification</data>
      <data key="d9">chunk-9c7da0bf6fbf207039ae9ca67c1e6a9d</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469297</data>
    </edge>
    <edge source="Index Addressing" target="Array Processing">
      <data key="d6">1.0</data>
      <data key="d7">Index addressing is primarily used for array processing, where variable indices enable sequential or indexed access to array elements.</data>
      <data key="d8">data access,user-level application</data>
      <data key="d9">chunk-9c7da0bf6fbf207039ae9ca67c1e6a9d</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469298</data>
    </edge>
    <edge source="Index Addressing" target="Instruction Word">
      <data key="d6">1.0</data>
      <data key="d7">In index addressing, the instruction word's form address (A) remains fixed, while the index register value varies during execution.</data>
      <data key="d8">address component,form address fixed</data>
      <data key="d9">chunk-9c7da0bf6fbf207039ae9ca67c1e6a9d</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469298</data>
    </edge>
    <edge source="Relative Addressing" target="Offset Addressing">
      <data key="d6">1.0</data>
      <data key="d7">Relative addressing is included in the category of offset addressing due to a common addressing mechanism.</data>
      <data key="d8">addressing category,classification</data>
      <data key="d9">chunk-9c7da0bf6fbf207039ae9ca67c1e6a9d</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469296</data>
    </edge>
    <edge source="Relative Addressing" target="Form Address">
      <data key="d6">1.0</data>
      <data key="d7">Relative addressing generates an effective address by adding a form address to a registerâ€™s content.</data>
      <data key="d8">address calculation,register addition</data>
      <data key="d9">chunk-9c7da0bf6fbf207039ae9ca67c1e6a9d</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469297</data>
    </edge>
    <edge source="Relative Addressing" target="Program Counter">
      <data key="d6">1.0</data>
      <data key="d7">Relative addressing uses the Program Counter as a reference point to compute the effective address with a signed offset.</data>
      <data key="d8">dynamic addressing,instruction flow</data>
      <data key="d9">chunk-ee7b048d8f7d4f6a7cdb8bd206b3d9c3</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469936</data>
    </edge>
    <edge source="Effective Address" target="Indirect Addressing">
      <data key="d6">1.0</data>
      <data key="d7">Indirect addressing computes the effective address by fetching it from the memory location specified by the form address.</data>
      <data key="d8">address resolution,multi-step lookup</data>
      <data key="d9">chunk-ee7b048d8f7d4f6a7cdb8bd206b3d9c3</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469936</data>
    </edge>
    <edge source="Base Register" target="Register Indirect Addressing">
      <data key="d6">1.0</data>
      <data key="d7">Register indirect addressing uses a register to point to the effective address, similar to base functionality.</data>
      <data key="d8">address chaining,combined addressing</data>
      <data key="d9">chunk-ee7b048d8f7d4f6a7cdb8bd206b3d9c3</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469936</data>
    </edge>
    <edge source="Instruction Word" target="32-Bit Word Length">
      <data key="d6">1.0</data>
      <data key="d7">The instruction word is typically designed to align with a 32-bit word length in modern systems, facilitating efficient memory and data processing.</data>
      <data key="d8">architectural alignment,word size standard</data>
      <data key="d9">chunk-7fa816a9f8d5ac78d7483ae33a74ba7b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469640</data>
    </edge>
    <edge source="Mov Instruction" target="Register">
      <data key="d6">1.0</data>
      <data key="d7">The Mov Instruction transfers data between registers or from register to memory or immediate value.</data>
      <data key="d8">data movement,operand transfer</data>
      <data key="d9">chunk-803e04b7ef409476eff2adc07fef14d1</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469379</data>
    </edge>
    <edge source="Mov Instruction" target="Memory">
      <data key="d6">1.0</data>
      <data key="d7">The Mov Instruction copies data from memory to a register or from an immediate value to memory.</data>
      <data key="d8">data movement,operand transfer</data>
      <data key="d9">chunk-803e04b7ef409476eff2adc07fef14d1</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469380</data>
    </edge>
    <edge source="Mov Instruction" target="Constant Value">
      <data key="d6">1.0</data>
      <data key="d7">The Mov Instruction can move immediate constant values into registers or memory locations.</data>
      <data key="d8">data movement,operand transfer</data>
      <data key="d9">chunk-803e04b7ef409476eff2adc07fef14d1</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469381</data>
    </edge>
    <edge source="Mov Instruction" target="Two Operands">
      <data key="d6">1.0</data>
      <data key="d7">The Mov Instruction requires two operands, but cannot transfer data directly from memory to memory.</data>
      <data key="d8">instruction format,operand constraint</data>
      <data key="d9">chunk-803e04b7ef409476eff2adc07fef14d1</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469381</data>
    </edge>
    <edge source="Mov Instruction" target="Data Transfer">
      <data key="d6">1.0</data>
      <data key="d7">The Mov Instruction is a fundamental operation for data transfer within the CPU and memory.</data>
      <data key="d8">instruction purpose,low-level operation</data>
      <data key="d9">chunk-803e04b7ef409476eff2adc07fef14d1</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469382</data>
    </edge>
    <edge source="Mov Instruction" target="Memory to Memory Copy">
      <data key="d6">1.0</data>
      <data key="d7">The mov instruction does not support direct memory-to-memory transfers, requiring an intermediate register.</data>
      <data key="d8">instruction constraint,operand limitation</data>
      <data key="d9">chunk-803e04b7ef409476eff2adc07fef14d1</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469382</data>
    </edge>
    <edge source="Push Instruction" target="Esp">
      <data key="d6">1.0</data>
      <data key="d7">The Push Instruction decrements the stack pointer (Esp) before writing the operand to memory.</data>
      <data key="d8">memory addressing,stack pointer update</data>
      <data key="d9">chunk-803e04b7ef409476eff2adc07fef14d1</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469380</data>
    </edge>
    <edge source="Push Instruction" target="32-Bit">
      <data key="d6">1.0</data>
      <data key="d7">Push operations store 32-bit values on the stack, maintaining fixed operand size.</data>
      <data key="d8">data width,stack alignment</data>
      <data key="d9">chunk-803e04b7ef409476eff2adc07fef14d1</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469380</data>
    </edge>
    <edge source="Push Instruction" target="Register">
      <data key="d6">1.0</data>
      <data key="d7">The Push Instruction transfers data from a register to the stack for temporary storage during program execution.</data>
      <data key="d8">data movement,temporary storage</data>
      <data key="d9">chunk-803e04b7ef409476eff2adc07fef14d1</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469381</data>
    </edge>
    <edge source="Push Instruction" target="Memory">
      <data key="d6">1.0</data>
      <data key="d7">The Push Instruction can push a 32-bit value from memory onto the stack.</data>
      <data key="d8">data movement,temporary storage</data>
      <data key="d9">chunk-803e04b7ef409476eff2adc07fef14d1</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469382</data>
    </edge>
    <edge source="Pop Instruction" target="Esp">
      <data key="d6">1.0</data>
      <data key="d7">The Pop Instruction increments the stack pointer (Esp) after reading the operand from memory.</data>
      <data key="d8">memory addressing,stack pointer update</data>
      <data key="d9">chunk-803e04b7ef409476eff2adc07fef14d1</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469380</data>
    </edge>
    <edge source="Pop Instruction" target="Register">
      <data key="d6">1.0</data>
      <data key="d7">The Pop Instruction retrieves a 32-bit value from the stack and stores it into a register.</data>
      <data key="d8">data movement,temporary storage</data>
      <data key="d9">chunk-803e04b7ef409476eff2adc07fef14d1</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469381</data>
    </edge>
    <edge source="Pop Instruction" target="32-Bit">
      <data key="d6">1.0</data>
      <data key="d7">Pop operations retrieve 32-bit values from the stack, ensuring consistency in data size.</data>
      <data key="d8">data width,stack alignment</data>
      <data key="d9">chunk-803e04b7ef409476eff2adc07fef14d1</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469381</data>
    </edge>
    <edge source="Pop Instruction" target="Memory">
      <data key="d6">1.0</data>
      <data key="d7">The Pop Instruction retrieves a 32-bit value from the stack and stores it into a memory location.</data>
      <data key="d8">data movement,temporary storage</data>
      <data key="d9">chunk-803e04b7ef409476eff2adc07fef14d1</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469382</data>
    </edge>
    <edge source="Register" target="Xor Instruction">
      <data key="d6">1.0</data>
      <data key="d7">The xor instruction performs a bitwise XOR operation between two operands, storing the result in a register.</data>
      <data key="d8">bitwise operation,logical XOR</data>
      <data key="d9">chunk-be143027fbd9f62579107c5fcd0f2740</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469703</data>
    </edge>
    <edge source="Register" target="Neg Instruction">
      <data key="d6">1.0</data>
      <data key="d7">The neg instruction computes the negative of a register value using twoâ€™s complement arithmetic.</data>
      <data key="d8">sign inversion,twos complement</data>
      <data key="d9">chunk-be143027fbd9f62579107c5fcd0f2740</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469704</data>
    </edge>
    <edge source="Register" target="Shr Instruction">
      <data key="d6">1.0</data>
      <data key="d7">The shr instruction performs a logical right shift on a register by a specified number of bits.</data>
      <data key="d8">bit shift,right shift</data>
      <data key="d9">chunk-be143027fbd9f62579107c5fcd0f2740</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469707</data>
    </edge>
    <edge source="Register" target="32-Bit Integer">
      <data key="d6">1.0</data>
      <data key="d7">Registers such as eax and esi are designed to hold 32-bit integers.</data>
      <data key="d8">bit-width,data representation</data>
      <data key="d9">chunk-be143027fbd9f62579107c5fcd0f2740</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469709</data>
    </edge>
    <edge source="Register" target="Eax Register">
      <data key="d6">1.0</data>
      <data key="d7">The eax register is a primary register for arithmetic operations and data handling.</data>
      <data key="d8">general-purpose register</data>
      <data key="d9">chunk-be143027fbd9f62579107c5fcd0f2740</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469713</data>
    </edge>
    <edge source="Register" target="Esi Register">
      <data key="d6">1.0</data>
      <data key="d7">The esi register is used for address indexing and data manipulation.</data>
      <data key="d8">general-purpose register</data>
      <data key="d9">chunk-be143027fbd9f62579107c5fcd0f2740</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469713</data>
    </edge>
    <edge source="Register" target="Edx Register">
      <data key="d6">1.0</data>
      <data key="d7">The edx register is used for holding the high portion of 64-bit values and in division operations.</data>
      <data key="d8">general-purpose register</data>
      <data key="d9">chunk-be143027fbd9f62579107c5fcd0f2740</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469714</data>
    </edge>
    <edge source="Register" target="Instruction Pointer">
      <data key="d6">1.0</data>
      <data key="d7">The Instruction Pointer is a specific type of register used to manage instruction execution flow.</data>
      <data key="d8">control flow,register function</data>
      <data key="d9">chunk-dc66410ab81cdb2a13f279e50457a470</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469793</data>
    </edge>
    <edge source="Register" target="Reg32">
      <data key="d6">1.0</data>
      <data key="d7">Reg32 is a specific type of register that represents a 32-bit register in the Intel Format.</data>
      <data key="d8">register size,specification</data>
      <data key="d9">chunk-3c363f9d809dadcf3a7c0f9008fb810a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469954</data>
    </edge>
    <edge source="Register" target="Reg16">
      <data key="d6">1.0</data>
      <data key="d7">Reg16 is a specific type of register that represents a 16-bit register in the Intel Format.</data>
      <data key="d8">register size,specification</data>
      <data key="d9">chunk-3c363f9d809dadcf3a7c0f9008fb810a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469956</data>
    </edge>
    <edge source="Register" target="Reg8">
      <data key="d6">1.0</data>
      <data key="d7">Reg8 is a specific type of register that represents an 8-bit register in the Intel Format.</data>
      <data key="d8">register size,specification</data>
      <data key="d9">chunk-3c363f9d809dadcf3a7c0f9008fb810a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469957</data>
    </edge>
    <edge source="Memory" target="Variable">
      <data key="d6">1.0</data>
      <data key="d7">The variable 'var' is a symbolic name representing a memory address used to store data.</data>
      <data key="d8">data storage,symbolic reference</data>
      <data key="d9">chunk-be143027fbd9f62579107c5fcd0f2740</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469706</data>
    </edge>
    <edge source="Memory" target="Byte Ptr">
      <data key="d6">1.0</data>
      <data key="d7">The byte ptr qualifier specifies that the access operation targets a single byte within a memory location.</data>
      <data key="d8">memory access,size specification</data>
      <data key="d9">chunk-be143027fbd9f62579107c5fcd0f2740</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469708</data>
    </edge>
    <edge source="Memory" target="Dword Ptr">
      <data key="d6">1.0</data>
      <data key="d7">The dword ptr qualifier specifies that the access operation targets a 4-byte (32-bit) value in memory.</data>
      <data key="d8">memory access,size specification</data>
      <data key="d9">chunk-be143027fbd9f62579107c5fcd0f2740</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469709</data>
    </edge>
    <edge source="Memory" target="Mem">
      <data key="d6">1.0</data>
      <data key="d7">Mem is a notation used in Intel Format to represent memory addresses.</data>
      <data key="d8">memory address notation,representation</data>
      <data key="d9">chunk-3c363f9d809dadcf3a7c0f9008fb810a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469954</data>
    </edge>
    <edge source="Data Transfer" target="MOV">
      <data key="d6">1.0</data>
      <data key="d7">MOV is a type of data transfer instruction.</data>
      <data key="d8">data movement,instruction category</data>
      <data key="d9">chunk-1853ae0bf21d6ed553e97992dab0cb73</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469595</data>
    </edge>
    <edge source="Data Transfer" target="LOAD">
      <data key="d6">1.0</data>
      <data key="d7">LOAD is a type of data transfer instruction.</data>
      <data key="d8">data movement,instruction category</data>
      <data key="d9">chunk-1853ae0bf21d6ed553e97992dab0cb73</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469596</data>
    </edge>
    <edge source="Data Transfer" target="STORE">
      <data key="d6">1.0</data>
      <data key="d7">STORE is a type of data transfer instruction.</data>
      <data key="d8">data movement,instruction category</data>
      <data key="d9">chunk-1853ae0bf21d6ed553e97992dab0cb73</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469596</data>
    </edge>
    <edge source="Data Transfer" target="PUSH">
      <data key="d6">1.0</data>
      <data key="d7">PUSH is a type of data transfer instruction.</data>
      <data key="d8">data movement,instruction category</data>
      <data key="d9">chunk-1853ae0bf21d6ed553e97992dab0cb73</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469597</data>
    </edge>
    <edge source="Data Transfer" target="POP">
      <data key="d6">1.0</data>
      <data key="d7">POP is a type of data transfer instruction.</data>
      <data key="d8">data movement,instruction category</data>
      <data key="d9">chunk-1853ae0bf21d6ed553e97992dab0cb73</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469597</data>
    </edge>
    <edge source="CISC" target="Software Compatibility">
      <data key="d6">1.0</data>
      <data key="d7">CISC supports software compatibility, allowing higher-end machines to run all instructions from lower-end models.</data>
      <data key="d8">backward compatibility,design feature</data>
      <data key="d9">chunk-d12ab3ee72f1f1a8f72c7e3dece14062</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469403</data>
    </edge>
    <edge source="CISC" target="Modern CISC Architecture">
      <data key="d6">1.0</data>
      <data key="d7">Modern CISC processors have incorporated many features from RISC, narrowing the performance gap.</data>
      <data key="d8">design convergence,evolution</data>
      <data key="d9">chunk-d12ab3ee72f1f1a8f72c7e3dece14062</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469404</data>
    </edge>
    <edge source="CISC" target="CPU Chip Area">
      <data key="d6">1.0</data>
      <data key="d7">CISC's microprogram control consumes over 50% of the CPU chip area, reducing available space for other components.</data>
      <data key="d8">area utilization,inefficiency</data>
      <data key="d9">chunk-2151538dd57e60dbb6761c6a35ea00c6</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761470020</data>
    </edge>
    <edge source="Intel" target="Modern CISC Architecture">
      <data key="d6">1.0</data>
      <data key="d7">Intel's dominance in the processor market is due to its continued use and enhancement of CISC architecture.</data>
      <data key="d8">market dominance,processor architecture</data>
      <data key="d9">chunk-d12ab3ee72f1f1a8f72c7e3dece14062</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469404</data>
    </edge>
    <edge source="100m Sprint Record" target="Noah Carter">
      <data key="d6">1.0</data>
      <data key="d7">Noah Carter set a new 100m sprint record at the championship.</data>
      <data key="d8">athlete achievement,record-breaking</data>
      <data key="d9">chunk-d12ab3ee72f1f1a8f72c7e3dece14062</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469404</data>
    </edge>
    <edge source="Carbon-Fiber Spikes" target="Noah Carter">
      <data key="d6">1.0</data>
      <data key="d7">Noah Carter used carbon-fiber spikes to enhance performance during the race.</data>
      <data key="d8">athletic equipment,performance boost</data>
      <data key="d9">chunk-d12ab3ee72f1f1a8f72c7e3dece14062</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469406</data>
    </edge>
    <edge source="Tokyo" target="World Athletics Championship">
      <data key="d6">1.0</data>
      <data key="d7">The World Athletics Championship is being hosted in Tokyo.</data>
      <data key="d8">event location,international competition</data>
      <data key="d9">chunk-d12ab3ee72f1f1a8f72c7e3dece14062</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469404</data>
    </edge>
    <edge source="World Athletics Championship" target="Noah Carter">
      <data key="d6">1.0</data>
      <data key="d7">Noah Carter is competing at the World Athletics Championship.</data>
      <data key="d8">athlete participation,competition</data>
      <data key="d9">chunk-d12ab3ee72f1f1a8f72c7e3dece14062</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469406</data>
    </edge>
    <edge source="Sequential Addressing" target="Program Counter">
      <data key="d6">1.0</data>
      <data key="d7">Sequential addressing automatically computes the next instruction address by adding the instruction length to the current Program Counter (PC) value.</data>
      <data key="d8">automatic addressing,incremental calculation</data>
      <data key="d9">chunk-090282a2e59cdb6b6513b1d2f898d3ae</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469456</data>
    </edge>
    <edge source="Sequential Addressing" target="Instruction Length">
      <data key="d6">1.0</data>
      <data key="d7">The amount by which the Program Counter (PC) is incremented during sequential addressing depends on the instruction length.</data>
      <data key="d8">address update,increment size</data>
      <data key="d9">chunk-090282a2e59cdb6b6513b1d2f898d3ae</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469456</data>
    </edge>
    <edge source="Jump Addressing" target="Absolute Transfer">
      <data key="d6">1.0</data>
      <data key="d7">Jump addressing includes absolute transfer, where the target address is directly specified in the instruction.</data>
      <data key="d8">conditional execution,direct control</data>
      <data key="d9">chunk-090282a2e59cdb6b6513b1d2f898d3ae</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469456</data>
    </edge>
    <edge source="Jump Addressing" target="Relative Transfer">
      <data key="d6">1.0</data>
      <data key="d7">Jump addressing includes relative transfer, where the target address is determined by adding an offset to the current Program Counter (PC) value.</data>
      <data key="d8">conditional execution,offset-based control</data>
      <data key="d9">chunk-090282a2e59cdb6b6513b1d2f898d3ae</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469457</data>
    </edge>
    <edge source="Jump Addressing" target="Status Register">
      <data key="d6">1.0</data>
      <data key="d7">The outcome of a jump addressing operation may be controlled by the flags stored in the Status Register.</data>
      <data key="d8">conditional branching control,execution decision</data>
      <data key="d9">chunk-090282a2e59cdb6b6513b1d2f898d3ae</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469457</data>
    </edge>
    <edge source="Program Counter" target="Main Memory">
      <data key="d6">1.0</data>
      <data key="d7">The CPU always uses the value stored in the Program Counter (PC) to fetch the next instruction from main memory.</data>
      <data key="d8">address input,instruction fetching</data>
      <data key="d9">chunk-090282a2e59cdb6b6513b1d2f898d3ae</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469456</data>
    </edge>
    <edge source="Program Counter" target="16-Bit Instruction">
      <data key="d6">1.0</data>
      <data key="d7">When executing a 16-bit instruction, the Program Counter (PC) is incremented by 2 to point to the next instruction.</data>
      <data key="d8">increment size,update logic</data>
      <data key="d9">chunk-090282a2e59cdb6b6513b1d2f898d3ae</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469457</data>
    </edge>
    <edge source="Program Counter" target="32-Bit Instruction">
      <data key="d6">1.0</data>
      <data key="d7">When executing a 32-bit instruction, the Program Counter (PC) is incremented by 4 to point to the next instruction.</data>
      <data key="d8">increment size,update logic</data>
      <data key="d9">chunk-090282a2e59cdb6b6513b1d2f898d3ae</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469457</data>
    </edge>
    <edge source="Program Counter" target="Processor Register">
      <data key="d6">1.0</data>
      <data key="d7">The program counter is a type of processor register that manages the flow of execution by storing the address of the next instruction.</data>
      <data key="d8">instruction control,register function</data>
      <data key="d9">chunk-986821269f2aa2025221040c595a72be</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469497</data>
    </edge>
    <edge source="Byte Addressing" target="16-Bit Instruction">
      <data key="d6">1.0</data>
      <data key="d7">In byte-addressed systems, a 16-bit instruction occupies two consecutive bytes in main memory.</data>
      <data key="d8">addressing granularity,memory layout</data>
      <data key="d9">chunk-090282a2e59cdb6b6513b1d2f898d3ae</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469456</data>
    </edge>
    <edge source="Byte Addressing" target="32-Bit Instruction">
      <data key="d6">1.0</data>
      <data key="d7">In byte-addressed systems, a 32-bit instruction occupies four consecutive bytes in main memory.</data>
      <data key="d8">addressing granularity,memory layout</data>
      <data key="d9">chunk-090282a2e59cdb6b6513b1d2f898d3ae</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469457</data>
    </edge>
    <edge source="Main Memory" target="cmp Instruction">
      <data key="d6">1.0</data>
      <data key="d7">The cmp instruction accesses data from main memory to compare values stored at memory addresses.</data>
      <data key="d8">memory access,operand retrieval</data>
      <data key="d9">chunk-dc66410ab81cdb2a13f279e50457a470</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469794</data>
    </edge>
    <edge source="Main Memory" target="test Instruction">
      <data key="d6">1.0</data>
      <data key="d7">The test instruction accesses data from main memory to perform a bitwise AND operation.</data>
      <data key="d8">memory access,operand retrieval</data>
      <data key="d9">chunk-dc66410ab81cdb2a13f279e50457a470</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469797</data>
    </edge>
    <edge source="Main Memory" target="Main Memory Address">
      <data key="d6">1.0</data>
      <data key="d7">Main memory stores data at specific addresses used for operand retrieval.</data>
      <data key="d8">data access,memory addressing</data>
      <data key="d9">chunk-dc66410ab81cdb2a13f279e50457a470</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469798</data>
    </edge>
    <edge source="Instruction Set Architecture" target="Machine Language">
      <data key="d6">1.0</data>
      <data key="d7">The Instruction Set Architecture defines the interface that machine language programs must follow to interact with the hardware.</data>
      <data key="d8">execution layer,interface specification</data>
      <data key="d9">chunk-986821269f2aa2025221040c595a72be</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469498</data>
    </edge>
    <edge source="Instruction Set Architecture" target="Assembly Language">
      <data key="d6">1.0</data>
      <data key="d7">Assembly language programs are written based on the instruction set defined by the ISA, providing a symbolic representation of machine code.</data>
      <data key="d8">human-readable form,interface specification</data>
      <data key="d9">chunk-986821269f2aa2025221040c595a72be</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469498</data>
    </edge>
    <edge source="Instruction Set Architecture" target="Instruction Format">
      <data key="d6">1.0</data>
      <data key="d7">The ISA specifies the format of each instruction, including how opcodes and operands are encoded.</data>
      <data key="d8">specification,structural definition</data>
      <data key="d9">chunk-986821269f2aa2025221040c595a72be</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469499</data>
    </edge>
    <edge source="Instruction Set Architecture" target="Operand Addressing Mode">
      <data key="d6">1.0</data>
      <data key="d7">The ISA defines how operands are located in memory or registers, including various addressing modes.</data>
      <data key="d8">memory access definition,specification</data>
      <data key="d9">chunk-986821269f2aa2025221040c595a72be</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469499</data>
    </edge>
    <edge source="Instruction Set Architecture" target="Data Type">
      <data key="d6">1.0</data>
      <data key="d7">The ISA defines the types of data that can be processed, including size, format, and representation (e.g., big or little endian).</data>
      <data key="d8">data representation,specification</data>
      <data key="d9">chunk-986821269f2aa2025221040c595a72be</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469499</data>
    </edge>
    <edge source="Instruction Set Architecture" target="Memory Addressing">
      <data key="d6">1.0</data>
      <data key="d7">The ISA defines the method by which the processor accesses memory, including address size and layout.</data>
      <data key="d8">specification,storage access method</data>
      <data key="d9">chunk-986821269f2aa2025221040c595a72be</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469500</data>
    </edge>
    <edge source="Instruction Set Architecture" target="Big Endian">
      <data key="d6">1.0</data>
      <data key="d7">The ISA specifies whether data is stored in big endian format, determining the byte order in multi-byte values.</data>
      <data key="d8">byte ordering,data representation</data>
      <data key="d9">chunk-986821269f2aa2025221040c595a72be</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469500</data>
    </edge>
    <edge source="Instruction Set Architecture" target="Little Endian">
      <data key="d6">1.0</data>
      <data key="d7">The ISA specifies whether data is stored in little endian format, determining the byte order in multi-byte values.</data>
      <data key="d8">byte ordering,data representation</data>
      <data key="d9">chunk-986821269f2aa2025221040c595a72be</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469500</data>
    </edge>
    <edge source="Assembly Language" target="Assembly Instructions">
      <data key="d6">1.0</data>
      <data key="d7">Assembly Instructions are the fundamental components of assembly language, defined by syntax rules such as those used in AT&amp;T and Intel formats.</data>
      <data key="d8">programming language type,syntactic basis</data>
      <data key="d9">chunk-53c922e8f9c9847391088bcc3c5430ac</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469812</data>
    </edge>
    <edge source="High-Level Language" target="Performance Optimization">
      <data key="d6">1.0</data>
      <data key="d7">High-level languages abstract away machine-level details, making it difficult for programmers to apply performance optimization techniques without understanding the underlying ISA and hardware.</data>
      <data key="d8">abstraction cost,optimization dependency</data>
      <data key="d9">chunk-986821269f2aa2025221040c595a72be</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469497</data>
    </edge>
    <edge source="Arithmetic And Logical Operations" target="ADD">
      <data key="d6">1.0</data>
      <data key="d7">ADD is a type of arithmetic and logical operation.</data>
      <data key="d8">arithmetic operation,instruction category</data>
      <data key="d9">chunk-1853ae0bf21d6ed553e97992dab0cb73</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469595</data>
    </edge>
    <edge source="Arithmetic And Logical Operations" target="SUB">
      <data key="d6">1.0</data>
      <data key="d7">SUB is a type of arithmetic and logical operation.</data>
      <data key="d8">arithmetic operation,instruction category</data>
      <data key="d9">chunk-1853ae0bf21d6ed553e97992dab0cb73</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469596</data>
    </edge>
    <edge source="Arithmetic And Logical Operations" target="MUL">
      <data key="d6">1.0</data>
      <data key="d7">MUL is a type of arithmetic and logical operation.</data>
      <data key="d8">arithmetic operation,instruction category</data>
      <data key="d9">chunk-1853ae0bf21d6ed553e97992dab0cb73</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469596</data>
    </edge>
    <edge source="Arithmetic And Logical Operations" target="DIV">
      <data key="d6">1.0</data>
      <data key="d7">DIV is a type of arithmetic and logical operation.</data>
      <data key="d8">arithmetic operation,instruction category</data>
      <data key="d9">chunk-1853ae0bf21d6ed553e97992dab0cb73</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469596</data>
    </edge>
    <edge source="Arithmetic And Logical Operations" target="INC">
      <data key="d6">1.0</data>
      <data key="d7">INC is a type of arithmetic and logical operation.</data>
      <data key="d8">arithmetic operation,instruction category</data>
      <data key="d9">chunk-1853ae0bf21d6ed553e97992dab0cb73</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469597</data>
    </edge>
    <edge source="Arithmetic And Logical Operations" target="DEC">
      <data key="d6">1.0</data>
      <data key="d7">DEC is a type of arithmetic and logical operation.</data>
      <data key="d8">arithmetic operation,instruction category</data>
      <data key="d9">chunk-1853ae0bf21d6ed553e97992dab0cb73</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469597</data>
    </edge>
    <edge source="Arithmetic And Logical Operations" target="AND">
      <data key="d6">1.0</data>
      <data key="d7">AND is a type of arithmetic and logical operation.</data>
      <data key="d8">instruction category,logical operation</data>
      <data key="d9">chunk-1853ae0bf21d6ed553e97992dab0cb73</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469598</data>
    </edge>
    <edge source="Arithmetic And Logical Operations" target="OR">
      <data key="d6">1.0</data>
      <data key="d7">OR is a type of arithmetic and logical operation.</data>
      <data key="d8">instruction category,logical operation</data>
      <data key="d9">chunk-1853ae0bf21d6ed553e97992dab0cb73</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469598</data>
    </edge>
    <edge source="Arithmetic And Logical Operations" target="NOT">
      <data key="d6">1.0</data>
      <data key="d7">NOT is a type of arithmetic and logical operation.</data>
      <data key="d8">instruction category,logical operation</data>
      <data key="d9">chunk-1853ae0bf21d6ed553e97992dab0cb73</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469599</data>
    </edge>
    <edge source="Arithmetic And Logical Operations" target="XOR">
      <data key="d6">1.0</data>
      <data key="d7">XOR is a type of arithmetic and logical operation.</data>
      <data key="d8">instruction category,logical operation</data>
      <data key="d9">chunk-1853ae0bf21d6ed553e97992dab0cb73</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469599</data>
    </edge>
    <edge source="Shift Operations" target="Arithmetic Shift">
      <data key="d6">1.0</data>
      <data key="d7">Arithmetic shift is a type of shift operation.</data>
      <data key="d8">bit manipulation,instruction category</data>
      <data key="d9">chunk-1853ae0bf21d6ed553e97992dab0cb73</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469597</data>
    </edge>
    <edge source="Shift Operations" target="Logical Shift">
      <data key="d6">1.0</data>
      <data key="d7">Logical shift is a type of shift operation.</data>
      <data key="d8">bit manipulation,instruction category</data>
      <data key="d9">chunk-1853ae0bf21d6ed553e97992dab0cb73</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469597</data>
    </edge>
    <edge source="Shift Operations" target="Circular Shift">
      <data key="d6">1.0</data>
      <data key="d7">Circular shift is a type of shift operation.</data>
      <data key="d8">bit manipulation,instruction category</data>
      <data key="d9">chunk-1853ae0bf21d6ed553e97992dab0cb73</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469598</data>
    </edge>
    <edge source="Branching Operations" target="JMP">
      <data key="d6">1.0</data>
      <data key="d7">JMP is a type of branching operation.</data>
      <data key="d8">control transfer,instruction category</data>
      <data key="d9">chunk-1853ae0bf21d6ed553e97992dab0cb73</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469597</data>
    </edge>
    <edge source="Branching Operations" target="BRANCH">
      <data key="d6">1.0</data>
      <data key="d7">BRANCH is a type of branching operation.</data>
      <data key="d8">control transfer,instruction category</data>
      <data key="d9">chunk-1853ae0bf21d6ed553e97992dab0cb73</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469598</data>
    </edge>
    <edge source="Branching Operations" target="CALL">
      <data key="d6">1.0</data>
      <data key="d7">CALL is a type of branching operation that supports subroutine calls.</data>
      <data key="d8">instruction category,subroutine handling</data>
      <data key="d9">chunk-1853ae0bf21d6ed553e97992dab0cb73</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469599</data>
    </edge>
    <edge source="Branching Operations" target="RET">
      <data key="d6">1.0</data>
      <data key="d7">RET is a type of branching operation that returns from a subroutine.</data>
      <data key="d8">instruction category,subroutine handling</data>
      <data key="d9">chunk-1853ae0bf21d6ed553e97992dab0cb73</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469599</data>
    </edge>
    <edge source="Branching Operations" target="TRAP">
      <data key="d6">1.0</data>
      <data key="d7">TRAP is a type of branching operation used for handling exceptions.</data>
      <data key="d8">exception handling,instruction category</data>
      <data key="d9">chunk-1853ae0bf21d6ed553e97992dab0cb73</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469600</data>
    </edge>
    <edge source="Fixed-Length Opcode Instruction Format" target="Opcode Field">
      <data key="d6">1.0</data>
      <data key="d7">The fixed-length opcode instruction format uses a dedicated opcode field within the instruction word to represent operation codes.</data>
      <data key="d8">encoding,instruction structure</data>
      <data key="d9">chunk-7fa816a9f8d5ac78d7483ae33a74ba7b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469640</data>
    </edge>
    <edge source="Fixed-Length Opcode Instruction Format" target="Instruction Decoding">
      <data key="d6">1.0</data>
      <data key="d7">The fixed-length opcode format simplifies and accelerates instruction decoding, improving processor performance.</data>
      <data key="d8">hardware simplicity,speed optimization</data>
      <data key="d9">chunk-7fa816a9f8d5ac78d7483ae33a74ba7b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469641</data>
    </edge>
    <edge source="Fixed-Length Opcode Instruction Format" target="Computer Hardware Design">
      <data key="d6">1.0</data>
      <data key="d7">Using fixed-length opcodes aids in simplifying computer hardware design by enabling predictable and uniform instruction processing.</data>
      <data key="d8">design advantage,implementation efficiency</data>
      <data key="d9">chunk-7fa816a9f8d5ac78d7483ae33a74ba7b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469641</data>
    </edge>
    <edge source="Opcode Field" target="Maximum Instruction Capacity">
      <data key="d6">1.0</data>
      <data key="d7">The size of the opcode field determines the maximum instruction capacity, which is 2 to the power of the field's bit count.</data>
      <data key="d8">bit-length dependency,capacity limit</data>
      <data key="d9">chunk-7fa816a9f8d5ac78d7483ae33a74ba7b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469641</data>
    </edge>
    <edge source="Idiv Instruction" target="Eax Register">
      <data key="d6">1.0</data>
      <data key="d7">The idiv instruction uses the 64-bit value formed by edx:eax as the dividend, where eax stores the low-order 32 bits.</data>
      <data key="d8">dividend handling,division operation</data>
      <data key="d9">chunk-be143027fbd9f62579107c5fcd0f2740</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469698</data>
    </edge>
    <edge source="Idiv Instruction" target="Edx Register">
      <data key="d6">1.0</data>
      <data key="d7">The idiv instruction stores the remainder of the division in the edx register after performing the division.</data>
      <data key="d8">division operation,remainder storage</data>
      <data key="d9">chunk-be143027fbd9f62579107c5fcd0f2740</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469699</data>
    </edge>
    <edge source="Idiv Instruction" target="64-Bit Value">
      <data key="d6">2.0</data>
      <data key="d7">The idiv instruction uses a 64-bit value from edx:eax as the dividend in a signed division.&lt;SEP&gt;The idiv instruction treats edx:eax as a 64-bit value during the division process.</data>
      <data key="d8">64-bit division,dividend representation</data>
      <data key="d9">chunk-be143027fbd9f62579107c5fcd0f2740</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469704</data>
    </edge>
    <edge source="Xor Instruction" target="Constant">
      <data key="d6">1.0</data>
      <data key="d7">The xor instruction can apply a constant to clear or toggle specific bits in a register or memory location.</data>
      <data key="d8">bitwise XOR with constant</data>
      <data key="d9">chunk-be143027fbd9f62579107c5fcd0f2740</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469704</data>
    </edge>
    <edge source="Xor Instruction" target="Logic Operation">
      <data key="d6">1.0</data>
      <data key="d7">The xor instruction implements a logical XOR operation between two operands.</data>
      <data key="d8">bitwise operation,logical XOR</data>
      <data key="d9">chunk-be143027fbd9f62579107c5fcd0f2740</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469711</data>
    </edge>
    <edge source="Neg Instruction" target="Two's Complement">
      <data key="d6">1.0</data>
      <data key="d7">The neg instruction uses the twoâ€™s complement method to compute the negative of a number.</data>
      <data key="d8">negative number,sign representation</data>
      <data key="d9">chunk-be143027fbd9f62579107c5fcd0f2740</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469709</data>
    </edge>
    <edge source="Shr Instruction" target="Constant">
      <data key="d6">1.0</data>
      <data key="d7">The shr instruction uses a constant to specify the number of bits to shift right in a register.</data>
      <data key="d8">shift by constant</data>
      <data key="d9">chunk-be143027fbd9f62579107c5fcd0f2740</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469706</data>
    </edge>
    <edge source="Constant" target="0fH">
      <data key="d6">1.0</data>
      <data key="d7">The constant 0fH is used as a mask to isolate the lower 4 bits in a bitwise AND operation.</data>
      <data key="d8">bit mask,hexadecimal value</data>
      <data key="d9">chunk-be143027fbd9f62579107c5fcd0f2740</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469711</data>
    </edge>
    <edge source="Constant" target="Con8">
      <data key="d6">1.0</data>
      <data key="d7">Con8 is a notation used in Intel Format to represent an 8-bit constant.</data>
      <data key="d8">constant size,representation</data>
      <data key="d9">chunk-3c363f9d809dadcf3a7c0f9008fb810a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469954</data>
    </edge>
    <edge source="Constant" target="Con16">
      <data key="d6">1.0</data>
      <data key="d7">Con16 is a notation used in Intel Format to represent a 16-bit constant.</data>
      <data key="d8">constant size,representation</data>
      <data key="d9">chunk-3c363f9d809dadcf3a7c0f9008fb810a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469956</data>
    </edge>
    <edge source="Constant" target="Con32">
      <data key="d6">1.0</data>
      <data key="d7">Con32 is a notation used in Intel Format to represent a 32-bit constant.</data>
      <data key="d8">constant size,representation</data>
      <data key="d9">chunk-3c363f9d809dadcf3a7c0f9008fb810a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469957</data>
    </edge>
    <edge source="Eax Register" target="Division Result">
      <data key="d6">1.0</data>
      <data key="d7">After division, the quotient is stored in the eax register.</data>
      <data key="d8">quotient storage</data>
      <data key="d9">chunk-be143027fbd9f62579107c5fcd0f2740</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469711</data>
    </edge>
    <edge source="Edx Register" target="Division Result">
      <data key="d6">1.0</data>
      <data key="d7">After division, the remainder is stored in the edx register.</data>
      <data key="d8">remainder storage</data>
      <data key="d9">chunk-be143027fbd9f62579107c5fcd0f2740</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469713</data>
    </edge>
    <edge source="Byte Ptr" target="Intel Format">
      <data key="d6">1.0</data>
      <data key="d7">In Intel Format, 'byte ptr' is used to explicitly declare a byte-sized operand.</data>
      <data key="d8">data size specification</data>
      <data key="d9">chunk-53c922e8f9c9847391088bcc3c5430ac</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469812</data>
    </edge>
    <edge source="Dword Ptr" target="Intel Format">
      <data key="d6">1.0</data>
      <data key="d7">In Intel Format, 'dword ptr' is used to explicitly declare a double-word-sized operand.</data>
      <data key="d8">data size specification</data>
      <data key="d9">chunk-53c922e8f9c9847391088bcc3c5430ac</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469814</data>
    </edge>
    <edge source="Overflow Flag" target="Exception Handling">
      <data key="d6">1.0</data>
      <data key="d7">The overflow flag being set triggers an interrupt or exception handler for overflow conditions.</data>
      <data key="d8">control flow,error detection</data>
      <data key="d9">chunk-be143027fbd9f62579107c5fcd0f2740</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469709</data>
    </edge>
    <edge source="Overflow Flag" target="cmp Instruction">
      <data key="d6">1.0</data>
      <data key="d7">The cmp instruction sets the Overflow Flag when the subtraction of two operands results in an overflow.</data>
      <data key="d8">arithmetic overflow,flag setting</data>
      <data key="d9">chunk-dc66410ab81cdb2a13f279e50457a470</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469797</data>
    </edge>
    <edge source="Two's Complement" target="Immediate Addressing">
      <data key="d6">1.0</data>
      <data key="d7">Immediate addressing uses two's complement to encode the immediate operand within the instruction.</data>
      <data key="d8">data representation,integer encoding</data>
      <data key="d9">chunk-ee7b048d8f7d4f6a7cdb8bd206b3d9c3</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469933</data>
    </edge>
    <edge source="x86 Processor" target="Instruction Pointer">
      <data key="d6">1.0</data>
      <data key="d7">The x86 processor maintains and updates the Instruction Pointer to track the address of the next instruction to be executed.</data>
      <data key="d8">instruction execution,register management</data>
      <data key="d9">chunk-dc66410ab81cdb2a13f279e50457a470</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469789</data>
    </edge>
    <edge source="Instruction Pointer" target="jmp Instruction">
      <data key="d6">1.0</data>
      <data key="d7">The jmp instruction modifies the instruction pointer to jump to a labeled address, thereby changing the flow of execution.</data>
      <data key="d8">address update,control flow</data>
      <data key="d9">chunk-dc66410ab81cdb2a13f279e50457a470</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469790</data>
    </edge>
    <edge source="Label" target="jmp Instruction">
      <data key="d6">1.0</data>
      <data key="d7">The jmp instruction uses a label to specify the target address for an unconditional jump.</data>
      <data key="d8">control flow,targeting</data>
      <data key="d9">chunk-dc66410ab81cdb2a13f279e50457a470</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469789</data>
    </edge>
    <edge source="Label" target="x86 Assembly Code">
      <data key="d6">1.0</data>
      <data key="d7">Labels are used in x86 assembly code to mark specific instruction addresses for control flow instructions.</data>
      <data key="d8">code labeling,syntactic structure</data>
      <data key="d9">chunk-dc66410ab81cdb2a13f279e50457a470</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469791</data>
    </edge>
    <edge source="jmp Instruction" target="x86 Assembly Code">
      <data key="d6">1.0</data>
      <data key="d7">The jmp instruction is written in x86 assembly code and instructs the processor to jump to a labeled instruction.</data>
      <data key="d8">control flow,instruction syntax</data>
      <data key="d9">chunk-dc66410ab81cdb2a13f279e50457a470</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469792</data>
    </edge>
    <edge source="jcondition Instruction" target="CPU Status Word">
      <data key="d6">1.0</data>
      <data key="d7">The jcondition instructions rely on condition codes set in the CPU Status Word to determine whether to transfer control.</data>
      <data key="d8">conditional branching,flag dependency</data>
      <data key="d9">chunk-dc66410ab81cdb2a13f279e50457a470</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469789</data>
    </edge>
    <edge source="jcondition Instruction" target="cmp Instruction">
      <data key="d6">1.0</data>
      <data key="d7">The cmp instruction is typically used before a jcondition instruction to set flags that determine the conditional jump outcome.</data>
      <data key="d8">conditional logic,instruction sequencing</data>
      <data key="d9">chunk-dc66410ab81cdb2a13f279e50457a470</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469790</data>
    </edge>
    <edge source="jcondition Instruction" target="test Instruction">
      <data key="d6">1.0</data>
      <data key="d7">The test instruction sets flags used by jcondition instructions to determine execution flow.</data>
      <data key="d8">conditional logic,instruction sequencing</data>
      <data key="d9">chunk-dc66410ab81cdb2a13f279e50457a470</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469791</data>
    </edge>
    <edge source="cmp Instruction" target="CPU Status Word">
      <data key="d6">1.0</data>
      <data key="d7">The cmp instruction sets the condition flags in the CPU Status Word based on the result of comparing two operands.</data>
      <data key="d8">arithmetic comparison,flag setting</data>
      <data key="d9">chunk-dc66410ab81cdb2a13f279e50457a470</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469791</data>
    </edge>
    <edge source="cmp Instruction" target="x86 Assembly Code">
      <data key="d6">1.0</data>
      <data key="d7">The cmp instruction is used in x86 assembly code to compare two operands and set flags.</data>
      <data key="d8">comparison,instruction syntax</data>
      <data key="d9">chunk-dc66410ab81cdb2a13f279e50457a470</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469793</data>
    </edge>
    <edge source="cmp Instruction" target="Zero Flag">
      <data key="d6">1.0</data>
      <data key="d7">The cmp instruction sets the Zero Flag when the two operands are equal.</data>
      <data key="d8">flag setting,result comparison</data>
      <data key="d9">chunk-dc66410ab81cdb2a13f279e50457a470</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469795</data>
    </edge>
    <edge source="cmp Instruction" target="Negative Flag">
      <data key="d6">1.0</data>
      <data key="d7">The cmp instruction sets the Negative Flag when the first operand is less than the second.</data>
      <data key="d8">flag setting,sign comparison</data>
      <data key="d9">chunk-dc66410ab81cdb2a13f279e50457a470</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469796</data>
    </edge>
    <edge source="cmp Instruction" target="dword ptr">
      <data key="d6">1.0</data>
      <data key="d7">The cmp instruction uses dword ptr to reference a 32-bit value stored in main memory.</data>
      <data key="d8">memory access,operand size specification</data>
      <data key="d9">chunk-dc66410ab81cdb2a13f279e50457a470</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469802</data>
    </edge>
    <edge source="test Instruction" target="x86 Assembly Code">
      <data key="d6">1.0</data>
      <data key="d7">The test instruction is used in x86 assembly code to perform a bitwise AND without storing the result.</data>
      <data key="d8">bitwise checking,instruction syntax</data>
      <data key="d9">chunk-dc66410ab81cdb2a13f279e50457a470</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469795</data>
    </edge>
    <edge source="test Instruction" target="CPU Status Word">
      <data key="d6">1.0</data>
      <data key="d7">The test instruction sets condition flags based on the result of a bitwise AND operation without storing the result.</data>
      <data key="d8">bitwise operation,flag setting</data>
      <data key="d9">chunk-dc66410ab81cdb2a13f279e50457a470</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469796</data>
    </edge>
    <edge source="test Instruction" target="Bitwise And Operation">
      <data key="d6">1.0</data>
      <data key="d7">The test instruction performs a bitwise AND operation and updates condition flags without storing the result.</data>
      <data key="d8">flag update,logical operation</data>
      <data key="d9">chunk-dc66410ab81cdb2a13f279e50457a470</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469798</data>
    </edge>
    <edge source="test Instruction" target="dword ptr">
      <data key="d6">1.0</data>
      <data key="d7">The test instruction uses dword ptr to specify a 32-bit memory operand for bitwise comparison.</data>
      <data key="d8">memory access,operand size specification</data>
      <data key="d9">chunk-dc66410ab81cdb2a13f279e50457a470</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469803</data>
    </edge>
    <edge source="call Instruction" target="ret Instruction">
      <data key="d6">1.0</data>
      <data key="d7">The call and ret instructions together form the fundamental mechanism for calling and returning from a subroutine.</data>
      <data key="d8">execution cycle,subroutine mechanism</data>
      <data key="d9">chunk-dc66410ab81cdb2a13f279e50457a470</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469791</data>
    </edge>
    <edge source="call Instruction" target="x86 Assembly Code">
      <data key="d6">1.0</data>
      <data key="d7">The call instruction is written in x86 assembly code to invoke a subroutine at a labeled address.</data>
      <data key="d8">instruction syntax,subroutine invocation</data>
      <data key="d9">chunk-dc66410ab81cdb2a13f279e50457a470</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469794</data>
    </edge>
    <edge source="ret Instruction" target="x86 Assembly Code">
      <data key="d6">1.0</data>
      <data key="d7">The ret instruction is written in x86 assembly code to return control from a subroutine.</data>
      <data key="d8">instruction syntax,subroutine return</data>
      <data key="d9">chunk-dc66410ab81cdb2a13f279e50457a470</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469796</data>
    </edge>
    <edge source="Zero Flag" target="jz Instruction">
      <data key="d6">1.0</data>
      <data key="d7">The jz instruction jumps when the Zero Flag is set, indicating a zero result from the last operation.</data>
      <data key="d8">conditional jump,zero detection</data>
      <data key="d9">chunk-dc66410ab81cdb2a13f279e50457a470</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469796</data>
    </edge>
    <edge source="Zero Flag" target="je Instruction">
      <data key="d6">1.0</data>
      <data key="d7">The je instruction jumps when the Zero Flag is set, indicating the operands are equal.</data>
      <data key="d8">conditional jump,equality detection</data>
      <data key="d9">chunk-dc66410ab81cdb2a13f279e50457a470</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469798</data>
    </edge>
    <edge source="Zero Flag" target="jne Instruction">
      <data key="d6">1.0</data>
      <data key="d7">The jne instruction jumps when the Zero Flag is not set, indicating the operands are not equal.</data>
      <data key="d8">conditional jump,inequality detection</data>
      <data key="d9">chunk-dc66410ab81cdb2a13f279e50457a470</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469800</data>
    </edge>
    <edge source="Negative Flag" target="jg Instruction">
      <data key="d6">1.0</data>
      <data key="d7">The jg instruction jumps when the result is greater than, based on the sign and zero flags.</data>
      <data key="d8">conditional jump,greater than</data>
      <data key="d9">chunk-dc66410ab81cdb2a13f279e50457a470</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469797</data>
    </edge>
    <edge source="Negative Flag" target="jge Instruction">
      <data key="d6">1.0</data>
      <data key="d7">The jge instruction jumps when the result is greater than or equal, utilizing the sign and zero flags.</data>
      <data key="d8">conditional jump,greater than or equal</data>
      <data key="d9">chunk-dc66410ab81cdb2a13f279e50457a470</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469799</data>
    </edge>
    <edge source="Negative Flag" target="jl Instruction">
      <data key="d6">1.0</data>
      <data key="d7">The jl instruction jumps when the result is less than, based on the sign flag.</data>
      <data key="d8">conditional jump,less than</data>
      <data key="d9">chunk-dc66410ab81cdb2a13f279e50457a470</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469801</data>
    </edge>
    <edge source="Negative Flag" target="jle Instruction">
      <data key="d6">1.0</data>
      <data key="d7">The jle instruction jumps when the result is less than or equal, based on sign and zero flags.</data>
      <data key="d8">conditional jump,less than or equal</data>
      <data key="d9">chunk-dc66410ab81cdb2a13f279e50457a470</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469802</data>
    </edge>
    <edge source="Main Memory Address" target="dword ptr">
      <data key="d6">1.0</data>
      <data key="d7">The dword ptr directive specifies a 32-bit memory operand whose address is accessed from main memory.</data>
      <data key="d8">memory addressing,operand size</data>
      <data key="d9">chunk-dc66410ab81cdb2a13f279e50457a470</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469800</data>
    </edge>
    <edge source="AT&amp;T Format" target="Intel Format">
      <data key="d6">1.0</data>
      <data key="d7">AT&amp;T Format and Intel Format are two distinct styles of assembly language syntax with differing conventions in case sensitivity, operand order, and operand notation.</data>
      <data key="d8">instruction distinction,syntax comparison</data>
      <data key="d9">chunk-53c922e8f9c9847391088bcc3c5430ac</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469810</data>
    </edge>
    <edge source="AT&amp;T Format" target="Register Prefix">
      <data key="d6">1.0</data>
      <data key="d7">In AT&amp;T Format, registers must be prefixed with '%' to indicate their use in instructions.</data>
      <data key="d8">operand notation</data>
      <data key="d9">chunk-53c922e8f9c9847391088bcc3c5430ac</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469810</data>
    </edge>
    <edge source="AT&amp;T Format" target="Immediate Value Prefix">
      <data key="d6">1.0</data>
      <data key="d7">In AT&amp;T Format, immediate values must be prefixed with '$' to distinguish them from other operands.</data>
      <data key="d8">operand notation</data>
      <data key="d9">chunk-53c922e8f9c9847391088bcc3c5430ac</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469811</data>
    </edge>
    <edge source="AT&amp;T Format" target="Memory Addressing Parentheses">
      <data key="d6">1.0</data>
      <data key="d7">In AT&amp;T Format, memory operands are enclosed in parentheses '(' and ')' to indicate indirect addressing.</data>
      <data key="d8">memory addressing syntax</data>
      <data key="d9">chunk-53c922e8f9c9847391088bcc3c5430ac</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469812</data>
    </edge>
    <edge source="AT&amp;T Format" target="Data Size Suffix">
      <data key="d6">1.0</data>
      <data key="d7">In AT&amp;T Format, data size is specified using suffixes like 'b', 'w', or 'l' following the instruction opcode.</data>
      <data key="d8">data specification</data>
      <data key="d9">chunk-53c922e8f9c9847391088bcc3c5430ac</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469813</data>
    </edge>
    <edge source="Intel Format" target="Memory Addressing Brackets">
      <data key="d6">1.0</data>
      <data key="d7">In Intel Format, memory operands are enclosed in brackets '[' and ']' to indicate indirect addressing.</data>
      <data key="d8">memory addressing syntax</data>
      <data key="d9">chunk-53c922e8f9c9847391088bcc3c5430ac</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469810</data>
    </edge>
    <edge source="Intel Format" target="Word Ptr">
      <data key="d6">1.0</data>
      <data key="d7">In Intel Format, 'word ptr' is used to explicitly declare a word-sized operand.</data>
      <data key="d8">data size specification</data>
      <data key="d9">chunk-53c922e8f9c9847391088bcc3c5430ac</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469813</data>
    </edge>
    <edge source="Intel Format" target="Data Transfer Instructions">
      <data key="d6">1.0</data>
      <data key="d7">Intel Format is used to define the syntax and categorization of data transfer instructions in assembly language.</data>
      <data key="d8">categorization,instruction syntax</data>
      <data key="d9">chunk-3c363f9d809dadcf3a7c0f9008fb810a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469954</data>
    </edge>
    <edge source="Intel Format" target="Arithmetic and Logic Operations Instructions">
      <data key="d6">1.0</data>
      <data key="d7">Intel Format is used to define the syntax and categorization of arithmetic and logic operations instructions.</data>
      <data key="d8">categorization,instruction syntax</data>
      <data key="d9">chunk-3c363f9d809dadcf3a7c0f9008fb810a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469956</data>
    </edge>
    <edge source="Intel Format" target="Control Flow Instructions">
      <data key="d6">1.0</data>
      <data key="d7">Intel Format is used to define the syntax and categorization of control flow instructions.</data>
      <data key="d8">categorization,instruction syntax</data>
      <data key="d9">chunk-3c363f9d809dadcf3a7c0f9008fb810a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469957</data>
    </edge>
    <edge source="Word" target="32-Bit Architecture">
      <data key="d6">1.0</data>
      <data key="d7">The 32-bit architecture uses 16-bit words as a foundational unit for data representation.</data>
      <data key="d8">architecture data size</data>
      <data key="d9">chunk-53c922e8f9c9847391088bcc3c5430ac</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469811</data>
    </edge>
    <edge source="Word" target="64-Bit Architecture">
      <data key="d6">1.0</data>
      <data key="d7">The 64-bit architecture uses 16-bit words as a foundational unit for data representation.</data>
      <data key="d8">architecture data size</data>
      <data key="d9">chunk-53c922e8f9c9847391088bcc3c5430ac</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469812</data>
    </edge>
    <edge source="æ‰©å±•æ“ä½œç æŒ‡ä»¤æ ¼å¼" target="å¯å˜é•¿åº¦æ“ä½œç ">
      <data key="d6">1.0</data>
      <data key="d7">The extension opcode instruction format implements variable-length opcodes to optimize instruction encoding.</data>
      <data key="d8">implementation technique,methodological relationship</data>
      <data key="d9">chunk-0d36c83754193098d8c62f2f838760fe</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469881</data>
    </edge>
    <edge source="æ‰©å±•æ“ä½œç æŒ‡ä»¤æ ¼å¼" target="è®¾è®¡æ‰©å±•æ“ä½œç æŒ‡ä»¤æ ¼å¼">
      <data key="d6">1.0</data>
      <data key="d7">The design of the extension opcode instruction format is the specific implementation approach used to realize the method in processor architecture.</data>
      <data key="d8">conceptual implementation,methodological specification</data>
      <data key="d9">chunk-0d36c83754193098d8c62f2f838760fe</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469883</data>
    </edge>
    <edge source="å¯å˜é•¿åº¦æ“ä½œç " target="æŒ‡ä»¤å­—é•¿">
      <data key="d6">1.0</data>
      <data key="d7">Variable-length opcodes help manage the constraint of limited instruction word length while supporting diverse instructions.</data>
      <data key="d8">constraint management,design trade-off</data>
      <data key="d9">chunk-0d36c83754193098d8c62f2f838760fe</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469883</data>
    </edge>
    <edge source="æ‰©å±•æ“ä½œç " target="åœ°å€ç ">
      <data key="d6">1.0</data>
      <data key="d7">The length of the extension opcode increases as the number of address codes decreases.</data>
      <data key="d8">instruction design,opcode length relationship</data>
      <data key="d9">chunk-0d36c83754193098d8c62f2f838760fe</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469881</data>
    </edge>
    <edge source="æ‰©å±•æ“ä½œç " target="çŸ­ç ">
      <data key="d6">1.0</data>
      <data key="d7">Short codes are assigned to instructions with higher usage frequency, while long codes are used for low-frequency ones.</data>
      <data key="d8">coding strategy,inverse length allocation</data>
      <data key="d9">chunk-0d36c83754193098d8c62f2f838760fe</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469885</data>
    </edge>
    <edge source="æ‰©å±•æ“ä½œç " target="é•¿ç ">
      <data key="d6">1.0</data>
      <data key="d7">Long codes are assigned to low-frequency instructions to reduce redundancy and avoid code conflict.</data>
      <data key="d8">coding strategy,inverse length allocation</data>
      <data key="d9">chunk-0d36c83754193098d8c62f2f838760fe</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469886</data>
    </edge>
    <edge source="çŸ­ç " target="ä¸å…è®¸æ˜¯é•¿ç çš„å‰ç¼€">
      <data key="d6">1.0</data>
      <data key="d7">Short codes must not be the prefix of longer codes to prevent ambiguity in instruction decoding.</data>
      <data key="d8">codeword constraint,prefix-free requirement</data>
      <data key="d9">chunk-0d36c83754193098d8c62f2f838760fe</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469881</data>
    </edge>
    <edge source="æ“ä½œç é‡å¤" target="ç¦æ­¢">
      <data key="d6">1.0</data>
      <data key="d7">Operational codes must be unique across all instructions to avoid decoding errors.</data>
      <data key="d8">design rule,error avoidance</data>
      <data key="d9">chunk-0d36c83754193098d8c62f2f838760fe</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469881</data>
    </edge>
    <edge source="ä½¿ç”¨é¢‘çŽ‡" target="æ“ä½œç åˆ†é…">
      <data key="d6">1.0</data>
      <data key="d7">Higher frequency instructions are assigned shorter opcodes to minimize decoding time.</data>
      <data key="d8">efficiency improvement,optimization strategy</data>
      <data key="d9">chunk-0d36c83754193098d8c62f2f838760fe</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469881</data>
    </edge>
    <edge source="æŒ‡ä»¤è¯‘ç å’Œåˆ†æžæ—¶é—´" target="çŸ­ç åˆ†é…">
      <data key="d6">1.0</data>
      <data key="d7">Assigning shorter opcodes to frequently used instructions reduces the average time needed for instruction decoding and analysis.</data>
      <data key="d8">efficiency gain,performance optimization</data>
      <data key="d9">chunk-0d36c83754193098d8c62f2f838760fe</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469883</data>
    </edge>
    <edge source="å˜å€å¯„å­˜å™¨" target="å½¢å¼åœ°å€A">
      <data key="d6">1.0</data>
      <data key="d7">The index register modifies the base address A to access different memory locations, enabling variable address generation.</data>
      <data key="d8">addressing mode,offset-based access</data>
      <data key="d9">chunk-be1b12c159545a6c843eae8f022b80e2</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469931</data>
    </edge>
    <edge source="å˜å€å¯„å­˜å™¨" target="åç§»é‡">
      <data key="d6">1.0</data>
      <data key="d7">The content of the index register IX is used as the offset and can be changed by the user during program execution.</data>
      <data key="d8">data modification,runtime adjustment</data>
      <data key="d9">chunk-be1b12c159545a6c843eae8f022b80e2</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469933</data>
    </edge>
    <edge source="å˜å€å¯„å­˜å™¨" target="æ•°ç»„é¦–åœ°å€">
      <data key="d6">1.0</data>
      <data key="d7">The array's starting address is used in conjunction with the index register to access elements in sequence.</data>
      <data key="d8">array traversal,index-based addressing</data>
      <data key="d9">chunk-be1b12c159545a6c843eae8f022b80e2</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469935</data>
    </edge>
    <edge source="å˜å€å¯„å­˜å™¨" target="é€šç”¨å¯„å­˜å™¨">
      <data key="d6">1.0</data>
      <data key="d7">é€šç”¨å¯„å­˜å™¨can be used as aå˜å€å¯„å­˜å™¨, allowing flexibility in addressing modes.</data>
      <data key="d8">functional substitution,register reuse</data>
      <data key="d9">chunk-be1b12c159545a6c843eae8f022b80e2</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469937</data>
    </edge>
    <edge source="åç§»é‡" target="å­˜å‚¨ç©ºé—´">
      <data key="d6">1.0</data>
      <data key="d7">The bit width of the offset (index register IX) must be sufficient to address the entire storage space.</data>
      <data key="d8">addressability,memory coverage</data>
      <data key="d9">chunk-be1b12c159545a6c843eae8f022b80e2</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469935</data>
    </edge>
    <edge source="å †æ ˆæŒ‡é’ˆSP" target="è¯»/å†™å †æ ˆ">
      <data key="d6">1.0</data>
      <data key="d7">The stack pointer SP is automatically adjusted during stack read/write operations.</data>
      <data key="d8">automatic pointer update,stack management</data>
      <data key="d9">chunk-be1b12c159545a6c843eae8f022b80e2</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469931</data>
    </edge>
    <edge source="ç¡¬å †æ ˆ" target="å¯„å­˜å™¨ç»„">
      <data key="d6">1.0</data>
      <data key="d7">Hard stack is implemented using the register set, providing high-speed access but limited in size.</data>
      <data key="d8">fast access,hardware implementation</data>
      <data key="d9">chunk-be1b12c159545a6c843eae8f022b80e2</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469931</data>
    </edge>
    <edge source="è½¯å †æ ˆ" target="æ— æ“ä½œæ•°æŒ‡ä»¤">
      <data key="d6">1.0</data>
      <data key="d7">In systems using soft stack, most instructions appear without operands, as operands are implicitly managed via SP.</data>
      <data key="d8">implicit operand usage,stack-based computation</data>
      <data key="d9">chunk-be1b12c159545a6c843eae8f022b80e2</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469931</data>
    </edge>
    <edge source="è½¯å †æ ˆ" target="å¯„å­˜å™¨ç»„">
      <data key="d6">1.0</data>
      <data key="d7">Soft stack is implemented using main memory, not the register set, allowing larger capacity at lower cost.</data>
      <data key="d8">memory implementation,scalable storage</data>
      <data key="d9">chunk-be1b12c159545a6c843eae8f022b80e2</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469933</data>
    </edge>
    <edge source="åŽè¿›å…ˆå‡ºåŽŸåˆ™" target="è‡ªåŠ¨å®Œæˆå¯¹SPçš„åŠ å‡æ“ä½œ">
      <data key="d6">1.0</data>
      <data key="d7">The LIFO principle governs stack behavior, with automatic SP adjustment to maintain correct stack state.</data>
      <data key="d8">control mechanism,stack operation</data>
      <data key="d9">chunk-be1b12c159545a6c843eae8f022b80e2</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469931</data>
    </edge>
    <edge source="å¯„å­˜å™¨" target="é€šç”¨å¯„å­˜å™¨">
      <data key="d6">1.0</data>
      <data key="d7">é€šç”¨å¯„å­˜å™¨is a subset of theå¯„å­˜å™¨, used for general data handling in the processor.</data>
      <data key="d8">processor component,register category</data>
      <data key="d9">chunk-be1b12c159545a6c843eae8f022b80e2</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761469933</data>
    </edge>
    <edge source="å¯„å­˜å™¨" target="å¯„å­˜å™¨é—´æŽ¥å¯»å€">
      <data key="d6">1.0</data>
      <data key="d7">The size of the register in register indirect addressing determines the range of addressable memory locations.</data>
      <data key="d8">addressable range,register size</data>
      <data key="d9">chunk-aff2d7d8604331c974d095c01133c056</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761470005</data>
    </edge>
    <edge source="æ•°æ®å¯»å€" target="æ“ä½œç ">
      <data key="d6">1.0</data>
      <data key="d7">Data addressing is a component of instruction design that includes the operation code as part of the overall instruction format.</data>
      <data key="d8">encoding,instruction structure</data>
      <data key="d9">chunk-aff2d7d8604331c974d095c01133c056</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761470005</data>
    </edge>
    <edge source="æ•°æ®å¯»å€" target="å¯»å€ç‰¹å¾">
      <data key="d6">1.0</data>
      <data key="d7">The addressing feature field in an instruction specifies the addressing mode used in data addressing.</data>
      <data key="d8">instruction encoding,mode specification</data>
      <data key="d9">chunk-aff2d7d8604331c974d095c01133c056</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761470006</data>
    </edge>
    <edge source="æ“ä½œç " target="æŒ‡ä»¤å­—">
      <data key="d6">1.0</data>
      <data key="d7">The instruction word contains the operation code as a part of its structure.</data>
      <data key="d8">encoding,instruction structure</data>
      <data key="d9">chunk-aff2d7d8604331c974d095c01133c056</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761470006</data>
    </edge>
    <edge source="å¯»å€ç‰¹å¾" target="æŒ‡ä»¤å­—">
      <data key="d6">1.0</data>
      <data key="d7">The instruction word includes the addressing feature field to specify the addressing mode.</data>
      <data key="d8">instruction encoding,mode specification</data>
      <data key="d9">chunk-aff2d7d8604331c974d095c01133c056</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761470007</data>
    </edge>
    <edge source="å½¢å¼åœ°å€" target="æœ‰æ•ˆåœ°å€">
      <data key="d6">1.0</data>
      <data key="d7">The effective address is derived from the form address by applying the addressing mode.</data>
      <data key="d8">address calculation,mode dependency</data>
      <data key="d9">chunk-aff2d7d8604331c974d095c01133c056</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761470005</data>
    </edge>
    <edge source="å½¢å¼åœ°å€" target="ç«‹å³å¯»å€">
      <data key="d6">1.0</data>
      <data key="d7">The length of the form address in immediate addressing determines the range of the operand value.</data>
      <data key="d8">instruction size,operand range</data>
      <data key="d9">chunk-aff2d7d8604331c974d095c01133c056</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761470006</data>
    </edge>
    <edge source="å½¢å¼åœ°å€" target="ç›´æŽ¥å¯»å€">
      <data key="d6">1.0</data>
      <data key="d7">The length of the form address in direct addressing determines the range of memory that can be accessed.</data>
      <data key="d8">addressable memory space,addressing capacity</data>
      <data key="d9">chunk-aff2d7d8604331c974d095c01133c056</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761470007</data>
    </edge>
    <edge source="å½¢å¼åœ°å€" target="å¯„å­˜å™¨å¯»å€">
      <data key="d6">1.0</data>
      <data key="d7">The length of the form address in register addressing determines the maximum number of general-purpose registers.</data>
      <data key="d8">register capacity,register count</data>
      <data key="d9">chunk-aff2d7d8604331c974d095c01133c056</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761470008</data>
    </edge>
    <edge source="å½¢å¼åœ°å€" target="æŒ‡ä»¤å­—">
      <data key="d6">1.0</data>
      <data key="d7">The instruction word contains the form address, which is used in computing the effective address.</data>
      <data key="d8">instruction component,operand addressing</data>
      <data key="d9">chunk-aff2d7d8604331c974d095c01133c056</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761470008</data>
    </edge>
    <edge source="æœ‰æ•ˆåœ°å€" target="å­˜å‚¨å™¨">
      <data key="d6">1.0</data>
      <data key="d7">The effective address points to the actual location of the operand in memory.</data>
      <data key="d8">data location,memory access</data>
      <data key="d9">chunk-aff2d7d8604331c974d095c01133c056</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761470006</data>
    </edge>
    <edge source="VLSI" target="CPU Chip Area">
      <data key="d6">1.0</data>
      <data key="d7">VLSI technology enables the efficient use of chip area, particularly beneficial in RISC architectures with minimal control logic.</data>
      <data key="d8">area management,technology enablement</data>
      <data key="d9">chunk-2151538dd57e60dbb6761c6a35ea00c6</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761470019</data>
    </edge>
  </graph>
</graphml>
