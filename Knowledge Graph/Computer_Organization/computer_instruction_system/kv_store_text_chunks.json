{
  "chunk-3da8377b70a3bce3bffec6cc41a145bb": {
    "tokens": 364,
    "content": "18. 复杂指令系统计算机 (CISC) 随着集成电路技术的发展，软件成本不断上升，促使人们在指令系统中增加更多、更复杂的指令，以适应不同的应用领域，这样就构成了CISC。 CISC 的主要特点如下： 1)指令系统复杂庞大，指令数目一般为200条以上。 2)指令的长度不固定，指令格式多，寻址方式多。 3)可以访存的指令不受限制。 4)各种指令使用频度相差很大。 5)各种指令执行时间相差很大，大多数指令需多个时钟周期才能完成。 6)控制器大多数采用微程序控制。有些指令非常复杂，以至于无法采用硬连线控制。 7)难以用优化编译生成高效的目标代码程序。 如此庞大的指令系统，对指令的设计提出了极高的要求，研制周期变得很长。后来人们发现， 一味地追求指令系统的复杂和完备程度不是提高性能的唯一途径。对传统 CISC 指令系统的测试表明，各种指令的使用频率相差悬殊，大概只有20%的简单指令被反复使用，约占整个程序的80%; 而80%左右的复杂指令则很少使用，约占整个程序的20%。从这一事实出发，人们开始用最常用的20%的简单指令，重组实现不常用的80%的指令功能，RISC 随之诞生。",
    "chunk_order_index": 0,
    "full_doc_id": "doc-3da8377b70a3bce3bffec6cc41a145bb",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:0b9c45b267a4a1f87fd4d31eb93e3e26",
      "default:extract:00675ef0b7dfaf764f0df4f1f89b86f5"
    ],
    "create_time": 1761468967,
    "update_time": 1761469042,
    "_id": "chunk-3da8377b70a3bce3bffec6cc41a145bb"
  },
  "chunk-28e3e7abf13d472ede4c7ccd1eed0db7": {
    "tokens": 377,
    "content": "16. 循环语句的机器级表示 常见的循环结构语句有 while 、for 和 do-while。汇编中没有相应的指令存在，可以用条件测试和转跳组合起来实现循环的效果，大多数编译器将这三种循环结构都转换为do-while形式来产生机器代码。在循环结构中，通常使用条件转移指令来判断循环条件的结束。 (1)do-while 循环 do-while 语句的通用形式如下： do body_statement while(test_expr); 这种通用形式可以被翻译成如下所示的条件和goto 语句： loopbod:y_statement t=test_expr; if(t) goto loop; 也就是说，每次循环，程序会执行循环体内的语句，body_statement至少会执行一次，然后执行测试表达式。若测试为真，则继续执行循环。 (2)while 循环 while语句的通用形式如下： while(test_expr) body_statement 与do-while的不同之处在于，第一次执行body_statement 之前，就会测试test_expr 的值，循环有可能中止。GCC 通常会将其翻译成条件分支加do-while循环的方式。 用如下模板来表达这种方法，将通用的while循环格式翻译成do-while循环： t=test_expr; if(!t) goto done; do body_statement while(test_expr); Done; 相应地，进一步将它翻译成goto 语句： t=test_expr; if(!t) goto done; loop: body_statement t=test_expr; if(t) goto loop; Done; (3)for 循环 for循环的通用形式如下： for(init_expr;test_expr;update_expr) body_statement",
    "chunk_order_index": 0,
    "full_doc_id": "doc-28e3e7abf13d472ede4c7ccd1eed0db7",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:d3a87691eeebce6d48bdaa8513eb0119",
      "default:extract:c9929aea1a0e6aaafabd1dff9d9a0405"
    ],
    "create_time": 1761468967,
    "update_time": 1761469068,
    "_id": "chunk-28e3e7abf13d472ede4c7ccd1eed0db7"
  },
  "chunk-af4c47630b7183e33e016913942c0781": {
    "tokens": 506,
    "content": "17. 过程调用的机器级表示 前面提到的call/ret 指令主要用于过程调用，它们都属于一种无条件转移指令。 假定过程P(调用者)调用过程Q(被调用者),过程调用的执行步骤如下： 1)P 将入口参数(实参)放到Q 能访问到的地方。 2)P 将返回地址存到特定的地方，然后将控制转移到Q。 3)Q保存P 的现场(通用寄存器的内容),并为自己的非静态局部变量分配空间。 4)执行过程Q。 5)Q 恢复P的现场，将返回结果放到P 能访问到的地方，并释放局部变量所占空间。 6)Q 取出返回地址，将控制转移到P。 步骤2)是由call 指令实现的，步骤6)通过ret 指令返回到过程P。在上述步骤中，需要为入口参数、返回地址、过程P 的现场、过程Q 的局部变量、返回结果找到存放空间。 用户可见寄存器数量有限，调用者和被调用者需共享寄存器，若直接覆盖对方的寄存器，则会导致程序出错。因此有如下规范：寄存器 EAX 、ECX和 EDX是调用者保存寄存器，当P 调用 Q 时，若Q 需用到这些寄存器，则由P 将这些寄存器的内容保存到栈中，并在返回后由P 恢复它们的值。寄存器 EBX 、ESI 、EDI 是被调用者保存寄存器， 当P 调用Q 时 ，Q 必须先将这些寄存器的内容保存在栈中才能使用它们，并在返回P 之前先恢复它们的值。 每个过程都有自己的栈区，称为栈帧，因此，一个栈由若干栈帧组成，寄存器EBP 指示栈帧的起始位置，寄存器ESP 指示栈顶，栈从高地址向低地址增长。过程执行时，ESP 会随着数据的入栈而动态变化，而EBP固定不变。当前栈帧的范围在EBP 和 ESP 指向的区域之间。",
    "chunk_order_index": 0,
    "full_doc_id": "doc-af4c47630b7183e33e016913942c0781",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:5292f462d284ef93cbcccacc93882fad",
      "default:extract:01afe33c0f04805ee1c218966ed3ae52"
    ],
    "create_time": 1761469048,
    "update_time": 1761469149,
    "_id": "chunk-af4c47630b7183e33e016913942c0781"
  },
  "chunk-823091106aa14acd3f766029738eb588": {
    "tokens": 1006,
    "content": "2. 指令的基本格式 一条指令就是机器语言的一个语句，它是一组有意义的二进制代码。一条指令通常包括操作码字段和地址码字段两部分： 操作码字段地址码字段其中，操作码指出该指令应执行什么操作以及具有何种功能。操作码是识别指令、了解指令功能及区分操作数地址内容等的关键信息。例如，指出是算术加运算还是算术减运算，是程序转移还是返回操作。地址码给出被操作的信息(指令或数据)的地址，包括参加运算的一个或多个操作数的地址、运算结果的保存地址、程序的转移地址、被调用子程序的入口地址等。 指令字长是指一条指令所包含的二进制代码的位数，其取决于操作码的长度、地址码的长度和地址码的个数。指令字长与机器字长没有固定的关系，它既可以等于机器字长，又可以大于或小于机器字长。通常，把指令长度等于机器字长的指令称为单字长指令，指令长度等于半个机器字长的指令称为半字长指令，指令长度等于两个机器字长的指令称为双字长指令。 注意注意指令长度的不同会导致取指令时间开销的不同，单字长指令只需访存1次就能将指令完整取出；而双字长指令则需访存2次才能完整取出，耗费2个存取周期。 在一个指令系统中，若所有指令的长度都是相等的，则称为定长指令字结构。定字长指令的执行速度快，控制简单。若各种指令的长度随指令功能而异，则称为变长指令字结构。然而，因为主存一般是按字节编址的，所以指令字长通常为字节的整数倍。 根据指令中操作数地址码的数目的不同，可将指令分成以下几种格式。 (1)零地址指令:只给出操作码OP, 没有显式地址。这种指令有两种可能： 1)不需要操作数的指令，如空操作指令、停机指令、关中断指令等。 2)零地址的运算类指令仅用在堆栈计算机中。通常参与运算的两个操作数隐含地从栈顶和次栈顶弹出，送到运算器进行运算，运算结果再隐含地压入堆栈。 (2)一地址指令：这种指令也有两种常见的形态，要根据操作码含义确定究竟是哪一种。 1)只有目的操作数的单操作数指令，按A₁ 地址读取操作数，进行OP 操作后，结果存回原地址。 2)隐含约定目的地址的双操作数指令，按指令地址A可读取源操作数，指令可隐含约定另一个操作数由 ACC (累加器)提供，运算结果也将存放在ACC 中。 (3)二地址指令：对于常用的算术和逻辑运算指令，往往要求使用两个操作数，需分别给出目的操作数和源操作数的地址，其中目的操作数地址还用于保存本次的运算结果。 (4)三地址指令：指令含义：(A1)OP(A2)→A3。 若指令字长为32位，操作码占8位，3个地址码字段各占8位，则每个操作数的直接寻址范围为2⁸=256。若地址码字段均为主存地址，则完成一条三地址需要4次访问存储器(取指令1次，取两个操作数2次，存结果1次)。 (5) 四地址指令 ：指令含义：(A1)OP(A2)→A3,A4=下一条将要执行指令的地址。 若指令字长为32位，操作码占8位，4个地址码字段各占6位，则每个操作数的直接寻址范围为2⁶=64。若地址码字段均为主存地址，则完成一条四地址指令需要4次访存(取指令1次， 取两个操作数2次，存结果1次)。",
    "chunk_order_index": 0,
    "full_doc_id": "doc-823091106aa14acd3f766029738eb588",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:19036f341aa1b4d90247be520e8658ac",
      "default:extract:b9eab4e1132a8183768e7fd83d90dd6c"
    ],
    "create_time": 1761469072,
    "update_time": 1761469217,
    "_id": "chunk-823091106aa14acd3f766029738eb588"
  },
  "chunk-26a06731e273a94d7270550437bc874a": {
    "tokens": 294,
    "content": "15. 选择语句的机器级表示 常见的选择结构语句有if-then、if-then-else等。编译器通过条件码(标志位)设置指令和各类转移指令来实现程序中的选择结构语句。条件码描述了最近的算术或逻辑运算操作的属性，可以检测这些寄存器来执行条件分支指令，最常用的条件码有CF、ZF、SF和OF。 常见的算术逻辑运算指令 (add,sub,imul,or,and,shl,inc,dec,not,sal等)会设置条件码，还有 cmp 和 test 指令只设置条件码而不改变任何其他寄存器。 之前介绍的jcondition 条件转跳指令，就是根据条件码 ZF和SF来实现转跳的。 if-else 语句的通用形式如下 ： if(test_expr) then_statement else else_statement 这里的 test_expr是一个整数表达式，它的取值为0(假),或为非0(真)。两个分支语句 (then_statement 或 else_statement) 中只会执行一个 。 这种通用形式可以被翻译成如下所示的goto 语句形式： t=test_expr; if( !t) goto false; then_statement goto done; False; else_statement Done;",
    "chunk_order_index": 0,
    "full_doc_id": "doc-26a06731e273a94d7270550437bc874a",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:a11b249db9a76e9eed3b7030c7e4dc25",
      "default:extract:b1ebef24471afbe9b5cf07c0821b5dc1"
    ],
    "create_time": 1761469156,
    "update_time": 1761469283,
    "_id": "chunk-26a06731e273a94d7270550437bc874a"
  },
  "chunk-9c7da0bf6fbf207039ae9ca67c1e6a9d": {
    "tokens": 213,
    "content": "9. 几种数据寻址方式的分析 显然，变址寻址与基址寻址的有效地址形成过程极为相似。但从本质上讲，两者有较大区别。 基址寻址面向系统，主要用于为多道程序或数据分配存储空间，因此基址寄存器的内容通常由操作系统或管理程序确定，在程序的执行过程中其值不可变，而指令字中的A 是可变的。变址寻址立足于用户，主要用于处理数组问题，在变址寻址中，变址寄存器的内容由用户设定，在程序执行过程中其值可变，而指令字中的A 是不可变的。 相对寻址、基址寻址和变址寻址三种寻址方式非常类似，都将某个寄存器的内容与一个形式地址相加而生成操作数的有效地址，通常把这三种寻址方式称为偏移寻址。",
    "chunk_order_index": 0,
    "full_doc_id": "doc-9c7da0bf6fbf207039ae9ca67c1e6a9d",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:e9653386753846a90b7b51f665d2b745",
      "default:extract:e2cf4abe18cbfcb731a99db3a03bad67"
    ],
    "create_time": 1761469225,
    "update_time": 1761469294,
    "_id": "chunk-9c7da0bf6fbf207039ae9ca67c1e6a9d"
  },
  "chunk-803e04b7ef409476eff2adc07fef14d1": {
    "tokens": 415,
    "content": "12. 数据传送指令 1) mov指令。将第二个操作数(寄存器的内容、内存中的内容或常数值)复制到第一个操作数(寄存器或内存)。 其语法如下： mov <reg>,<reg> mov <reg>,<mem> mov <mem>,<reg> mov <reg>,<con> mov <mem>,<con> 举例： mov eax,ebx #将ebx 值复制到eax mov byte ptr [var],5 #将5保存到var 值指示的内存地址的一字节中 双操作数指令的两个操作数不能都是内存，即 mov 指令不能用于直接从内存复制到内存，若需在内存之间复制，可先从内存复制到一个寄存器，再从这个寄存器复制到内存。 2) push 指令。将操作数压入内存的栈，常用于函数调用。 ESP 是栈顶，入栈前先将 ESP 值减4(栈增长方向与内存地址增长方向相反),然后将操作数压入ESP 指示的地址。 其语法如下： push <reg32> push <mem> push <con32> 举例(注意，栈中元素固定为32位): Push eax #将eax值入栈 push [var] #将var值指示的内存地址的4字节值入栈 3)pop指令。与push指令相反，pop 指令执行的是出栈工作，出栈前先将ESP指示的地址中的内容出栈，然后将 ESP 值加4。 其语法如下： Pop eax #弹出栈顶元素送到eax Pop [ebx] #弹出栈顶元素送到ebx 值指示的内存地址的4字节中",
    "chunk_order_index": 0,
    "full_doc_id": "doc-803e04b7ef409476eff2adc07fef14d1",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:e36fefbaa483fb9d32665ee7cb42a220",
      "default:extract:64718ce11d1814f7396b232c40d0f63a"
    ],
    "create_time": 1761469291,
    "update_time": 1761469376,
    "_id": "chunk-803e04b7ef409476eff2adc07fef14d1"
  },
  "chunk-d12ab3ee72f1f1a8f72c7e3dece14062": {
    "tokens": 383,
    "content": "19. 精简指令系统计算机 (RISC) RISC的中心思想是要求指令系统简化，尽量使用寄存器-寄存器操作指令，指令格式力求一致。RISC的主要特点如下： 1)选取使用频率最高的一些简单指令，复杂指令的功能由简单指令的组合来实现。 2)指令长度固定，指令格式种类少，寻址方式种类少。 3)只有LOAD/STORE (取数/存数)指令访存，其余指令的操作都在寄存器之间进行。 4)CPU中通用寄存器的数量相当多。 5)一定采用指令流水线技术，大部分指令在一个时钟周期内完成。 6)以硬布线控制为主，不用或少用微程序控制。 7)特别重视编译优化工作，以减少程序执行时间。 值得注意的是，从指令系统兼容性看，CISC大多能实现软件兼容，即高档机包含了低档机的全部指令，并可加以扩充。但RISC简化了指令系统，指令条数少，格式也不同于老机器，因此大多数RISC 机不能与老机器兼容。RISC 具有更强的实用性，因此应该是未来处理器的发展方向。但事实上，当今时代 Intel 几乎一统江湖，且早期很多软件都是根据 CISC 设计的，单纯的 RISC 将无法兼容。此外，现代CISC 结构的CPU 已经融合了很多RISC 的成分，其性能差距已经越来越小。CISC 可以提供更多的功能，这是程序设计所需要的。",
    "chunk_order_index": 0,
    "full_doc_id": "doc-d12ab3ee72f1f1a8f72c7e3dece14062",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:8bd1a6dbdb0a15547b8059231841a8e5",
      "default:extract:6fe748f97725afca190d415b5d425c3d"
    ],
    "create_time": 1761469299,
    "update_time": 1761469399,
    "_id": "chunk-d12ab3ee72f1f1a8f72c7e3dece14062"
  },
  "chunk-090282a2e59cdb6b6513b1d2f898d3ae": {
    "tokens": 259,
    "content": "6. 指令寻址 指令寻址方式有两种：一种是顺序寻址方式，另一种是跳跃寻址方式。 (1)顺序寻址通过程序计数器PC加1(1条指令的长度),自动形成下一条指令的地址。 注意PC自增的大小与编址方式、指令字长有关。现代计算机通常是按字节编址的，若指令字长为16位，则PC自增为(PC)+2; 若指令字长为32位，则PC自增为(PC)+4。 (2)跳跃寻址通过转移类指令实现。跳跃是指由本条指令给出下条指令地址的计算方式。而是否跳跃可能受到状态寄存器的控制，跳跃的方式分为绝对转移(地址码直接指出转移目标地址)和相对转移 (地址码指出转移目的地址相对于当前PC 值的偏移量),CPU总是根据PC的内容去主存取指令的，因此转移指令执行的结果是修改PC 值，下一条指令仍然通过 PC 给出。",
    "chunk_order_index": 0,
    "full_doc_id": "doc-090282a2e59cdb6b6513b1d2f898d3ae",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:7df3989d8376be8b59a5faaf2de51a02",
      "default:extract:c651e11a908a6f02f9b8e8213d33af5f"
    ],
    "create_time": 1761469383,
    "update_time": 1761469453,
    "_id": "chunk-090282a2e59cdb6b6513b1d2f898d3ae"
  },
  "chunk-986821269f2aa2025221040c595a72be": {
    "tokens": 355,
    "content": "1. 指令集体系结构命题追踪 机器指令(简称指令)是指示计算机执行某种操作的命令。一台计算机的所有指令的集合构成该机的指令系统，也称指令集。指令系统是指令集体系结构 (ISA)中最核心的部分，ISA完整定义了软件和硬件之间的接口，是机器语言或汇编语言程序员所应熟悉的。 ISA 规定的内容主要包括： 1)指令格式，指令寻址方式，操作类型，以及每种操作对应的操作数的相应规定。 2)操作数的类型，操作数寻址方式，以及是按大端方式还是按小端方式存放。 3)程序可访问的寄存器编号、个数和位数，存储空间的大小和编址方式。 4)指令执行过程的控制方式等，包括程序计数器、条件码定义等。 ISA 规定了机器级程序的格式，机器语言或汇编语言程序员必须对机器的ISA 非常熟悉。不过，大多数程序员不会用汇编语言或机器语言编写程序，通常用高级语言(如C/C++/Java) 编写程序，这样开发效率更高，也不易出错。但是，高级语言抽象层太高，隐藏了许多机器级程序的细节，使得高级语言程序员不能很好地利用与机器结构相关的一些优化方法来提升程序的性能。 若程序员对ISA 和底层硬件实现细节有充分的了解，则可以更好地编制高性能程序。",
    "chunk_order_index": 0,
    "full_doc_id": "doc-986821269f2aa2025221040c595a72be",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:eb26aff12ca5069c990949920ea95bed",
      "default:extract:dd5430fe7e6aae5b436eb11b5dedf2b5"
    ],
    "create_time": 1761469407,
    "update_time": 1761469494,
    "_id": "chunk-986821269f2aa2025221040c595a72be"
  },
  "chunk-1853ae0bf21d6ed553e97992dab0cb73": {
    "tokens": 399,
    "content": "5. 指令的操作类型 设计指令系统时必须考虑应提供哪些操作类型，指令操作类型按功能可分为以下几种。 (1)数据传送。传送指令通常有寄存器之间的传送(MOV) 、从内存单元读取数据到CPU 寄存器(LOAD)、从 CPU 寄存器写数据到内存单元 (STORE) 、进栈操作 (PUSH) 、出栈操作 (POP) 等 。 (2)算术和逻辑运算。这类指令主要有加 (ADD) 、减 (SUB) 、乘 (MUL) 、 除 (DIV) 、 加 1 (INC) 、减 1(DEC)、与 (AND) 、或 (OR) 、取反 (NOT) 、异或 (XOR) 等 。 (3)移位操作。移位指令主要有算术移位、逻辑移位、循环移位等。 (4)转移操作。转移指令主要有无条件转移(JMP) 、 条件转移(BRANCH) 、 调用(CALL) 、 返回(RET)、陷阱 (TRAP) 等。无条件转移指令在任何情况下都执行转移操作，而条件转移指令仅在特定条件满足时才执行转移操作，转移条件一般是某个标志位的值，或几个标志位的组合。 调用指令和转移指令的区别：执行调用指令时必须保存下一条指令的地址(返回地址),当子程序执行结束时，根据返回地址返回到主程序继续执行；而转移指令则不返回执行。 (5)输入输出操作。这类指令用于完成CPU 与外部设备交换数据或传送控制命令及状态信息。",
    "chunk_order_index": 0,
    "full_doc_id": "doc-1853ae0bf21d6ed553e97992dab0cb73",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:3fcec5790ca2496254361c3ea2af2508",
      "default:extract:079e807ebdbaa35e3c8c79b5453b93b1"
    ],
    "create_time": 1761469457,
    "update_time": 1761469590,
    "_id": "chunk-1853ae0bf21d6ed553e97992dab0cb73"
  },
  "chunk-be143027fbd9f62579107c5fcd0f2740": {
    "tokens": 913,
    "content": "13. 算术和逻辑运算指令 1) add/sub 指令。add 指令将两个操作数相加，相加的结果保存到第一个操作数中。sub 指令用于两个操作数相减，相减的结果保存到第一个操作数中。 它们的语法如下： add <reg>,<reg>/sub <reg>,<reg> add <reg>,<mem>/sub <reg>,<mem> add <mem>,<reg>/sub <mem>,<reg> add <reg>,<con>/sub <reg>,<con> Add <mem>,<con>/sub <mem>,<con> 举例 ： sub eax,10 #eax←eax-10 add byte ptr [var],10 # 10与var值指示的内存地址的一字节值相加，并将结果保存在var 值指示的内存地址的字节中 2)inc/dec 指令。inc 、dec指令分别表示将操作数自加1、自减1。 它们的语法如下： inc <reg>/dec <reg> inc <mem>/dec <mem> 举例： dec eax #eax 值自减 1 inc dword ptr [var] #var 值指示的内存地址的4字节值自加1 3)imul指令。有符号整数乘法指令，有两种格式：①两个操作数，将两个操作数相乘，将结果保存在第一个操作数中，第一个操作数必须为寄存器；②三个操作数，将第二个和第三个操作数相乘，将结果保存在第一个操作数中，第一个操作数必须为寄存器。 其语法如下： imul <reg32>,<reg32> imul <reg32>,<mem> imul <reg32>,<reg32>,<con> im ul <reg32>,<mem>,<con> 举例 ： imul eax,[var] #eax←eax*[var] imul esi,edi,25 #esi←edi*25 乘法操作结果可能溢出，则编译器置溢出标志OF=1, 以使CPU 调出溢出异常处理程序。 4) idiv指令。有符号整数除法指令，它只有一个操作数，即除数，而被除数则为edx:eax中的内容(共64位),操作结果有两部分：商和余数，商送到eax, 余数则送到edx。 5)and/or/xor指令。and、or、xor指令分别是逻辑与、逻辑或、逻辑异或操作指令，用于操作数的位操作，操作结果放在第一个操作数中。 它们的语法如下： and <reg>,<reg>/or <reg>,<reg>/xor <reg>,<reg> and <reg>,<mem>/or <reg>,<mem>/xor <reg>,<mem> and <mem>,<reg>/or <mem>,<reg>/xor <mem>,<reg> and <reg>,<con>/or <reg>,<con>/xor <reg>,<con> and <mem>,<con>/or <mem>,<con>/xor <mem>,<con> 举例： and eax,0fH #将eax中的前28位全部置为0,最后4位保持不变 xor edx,edx #置edx 中的内容为0 6)not 指令。位翻转指令，将操作数中的每一位翻转，即0→ 1、1→0。 其语法如下： not <reg> not <mem> 举例： not byte ptr [var] #将var 值指示的内存地址的一字节的所有位翻转 7)neg 指令。取负指令。 其语法如下： neg <reg> neg <mem> 举例： neg eax #eax←-eax 8)shl/shr 指令。逻辑移位指令，shl 为逻辑左移，shr 为逻辑右移，第一个操作数表示被操作数，第二个操作数指示移位的位数。",
    "chunk_order_index": 0,
    "full_doc_id": "doc-be143027fbd9f62579107c5fcd0f2740",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:a5e9c30f90301aebb5386ecf9f18bc70",
      "default:extract:1886d28452a5eaee28e73ab8d2b4d95b"
    ],
    "create_time": 1761469501,
    "update_time": 1761469686,
    "_id": "chunk-be143027fbd9f62579107c5fcd0f2740"
  },
  "chunk-7fa816a9f8d5ac78d7483ae33a74ba7b": {
    "tokens": 104,
    "content": "3. 定长操作码指令格式 定长操作码指令在指令字的最高位部分分配固定的若干位(定长)表示操作码。 一般n位操 作码字段的指令系统最大能够表示2的n次方条指令。定长操作码对于简化计算机硬件设计，提高指令译码和识别速度很有利。当计算机字长为32位或更长时，这是常规用法。",
    "chunk_order_index": 0,
    "full_doc_id": "doc-7fa816a9f8d5ac78d7483ae33a74ba7b",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:89495949ed5d6839fa863e9dc1db1f59",
      "default:extract:39787195dcfee7e81237cfaa7a249100"
    ],
    "create_time": 1761469600,
    "update_time": 1761469639,
    "_id": "chunk-7fa816a9f8d5ac78d7483ae33a74ba7b"
  },
  "chunk-dc66410ab81cdb2a13f279e50457a470": {
    "tokens": 830,
    "content": "14. 控制流指令 x86 处理器维持着一个指示当前执行指令的指令指针 (IP),当一条指令执行后，此指针自动指向下一条指令。IP寄存器不能直接操作，但可以用控制流指令更新。通常用标签 (label) 指示程序中的指令地址，在x86 汇编代码中，可在任何指令前加入标签。例如， mov esi,[ebp+8] begin: xor ecx,ecx mov eax,[esi] 这样就用begin 指示了第二条指令，控制流指令通过标签就可以实现程序指令的跳转。 1)jmp 指令。jmp 指令控制 IP 转移到label 所指示的地址(从label 中取出指令执行)。 其语法如下： jmp <label> 举例： jmp begin #转跳到begin 标记的指令执行 2)jcondition 指令。条件转移指令，依据CPU 状态字中的一系列条件状态转移。CPU 状态字中包括指示最后一个算术运算结果是否为0,运算结果是否为负数等。 其语法如下： je <label>(jump when equal) jz <label>(jump when ast result was zero) jne <label>(jump when not equal) jg <label>(jump when greater than) jge <label>(jump when greater than or equal to) jl <label>(jump when less than) jle <label>(jump when less than or equal to) 举例 ： cmp eax,ebx jle done #若eax 值<=ebx 值，则跳转到done 执行；否则执行下一条指令 3) cmp/test 指令。cmp 指令的功能相当于sub 指令，用于比较两个操作数的值。test 指令的功能相当于and 指令，对两个操作数进行逐位与运算。与sub 和 and 指令不同的是，这两类指令都不保存操作结果，仅根据运算结果设置CPU 状态字中的条件码。 其语法如下 ： cmp <reg>,<reg>/test <reg>,<reg> cmp <reg>,<mem>/test <reg>,<mem> cmp <mem>,<reg>/test <mem>,<reg> cmp <reg>,<con>/test <reg>,<con> cmp 和test 指令通常和jcondition 指令搭配使用，举例： cmp dword ptr [var],10 #将var指示的主存地址的4字节内容，与10比较 jne loop test eax,eax jz XXXX #若相等则继续顺序执行；否则跳转到 loop 处执行 #测试eax 是否为零 #为零则置标志ZF 为1,转跳到xxxx 处执行 4) call/ret 指令。分别用于实现子程序(过程、函数等)的调用及返回。 其语法如下 ： call <label> ret/call指令将下一条指令的地址(返回地址)入栈，然后无条件转移到由标签指示的指令。与其他简单的跳转指令不同，call 指令保存该指令的下一条指令的地址(当call 指令结束后，返回保存的地址)。ret 指令实现子程序的返回机制，ret 指令弹出栈中保存的指令地址，然后无条件转移到保存的指令地址执行。call 和ret 是程序(函数)调用中最关键的两条指令。 理解上述指令的语法和用途，可以更好地帮助读者解答相关题型。读者在上机调试C 程序代码时，也可以尝试用编译器调试，以便更好地帮助理解机器指令的执行。",
    "chunk_order_index": 0,
    "full_doc_id": "doc-dc66410ab81cdb2a13f279e50457a470",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:cd572d01288dd4c2ebcc2c18de44df38",
      "default:extract:8896f4d30e38b8b9b5409cde93a24537"
    ],
    "create_time": 1761469641,
    "update_time": 1761469779,
    "_id": "chunk-dc66410ab81cdb2a13f279e50457a470"
  },
  "chunk-53c922e8f9c9847391088bcc3c5430ac": {
    "tokens": 331,
    "content": "10. 汇编指令格式 使用不同的编程工具开发程序时，用到的汇编程序也不同， 一般有两种不同的汇编格式： AT&T 格式和Intel 格式。它们的区别主要体现如下： ①AT&T格式的指令只能用小写字母，而Intel 格式的指令对大小写不敏感。 ②在AT&T 格式中，第一个为源操作数，第二个为目的操作数，方向从左到右，合乎自然；在Intel格式中，第一个为目的操作数，第二个为源操作数，方向从右向左。 ③在AT&T格式中，寄存器需要加前缀“%”,立即数需要加前缀“$”;在Intel 格式中， 寄存器和立即数都不需要加前缀。 ④在内存寻址方面， AT&T 格式使用“(”和“)”,而 Intel 格式使用“[”和“]”。 ⑤在指定数据长度方面， AT&T 格式指令操作码的后面紧跟一个字符，表明操作数大小， “b” 表示 byte(字节)、 “w”表示 word(字)或“l”表示 long(双字) 。Intel格式也有类似的语法，它在操作码后面显式地注明byte ptr、word ptr或dword ptr。 注意32或64位体系结构都是由16位扩展而来的，因此用word(字)表示16位。",
    "chunk_order_index": 0,
    "full_doc_id": "doc-53c922e8f9c9847391088bcc3c5430ac",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:496c5a7d0f7fa9d796b7765c1269dafb",
      "default:extract:ada7eb0f325d64a8d54b9205c31b612c"
    ],
    "create_time": 1761469714,
    "update_time": 1761469805,
    "_id": "chunk-53c922e8f9c9847391088bcc3c5430ac"
  },
  "chunk-ee7b048d8f7d4f6a7cdb8bd206b3d9c3": {
    "tokens": 1200,
    "content": "8. 常见的数据寻址方式 (1)隐含寻址:这种类型的指令不明显地给出操作数的地址，而是隐含操作数的地址。例如，单地址的指令格式就隐含约定第二个操作数由累加器 (ACC) 提供，指令中只明显指出第一个操作数的地址。因此累加器(ACC)对单地址指令格式来说是隐含寻址。 (2)立即寻址:指令字中的地址字段指出的不是操作数的地址，而是操作数本身，也称立即数，采用补码表示。优点是指令在执行阶段不访存，指令执行速度最快；缺点是A 的位数限制了立即数的范围。 (3)直接寻址:指令字中的形式地址A 就是操作数的真实地址 EA,即EA=A。 直接寻址优点是简单，不需要专门计算操作数的地址，指令在执行阶段仅需访存一次；缺点是A 的位数限制了该指令操作数的寻址范围，操作数的地址不易修改。 (4)间接寻址:间接寻址是相对于直接寻址而言的，指令的地址字段给出的不是操作数的真正地址，而是操作数有效地址所在主存单元的地址，也就是操作数地址的地址，即 EA=(A)。 间接寻址优点是可扩大寻址范围(有效地址 EA 的位数大于形式地址 A 的位数),便于编制程序(用间接寻址可方便地完成子程序返回);缺点是指令在执行阶段要多次访存(一次间接寻址需2次访存)。由于执行速度较慢，一般为了扩大寻址范围时，通常采用寄存器间接寻址。 (5)寄存器寻址:与直接寻址的原理一样，只是把访问主存改为访问寄存器，指令的地址字段给出的是操作数所在寄存器的编号，即EA=R,其操作数在由R,所指的寄存器内。 优点是指令在执行阶段不用访存，只访问寄存器，执行速度快；寄存器数量远小于内存单元数，所以地址码位数较少，指令字长较短；缺点是寄存器价格昂贵，CPU 的寄存器数量有限。 (6)寄存器间接寻址:这种方式综合了间接寻址和寄存器寻址各自的特点，指令字中的R;所指寄存器给出的不是一个操作数，而是操作数所在主存单元的地址，即EA=(R), 。 寄存器间接寻址相比间接寻址，这种方式既扩大了寻址范围，又减少了访存次数，在执行阶段仅需访存1次。相比寄存器寻址，这种方式在执行阶段需要访存(因操作数在主存中)获得操作数。 (7)相对寻址:相对寻址是把 PC 的内容加上指令格式中的形式地址A 而形成操作数的有效地址，即 EA= (PC)+A, 其中A 是相对于当前 PC 值的偏移量，可正可负，补码表示。 优点是操作数的地址不是固定的，它随PC值的变化而变化，且与指令地址之间总是相差一个固定的偏移量，因此便于程序浮动。相对寻址广泛应用于转移指令。 (8)基址寻址:基址寻址是指将基址寄存器 (BR) 的内容加上指令字中的形式地址 A 而形成操作数的有效地址，即EA=(BR)+A 。 其中基址寄存器既可采用专用寄存器，又可指定某个通用寄存器作为基址寄存器。 基址寄存器是面向操作系统的，其内容由操作系统或管理程序确定，主要用于解决程序逻辑空间与存储器物理空间的无关性。在程序执行过程中，基址寄存器的内容不变(作为基地址), 形式地址可变(作为偏移量)。采用通用寄存器作为基址寄存器时，可由用户决定哪个寄存器作为基址寄存器，但其内容仍由操作系统确定。 基址寻址的优点是可以扩大寻址范围(基址寄存器的位数大于形式地址 A 的位数);用户不必考虑自己的程序存于主存的具体位置，因此有利于多道程序设计，并可用于编制浮动程序，但偏移量(形式地址A) 的位数较短。 (9)变址寻址:变址寻址是指将变址寄存器 (IX) 的内容加上指令字中的形式地址A而形成操作数的有效地址，即 EA=(IX)+A,其中IX 为变址寄存器(专用),也可用通用寄存器作为变址寄存器。变址寄存器是面向用户的，在程序执行过程中，变址寄存器的内容可由用户改变(作为偏移量),形式地址A 不变(作为基地址)。 变址寻址的优点是可扩大寻址范围(变址寄存器的位数大于形式地址A 的位数);在数组处理过程中",
    "chunk_order_index": 0,
    "full_doc_id": "doc-ad5acebbb603e74c2d3ec59f532eee59",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:5dc287a7dbd984ffb4e9e0efdbcb579c",
      "default:extract:a9099bc1b3aba297cfa70a31f4877981"
    ],
    "create_time": 1761469804,
    "update_time": 1761469920,
    "_id": "chunk-ee7b048d8f7d4f6a7cdb8bd206b3d9c3"
  },
  "chunk-be1b12c159545a6c843eae8f022b80e2": {
    "tokens": 406,
    "content": "寄存器(专用),也可用通用寄存器作为变址寄存器。变址寄存器是面向用户的，在程序执行过程中，变址寄存器的内容可由用户改变(作为偏移量),形式地址A 不变(作为基地址)。 变址寻址的优点是可扩大寻址范围(变址寄存器的位数大于形式地址A 的位数);在数组处理过程中，可设定A 为数组的首地址，不断改变变址寄存器IX 的内容，便可很容易形成数组中任意一个数据的地址，特别适合编制循环程序。偏移量(变址寄存器IX) 的位数足以表示整个存储空间。 (10)堆栈寻址:堆栈是存储器(或寄存器组)中一块特定的、按后进先出 (LIFO)原则管理的存储区，该存储区中读/写单元的地址是用一个特定寄存器给出的，该寄存器称为堆栈指针 (SP) 。 堆栈可分为硬堆栈和软堆栈两种。寄存器堆栈也称硬堆栈，硬堆栈的成本较高，不适合做大容量的堆栈。而从主存中划出一段区域来做堆栈是最合算且最常用的方法，这种堆栈称为软堆栈。在采用堆栈结构的计算机中，大部分指令表面上都表现为无操作数指令的形式，因为操作数地址都隐含使用了SP。因此在读/写堆栈的前后都伴有自动完成对SP 的加减操作。",
    "chunk_order_index": 1,
    "full_doc_id": "doc-ad5acebbb603e74c2d3ec59f532eee59",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:b3d8c48ae013ddc3fd4c6b0eaaaf292f",
      "default:extract:ae964c2f0d645b83da2a888fc5ace481"
    ],
    "create_time": 1761469804,
    "update_time": 1761469883,
    "_id": "chunk-be1b12c159545a6c843eae8f022b80e2"
  },
  "chunk-0d36c83754193098d8c62f2f838760fe": {
    "tokens": 259,
    "content": "4. 扩展操作码指令格式 为了在指令字长有限的前提下仍保持比较丰富的指令种类，可采取可变长度操作码，即全部指令的操作码字段的位数不固定，且分散地放在指令字的不同位置上。显然，这将增加指令译码和分析的难度，使控制器的设计复杂化。最常见的变长操作码方法是扩展操作码，它使操作码的长度随地址码的减少而增加，不同地址数的指令可具有不同长度的操作码，从而在满足需要的前提下，有效地缩短指令字长。 在设计扩展操作码指令格式时，必须注意以下两点： 1)不允许短码是长码的前缀，即短操作码不能与长操作码的前面部分的代码相同。 2)各指令的操作码一定不能重复。 通常情况下，对使用频率较高的指令分配较短的操作码，对使用频率较低的指令分配较长的操作码，从而尽可能减少指令译码和分析的时间。",
    "chunk_order_index": 0,
    "full_doc_id": "doc-0d36c83754193098d8c62f2f838760fe",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:bce9616f97966bab8b88eb3693d13d14",
      "default:extract:5b69596b28d63d6694b1a300780a24cd"
    ],
    "create_time": 1761469814,
    "update_time": 1761469876,
    "_id": "chunk-0d36c83754193098d8c62f2f838760fe"
  },
  "chunk-3c363f9d809dadcf3a7c0f9008fb810a": {
    "tokens": 256,
    "content": "11. 常用操作数标记 汇编指令通常可分为数据传送指令、算术和逻辑运算指令和控制流指令，下面以Intel格式为例，介绍一些常用的指令。以下用于操作数的标记分别表示寄存器、内存和常数。 （1）<reg>:表示任意寄存器，若其后带有数字，则指定其位数，如<reg32> 表示32位寄存器(eax,ebx,ecx,edx,esi,edi,esp或 ebp);<reg16>表示16位寄存器 (ax,bx,cx或dx);<reg8> 表示8位寄存器 (ah,al,bh,bl,ch,cl,dh,dl)。 （2）<mem>:表示内存地址(如[eax]、[var+4]或dword ptr [eax+ebx])。 （3）<con>:表示8位、16位或32位常数。<con8> 表示8位常数；<con16>表示16位常数；<con32> 表示32位常数。",
    "chunk_order_index": 0,
    "full_doc_id": "doc-3c363f9d809dadcf3a7c0f9008fb810a",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:8e9d5ffc51392cf2c9bd3656bb2c2dce",
      "default:extract:cbbd656952d17be6c66ff863d4e5c994"
    ],
    "create_time": 1761469887,
    "update_time": 1761469950,
    "_id": "chunk-3c363f9d809dadcf3a7c0f9008fb810a"
  },
  "chunk-aff2d7d8604331c974d095c01133c056": {
    "tokens": 266,
    "content": "7. 数据寻址 数据寻址是指如何在指令中表示一个操作数的地址，或怎样计算出操作数的地址。数据寻址的方式较多，为区别各种方式，通常在指令字中设置一个寻址特征字段，用来指明属于哪种寻址方式(其位数决定了寻址方式的种类),由此可得指令的格式如下所示： 操作码+寻址特征+形式地址。 指令中的地址码字段并不代表操作数的真实地址，这种地址称为形式地址(A) 。形式地址结合寻址方式，可以计算出操作数在存储器中的真实地址，这种地址称为有效地址(EA)。 若为立即寻址，则形式地址的位数决定了操作数的范围。 若为直接寻址，则形式地址的位数决定了可寻址的范围。 若为寄存器寻址，则形式地址的位数决定了通用寄存器的最大数量。 若为寄存器间接寻址，则寄存器的位数决定了可寻址的范围。 注意(A)表示地址为A的数值，A既可以是寄存器编号，又可以是内存地址。",
    "chunk_order_index": 0,
    "full_doc_id": "doc-aff2d7d8604331c974d095c01133c056",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:49fa9051cacd22fc4b0e11a50020ac57",
      "default:extract:e36994dc7c1fc4b2a344e58631c325c1"
    ],
    "create_time": 1761469941,
    "update_time": 1761470001,
    "_id": "chunk-aff2d7d8604331c974d095c01133c056"
  },
  "chunk-2151538dd57e60dbb6761c6a35ea00c6": {
    "tokens": 265,
    "content": "20. CISC和RISC 的比较 和CISC 相比，RISC 的优点主要体现在以下几点： 1)RISC 更能充分利用VLSI (超大规模集成电路)芯片的面积。 CISC 采用微程序控制，其控制存储器占CPU 芯片面积的50%以上，而RISC 采用组合逻辑控制，其硬布线逻辑只占 CPU 芯片面积的10%左右。 2)RISC 更能提高运算速度。RISC的指令数、寻址方式和指令格式种类少，又设有多个通用寄存器，采用流水线技术，所以运算速度更快，大多数指令在一个时钟周期内完成。 3)RISC 便于设计，可降低成本，提高可靠性。RISC 指令系统简单，因此机器设计周期短； 其逻辑简单，出错概率低，有错也易发现，因此可靠性高。 4)RISC 有利于编译程序代码优化。RISC指令类型少，寻址方式少，使编译程序容易选择更有效的指令和寻址方式，并适当地调整指令顺序，使得代码执行更高效化。",
    "chunk_order_index": 0,
    "full_doc_id": "doc-2151538dd57e60dbb6761c6a35ea00c6",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:8ab39366384c630eb339139a481cd649",
      "default:extract:548bf3ec0698097612654b8e143a3047"
    ],
    "create_time": 1761469959,
    "update_time": 1761470014,
    "_id": "chunk-2151538dd57e60dbb6761c6a35ea00c6"
  }
}