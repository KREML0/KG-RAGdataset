<?xml version='1.0' encoding='utf-8'?>
<graphml xmlns="http://graphml.graphdrawing.org/xmlns" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://graphml.graphdrawing.org/xmlns http://graphml.graphdrawing.org/xmlns/1.0/graphml.xsd">
  <key id="d11" for="edge" attr.name="created_at" attr.type="long" />
  <key id="d10" for="edge" attr.name="file_path" attr.type="string" />
  <key id="d9" for="edge" attr.name="source_id" attr.type="string" />
  <key id="d8" for="edge" attr.name="keywords" attr.type="string" />
  <key id="d7" for="edge" attr.name="description" attr.type="string" />
  <key id="d6" for="edge" attr.name="weight" attr.type="double" />
  <key id="d5" for="node" attr.name="created_at" attr.type="long" />
  <key id="d4" for="node" attr.name="file_path" attr.type="string" />
  <key id="d3" for="node" attr.name="source_id" attr.type="string" />
  <key id="d2" for="node" attr.name="description" attr.type="string" />
  <key id="d1" for="node" attr.name="entity_type" attr.type="string" />
  <key id="d0" for="node" attr.name="entity_id" attr.type="string" />
  <graph edgedefault="undirected">
    <node id="DRAM">
      <data key="d0">DRAM</data>
      <data key="d1">artifact</data>
      <data key="d2">DRAM (Dynamic Random-Access Memory) is a type of semiconductor memory that stores data using capacitors in storage cells, requiring periodic refresh to maintain data integrity.&lt;SEP&gt;DRAM is a type of volatile semiconductor memory with high density and lower cost, commonly used in computer main memory.</data>
      <data key="d3">chunk-e100f5adcf7f52281eb1c5920bc2d5d0&lt;SEP&gt;chunk-8ce34f8853facbe5658d8d7a94051590</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468132</data>
    </node>
    <node id="SRAM">
      <data key="d0">SRAM</data>
      <data key="d1">artifact</data>
      <data key="d2">SRAM (Static Random-Access Memory) is a type of semiconductor memory that stores data using flip-flops, does not require refreshing, and has faster access speeds than DRAM.&lt;SEP&gt;SRAM is a type of volatile semiconductor memory that is fast but more expensive and less dense than DRAM.&lt;SEP&gt;SRAM (Static Random Access Memory) is a type of memory used to implement TLB due to its high speed.&lt;SEP&gt;SRAM is a type of static random-access memory that uses bistable triggers to store information and maintains data without regeneration after reading.&lt;SEP&gt;SRAM (Static Random-Access Memory) is a type of memory technology used to build cache due to its speed and low latency.</data>
      <data key="d3">chunk-263465ac01c4eb10c3c852d62559620b&lt;SEP&gt;chunk-8ce34f8853facbe5658d8d7a94051590&lt;SEP&gt;chunk-e100f5adcf7f52281eb1c5920bc2d5d0&lt;SEP&gt;chunk-7c2151344b39c51051c3dacc3290bcf9&lt;SEP&gt;chunk-d02693bcc2f3ef38eee5bb553035284e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468593</data>
    </node>
    <node id="Storage Cell">
      <data key="d0">Storage Cell</data>
      <data key="d1">artifact</data>
      <data key="d2">The storage cell in DRAM consists of a single transistor and a capacitor, used to hold a single bit of data as electrical charge.&lt;SEP&gt;A storage cell, also known as a storage unit or storage element, is a physical device capable of maintaining two stable states to represent binary 0 and 1.&lt;SEP&gt;A storage cell is the basic building block of a memory system, consisting of a physical device that stores one binary bit.</data>
      <data key="d3">chunk-7c2151344b39c51051c3dacc3290bcf9&lt;SEP&gt;chunk-14ad8c0a834e0ce37fd97c7ac9177add&lt;SEP&gt;chunk-e100f5adcf7f52281eb1c5920bc2d5d0</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468378</data>
    </node>
    <node id="Gate Capacitor">
      <data key="d0">Gate Capacitor</data>
      <data key="d1">artifact</data>
      <data key="d2">The gate capacitor in a DRAM cell stores electrical charge to represent binary data.</data>
      <data key="d3">chunk-e100f5adcf7f52281eb1c5920bc2d5d0</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468052</data>
    </node>
    <node id="Carbon-Fiber Spikes">
      <data key="d0">Carbon-Fiber Spikes</data>
      <data key="d1">artifact</data>
      <data key="d2">Carbon-fiber spikes are advanced athletic footwear components but are not relevant to the DRAM context; this entity was mistakenly introduced and should be excluded.</data>
      <data key="d3">chunk-e100f5adcf7f52281eb1c5920bc2d5d0</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468052</data>
    </node>
    <node id="1 to 2ms">
      <data key="d0">1 to 2ms</data>
      <data key="d1">data</data>
      <data key="d2">The charge on a DRAM capacitor typically lasts only 1 to 2 milliseconds before needing refresh.</data>
      <data key="d3">chunk-e100f5adcf7f52281eb1c5920bc2d5d0</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468052</data>
    </node>
    <node id="Refresh Cycle">
      <data key="d0">Refresh Cycle</data>
      <data key="d1">concept</data>
      <data key="d2">The refresh cycle is the time interval between successive refresh operations for a DRAM row, typically set to 2ms.</data>
      <data key="d3">chunk-e100f5adcf7f52281eb1c5920bc2d5d0</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468052</data>
    </node>
    <node id="Concentrated Refresh">
      <data key="d0">Concentrated Refresh</data>
      <data key="d1">method</data>
      <data key="d2">Concentrated refresh is a method where all rows are refreshed consecutively within a single refresh interval, causing a temporary suspension of memory access.</data>
      <data key="d3">chunk-e100f5adcf7f52281eb1c5920bc2d5d0</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468052</data>
    </node>
    <node id="Main Memory">
      <data key="d0">Main Memory</data>
      <data key="d1">location</data>
      <data key="d2">Main Memory, also known as RAM (Random Access Memory), primary memory, or main storage, is the primary repository for data and instructions actively used by a computer's central processing unit (CPU) during program execution. It serves as the principal storage component in a computer system, directly accessible by the CPU for rapid processing. Main Memory is implemented using DRAM (Dynamic Random Access Memory) chips and functions as the main workspace where programs and data are loaded for immediate access and manipulation. It is characterized by fast access speeds, higher cost per unit of storage, and relatively smaller capacity compared to secondary storage devices like hard drives or SSDs. As a volatile memory, Main Memory retains its contents only while the system is powered, losing all stored data upon shutdown or power interruption. It plays a critical role in supporting both cache and virtual memory operations, effectively bridging the speed gap between the CPU and slower secondary storage, thus enhancing overall system performance. The storage architecture of Main Memory is organized into a matrix of storage units, often partitioned into physical pages, enabling efficient data access, management, and alignment with the CPU’s execution needs. Throughout software execution, Main Memory dynamically holds active programs, their instructions, and associated operands, ensuring seamless and efficient computing by allowing the CPU to retrieve and process information with minimal latency.&lt;SEP&gt;Main Memory is the primary data storage component directly accessible by the CPU.&lt;SEP&gt;Main memory refers to the primary storage of a computer system used for active data and program execution.</data>
      <data key="d3">chunk-263465ac01c4eb10c3c852d62559620b&lt;SEP&gt;chunk-555f79801ef87ce95e52becac62479d6&lt;SEP&gt;chunk-84c8d12524cbd30a01b0da556f764478&lt;SEP&gt;chunk-14ad8c0a834e0ce37fd97c7ac9177add&lt;SEP&gt;chunk-f58beb694766dd43b7432ff7d16d2a65&lt;SEP&gt;chunk-cef942e7cbaeb916484eb8b3e7bcbd9a&lt;SEP&gt;chunk-833bb1bcf85cd79d91b4dcd6ca2eb3db&lt;SEP&gt;chunk-b5dba59d5f9377e5060b73fecdb0de06&lt;SEP&gt;chunk-361185a50ecc6636f127fb6f6ad6eabd&lt;SEP&gt;chunk-e0a87778cef25aba2903a8a3e12c5faa&lt;SEP&gt;chunk-ed6056f0e58f2d01493e9eeb4c4363bd&lt;SEP&gt;chunk-9dccf612396a3accbfe19f8f0ed1d51b&lt;SEP&gt;chunk-ce9d79eec3b8225be9c02cda24c5a519&lt;SEP&gt;chunk-b1c06d839960e789e3e60c72b78fd928&lt;SEP&gt;chunk-0d5d7f0f10bdd7e081046bf9fbfdf10a&lt;SEP&gt;chunk-d02693bcc2f3ef38eee5bb553035284e&lt;SEP&gt;chunk-6c698405c4fcc8fb19ebad83fe798b48</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468859</data>
    </node>
    <node id="Storage Matrix">
      <data key="d0">Storage Matrix</data>
      <data key="d1">artifact</data>
      <data key="d2">The storage matrix, also referred to as the storage body or storage array, is the core structure of a memory system made up of interconnected storage cells.</data>
      <data key="d3">chunk-14ad8c0a834e0ce37fd97c7ac9177add</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468053</data>
    </node>
    <node id="Addressing">
      <data key="d0">Addressing</data>
      <data key="d1">method</data>
      <data key="d2">Addressing is the process of assigning unique addresses to storage cells to enable access and retrieval of data.</data>
      <data key="d3">chunk-14ad8c0a834e0ce37fd97c7ac9177add</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468053</data>
    </node>
    <node id="Byte Addressing">
      <data key="d0">Byte Addressing</data>
      <data key="d1">method</data>
      <data key="d2">Byte addressing is a method of organizing memory where each byte is assigned a unique address, commonly used in modern computers.</data>
      <data key="d3">chunk-14ad8c0a834e0ce37fd97c7ac9177add</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468053</data>
    </node>
    <node id="Word Addressing">
      <data key="d0">Word Addressing</data>
      <data key="d1">method</data>
      <data key="d2">Word addressing is a method of organizing memory where entire words are assigned a single address.</data>
      <data key="d3">chunk-14ad8c0a834e0ce37fd97c7ac9177add</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468053</data>
    </node>
    <node id="Memory Access">
      <data key="d0">Memory Access</data>
      <data key="d1">method</data>
      <data key="d2">Memory access refers to the process of reading from or writing to a specific memory location during instruction execution.</data>
      <data key="d3">chunk-14ad8c0a834e0ce37fd97c7ac9177add</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468053</data>
    </node>
    <node id="MAR">
      <data key="d0">MAR</data>
      <data key="d1">artifact</data>
      <data key="d2">MAR (Memory Address Register) is a register in the CPU that holds the address of the memory location to be accessed.</data>
      <data key="d3">chunk-14ad8c0a834e0ce37fd97c7ac9177add</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468053</data>
    </node>
    <node id="Dead Time">
      <data key="d0">Dead Time</data>
      <data key="d1">concept</data>
      <data key="d2">Dead time refers to the period during concentrated refresh when the memory is inaccessible for read/write operations.</data>
      <data key="d3">chunk-e100f5adcf7f52281eb1c5920bc2d5d0</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468054</data>
    </node>
    <node id="Distributed Refresh">
      <data key="d0">Distributed Refresh</data>
      <data key="d1">method</data>
      <data key="d2">Distributed refresh divides the memory cycle into two parts: one for normal access and one for refresh, avoiding dead time but increasing total access time.</data>
      <data key="d3">chunk-e100f5adcf7f52281eb1c5920bc2d5d0</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468055</data>
    </node>
    <node id="Asynchronous Refresh">
      <data key="d0">Asynchronous Refresh</data>
      <data key="d1">method</data>
      <data key="d2">Asynchronous refresh spreads refresh requests across the refresh cycle by refreshing one row at a time at regular intervals, minimizing idle wait periods for the CPU.</data>
      <data key="d3">chunk-e100f5adcf7f52281eb1c5920bc2d5d0</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468055</data>
    </node>
    <node id="Row Address">
      <data key="d0">Row Address</data>
      <data key="d1">data</data>
      <data key="d2">In DRAM, the row address is used to select a specific row of memory cells for refresh or access.</data>
      <data key="d3">chunk-e100f5adcf7f52281eb1c5920bc2d5d0</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468055</data>
    </node>
    <node id="Column Address">
      <data key="d0">Column Address</data>
      <data key="d1">data</data>
      <data key="d2">In DRAM, the column address is used to select a specific column within a selected row for data access.</data>
      <data key="d3">chunk-e100f5adcf7f52281eb1c5920bc2d5d0</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468055</data>
    </node>
    <node id="Address Pin Multiplexing">
      <data key="d0">Address Pin Multiplexing</data>
      <data key="d1">method</data>
      <data key="d2">Address pin multiplexing is a technique that reduces the number of address pins by inputting row and column addresses sequentially via the same set of pins.</data>
      <data key="d3">chunk-e100f5adcf7f52281eb1c5920bc2d5d0</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468055</data>
    </node>
    <node id="Memory Chip">
      <data key="d0">Memory Chip</data>
      <data key="d1">artifact</data>
      <data key="d2">A memory chip is a physical integrated circuit that contains DRAM cells and support circuitry for data storage and access.</data>
      <data key="d3">chunk-e100f5adcf7f52281eb1c5920bc2d5d0</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468055</data>
    </node>
    <node id="Bit Price">
      <data key="d0">Bit Price</data>
      <data key="d1">concept</data>
      <data key="d2">Bit price refers to the cost per bit of memory, which is lower in DRAM compared to SRAM due to higher integration density.&lt;SEP&gt;Bit price is the cost per bit, calculated as total cost divided by total storage capacity.</data>
      <data key="d3">chunk-3c1c3cb1cdfefa986a82277dd52e88ef&lt;SEP&gt;chunk-e100f5adcf7f52281eb1c5920bc2d5d0</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468737</data>
    </node>
    <node id="MDR">
      <data key="d0">MDR</data>
      <data key="d1">artifact</data>
      <data key="d2">MDR (Memory Data Register) is a register in the CPU that holds the data being transferred to or from memory.</data>
      <data key="d3">chunk-14ad8c0a834e0ce37fd97c7ac9177add</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468055</data>
    </node>
    <node id="Address Bus">
      <data key="d0">Address Bus</data>
      <data key="d1">artifact</data>
      <data key="d2">The address bus is a set of lines used to transfer the memory address from the CPU to the main memory.&lt;SEP&gt;Address bus is a communication pathway that carries memory addresses from the CPU to main memory, determining the maximum addressable memory space.</data>
      <data key="d3">chunk-14ad8c0a834e0ce37fd97c7ac9177add&lt;SEP&gt;chunk-f58beb694766dd43b7432ff7d16d2a65</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468347</data>
    </node>
    <node id="Data Bus">
      <data key="d0">Data Bus</data>
      <data key="d1">artifact</data>
      <data key="d2">The data bus is a set of lines used to transfer data between the CPU and the main memory.&lt;SEP&gt;Data bus is a communication pathway that transfers data between the CPU and main memory, with its width and frequency affecting data transfer rate.</data>
      <data key="d3">chunk-14ad8c0a834e0ce37fd97c7ac9177add&lt;SEP&gt;chunk-f58beb694766dd43b7432ff7d16d2a65</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468347</data>
    </node>
    <node id="Read/Write Control Circuit">
      <data key="d0">Read/Write Control Circuit</data>
      <data key="d1">artifact</data>
      <data key="d2">The read/write control circuit in main memory manages read and write operations based on control signals from the CPU.</data>
      <data key="d3">chunk-14ad8c0a834e0ce37fd97c7ac9177add</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468057</data>
    </node>
    <node id="Address Decoder">
      <data key="d0">Address Decoder</data>
      <data key="d1">artifact</data>
      <data key="d2">The address decoder in main memory interprets the address signal and selects the appropriate memory cell.&lt;SEP&gt;Address decoder is a circuit that generates chip select signals from high-order address lines.</data>
      <data key="d3">chunk-14ad8c0a834e0ce37fd97c7ac9177add&lt;SEP&gt;chunk-a438ed247c5a79e72ee6372aba002ee0</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468298</data>
    </node>
    <node id="Storage Word Length">
      <data key="d0">Storage Word Length</data>
      <data key="d1">concept</data>
      <data key="d2">Storage word length refers to the number of bits contained in a single memory word, typically matching the data bus width.</data>
      <data key="d3">chunk-14ad8c0a834e0ce37fd97c7ac9177add</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468057</data>
    </node>
    <node id="Read-After-Write Regeneration">
      <data key="d0">Read-After-Write Regeneration</data>
      <data key="d1">method</data>
      <data key="d2">Read-after-write regeneration is the process of rewriting data to a memory cell immediately after a read operation to preserve its state.</data>
      <data key="d3">chunk-e100f5adcf7f52281eb1c5920bc2d5d0</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468057</data>
    </node>
    <node id="CPU">
      <data key="d0">CPU</data>
      <data key="d1">artifact</data>
      <data key="d2">The CPU (Central Processing Unit) is the primary processor in a computer system responsible for executing instructions and managing data flow between components. As the central processing unit, it serves as the core component of a computer, handling the execution of instructions and the processing of data. The CPU interacts with memory systems and is tasked with managing timing associated with memory refresh operations, ensuring efficient and accurate data handling. It operates at a significantly faster speed compared to memory, enabling it to efficiently process multiple instructions fetched simultaneously. This high-speed operation allows the CPU to maintain optimal performance by minimizing bottlenecks in data processing. Additionally, the CPU is responsible for controlling the selection of memory chips and accessing specific memory cells, playing a pivotal role in data retrieval and storage coordination. Overall, the CPU orchestrates critical operations within a computer, managing instruction execution, data processing, memory access, and system component communication, thereby acting as the central intelligence of the computing system.&lt;SEP&gt;CPU is the central processing unit that performs most of the processing inside a computer and interacts with main memory via buses.&lt;SEP&gt;CPU is the central processing unit that issues read and write requests for memory access.&lt;SEP&gt;CPU (Central Processing Unit) is the primary processor of a computer system responsible for executing instructions.&lt;SEP&gt;CPU is the central processing unit responsible for executing instructions and accessing memory.</data>
      <data key="d3">chunk-8f87fc865b405b5892e67cab1873a773&lt;SEP&gt;chunk-3dce61048f7c557d41879fb4d9705cdc&lt;SEP&gt;chunk-0af5a7c8d38a4b5d1e4bac2d53e20424&lt;SEP&gt;chunk-14ad8c0a834e0ce37fd97c7ac9177add&lt;SEP&gt;chunk-f58beb694766dd43b7432ff7d16d2a65&lt;SEP&gt;chunk-833bb1bcf85cd79d91b4dcd6ca2eb3db&lt;SEP&gt;chunk-e0a87778cef25aba2903a8a3e12c5faa&lt;SEP&gt;chunk-a438ed247c5a79e72ee6372aba002ee0&lt;SEP&gt;chunk-9dccf612396a3accbfe19f8f0ed1d51b&lt;SEP&gt;chunk-e100f5adcf7f52281eb1c5920bc2d5d0&lt;SEP&gt;chunk-946a56828431f2eb84c208ded0826aae&lt;SEP&gt;chunk-d02693bcc2f3ef38eee5bb553035284e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468769</data>
    </node>
    <node id="Destructive Readout">
      <data key="d0">Destructive Readout</data>
      <data key="d1">concept</data>
      <data key="d2">Destructive readout is a characteristic of DRAM where reading data from a cell destroys the stored charge, requiring regeneration.&lt;SEP&gt;Destructive Readout occurs when reading a memory cell destroys the original stored information, requiring a regeneration operation immediately after read.&lt;SEP&gt;Destructive readout is a type of memory access where data is lost during reading and must be regenerated immediately.</data>
      <data key="d3">chunk-3c1c3cb1cdfefa986a82277dd52e88ef&lt;SEP&gt;chunk-e100f5adcf7f52281eb1c5920bc2d5d0&lt;SEP&gt;chunk-ce9d79eec3b8225be9c02cda24c5a519</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468737</data>
    </node>
    <node id="64-Bit Data Bus">
      <data key="d0">64-Bit Data Bus</data>
      <data key="d1">artifact</data>
      <data key="d2">A 64-bit data bus is a data transfer path capable of moving 64 bits of data simultaneously, increasing data throughput.</data>
      <data key="d3">chunk-14ad8c0a834e0ce37fd97c7ac9177add</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468058</data>
    </node>
    <node id="Power Supply">
      <data key="d0">Power Supply</data>
      <data key="d1">naturalobject</data>
      <data key="d2">The power supply provides continuous electrical energy to the DRAM, though data is lost if power is omitted due to charge leakage.</data>
      <data key="d3">chunk-e100f5adcf7f52281eb1c5920bc2d5d0</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468058</data>
    </node>
    <node id="100m Sprint Record">
      <data key="d0">100m Sprint Record</data>
      <data key="d1">category</data>
      <data key="d2">The 100m sprint record is a benchmark in athletics, recently broken by Noah Carter.</data>
      <data key="d3">chunk-e100f5adcf7f52281eb1c5920bc2d5d0</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468058</data>
    </node>
    <node id="36-Bit Address Bus">
      <data key="d0">36-Bit Address Bus</data>
      <data key="d1">artifact</data>
      <data key="d2">A 36-bit address bus allows the CPU to access up to 2^36 unique memory addresses, forming the maximum addressable memory space.</data>
      <data key="d3">chunk-14ad8c0a834e0ce37fd97c7ac9177add</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468059</data>
    </node>
    <node id="Addressable Memory Space">
      <data key="d0">Addressable Memory Space</data>
      <data key="d1">concept</data>
      <data key="d2">Addressable memory space is the total range of memory addresses that can be accessed by the CPU, determined by the number of address lines.</data>
      <data key="d3">chunk-14ad8c0a834e0ce37fd97c7ac9177add</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468059</data>
    </node>
    <node id="Binary Representation">
      <data key="d0">Binary Representation</data>
      <data key="d3">chunk-14ad8c0a834e0ce37fd97c7ac9177add</data>
      <data key="d2">Each storage cell has two stable states to represent the binary values 0 and 1.</data>
      <data key="d1">UNKNOWN</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468061</data>
    </node>
    <node id="Noah Carter">
      <data key="d0">Noah Carter</data>
      <data key="d3">chunk-e100f5adcf7f52281eb1c5920bc2d5d0</data>
      <data key="d2">Noah Carter set a new 100m sprint record at the championship.</data>
      <data key="d1">UNKNOWN</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468066</data>
    </node>
    <node id="Tokyo">
      <data key="d0">Tokyo</data>
      <data key="d3">chunk-e100f5adcf7f52281eb1c5920bc2d5d0</data>
      <data key="d2">The World Athletics Championship is being hosted in Tokyo.</data>
      <data key="d1">UNKNOWN</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468067</data>
    </node>
    <node id="World Athletics Championship">
      <data key="d0">World Athletics Championship</data>
      <data key="d3">chunk-e100f5adcf7f52281eb1c5920bc2d5d0</data>
      <data key="d2">The World Athletics Championship is being hosted in Tokyo.</data>
      <data key="d1">UNKNOWN</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468067</data>
    </node>
    <node id="Multi-Level Storage System">
      <data key="d0">Multi-Level Storage System</data>
      <data key="d1">concept</data>
      <data key="d2">A storage system architecture designed to resolve the conflict between high capacity, fast speed, and low cost in computer systems by using hierarchical memory layers.</data>
      <data key="d3">chunk-9dccf612396a3accbfe19f8f0ed1d51b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468099</data>
    </node>
    <node id="Storage Hierarchy Structure">
      <data key="d0">Storage Hierarchy Structure</data>
      <data key="d1">concept</data>
      <data key="d2">The primary design principle of the multi-level storage system where each upper-level storage acts as a high-speed cache for the lower-level storage.</data>
      <data key="d3">chunk-9dccf612396a3accbfe19f8f0ed1d51b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468099</data>
    </node>
    <node id="Cache">
      <data key="d0">Cache</data>
      <data key="d1">artifact</data>
      <data key="d2">Cache is a high-speed memory layer that stores copies of frequently accessed data from main memory to reduce access time and improve overall system performance. Positioned close to the processor, typically implemented using SRAM (Static Random-Access Memory) chips, Cache serves as a small-capacity but fast intermediary between the CPU and main memory. By temporarily holding data currently being used by the CPU or data that is likely to be accessed next, Cache minimizes the latency associated with retrieving information from slower main memory. This mechanism enhances system efficiency by drastically reducing the time required for data access, especially in operations involving repeated or sequential data retrieval. Cache operates on the principle of data locality, where recently or frequently accessed data is kept readily available, further optimizing computational throughput. As a critical component in modern computing architectures, Cache plays a vital role in maintaining high-speed data access and improving the responsiveness of processing systems.&lt;SEP&gt;Cache is a high-speed memory that stores copies of frequently accessed data from main memory to reduce access time.&lt;SEP&gt;Cache is a high-speed memory that stores copies of data from frequently used main memory locations to reduce access time.&lt;SEP&gt;Cache is a high-speed memory that stores copies of data from main memory to improve access speed.&lt;SEP&gt;Cache is a high-speed memory component located between CPU and main memory to reduce data access latency.&lt;SEP&gt;Cache refers to a fast memory layer that stores frequently accessed data to improve system performance; virtual memory employs similar principles.</data>
      <data key="d3">chunk-263465ac01c4eb10c3c852d62559620b&lt;SEP&gt;chunk-555f79801ef87ce95e52becac62479d6&lt;SEP&gt;chunk-84c8d12524cbd30a01b0da556f764478&lt;SEP&gt;chunk-3dce61048f7c557d41879fb4d9705cdc&lt;SEP&gt;chunk-cef942e7cbaeb916484eb8b3e7bcbd9a&lt;SEP&gt;chunk-833bb1bcf85cd79d91b4dcd6ca2eb3db&lt;SEP&gt;chunk-b5dba59d5f9377e5060b73fecdb0de06&lt;SEP&gt;chunk-361185a50ecc6636f127fb6f6ad6eabd&lt;SEP&gt;chunk-e0a87778cef25aba2903a8a3e12c5faa&lt;SEP&gt;chunk-ed6056f0e58f2d01493e9eeb4c4363bd&lt;SEP&gt;chunk-9dccf612396a3accbfe19f8f0ed1d51b&lt;SEP&gt;chunk-d02693bcc2f3ef38eee5bb553035284e&lt;SEP&gt;chunk-6c698405c4fcc8fb19ebad83fe798b48</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468861</data>
    </node>
    <node id="Disk Storage">
      <data key="d0">Disk Storage</data>
      <data key="d1">artifact</data>
      <data key="d2">Disk storage, also known as auxiliary storage, is a non-volatile storage medium used for long-term data retention with large capacity.</data>
      <data key="d3">chunk-9dccf612396a3accbfe19f8f0ed1d51b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468099</data>
    </node>
    <node id="Virtual Storage System">
      <data key="d0">Virtual Storage System</data>
      <data key="d1">concept</data>
      <data key="d2">A system that allows programmers to use an address space larger than the physical main memory by using a combination of main memory and disk storage.&lt;SEP&gt;A memory management system that uses virtual addressing to provide processes with the illusion of contiguous memory.</data>
      <data key="d3">chunk-9dccf612396a3accbfe19f8f0ed1d51b&lt;SEP&gt;chunk-b1c06d839960e789e3e60c72b78fd928</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468188</data>
    </node>
    <node id="Hardware">
      <data key="d0">Hardware</data>
      <data key="d1">artifact</data>
      <data key="d2">The physical components responsible for managing data movement between cache and main memory automatically.&lt;SEP&gt;Hardware refers to physical components of the computer system that implement cache and part of virtual memory.&lt;SEP&gt;Hardware refers to physical components such as the CPU, memory, and controllers that support system operations.</data>
      <data key="d3">chunk-833bb1bcf85cd79d91b4dcd6ca2eb3db&lt;SEP&gt;chunk-9dccf612396a3accbfe19f8f0ed1d51b&lt;SEP&gt;chunk-6c698405c4fcc8fb19ebad83fe798b48</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468266</data>
    </node>
    <node id="Operating System">
      <data key="d0">Operating System</data>
      <data key="d1">organization</data>
      <data key="d2">The software layer that manages the interaction between hardware and application programs, particularly in data transfer between main memory and disk storage.&lt;SEP&gt;The operating system manages memory resources, implements virtual memory, and coordinates between hardware and software.&lt;SEP&gt;The operating system manages memory and handles page faults by loading missing pages into main memory.</data>
      <data key="d3">chunk-833bb1bcf85cd79d91b4dcd6ca2eb3db&lt;SEP&gt;chunk-9dccf612396a3accbfe19f8f0ed1d51b&lt;SEP&gt;chunk-b1c06d839960e789e3e60c72b78fd928</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468188</data>
    </node>
    <node id="Programmer">
      <data key="d0">Programmer</data>
      <data key="d1">person</data>
      <data key="d2">A person who writes software and programs, whose view of address space is abstracted by the virtual storage system.</data>
      <data key="d3">chunk-9dccf612396a3accbfe19f8f0ed1d51b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468101</data>
    </node>
    <node id="Data Transfer">
      <data key="d0">Data Transfer</data>
      <data key="d1">concept</data>
      <data key="d2">The process of moving data from one storage level to another, such as from disk to main memory or main memory to cache.</data>
      <data key="d3">chunk-9dccf612396a3accbfe19f8f0ed1d51b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468101</data>
    </node>
    <node id="Cache- Main Memory Layer">
      <data key="d0">Cache- Main Memory Layer</data>
      <data key="d1">concept</data>
      <data key="d2">A hierarchical storage layer that resolves the speed mismatch between CPU and main memory by using cache as a high-speed buffer.</data>
      <data key="d3">chunk-9dccf612396a3accbfe19f8f0ed1d51b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468101</data>
    </node>
    <node id="Main Memory- Auxiliary Storage Layer">
      <data key="d0">Main Memory- Auxiliary Storage Layer</data>
      <data key="d1">concept</data>
      <data key="d2">A hierarchical storage layer that increases system capacity by using auxiliary storage as an extension of main memory.</data>
      <data key="d3">chunk-9dccf612396a3accbfe19f8f0ed1d51b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468101</data>
    </node>
    <node id="Address Space">
      <data key="d0">Address Space</data>
      <data key="d1">concept</data>
      <data key="d2">The range of memory addresses available to a programmer in a virtual storage system, which can exceed the physical capacity of main memory.&lt;SEP&gt;Address space refers to the total range of addresses available for memory access.</data>
      <data key="d3">chunk-a438ed247c5a79e72ee6372aba002ee0&lt;SEP&gt;chunk-9dccf612396a3accbfe19f8f0ed1d51b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468298</data>
    </node>
    <node id="Speed-Matching Solution">
      <data key="d0">Speed-Matching Solution</data>
      <data key="d3">chunk-9dccf612396a3accbfe19f8f0ed1d51b</data>
      <data key="d2">This layer resolves the speed mismatch between the CPU and main memory through hardware-managed data transfers that are transparent to programmers.</data>
      <data key="d1">UNKNOWN</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468102</data>
    </node>
    <node id="Capacity Expansion Solution">
      <data key="d0">Capacity Expansion Solution</data>
      <data key="d3">chunk-9dccf612396a3accbfe19f8f0ed1d51b</data>
      <data key="d2">This layer addresses storage capacity limitations by allowing data to be swapped between main memory and auxiliary storage, managed by hardware and the operating system in a transparent way to application programmers.</data>
      <data key="d1">UNKNOWN</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468102</data>
    </node>
    <node id="TLB">
      <data key="d0">TLB</data>
      <data key="d1">artifact</data>
      <data key="d2">TLB (Translation Lookaside Buffer) is a cache used to speed up virtual address translation by storing recent virtual-to-physical address mappings.&lt;SEP&gt;TLB (Translation Lookaside Buffer) is a hardware component that caches page table entries to speed up virtual address translation.&lt;SEP&gt;TLB is a translation lookaside buffer that stores recent translations of virtual page numbers to physical page numbers, improving memory access speed.</data>
      <data key="d3">chunk-ed6056f0e58f2d01493e9eeb4c4363bd&lt;SEP&gt;chunk-263465ac01c4eb10c3c852d62559620b&lt;SEP&gt;chunk-6c698405c4fcc8fb19ebad83fe798b48</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468264</data>
    </node>
    <node id="2 Way Set Associative Cache">
      <data key="d0">2 Way Set Associative Cache</data>
      <data key="d1">method</data>
      <data key="d2">2 Way Set Associative Cache is a cache mapping technique where each memory block can be stored in one of two possible cache lines within a set.</data>
      <data key="d3">chunk-ed6056f0e58f2d01493e9eeb4c4363bd</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468109</data>
    </node>
    <node id="32 Bit Virtual Address">
      <data key="d0">32 Bit Virtual Address</data>
      <data key="d1">data</data>
      <data key="d2">32 Bit Virtual Address is a 32-bit address issued by the CPU for accessing virtual memory.</data>
      <data key="d3">chunk-ed6056f0e58f2d01493e9eeb4c4363bd</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468109</data>
    </node>
    <node id="Full Associative TLB">
      <data key="d0">Full Associative TLB</data>
      <data key="d1">method</data>
      <data key="d2">Full Associative TLB is a TLB design where any virtual page can be stored in any TLB entry, allowing maximum flexibility in address matching.</data>
      <data key="d3">chunk-ed6056f0e58f2d01493e9eeb4c4363bd</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468109</data>
    </node>
    <node id="Virtual Page Number">
      <data key="d0">Virtual Page Number</data>
      <data key="d1">concept</data>
      <data key="d2">Virtual Page Number is the portion of a virtual address used to index into the page table or TLB.&lt;SEP&gt;Virtual Page Number is the part of a virtual address that identifies the page within a virtual address space.&lt;SEP&gt;The high-order field of a virtual address that identifies the virtual page.&lt;SEP&gt;Virtual Page Number is the identifier for a page in virtual memory that is translated to a physical page number via the TLB or page table.</data>
      <data key="d3">chunk-ed6056f0e58f2d01493e9eeb4c4363bd&lt;SEP&gt;chunk-263465ac01c4eb10c3c852d62559620b&lt;SEP&gt;chunk-b1c06d839960e789e3e60c72b78fd928&lt;SEP&gt;chunk-6c698405c4fcc8fb19ebad83fe798b48</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468266</data>
    </node>
    <node id="Page Directory Index">
      <data key="d0">Page Directory Index</data>
      <data key="d1">data</data>
      <data key="d2">Page Directory Index is the part of a virtual page number used to index the page directory in a two-level page table system.</data>
      <data key="d3">chunk-ed6056f0e58f2d01493e9eeb4c4363bd</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468109</data>
    </node>
    <node id="Page Table Index">
      <data key="d0">Page Table Index</data>
      <data key="d1">data</data>
      <data key="d2">Page Table Index is the part of a virtual page number used to index the page table entry in a two-level page table system.</data>
      <data key="d3">chunk-ed6056f0e58f2d01493e9eeb4c4363bd</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468109</data>
    </node>
    <node id="Page Table">
      <data key="d0">Page Table</data>
      <data key="d1">artifact</data>
      <data key="d2">Page Table is a data structure used by the operating system to store the mapping between virtual and physical page numbers.&lt;SEP&gt;Page table is a data structure that keeps track of the mapping between virtual pages and physical pages in memory.&lt;SEP&gt;Page Table is a data structure stored in main memory that maps virtual pages to physical frames.&lt;SEP&gt;A page table is a data structure stored in main memory that maps virtual page numbers to physical page numbers.&lt;SEP&gt;Page Table is a data structure used by the operating system to store mappings from virtual page numbers to physical page numbers, accessed during TLB misses.</data>
      <data key="d3">chunk-263465ac01c4eb10c3c852d62559620b&lt;SEP&gt;chunk-ed6056f0e58f2d01493e9eeb4c4363bd&lt;SEP&gt;chunk-b1c06d839960e789e3e60c72b78fd928&lt;SEP&gt;chunk-0d5d7f0f10bdd7e081046bf9fbfdf10a&lt;SEP&gt;chunk-6c698405c4fcc8fb19ebad83fe798b48</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468267</data>
    </node>
    <node id="Physical Address">
      <data key="d0">Physical Address</data>
      <data key="d1">concept</data>
      <data key="d2">Physical Address is the actual address in main memory that corresponds to a virtual address after translation.&lt;SEP&gt;A physical address is the actual location in main memory where data or instructions are stored, derived from a virtual address through address translation.&lt;SEP&gt;A physical address is the real memory location in main memory, also known as an actual address.</data>
      <data key="d3">chunk-b5dba59d5f9377e5060b73fecdb0de06&lt;SEP&gt;chunk-ed6056f0e58f2d01493e9eeb4c4363bd&lt;SEP&gt;chunk-b1c06d839960e789e3e60c72b78fd928</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468859</data>
    </node>
    <node id="Cache Line">
      <data key="d0">Cache Line</data>
      <data key="d1">artifact</data>
      <data key="d2">Cache Line is a unit of data storage in cache memory that holds a block of data from main memory.&lt;SEP&gt;Cache Line is a single unit of storage within a cache that holds a block of data from main memory.&lt;SEP&gt;Cache Line is another term for Cache Block, referring to a unit of data in Cache that holds a fixed number of bytes.&lt;SEP&gt;Cache line is a unit of data transfer between main memory and cache, typically containing a block of data.</data>
      <data key="d3">chunk-361185a50ecc6636f127fb6f6ad6eabd&lt;SEP&gt;chunk-ed6056f0e58f2d01493e9eeb4c4363bd&lt;SEP&gt;chunk-555f79801ef87ce95e52becac62479d6&lt;SEP&gt;chunk-e0a87778cef25aba2903a8a3e12c5faa</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468587</data>
    </node>
    <node id="Tag Field">
      <data key="d0">Tag Field</data>
      <data key="d1">artifact</data>
      <data key="d2">Tag Field is a portion of a memory address stored in cache to identify which main memory block is stored in the cache line.</data>
      <data key="d3">chunk-ed6056f0e58f2d01493e9eeb4c4363bd</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468110</data>
    </node>
    <node id="Block Offset">
      <data key="d0">Block Offset</data>
      <data key="d1">data</data>
      <data key="d2">Block Offset is the portion of an address used to select a specific byte within a cache block.</data>
      <data key="d3">chunk-ed6056f0e58f2d01493e9eeb4c4363bd</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468110</data>
    </node>
    <node id="Replacement Policy">
      <data key="d0">Replacement Policy</data>
      <data key="d1">method</data>
      <data key="d2">Replacement Policy is a strategy used to determine which cache entry to evict when the cache is full and a new entry must be stored.</data>
      <data key="d3">chunk-ed6056f0e58f2d01493e9eeb4c4363bd</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468110</data>
    </node>
    <node id="Virtual Memory">
      <data key="d0">Virtual Memory</data>
      <data key="d1">concept</data>
      <data key="d2">Virtual Memory is a memory management technique that allows a computer to use more memory than physically available by combining RAM and disk storage.&lt;SEP&gt;Virtual memory is a memory management technique that provides an illusion of a large main memory by using secondary storage, improving system performance by handling larger programs than physical memory can hold.&lt;SEP&gt;Virtual memory is a memory management technique that creates a large, unified address space by combining main memory and secondary storage, allowing users to program without regard to actual physical memory size or location.</data>
      <data key="d3">chunk-833bb1bcf85cd79d91b4dcd6ca2eb3db&lt;SEP&gt;chunk-b5dba59d5f9377e5060b73fecdb0de06&lt;SEP&gt;chunk-ed6056f0e58f2d01493e9eeb4c4363bd</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468859</data>
    </node>
    <node id="Program Access Locality Principle">
      <data key="d0">Program Access Locality Principle</data>
      <data key="d1">concept</data>
      <data key="d2">The Program Access Locality Principle refers to the tendency of programs to access a relatively small portion of their address space intensively over a short period, encompassing both temporal and spatial locality.</data>
      <data key="d3">chunk-3dce61048f7c557d41879fb4d9705cdc</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468116</data>
    </node>
    <node id="Time Locality">
      <data key="d0">Time Locality</data>
      <data key="d1">concept</data>
      <data key="d2">Time locality indicates that information recently used is likely to be used again in the near future, due to program structures such as loops, repeated subroutine segments, and array access patterns.</data>
      <data key="d3">chunk-3dce61048f7c557d41879fb4d9705cdc</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468116</data>
    </node>
    <node id="Spatial Locality">
      <data key="d0">Spatial Locality</data>
      <data key="d1">concept</data>
      <data key="d2">Spatial locality indicates that information near the currently accessed data is likely to be accessed soon, due to sequential instruction execution and data storage in clusters such as vectors and arrays.&lt;SEP&gt;Spatial Locality refers to the tendency of programs to access memory locations that are close to each other, which is exploited by write allocation strategies.</data>
      <data key="d3">chunk-3dce61048f7c557d41879fb4d9705cdc&lt;SEP&gt;chunk-cef942e7cbaeb916484eb8b3e7bcbd9a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468474</data>
    </node>
    <node id="High-Speed Buffering Technology">
      <data key="d0">High-Speed Buffering Technology</data>
      <data key="d1">method</data>
      <data key="d2">High-Speed Buffering Technology leverages the principle of locality to store frequently accessed data in a fast, small-capacity cache, enabling CPU operations to primarily target the cache to improve execution speed.</data>
      <data key="d3">chunk-3dce61048f7c557d41879fb4d9705cdc</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468116</data>
    </node>
    <node id="Page-Based Virtual Memory">
      <data key="d0">Page-Based Virtual Memory</data>
      <data key="d1">concept</data>
      <data key="d2">Page-based virtual memory is a memory management method that uses pages as the basic unit for allocating and managing virtual and physical memory.</data>
      <data key="d3">chunk-0d5d7f0f10bdd7e081046bf9fbfdf10a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468128</data>
    </node>
    <node id="Physical Page">
      <data key="d0">Physical Page</data>
      <data key="d1">artifact</data>
      <data key="d2">Physical page, also known as real page or page frame, refers to a block of memory in main memory that is used to store data from virtual memory.</data>
      <data key="d3">chunk-0d5d7f0f10bdd7e081046bf9fbfdf10a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468128</data>
    </node>
    <node id="Virtual Page">
      <data key="d0">Virtual Page</data>
      <data key="d1">artifact</data>
      <data key="d2">Virtual page, also known as虚页, is a block of memory in the virtual address space that is mapped to physical memory.</data>
      <data key="d3">chunk-0d5d7f0f10bdd7e081046bf9fbfdf10a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468128</data>
    </node>
    <node id="Virtual Address Space">
      <data key="d0">Virtual Address Space</data>
      <data key="d1">concept</data>
      <data key="d2">Virtual address space is the memory space available to a process, divided into virtual pages.</data>
      <data key="d3">chunk-0d5d7f0f10bdd7e081046bf9fbfdf10a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468128</data>
    </node>
    <node id="Page Size">
      <data key="d0">Page Size</data>
      <data key="d1">concept</data>
      <data key="d2">Page size is the fixed size of each page in both virtual and physical memory, ensuring consistent alignment.</data>
      <data key="d3">chunk-0d5d7f0f10bdd7e081046bf9fbfdf10a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468128</data>
    </node>
    <node id="ROM">
      <data key="d0">ROM</data>
      <data key="d1">artifact</data>
      <data key="d2">ROM is a type of read-only memory that retains data even after power loss and is non-volatile.&lt;SEP&gt;ROM (Read-Only Memory) is a non-volatile memory type used to store permanent data such as system firmware and boot instructions.</data>
      <data key="d3">chunk-8ce34f8853facbe5658d8d7a94051590&lt;SEP&gt;chunk-946a56828431f2eb84c208ded0826aae</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468222</data>
    </node>
    <node id="RAM">
      <data key="d0">RAM</data>
      <data key="d1">artifact</data>
      <data key="d2">RAM is a volatile memory that loses data when power is turned off and supports random access.&lt;SEP&gt;RAM (Random Access Memory) is a type of volatile memory used for temporary storage during program execution and user data processing.</data>
      <data key="d3">chunk-8ce34f8853facbe5658d8d7a94051590&lt;SEP&gt;chunk-946a56828431f2eb84c208ded0826aae</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468222</data>
    </node>
    <node id="Non-Volatile">
      <data key="d0">Non-Volatile</data>
      <data key="d1">concept</data>
      <data key="d2">Non-volatile refers to the property of retaining stored data even when power is lost.</data>
      <data key="d3">chunk-8ce34f8853facbe5658d8d7a94051590</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468132</data>
    </node>
    <node id="Random Access">
      <data key="d0">Random Access</data>
      <data key="d1">method</data>
      <data key="d2">Random access is a method of accessing data in memory where any location can be directly accessed without sequential access.</data>
      <data key="d3">chunk-8ce34f8853facbe5658d8d7a94051590</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468132</data>
    </node>
    <node id="Bit Density">
      <data key="d0">Bit Density</data>
      <data key="d1">concept</data>
      <data key="d2">Bit density refers to the number of data bits stored per unit area in a memory device, often used to measure storage efficiency.</data>
      <data key="d3">chunk-8ce34f8853facbe5658d8d7a94051590</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468132</data>
    </node>
    <node id="Structural Simplicity">
      <data key="d0">Structural Simplicity</data>
      <data key="d1">concept</data>
      <data key="d2">Structural simplicity refers to the reduced complexity in the design and layout of memory components, contributing to higher bit density.</data>
      <data key="d3">chunk-8ce34f8853facbe5658d8d7a94051590</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468132</data>
    </node>
    <node id="Volatile">
      <data key="d0">Volatile</data>
      <data key="d3">chunk-8ce34f8853facbe5658d8d7a94051590</data>
      <data key="d2">SRAM is volatile and loses its stored data when power is turned off.</data>
      <data key="d1">UNKNOWN</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468134</data>
    </node>
    <node id="Virtual Address Translation">
      <data key="d0">Virtual Address Translation</data>
      <data key="d1">method</data>
      <data key="d2">Virtual Address Translation is the process of converting virtual addresses to physical addresses during memory access.</data>
      <data key="d3">chunk-263465ac01c4eb10c3c852d62559620b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468160</data>
    </node>
    <node id="Locality Principle">
      <data key="d0">Locality Principle</data>
      <data key="d1">concept</data>
      <data key="d2">Locality Principle is the concept that programs tend to access the same set of memory locations repeatedly over a short period.&lt;SEP&gt;The locality principle refers to the tendency of programs to access a limited set of memory locations repeatedly, forming the basis for cache and virtual memory optimizations.&lt;SEP&gt;Locality Principle refers to the tendency of a processor to access the same set of memory locations repeatedly over a short period of time.</data>
      <data key="d3">chunk-833bb1bcf85cd79d91b4dcd6ca2eb3db&lt;SEP&gt;chunk-263465ac01c4eb10c3c852d62559620b&lt;SEP&gt;chunk-555f79801ef87ce95e52becac62479d6</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468351</data>
    </node>
    <node id="Full Associative Mapping">
      <data key="d0">Full Associative Mapping</data>
      <data key="d1">method</data>
      <data key="d2">Full Associative Mapping is a TLB mapping technique where any page table entry can be stored in any TLB set.&lt;SEP&gt;Full Associative Mapping is a cache mapping technique where any block from main memory can be placed in any line of the cache.&lt;SEP&gt;Full associative mapping allows any virtual page to be stored in any available physical page frame, enhancing flexibility and hit rates.</data>
      <data key="d3">chunk-b5dba59d5f9377e5060b73fecdb0de06&lt;SEP&gt;chunk-263465ac01c4eb10c3c852d62559620b&lt;SEP&gt;chunk-555f79801ef87ce95e52becac62479d6</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468861</data>
    </node>
    <node id="Set Associative Mapping">
      <data key="d0">Set Associative Mapping</data>
      <data key="d1">method</data>
      <data key="d2">Set Associative Mapping is a TLB mapping technique where each page table entry is stored in a specific set, determined by a portion of the virtual page number.&lt;SEP&gt;Set Associative Mapping is a cache mapping technique that divides the cache into sets, where a block from main memory can be placed in any line within a specific set.&lt;SEP&gt;Set associative mapping divides the cache into groups (sets), with each block assigned to a specific set, and can be placed in any line within that set.</data>
      <data key="d3">chunk-361185a50ecc6636f127fb6f6ad6eabd&lt;SEP&gt;chunk-263465ac01c4eb10c3c852d62559620b&lt;SEP&gt;chunk-555f79801ef87ce95e52becac62479d6</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468589</data>
    </node>
    <node id="TLB Tag">
      <data key="d0">TLB Tag</data>
      <data key="d1">data</data>
      <data key="d2">TLB Tag is a field in a TLB entry used to identify the corresponding virtual page number.</data>
      <data key="d3">chunk-263465ac01c4eb10c3c852d62559620b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468162</data>
    </node>
    <node id="TLB Entry">
      <data key="d0">TLB Entry</data>
      <data key="d1">artifact</data>
      <data key="d2">TLB Entry is a unit in the TLB that stores a virtual page number and its corresponding physical page frame.</data>
      <data key="d3">chunk-263465ac01c4eb10c3c852d62559620b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468162</data>
    </node>
    <node id="Slow Table">
      <data key="d0">Slow Table</data>
      <data key="d1">data</data>
      <data key="d2">Slow Table refers to the page table stored in main memory, in contrast to the fast TLB, and is used as a backup during page table lookups.</data>
      <data key="d3">chunk-263465ac01c4eb10c3c852d62559620b</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468162</data>
    </node>
    <node id="System Performance">
      <data key="d0">System Performance</data>
      <data key="d1">concept</data>
      <data key="d2">System performance refers to the efficiency and speed of a computer system in executing tasks, influenced by memory hierarchy and data access mechanisms.</data>
      <data key="d3">chunk-833bb1bcf85cd79d91b4dcd6ca2eb3db</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468179</data>
    </node>
    <node id="Capacity">
      <data key="d0">Capacity</data>
      <data key="d1">concept</data>
      <data key="d2">Capacity refers to the amount of data that can be stored in a memory system, a key factor in both virtual memory and cache.</data>
      <data key="d3">chunk-833bb1bcf85cd79d91b4dcd6ca2eb3db</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468179</data>
    </node>
    <node id="Speed">
      <data key="d0">Speed</data>
      <data key="d1">concept</data>
      <data key="d2">Speed is the rate at which data can be accessed or processed, a critical attribute in determining system performance for both cache and virtual memory.</data>
      <data key="d3">chunk-833bb1bcf85cd79d91b4dcd6ca2eb3db</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468179</data>
    </node>
    <node id="Price">
      <data key="d0">Price</data>
      <data key="d1">concept</data>
      <data key="d2">Price refers to the cost of memory components, forming a gradient along with capacity and speed in memory systems.</data>
      <data key="d3">chunk-833bb1bcf85cd79d91b4dcd6ca2eb3db</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468179</data>
    </node>
    <node id="Information Block">
      <data key="d0">Information Block</data>
      <data key="d1">artifact</data>
      <data key="d2">An information block is a unit of data that is moved between memory levels, used as the basic exchange unit in virtual memory and cache systems.</data>
      <data key="d3">chunk-833bb1bcf85cd79d91b4dcd6ca2eb3db</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468179</data>
    </node>
    <node id="Address Mapping">
      <data key="d0">Address Mapping</data>
      <data key="d1">method</data>
      <data key="d2">Address mapping is the process of translating logical addresses to physical addresses, a shared concern in both cache and virtual memory systems.</data>
      <data key="d3">chunk-833bb1bcf85cd79d91b4dcd6ca2eb3db</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468179</data>
    </node>
    <node id="Replacement Algorithm">
      <data key="d0">Replacement Algorithm</data>
      <data key="d1">method</data>
      <data key="d2">A replacement algorithm determines which data to evict from memory when new data must be loaded, used in both cache and virtual memory operations.&lt;SEP&gt;A Replacement Algorithm determines which cache line should be replaced when a new block is to be loaded into a full cache.&lt;SEP&gt;Replacement Algorithm is a strategy used to determine which block in the Cache should be replaced when the Cache is full and a new block needs to be loaded.&lt;SEP&gt;A replacement algorithm is used to determine which page or segment to remove from main memory when it is full and a new one needs to be loaded.</data>
      <data key="d3">chunk-833bb1bcf85cd79d91b4dcd6ca2eb3db&lt;SEP&gt;chunk-b5dba59d5f9377e5060b73fecdb0de06&lt;SEP&gt;chunk-e0a87778cef25aba2903a8a3e12c5faa&lt;SEP&gt;chunk-555f79801ef87ce95e52becac62479d6</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468861</data>
    </node>
    <node id="Update Strategy">
      <data key="d0">Update Strategy</data>
      <data key="d1">method</data>
      <data key="d2">An update strategy defines how changes to data in memory are synchronized, a common issue in both cache and virtual memory systems.</data>
      <data key="d3">chunk-833bb1bcf85cd79d91b4dcd6ca2eb3db</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468181</data>
    </node>
    <node id="Fast Cache">
      <data key="d0">Fast Cache</data>
      <data key="d1">concept</data>
      <data key="d2">Fast cache is a design concept based on locality, placing active data in faster memory components to reduce access latency.</data>
      <data key="d3">chunk-833bb1bcf85cd79d91b4dcd6ca2eb3db</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468181</data>
    </node>
    <node id="Secondary Storage">
      <data key="d0">Secondary Storage</data>
      <data key="d1">location</data>
      <data key="d2">Secondary storage, such as hard drives, is used for long-term data storage and provides backing for virtual memory.&lt;SEP&gt;Secondary storage is non-volatile memory used for long-term data storage, such as hard drives or SSDs.</data>
      <data key="d3">chunk-833bb1bcf85cd79d91b4dcd6ca2eb3db&lt;SEP&gt;chunk-b5dba59d5f9377e5060b73fecdb0de06</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468859</data>
    </node>
    <node id="Cache Hierarchy">
      <data key="d0">Cache Hierarchy</data>
      <data key="d1">concept</data>
      <data key="d2">The cache hierarchy refers to the layered arrangement of cache levels in a system, from L1 to L2, aimed at improving memory access speed.</data>
      <data key="d3">chunk-833bb1bcf85cd79d91b4dcd6ca2eb3db</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468181</data>
    </node>
    <node id="Virtual Memory System">
      <data key="d0">Virtual Memory System</data>
      <data key="d1">concept</data>
      <data key="d2">A virtual memory system extends physical memory through secondary storage, enabling efficient use of limited RAM.</data>
      <data key="d3">chunk-833bb1bcf85cd79d91b4dcd6ca2eb3db</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468182</data>
    </node>
    <node id="Programmer Transparency">
      <data key="d0">Programmer Transparency</data>
      <data key="d1">concept</data>
      <data key="d2">Programmer transparency refers to the extent to which memory mechanisms are hidden from programmers, varying between cache (transparent) and virtual memory (partially visible).</data>
      <data key="d3">chunk-833bb1bcf85cd79d91b4dcd6ca2eb3db</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468182</data>
    </node>
    <node id="Cache Miss">
      <data key="d0">Cache Miss</data>
      <data key="d1">concept</data>
      <data key="d2">A cache miss occurs when requested data is not found in the cache and must be retrieved from slower memory.&lt;SEP&gt;Cache miss occurs when the requested data block is not found in the cache, requiring a fetch from main memory.&lt;SEP&gt;Cache Miss occurs when the requested data is not in the Cache, requiring access to Main Memory.</data>
      <data key="d3">chunk-833bb1bcf85cd79d91b4dcd6ca2eb3db&lt;SEP&gt;chunk-e0a87778cef25aba2903a8a3e12c5faa&lt;SEP&gt;chunk-6c698405c4fcc8fb19ebad83fe798b48</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468392</data>
    </node>
    <node id="Page Fault">
      <data key="d0">Page Fault</data>
      <data key="d1">concept</data>
      <data key="d2">A page fault occurs when requested data is not in main memory and must be loaded from secondary storage in a virtual memory system.&lt;SEP&gt;A condition that occurs when a requested virtual page is not present in main memory, requiring the operating system to handle page loading.</data>
      <data key="d3">chunk-833bb1bcf85cd79d91b4dcd6ca2eb3db&lt;SEP&gt;chunk-b1c06d839960e789e3e60c72b78fd928</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468186</data>
    </node>
    <node id="Virtual Address">
      <data key="d0">Virtual Address</data>
      <data key="d1">concept</data>
      <data key="d2">A virtual address is an address generated by the CPU that must be converted to a physical address for memory access in a virtual storage system.&lt;SEP&gt;A virtual address is an address used by a program to access memory, which is translated into a physical address by the memory management unit.</data>
      <data key="d3">chunk-b5dba59d5f9377e5060b73fecdb0de06&lt;SEP&gt;chunk-b1c06d839960e789e3e60c72b78fd928</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468859</data>
    </node>
    <node id="Page Offset">
      <data key="d0">Page Offset</data>
      <data key="d1">concept</data>
      <data key="d2">The low-order field of a virtual address or physical address that represents the position within a page.</data>
      <data key="d3">chunk-b1c06d839960e789e3e60c72b78fd928</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468186</data>
    </node>
    <node id="Physical Page Number">
      <data key="d0">Physical Page Number</data>
      <data key="d1">concept</data>
      <data key="d2">The high-order field of a physical address that identifies the physical page in main memory.&lt;SEP&gt;Physical Page Number is the actual address in main memory corresponding to a virtual page number after translation.</data>
      <data key="d3">chunk-b1c06d839960e789e3e60c72b78fd928&lt;SEP&gt;chunk-6c698405c4fcc8fb19ebad83fe798b48</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468266</data>
    </node>
    <node id="Page Table Base Register">
      <data key="d0">Page Table Base Register</data>
      <data key="d1">artifact</data>
      <data key="d2">A register that stores the starting address of the page table for a given process.</data>
      <data key="d3">chunk-b1c06d839960e789e3e60c72b78fd928</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468186</data>
    </node>
    <node id="Process">
      <data key="d0">Process</data>
      <data key="d1">concept</data>
      <data key="d2">A process is an instance of a program in execution, each having its own page table and virtual address space.</data>
      <data key="d3">chunk-b1c06d839960e789e3e60c72b78fd928</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468188</data>
    </node>
    <node id="主存容量的扩展">
      <data key="d0">主存容量的扩展</data>
      <data key="d1">concept</data>
      <data key="d2">主存容量的扩展refers to the process of increasing the storage capacity of a computer's main memory by expanding in both word count and word length.</data>
      <data key="d3">chunk-d6bddd3dfdc4b05e9f684acd41e40adb</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468216</data>
    </node>
    <node id="位扩展法">
      <data key="d0">位扩展法</data>
      <data key="d1">method</data>
      <data key="d2">位扩展法is a technique used to increase the word length of memory by connecting multiple memory chips in parallel to match the CPU's data bus width.</data>
      <data key="d3">chunk-d6bddd3dfdc4b05e9f684acd41e40adb</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468216</data>
    </node>
    <node id="字扩展法">
      <data key="d0">字扩展法</data>
      <data key="d1">method</data>
      <data key="d2">字扩展法is a technique used to increase the number of storage words by connecting memory chips in a way that uses higher address lines to select different chips.</data>
      <data key="d3">chunk-d6bddd3dfdc4b05e9f684acd41e40adb</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468216</data>
    </node>
    <node id="字位同时扩展法">
      <data key="d0">字位同时扩展法</data>
      <data key="d1">method</data>
      <data key="d2">字位同时扩展法combines both bit and word expansion methods to simultaneously increase the number of storage words and the word length.</data>
      <data key="d3">chunk-d6bddd3dfdc4b05e9f684acd41e40adb</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468216</data>
    </node>
    <node id="存储芯片">
      <data key="d0">存储芯片</data>
      <data key="d1">artifact</data>
      <data key="d2">存储芯片is a semiconductor device used to store data, with limited capacity in terms of word count and word length.</data>
      <data key="d3">chunk-d6bddd3dfdc4b05e9f684acd41e40adb</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468216</data>
    </node>
    <node id="字长">
      <data key="d0">字长</data>
      <data key="d1">concept</data>
      <data key="d2">字长refers to the number of bits that can be processed or stored in a single memory word.</data>
      <data key="d3">chunk-d6bddd3dfdc4b05e9f684acd41e40adb</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468216</data>
    </node>
    <node id="存储字数">
      <data key="d0">存储字数</data>
      <data key="d1">concept</data>
      <data key="d2">存储字数is the total number of distinct storage locations (words) available in a memory system.</data>
      <data key="d3">chunk-d6bddd3dfdc4b05e9f684acd41e40adb</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468216</data>
    </node>
    <node id="CPU系统数据线">
      <data key="d0">CPU系统数据线</data>
      <data key="d1">artifact</data>
      <data key="d2">CPU系统数据线is the data bus connecting the CPU to the memory system, having a specific number of bits.</data>
      <data key="d3">chunk-d6bddd3dfdc4b05e9f684acd41e40adb</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468216</data>
    </node>
    <node id="系统总线">
      <data key="d0">系统总线</data>
      <data key="d1">artifact</data>
      <data key="d2">系统总线is the communication pathway that connects the CPU, memory, and other components, including address, data, and control lines.</data>
      <data key="d3">chunk-d6bddd3dfdc4b05e9f684acd41e40adb</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468218</data>
    </node>
    <node id="地址线">
      <data key="d0">地址线</data>
      <data key="d1">artifact</data>
      <data key="d2">地址线is a set of wires in a system that carry address information to select a specific memory location.</data>
      <data key="d3">chunk-d6bddd3dfdc4b05e9f684acd41e40adb</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468218</data>
    </node>
    <node id="片选控制线">
      <data key="d0">片选控制线</data>
      <data key="d1">artifact</data>
      <data key="d2">片选控制线is a control signal used to activate a specific memory chip in a memory expansion setup.</data>
      <data key="d3">chunk-d6bddd3dfdc4b05e9f684acd41e40adb</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468218</data>
    </node>
    <node id="读/写控制线">
      <data key="d0">读/写控制线</data>
      <data key="d1">artifact</data>
      <data key="d2">读/写控制线is a control line that determines whether data is being read from or written to a memory chip.</data>
      <data key="d3">chunk-d6bddd3dfdc4b05e9f684acd41e40adb</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468218</data>
    </node>
    <node id="高位译码">
      <data key="d0">高位译码</data>
      <data key="d1">method</data>
      <data key="d2">高位译码is a process that uses the higher-order address lines to generate chip select signals for different memory chips.</data>
      <data key="d3">chunk-d6bddd3dfdc4b05e9f684acd41e40adb</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468218</data>
    </node>
    <node id="低位连接">
      <data key="d0">低位连接</data>
      <data key="d1">method</data>
      <data key="d2">低位连接is the method of connecting the lower-order address lines of memory chips to the corresponding address lines of the system.</data>
      <data key="d3">chunk-d6bddd3dfdc4b05e9f684acd41e40adb</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468218</data>
    </node>
    <node id="并联">
      <data key="d0">并联</data>
      <data key="d1">method</data>
      <data key="d2">并联refers to the connection of components in parallel, commonly used for data and control lines in memory expansion.</data>
      <data key="d3">chunk-d6bddd3dfdc4b05e9f684acd41e40adb</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468218</data>
    </node>
    <node id="Storage Chip">
      <data key="d0">Storage Chip</data>
      <data key="d1">artifact</data>
      <data key="d2">A storage chip is a semiconductor device used in computer memory systems, available in types such as RAM and ROM, and is essential for storing data and instructions.&lt;SEP&gt;Storage chip is a memory component that requires chip selection and word selection for data read/write operations.</data>
      <data key="d3">chunk-a438ed247c5a79e72ee6372aba002ee0&lt;SEP&gt;chunk-946a56828431f2eb84c208ded0826aae</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468296</data>
    </node>
    <node id="Address Line">
      <data key="d0">Address Line</data>
      <data key="d1">concept</data>
      <data key="d2">The address line is a signal line used to specify the memory location or address of a data unit within a storage device or system.</data>
      <data key="d3">chunk-946a56828431f2eb84c208ded0826aae</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468219</data>
    </node>
    <node id="Data Line">
      <data key="d0">Data Line</data>
      <data key="d1">concept</data>
      <data key="d2">The data line is a signal line used for transmitting data between the CPU and memory components, with bit-width determining data transfer capacity.</data>
      <data key="d3">chunk-946a56828431f2eb84c208ded0826aae</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468219</data>
    </node>
    <node id="Read/Write Control Line">
      <data key="d0">Read/Write Control Line</data>
      <data key="d1">concept</data>
      <data key="d2">The read/write control line is a signal used to determine the direction of data transfer between the CPU and memory, enabling read or write operations.</data>
      <data key="d3">chunk-946a56828431f2eb84c208ded0826aae</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468219</data>
    </node>
    <node id="Chip Select Control Line">
      <data key="d0">Chip Select Control Line</data>
      <data key="d1">concept</data>
      <data key="d2">The chip select control line (CS) is a signal used to enable or disable a specific storage chip, allowing the CPU to select a particular chip during memory access.</data>
      <data key="d3">chunk-946a56828431f2eb84c208ded0826aae</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468219</data>
    </node>
    <node id="System Program">
      <data key="d0">System Program</data>
      <data key="d1">content</data>
      <data key="d2">System programs are low-level software routines stored in ROM for initializing and managing system functions.</data>
      <data key="d3">chunk-946a56828431f2eb84c208ded0826aae</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468219</data>
    </node>
    <node id="Standard Subroutine">
      <data key="d0">Standard Subroutine</data>
      <data key="d1">content</data>
      <data key="d2">Standard subroutines are reusable sets of instructions stored in ROM for common operations in computing systems.</data>
      <data key="d3">chunk-946a56828431f2eb84c208ded0826aae</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468219</data>
    </node>
    <node id="系统地址线">
      <data key="d0">系统地址线</data>
      <data key="d3">chunk-d6bddd3dfdc4b05e9f684acd41e40adb</data>
      <data key="d2">系统地址线higher bits are used in高位译码to generate individual chip select signals.</data>
      <data key="d1">UNKNOWN</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468221</data>
    </node>
    <node id="Constant Value">
      <data key="d0">Constant Value</data>
      <data key="d1">data</data>
      <data key="d2">Constant values are fixed data elements stored in ROM for use in program execution.</data>
      <data key="d3">chunk-946a56828431f2eb84c208ded0826aae</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468221</data>
    </node>
    <node id="Memory Expansion">
      <data key="d0">Memory Expansion</data>
      <data key="d1">concept</data>
      <data key="d2">Memory expansion refers to the process of increasing the total storage capacity of a system by adding additional storage chips.</data>
      <data key="d3">chunk-946a56828431f2eb84c208ded0826aae</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468222</data>
    </node>
    <node id="Chip Interior Logic">
      <data key="d0">Chip Interior Logic</data>
      <data key="d1">method</data>
      <data key="d2">Chip interior logic is the internal circuitry within a storage chip responsible for decoding address lines and selecting specific memory cells.</data>
      <data key="d3">chunk-946a56828431f2eb84c208ded0826aae</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468222</data>
    </node>
    <node id="External Decoder Logic">
      <data key="d0">External Decoder Logic</data>
      <data key="d1">method</data>
      <data key="d2">External decoder logic is a circuit external to storage chips used to decode high-order address lines for chip selection.</data>
      <data key="d3">chunk-946a56828431f2eb84c208ded0826aae</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468222</data>
    </node>
    <node id="Memory Access Request">
      <data key="d0">Memory Access Request</data>
      <data key="d1">concept</data>
      <data key="d2">A memory access request is a signal initiated by the CPU to read from or write to a memory location.</data>
      <data key="d3">chunk-946a56828431f2eb84c208ded0826aae</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468222</data>
    </node>
    <node id="MREQ">
      <data key="d0">MREQ</data>
      <data key="d1">artifact</data>
      <data key="d2">MREQ (Memory Request) is a control signal generated by the CPU indicating a request for memory access, typically active-low.</data>
      <data key="d3">chunk-946a56828431f2eb84c208ded0826aae</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468222</data>
    </node>
    <node id="MROM">
      <data key="d0">MROM</data>
      <data key="d1">artifact</data>
      <data key="d2">MROM is a type of ROM where data is permanently written during the semiconductor manufacturing process, making it unchangeable after production.</data>
      <data key="d3">chunk-364aa0dbd990ea22dbb324056cc5473e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468249</data>
    </node>
    <node id="PROM">
      <data key="d0">PROM</data>
      <data key="d1">artifact</data>
      <data key="d2">PROM is a type of ROM that allows a single programming session by the user using a programmer, after which the data cannot be altered.</data>
      <data key="d3">chunk-364aa0dbd990ea22dbb324056cc5473e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468249</data>
    </node>
    <node id="EPROM">
      <data key="d0">EPROM</data>
      <data key="d1">artifact</data>
      <data key="d2">EPROM is a type of ROM that can be programmed and erased multiple times using ultraviolet light, enabling revisions to stored data.</data>
      <data key="d3">chunk-364aa0dbd990ea22dbb324056cc5473e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468249</data>
    </node>
    <node id="Flash Memory">
      <data key="d0">Flash Memory</data>
      <data key="d1">artifact</data>
      <data key="d2">Flash Memory is a type of non-volatile memory derived from EPROM, capable of fast electric erasure and reprogramming without power.&lt;SEP&gt;Flash memory is the core storage component in SSDs with a limited number of program/erase cycles, typically ranging from hundreds to thousands.</data>
      <data key="d3">chunk-5b1903143e069742cd454a3ac6ea0d4a&lt;SEP&gt;chunk-364aa0dbd990ea22dbb324056cc5473e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468675</data>
    </node>
    <node id="SSD">
      <data key="d0">SSD</data>
      <data key="d1">artifact</data>
      <data key="d2">SSD, or Solid State Drive, is a storage device based on flash memory that uses a chip array for data storage and offers high-speed read/write operations.</data>
      <data key="d3">chunk-364aa0dbd990ea22dbb324056cc5473e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468249</data>
    </node>
    <node id="Semiconductor Manufacturing Process">
      <data key="d0">Semiconductor Manufacturing Process</data>
      <data key="d1">method</data>
      <data key="d2">The semiconductor manufacturing process is the production method used by vendors to embed data directly into MROM chips.</data>
      <data key="d3">chunk-364aa0dbd990ea22dbb324056cc5473e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468249</data>
    </node>
    <node id="Programming">
      <data key="d0">Programming</data>
      <data key="d1">method</data>
      <data key="d2">Programming is the process of writing data into PROM or EPROM using a specialized programmer device.</data>
      <data key="d3">chunk-364aa0dbd990ea22dbb324056cc5473e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468249</data>
    </node>
    <node id="Ultraviolet Erasure">
      <data key="d0">Ultraviolet Erasure</data>
      <data key="d1">method</data>
      <data key="d2">Ultraviolet erasure is a method used to erase data from EPROM by exposing the chip to UV light.</data>
      <data key="d3">chunk-364aa0dbd990ea22dbb324056cc5473e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468249</data>
    </node>
    <node id="Electric Erasure">
      <data key="d0">Electric Erasure</data>
      <data key="d1">method</data>
      <data key="d2">Electric erasure is the method used in Flash memory to erase and rewrite data electronically, without requiring UV light.</data>
      <data key="d3">chunk-364aa0dbd990ea22dbb324056cc5473e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468251</data>
    </node>
    <node id="Non-Volatile Storage">
      <data key="d0">Non-Volatile Storage</data>
      <data key="d1">concept</data>
      <data key="d2">Non-volatile storage refers to the ability of memory devices to retain data even when power is removed.</data>
      <data key="d3">chunk-364aa0dbd990ea22dbb324056cc5473e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468251</data>
    </node>
    <node id="Integration Density">
      <data key="d0">Integration Density</data>
      <data key="d1">concept</data>
      <data key="d2">Integration density describes the number of components or circuits packed into a given area of a semiconductor chip, influencing performance and cost.</data>
      <data key="d3">chunk-364aa0dbd990ea22dbb324056cc5473e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468251</data>
    </node>
    <node id="Write Speed">
      <data key="d0">Write Speed</data>
      <data key="d1">concept</data>
      <data key="d2">Write speed refers to the rate at which data can be written or rewritten onto a storage device, a factor affecting usability.</data>
      <data key="d3">chunk-364aa0dbd990ea22dbb324056cc5473e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468251</data>
    </node>
    <node id="Power Consumption">
      <data key="d0">Power Consumption</data>
      <data key="d1">concept</data>
      <data key="d2">Power consumption refers to the amount of electrical energy used by a device during operation, a key consideration in portable systems.</data>
      <data key="d3">chunk-364aa0dbd990ea22dbb324056cc5473e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468251</data>
    </node>
    <node id="Cost Efficiency">
      <data key="d0">Cost Efficiency</data>
      <data key="d1">concept</data>
      <data key="d2">Cost efficiency is a measure of how economical a technology is in terms of price relative to performance and capacity.</data>
      <data key="d3">chunk-364aa0dbd990ea22dbb324056cc5473e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468251</data>
    </node>
    <node id="Page">
      <data key="d0">Page</data>
      <data key="d1">artifact</data>
      <data key="d2">Page refers to a fixed-size block of memory used in virtual memory systems, which may reside in main memory or on disk.&lt;SEP&gt;A page is the smallest unit of data that can be read or written in flash memory, typically sized between 512B and 4KB.&lt;SEP&gt;A page is a fixed-size block of memory used in virtual memory management for transferring data between main memory and secondary storage.</data>
      <data key="d3">chunk-b5dba59d5f9377e5060b73fecdb0de06&lt;SEP&gt;chunk-8722d229424243d0f7b9869b271bb08f&lt;SEP&gt;chunk-6c698405c4fcc8fb19ebad83fe798b48</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468861</data>
    </node>
    <node id="Disk">
      <data key="d0">Disk</data>
      <data key="d1">artifact</data>
      <data key="d2">Disk refers to secondary storage, such as a hard drive or SSD, used for long-term data storage.&lt;SEP&gt;Disk is a mechanical storage device that stores data using magnetic surfaces, organized into tracks, surfaces, and sectors.</data>
      <data key="d3">chunk-59c3b987a075436eab7c271ca2d5302a&lt;SEP&gt;chunk-6c698405c4fcc8fb19ebad83fe798b48</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468936</data>
    </node>
    <node id="TLB Miss">
      <data key="d0">TLB Miss</data>
      <data key="d1">concept</data>
      <data key="d2">TLB miss occurs when the requested virtual page number is not found in the TLB, requiring a page table lookup.</data>
      <data key="d3">chunk-6c698405c4fcc8fb19ebad83fe798b48</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468264</data>
    </node>
    <node id="Page Miss">
      <data key="d0">Page Miss</data>
      <data key="d1">concept</data>
      <data key="d2">Page miss, or page fault, occurs when the requested page is not present in main memory, requiring loading from disk.</data>
      <data key="d3">chunk-6c698405c4fcc8fb19ebad83fe798b48</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468264</data>
    </node>
    <node id="Multilevel Storage System">
      <data key="d0">Multilevel Storage System</data>
      <data key="d1">concept</data>
      <data key="d2">Multilevel storage system refers to a hierarchy of storage mechanisms including TLB, Cache, main memory, and disk, designed to optimize access speed and capacity.</data>
      <data key="d3">chunk-6c698405c4fcc8fb19ebad83fe798b48</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468266</data>
    </node>
    <node id="Software">
      <data key="d0">Software</data>
      <data key="d1">artifact</data>
      <data key="d2">Software refers to programs and instructions, such as the operating system, that manage system resources and processes.</data>
      <data key="d3">chunk-6c698405c4fcc8fb19ebad83fe798b48</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468266</data>
    </node>
    <node id="Page Fault Handling">
      <data key="d0">Page Fault Handling</data>
      <data key="d1">method</data>
      <data key="d2">Page fault handling is a software-based process executed by the operating system when a page miss occurs, involving loading the page from disk.</data>
      <data key="d3">chunk-6c698405c4fcc8fb19ebad83fe798b48</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468266</data>
    </node>
    <node id="TLB Replacement">
      <data key="d0">TLB Replacement</data>
      <data key="d1">method</data>
      <data key="d2">TLB replacement refers to the algorithm or strategy used to manage TLB entries when a miss occurs, which can be handled by hardware or software.</data>
      <data key="d3">chunk-6c698405c4fcc8fb19ebad83fe798b48</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468266</data>
    </node>
    <node id="CPU Memory Access">
      <data key="d0">CPU Memory Access</data>
      <data key="d1">method</data>
      <data key="d2">CPU Memory Access refers to the process by which the CPU requests data from memory, potentially triggering TLB, Cache, and Page lookups.&lt;SEP&gt;CPU memory access refers to the process of retrieving data by the CPU, involving cache checking and main memory access if necessary.</data>
      <data key="d3">chunk-361185a50ecc6636f127fb6f6ad6eabd&lt;SEP&gt;chunk-6c698405c4fcc8fb19ebad83fe798b48</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468589</data>
    </node>
    <node id="Multi-Module Memory">
      <data key="d0">Multi-Module Memory</data>
      <data key="d1">concept</data>
      <data key="d2">Multi-module memory is a spatial parallel technology that enhances memory throughput by enabling parallel operation of multiple identical storage modules.</data>
      <data key="d3">chunk-8f87fc865b405b5892e67cab1873a773</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468275</data>
    </node>
    <node id="Single-Body Multi-Word Memory">
      <data key="d0">Single-Body Multi-Word Memory</data>
      <data key="d1">method</data>
      <data key="d2">Single-body multi-word memory stores m words per storage unit with a bus width of m words, allowing m words to be read in parallel in one access cycle.</data>
      <data key="d3">chunk-8f87fc865b405b5892e67cab1873a773</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468275</data>
    </node>
    <node id="Multi-Body Interleaved Memory">
      <data key="d0">Multi-Body Interleaved Memory</data>
      <data key="d1">method</data>
      <data key="d2">Multi-body interleaved memory consists of multiple storage modules with identical capacity and access speed, each having independent read/write control circuits, address registers, and data registers, enabling both parallel and interleaved operation.</data>
      <data key="d3">chunk-8f87fc865b405b5892e67cab1873a773</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468275</data>
    </node>
    <node id="Memory Throughput">
      <data key="d0">Memory Throughput</data>
      <data key="d1">concept</data>
      <data key="d2">Memory throughput refers to the rate at which data can be read from or written to memory, enhanced through parallel module operation.</data>
      <data key="d3">chunk-8f87fc865b405b5892e67cab1873a773</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468275</data>
    </node>
    <node id="Access Cycle">
      <data key="d0">Access Cycle</data>
      <data key="d1">concept</data>
      <data key="d2">An access cycle is the time required to complete one memory access operation, with instructions retrieved every 1/m of a cycle in single-body multi-word systems.&lt;SEP&gt;Access cycle is the minimum time interval required between two consecutive independent memory operations (read or write).</data>
      <data key="d3">chunk-3c1c3cb1cdfefa986a82277dd52e88ef&lt;SEP&gt;chunk-8f87fc865b405b5892e67cab1873a773</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468735</data>
    </node>
    <node id="Instruction Fetching">
      <data key="d0">Instruction Fetching</data>
      <data key="d1">concept</data>
      <data key="d2">Instruction fetching is the process of retrieving instructions from main memory to the CPU for execution.</data>
      <data key="d3">chunk-8f87fc865b405b5892e67cab1873a773</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468275</data>
    </node>
    <node id="Transfer Instruction">
      <data key="d0">Transfer Instruction</data>
      <data key="d1">concept</data>
      <data key="d2">A transfer instruction is a type of command that alters the flow of execution, potentially disrupting continuous data access.</data>
      <data key="d3">chunk-8f87fc865b405b5892e67cab1873a773</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468275</data>
    </node>
    <node id="Continuous Data Storage">
      <data key="d0">Continuous Data Storage</data>
      <data key="d1">concept</data>
      <data key="d2">Continuous data storage refers to the arrangement of data in consecutive memory locations, which is necessary for optimal performance in single-body multi-word systems.</data>
      <data key="d3">chunk-8f87fc865b405b5892e67cab1873a773</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468277</data>
    </node>
    <node id="Independent Read/Write Control Circuits">
      <data key="d0">Independent Read/Write Control Circuits</data>
      <data key="d1">artifact</data>
      <data key="d2">Independent read/write control circuits are components within each storage module enabling autonomous operation.</data>
      <data key="d3">chunk-8f87fc865b405b5892e67cab1873a773</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468277</data>
    </node>
    <node id="Address Register">
      <data key="d0">Address Register</data>
      <data key="d1">artifact</data>
      <data key="d2">An address register stores the memory address for the current read or write operation.</data>
      <data key="d3">chunk-8f87fc865b405b5892e67cab1873a773</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468277</data>
    </node>
    <node id="Data Register">
      <data key="d0">Data Register</data>
      <data key="d1">artifact</data>
      <data key="d2">A data register holds the data being transferred between the memory module and the CPU.</data>
      <data key="d3">chunk-8f87fc865b405b5892e67cab1873a773</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468277</data>
    </node>
    <node id="Multi-Body Parallel Memory">
      <data key="d0">Multi-Body Parallel Memory</data>
      <data key="d1">method</data>
      <data key="d2">Multi-body parallel memory is another term for multi-body interleaved memory, referring to a storage architecture where multiple modules operate in parallel to enhance performance.</data>
      <data key="d3">chunk-8f87fc865b405b5892e67cab1873a773</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468277</data>
    </node>
    <node id="Address Assignment">
      <data key="d0">Address Assignment</data>
      <data key="d1">concept</data>
      <data key="d2">Address assignment refers to the process of allocating specific addresses to memory cells for data access.</data>
      <data key="d3">chunk-a438ed247c5a79e72ee6372aba002ee0</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468296</data>
    </node>
    <node id="Chip Select">
      <data key="d0">Chip Select</data>
      <data key="d1">concept</data>
      <data key="d2">Chip select is the process of choosing a specific memory chip for data access.</data>
      <data key="d3">chunk-a438ed247c5a79e72ee6372aba002ee0</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468296</data>
    </node>
    <node id="Word Select">
      <data key="d0">Word Select</data>
      <data key="d1">concept</data>
      <data key="d2">Word select is the process of selecting a specific storage unit within a targeted memory chip.</data>
      <data key="d3">chunk-a438ed247c5a79e72ee6372aba002ee0</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468296</data>
    </node>
    <node id="N Bits of Low-Order Address Lines">
      <data key="d0">N Bits of Low-Order Address Lines</data>
      <data key="d1">artifact</data>
      <data key="d2">N bits of low-order address lines are used to perform word selection within a chip, with N determined by the chip’s internal memory capacity (2^N).</data>
      <data key="d3">chunk-a438ed247c5a79e72ee6372aba002ee0</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468296</data>
    </node>
    <node id="Line Selection Method">
      <data key="d0">Line Selection Method</data>
      <data key="d1">method</data>
      <data key="d2">Line selection method uses high-order address lines directly connected to the chip select pins; a "0" on a line selects the corresponding chip.</data>
      <data key="d3">chunk-a438ed247c5a79e72ee6372aba002ee0</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468296</data>
    </node>
    <node id="Decoder-Based Chip Selection">
      <data key="d0">Decoder-Based Chip Selection</data>
      <data key="d1">method</data>
      <data key="d2">Decoder-based chip selection uses an address decoder to generate chip select signals from high-order address lines.</data>
      <data key="d3">chunk-a438ed247c5a79e72ee6372aba002ee0</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468296</data>
    </node>
    <node id="High-Order Address Lines">
      <data key="d0">High-Order Address Lines</data>
      <data key="d1">artifact</data>
      <data key="d2">High-order address lines are used for chip selection and are not used for addressing within the chip.</data>
      <data key="d3">chunk-a438ed247c5a79e72ee6372aba002ee0</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468298</data>
    </node>
    <node id="Memory Capacity">
      <data key="d0">Memory Capacity</data>
      <data key="d1">concept</data>
      <data key="d2">Memory capacity is the amount of storage available within a chip, defined as 2^N.</data>
      <data key="d3">chunk-a438ed247c5a79e72ee6372aba002ee0</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468298</data>
    </node>
    <node id="Low Voltage Level">
      <data key="d0">Low Voltage Level</data>
      <data key="d1">concept</data>
      <data key="d2">Low voltage level is a signal state used in chip selection, typically indicating selection when set to "0".</data>
      <data key="d3">chunk-a438ed247c5a79e72ee6372aba002ee0</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468298</data>
    </node>
    <node id="2^N">
      <data key="d0">2^N</data>
      <data key="d1">concept</data>
      <data key="d2">2^N represents the internal memory capacity of a chip, calculated as two raised to the power of N, where N is the number of bits in the low-order address lines.</data>
      <data key="d3">chunk-a438ed247c5a79e72ee6372aba002ee0</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468298</data>
    </node>
    <node id="段式虚拟存储器">
      <data key="d0">段式虚拟存储器</data>
      <data key="d1">concept</data>
      <data key="d2">段式虚拟存储器是一种内存管理技术，根据程序的逻辑结构划分段，每个段的长度可变，通过段表实现虚拟地址到物理地址的转换。&lt;SEP&gt;段式虚拟存储器is a memory management scheme that divides memory into variable-sized segments based on logical units.</data>
      <data key="d3">chunk-0af5a7c8d38a4b5d1e4bac2d53e20424&lt;SEP&gt;chunk-87c0289dc1f88d2676624e47042c749f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468772</data>
    </node>
    <node id="段号">
      <data key="d0">段号</data>
      <data key="d1">data</data>
      <data key="d2">段号是虚拟地址的一部分，用于标识程序中的特定逻辑段。&lt;SEP&gt;段号是虚地址的一部分，用于查找对应的段表。</data>
      <data key="d3">chunk-a531a45f53700863615cfa8c40892f61&lt;SEP&gt;chunk-87c0289dc1f88d2676624e47042c749f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468490</data>
    </node>
    <node id="段内地址">
      <data key="d0">段内地址</data>
      <data key="d1">concept</data>
      <data key="d2">段内地址是虚拟地址的另一部分，表示段内的偏移量。</data>
      <data key="d3">chunk-87c0289dc1f88d2676624e47042c749f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468302</data>
    </node>
    <node id="段表">
      <data key="d0">段表</data>
      <data key="d1">data</data>
      <data key="d2">段表是记录程序逻辑段与主存中实际位置对应关系的表格，包含段号、装入位、段起点和段长等信息。&lt;SEP&gt;段表是每个程序对应的结构，用于存储各段的页表起始地址。</data>
      <data key="d3">chunk-a531a45f53700863615cfa8c40892f61&lt;SEP&gt;chunk-87c0289dc1f88d2676624e47042c749f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468489</data>
    </node>
    <node id="段表基地址">
      <data key="d0">段表基地址</data>
      <data key="d1">concept</data>
      <data key="d2">段表基地址是段表在主存中起始位置的地址，用于构建段表项的内存地址。</data>
      <data key="d3">chunk-87c0289dc1f88d2676624e47042c749f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468302</data>
    </node>
    <node id="装入位">
      <data key="d0">装入位</data>
      <data key="d1">concept</data>
      <data key="d2">装入位是段表中的一位标识，表示该段是否已调入主存(1表示已调入，0表示未调入)。&lt;SEP&gt;装入位is an alternative name for the valid bit, used to signify that a virtual page has been loaded into main memory.</data>
      <data key="d3">chunk-0af5a7c8d38a4b5d1e4bac2d53e20424&lt;SEP&gt;chunk-87c0289dc1f88d2676624e47042c749f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468768</data>
    </node>
    <node id="段起点">
      <data key="d0">段起点</data>
      <data key="d1">concept</data>
      <data key="d2">段起点是该段在主存中起始地址的值，用于计算物理地址。&lt;SEP&gt;段起点是程序中某一段的开始地址，必须对齐到某一页的起始位置，以保证页内寻址的正确性。</data>
      <data key="d3">chunk-a531a45f53700863615cfa8c40892f61&lt;SEP&gt;chunk-87c0289dc1f88d2676624e47042c749f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468492</data>
    </node>
    <node id="段长">
      <data key="d0">段长</data>
      <data key="d1">concept</data>
      <data key="d2">段长是该段在逻辑上的长度，用于边界检查和内存管理。&lt;SEP&gt;段长是程序中某一段的长度，必须是页长的整数倍，以确保段的起点位于某一页的起点。</data>
      <data key="d3">chunk-a531a45f53700863615cfa8c40892f61&lt;SEP&gt;chunk-87c0289dc1f88d2676624e47042c749f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468491</data>
    </node>
    <node id="虚拟地址">
      <data key="d0">虚拟地址</data>
      <data key="d1">data</data>
      <data key="d2">虚拟地址是程序运行时使用的逻辑地址，由段号和段内地址组成。&lt;SEP&gt;虚拟地址is a logical address generated by the CPU that must be translated to a physical address for memory access.</data>
      <data key="d3">chunk-0af5a7c8d38a4b5d1e4bac2d53e20424&lt;SEP&gt;chunk-87c0289dc1f88d2676624e47042c749f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468769</data>
    </node>
    <node id="主存">
      <data key="d0">主存</data>
      <data key="d1">location</data>
      <data key="d2">主存指计算机的物理内存，用于存放已调入的程序段。&lt;SEP&gt;主存refers to the main memory or RAM of a computer system where active data and instructions are stored.</data>
      <data key="d3">chunk-0af5a7c8d38a4b5d1e4bac2d53e20424&lt;SEP&gt;chunk-87c0289dc1f88d2676624e47042c749f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468768</data>
    </node>
    <node id="物理地址">
      <data key="d0">物理地址</data>
      <data key="d1">data</data>
      <data key="d2">物理地址是主存中的实际地址，由段起点与段内地址相加得到。&lt;SEP&gt;物理地址is the actual memory address in main memory corresponding to a virtual address.</data>
      <data key="d3">chunk-0af5a7c8d38a4b5d1e4bac2d53e20424&lt;SEP&gt;chunk-87c0289dc1f88d2676624e47042c749f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468771</data>
    </node>
    <node id="程序的逻辑结构">
      <data key="d0">程序的逻辑结构</data>
      <data key="d1">concept</data>
      <data key="d2">程序的逻辑结构指程序中按照功能划分的独立部分，是分段的依据。</data>
      <data key="d3">chunk-87c0289dc1f88d2676624e47042c749f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468304</data>
    </node>
    <node id="分段">
      <data key="d0">分段</data>
      <data key="d1">method</data>
      <data key="d2">分段是将程序按其逻辑结构划分为多个段的内存管理方法。</data>
      <data key="d3">chunk-87c0289dc1f88d2676624e47042c749f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468304</data>
    </node>
    <node id="分页">
      <data key="d0">分页</data>
      <data key="d1">method</data>
      <data key="d2">分页是将程序划分为固定大小页面的内存管理方法，对程序员透明。</data>
      <data key="d3">chunk-87c0289dc1f88d2676624e47042c749f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468304</data>
    </node>
    <node id="逻辑独立性">
      <data key="d0">逻辑独立性</data>
      <data key="d1">concept</data>
      <data key="d2">逻辑独立性指程序段在逻辑上可独立管理，便于编译、修改与共享。</data>
      <data key="d3">chunk-87c0289dc1f88d2676624e47042c749f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468304</data>
    </node>
    <node id="多道程序共享">
      <data key="d0">多道程序共享</data>
      <data key="d1">concept</data>
      <data key="d2">多道程序共享指多个程序的段可被系统高效共享，提升资源利用率。</data>
      <data key="d3">chunk-87c0289dc1f88d2676624e47042c749f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468304</data>
    </node>
    <node id="内存碎片">
      <data key="d0">内存碎片</data>
      <data key="d1">concept</data>
      <data key="d2">内存碎片是由于段长度可变导致在主存中段间出现无法利用的小内存区域，造成空间浪费。</data>
      <data key="d3">chunk-87c0289dc1f88d2676624e47042c749f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468305</data>
    </node>
    <node id="透明性">
      <data key="d0">透明性</data>
      <data key="d3">chunk-87c0289dc1f88d2676624e47042c749f</data>
      <data key="d2">分页对程序员透明，无需关心程序分页细节。</data>
      <data key="d1">UNKNOWN</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468309</data>
    </node>
    <node id="SRAM Chip">
      <data key="d0">SRAM Chip</data>
      <data key="d1">artifact</data>
      <data key="d2">SRAM Chip is a type of static random access memory used in cache memory close to the processor.</data>
      <data key="d3">chunk-84c8d12524cbd30a01b0da556f764478</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468324</data>
    </node>
    <node id="DRAM Chip">
      <data key="d0">DRAM Chip</data>
      <data key="d1">artifact</data>
      <data key="d2">DRAM Chip is a type of dynamic random access memory used in main memory.</data>
      <data key="d3">chunk-84c8d12524cbd30a01b0da556f764478</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468324</data>
    </node>
    <node id="Random Access Memory">
      <data key="d0">Random Access Memory</data>
      <data key="d1">artifact</data>
      <data key="d2">Random Access Memory is a category of volatile memory that allows data to be read and written in any order.&lt;SEP&gt;Random Access Memory (RAM) allows random access to any storage unit regardless of physical location, offering fast read/write capabilities; it is commonly used for main memory and cache.</data>
      <data key="d3">chunk-ce9d79eec3b8225be9c02cda24c5a519&lt;SEP&gt;chunk-84c8d12524cbd30a01b0da556f764478</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468446</data>
    </node>
    <node id="Read-Only Memory">
      <data key="d0">Read-Only Memory</data>
      <data key="d1">artifact</data>
      <data key="d2">Read-Only Memory is a category of non-volatile memory that stores data permanently.&lt;SEP&gt;Read-Only Memory (ROM) allows data to be read but not written; information stored remains intact even after power loss and is used for fixed programs, constants, and lookup tables.</data>
      <data key="d3">chunk-ce9d79eec3b8225be9c02cda24c5a519&lt;SEP&gt;chunk-84c8d12524cbd30a01b0da556f764478</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468447</data>
    </node>
    <node id="Static Random Access Memory">
      <data key="d0">Static Random Access Memory</data>
      <data key="d1">concept</data>
      <data key="d2">Static Random Access Memory is a type of volatile memory that retains data as long as power is supplied.</data>
      <data key="d3">chunk-84c8d12524cbd30a01b0da556f764478</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468324</data>
    </node>
    <node id="Dynamic Random Access Memory">
      <data key="d0">Dynamic Random Access Memory</data>
      <data key="d1">concept</data>
      <data key="d2">Dynamic Random Access Memory is a type of volatile memory that requires periodic refreshing to maintain stored data.</data>
      <data key="d3">chunk-84c8d12524cbd30a01b0da556f764478</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468324</data>
    </node>
    <node id="Volatile Memory">
      <data key="d0">Volatile Memory</data>
      <data key="d1">artifact</data>
      <data key="d2">Volatile Memory is a type of memory that loses stored data when power is turned off.&lt;SEP&gt;Volatile Memory loses stored data when power is removed; examples include RAM.</data>
      <data key="d3">chunk-ce9d79eec3b8225be9c02cda24c5a519&lt;SEP&gt;chunk-84c8d12524cbd30a01b0da556f764478</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468447</data>
    </node>
    <node id="Non-Volatile Memory">
      <data key="d0">Non-Volatile Memory</data>
      <data key="d1">artifact</data>
      <data key="d2">Non-Volatile Memory retains stored data even after power is turned off.&lt;SEP&gt;Non-Volatile Memory retains stored data even after power loss; examples include ROM, magnetic surface storage, and optical storage.</data>
      <data key="d3">chunk-ce9d79eec3b8225be9c02cda24c5a519&lt;SEP&gt;chunk-84c8d12524cbd30a01b0da556f764478</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468447</data>
    </node>
    <node id="Control Bus">
      <data key="d0">Control Bus</data>
      <data key="d1">artifact</data>
      <data key="d2">Control bus manages the flow of signals between the CPU and main memory, indicating read/write operations and timing of data transfers.</data>
      <data key="d3">chunk-f58beb694766dd43b7432ff7d16d2a65</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468347</data>
    </node>
    <node id="Memory Chip Extension Technology">
      <data key="d0">Memory Chip Extension Technology</data>
      <data key="d1">method</data>
      <data key="d2">Memory chip extension technology is a technique used to combine multiple memory chips into a single memory module to increase storage capacity.</data>
      <data key="d3">chunk-f58beb694766dd43b7432ff7d16d2a65</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468347</data>
    </node>
    <node id="Memory Module">
      <data key="d0">Memory Module</data>
      <data key="d1">artifact</data>
      <data key="d2">Memory module is a circuit board containing multiple memory chips, used to expand the main memory of a computer system.</data>
      <data key="d3">chunk-f58beb694766dd43b7432ff7d16d2a65</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468347</data>
    </node>
    <node id="ROM Chip">
      <data key="d0">ROM Chip</data>
      <data key="d1">artifact</data>
      <data key="d2">ROM chip is a type of non-volatile memory on the motherboard that stores firmware and system startup instructions.</data>
      <data key="d3">chunk-f58beb694766dd43b7432ff7d16d2a65</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468347</data>
    </node>
    <node id="Direct Mapping">
      <data key="d0">Direct Mapping</data>
      <data key="d1">method</data>
      <data key="d2">Direct Mapping is a cache mapping technique in which a block from main memory can be placed in only one specific cache line.&lt;SEP&gt;Direct mapping is a cache addressing method where each main memory block maps to exactly one cache line, determined by a modulo operation.</data>
      <data key="d3">chunk-361185a50ecc6636f127fb6f6ad6eabd&lt;SEP&gt;chunk-555f79801ef87ce95e52becac62479d6</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468587</data>
    </node>
    <node id="Random Algorithm">
      <data key="d0">Random Algorithm</data>
      <data key="d1">method</data>
      <data key="d2">Random Algorithm is a replacement strategy that randomly selects a cache line for replacement, without considering access patterns.</data>
      <data key="d3">chunk-555f79801ef87ce95e52becac62479d6</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468348</data>
    </node>
    <node id="FIFO Algorithm">
      <data key="d0">FIFO Algorithm</data>
      <data key="d1">method</data>
      <data key="d2">FIFO Algorithm is a replacement strategy that replaces the cache line that was loaded the earliest.</data>
      <data key="d3">chunk-555f79801ef87ce95e52becac62479d6</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468348</data>
    </node>
    <node id="Total Bus Connection">
      <data key="d0">Total Bus Connection</data>
      <data key="d1">concept</data>
      <data key="d2">Total bus connection refers to the combined interaction of data, address, and control buses linking the CPU with main memory.</data>
      <data key="d3">chunk-f58beb694766dd43b7432ff7d16d2a65</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468349</data>
    </node>
    <node id="Single Chip Capacity Limitation">
      <data key="d0">Single Chip Capacity Limitation</data>
      <data key="d1">concept</data>
      <data key="d2">Single chip capacity limitation refers to the inherent physical constraint of individual memory chips, which restricts the amount of data they can store and necessitates the use of chip expansion techniques.</data>
      <data key="d3">chunk-f58beb694766dd43b7432ff7d16d2a65</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468350</data>
    </node>
    <node id="LRU Algorithm">
      <data key="d0">LRU Algorithm</data>
      <data key="d1">method</data>
      <data key="d2">LRU Algorithm is a replacement strategy that replaces the cache line that has not been accessed for the longest period, based on the principle of locality.</data>
      <data key="d3">chunk-555f79801ef87ce95e52becac62479d6</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468350</data>
    </node>
    <node id="LFU Algorithm">
      <data key="d0">LFU Algorithm</data>
      <data key="d1">method</data>
      <data key="d2">LFU Algorithm is a replacement strategy that replaces the cache line with the lowest access frequency over a period of time.</data>
      <data key="d3">chunk-555f79801ef87ce95e52becac62479d6</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468350</data>
    </node>
    <node id="LRU Replacement Bit">
      <data key="d0">LRU Replacement Bit</data>
      <data key="d1">artifact</data>
      <data key="d2">LRU Replacement Bit is a counter associated with each cache line in an LRU algorithm to track access history and determine replacement.</data>
      <data key="d3">chunk-555f79801ef87ce95e52becac62479d6</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468351</data>
    </node>
    <node id="Counting Mechanism">
      <data key="d0">Counting Mechanism</data>
      <data key="d1">method</data>
      <data key="d2">Counting Mechanism is a method used in replacement algorithms to track access frequency or recency.</data>
      <data key="d3">chunk-555f79801ef87ce95e52becac62479d6</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468351</data>
    </node>
    <node id="Thrashing">
      <data key="d0">Thrashing</data>
      <data key="d1">concept</data>
      <data key="d2">Thrashing is a phenomenon in memory systems where excessive page swapping or cache replacements degrade performance due to high contention.</data>
      <data key="d3">chunk-555f79801ef87ce95e52becac62479d6</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468351</data>
    </node>
    <node id="Data Transfer Rate">
      <data key="d0">Data Transfer Rate</data>
      <data key="d3">chunk-3c1c3cb1cdfefa986a82277dd52e88ef&lt;SEP&gt;chunk-f58beb694766dd43b7432ff7d16d2a65</data>
      <data key="d2">The bit width and operating frequency of the data bus directly determine the data transfer rate.&lt;SEP&gt;Data transfer rate is the number of bits transferred per second, calculated as data width divided by access cycle time.</data>
      <data key="d1">concept</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468735</data>
    </node>
    <node id="Maximum Memory Space">
      <data key="d0">Maximum Memory Space</data>
      <data key="d3">chunk-f58beb694766dd43b7432ff7d16d2a65</data>
      <data key="d2">The number of bits in the address bus defines the maximum memory space that can be addressed.</data>
      <data key="d1">UNKNOWN</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468351</data>
    </node>
    <node id="Read/Write Operation">
      <data key="d0">Read/Write Operation</data>
      <data key="d3">chunk-f58beb694766dd43b7432ff7d16d2a65</data>
      <data key="d2">The control bus signals the type of operation and marks the completion of data input or output.</data>
      <data key="d1">UNKNOWN</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468351</data>
    </node>
    <node id="Cache Group">
      <data key="d0">Cache Group</data>
      <data key="d1">artifact</data>
      <data key="d2">Cache Group is a set of cache lines used in set-associative mapping, where a main memory block can be mapped to any line within the group.</data>
      <data key="d3">chunk-555f79801ef87ce95e52becac62479d6</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468352</data>
    </node>
    <node id="Main Memory Block">
      <data key="d0">Main Memory Block</data>
      <data key="d1">artifact</data>
      <data key="d2">A Main Memory Block is a unit of data transferred between main memory and cache during memory operations.</data>
      <data key="d3">chunk-555f79801ef87ce95e52becac62479d6</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468352</data>
    </node>
    <node id="Cache Line Replacement">
      <data key="d0">Cache Line Replacement</data>
      <data key="d1">concept</data>
      <data key="d2">Cache Line Replacement refers to the process of removing an existing cache line to make space for a new one when the cache is full.</data>
      <data key="d3">chunk-555f79801ef87ce95e52becac62479d6</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468352</data>
    </node>
    <node id="Count Value">
      <data key="d0">Count Value</data>
      <data key="d1">data</data>
      <data key="d2">Count Value is a numerical value that tracks usage frequency or recency in replacement algorithms.</data>
      <data key="d3">chunk-555f79801ef87ce95e52becac62479d6</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468353</data>
    </node>
    <node id="Storage Unit">
      <data key="d0">Storage Unit</data>
      <data key="d1">artifact</data>
      <data key="d2">A storage unit is composed of multiple storage cells sharing the same address code.</data>
      <data key="d3">chunk-7c2151344b39c51051c3dacc3290bcf9</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468378</data>
    </node>
    <node id="Storage Body">
      <data key="d0">Storage Body</data>
      <data key="d1">artifact</data>
      <data key="d2">A storage body is a collection of multiple storage units used in memory systems.</data>
      <data key="d3">chunk-7c2151344b39c51051c3dacc3290bcf9</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468378</data>
    </node>
    <node id="Bistable Trigger">
      <data key="d0">Bistable Trigger</data>
      <data key="d1">artifact</data>
      <data key="d2">A bistable trigger is a circuit with two stable states used to store binary information, commonly implemented using six MOS transistors in SRAM.</data>
      <data key="d3">chunk-7c2151344b39c51051c3dacc3290bcf9</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468378</data>
    </node>
    <node id="Six Transistor MOS">
      <data key="d0">Six Transistor MOS</data>
      <data key="d1">artifact</data>
      <data key="d2">Six transistor MOS is a circuit configuration used in SRAM to implement bistable triggers for data storage.</data>
      <data key="d3">chunk-7c2151344b39c51051c3dacc3290bcf9</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468378</data>
    </node>
    <node id="Non-Destructive Readout">
      <data key="d0">Non-Destructive Readout</data>
      <data key="d1">concept</data>
      <data key="d2">Non-destructive readout is a read operation where data remains unchanged after being read, enabling SRAM to retain its original state.&lt;SEP&gt;Non-Destructive Readout allows reading a memory cell without destroying its stored content, preserving data integrity during access.</data>
      <data key="d3">chunk-7c2151344b39c51051c3dacc3290bcf9&lt;SEP&gt;chunk-ce9d79eec3b8225be9c02cda24c5a519</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468449</data>
    </node>
    <node id="High Access Speed">
      <data key="d0">High Access Speed</data>
      <data key="d1">concept</data>
      <data key="d2">High access speed refers to the fast retrieval and storage of data, a key characteristic of SRAM.</data>
      <data key="d3">chunk-7c2151344b39c51051c3dacc3290bcf9</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468378</data>
    </node>
    <node id="Low Integration Density">
      <data key="d0">Low Integration Density</data>
      <data key="d1">concept</data>
      <data key="d2">Low integration density means SRAM has fewer memory cells per unit area, limiting its scalability.</data>
      <data key="d3">chunk-7c2151344b39c51051c3dacc3290bcf9</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468379</data>
    </node>
    <node id="High Power Consumption">
      <data key="d0">High Power Consumption</data>
      <data key="d1">concept</data>
      <data key="d2">High power consumption is a drawback of SRAM due to constant current flow in the bistable trigger circuit.</data>
      <data key="d3">chunk-7c2151344b39c51051c3dacc3290bcf9</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468380</data>
    </node>
    <node id="High Cost">
      <data key="d0">High Cost</data>
      <data key="d1">concept</data>
      <data key="d2">High cost is a result of low integration density and complex circuitry in SRAM.</data>
      <data key="d3">chunk-7c2151344b39c51051c3dacc3290bcf9</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468380</data>
    </node>
    <node id="Cache Memory">
      <data key="d0">Cache Memory</data>
      <data key="d1">artifact</data>
      <data key="d2">Cache memory is a high-speed memory used to store frequently accessed data, typically implemented using SRAM.&lt;SEP&gt;Cache Memory is located between the CPU and main memory, storing frequently used instructions and data to enable fast CPU access; it offers high-speed access matching CPU speed but has limited capacity and high price.</data>
      <data key="d3">chunk-7c2151344b39c51051c3dacc3290bcf9&lt;SEP&gt;chunk-ce9d79eec3b8225be9c02cda24c5a519</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468446</data>
    </node>
    <node id="Cache Block">
      <data key="d0">Cache Block</data>
      <data key="d1">artifact</data>
      <data key="d2">Cache Block, also known as Cache Line, is a unit of data transfer between Cache and Main Memory, consisting of multiple bytes.</data>
      <data key="d3">chunk-e0a87778cef25aba2903a8a3e12c5faa</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468391</data>
    </node>
    <node id="Block Length">
      <data key="d0">Block Length</data>
      <data key="d1">concept</data>
      <data key="d2">Block Length, also known as Line Length, is the size of a Cache Block in bytes.</data>
      <data key="d3">chunk-e0a87778cef25aba2903a8a3e12c5faa</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468391</data>
    </node>
    <node id="Cache Capacity">
      <data key="d0">Cache Capacity</data>
      <data key="d1">concept</data>
      <data key="d2">Cache Capacity refers to the total amount of data that the Cache can hold, which is significantly smaller than Main Memory capacity.</data>
      <data key="d3">chunk-e0a87778cef25aba2903a8a3e12c5faa</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468391</data>
    </node>
    <node id="Main Memory Capacity">
      <data key="d0">Main Memory Capacity</data>
      <data key="d1">concept</data>
      <data key="d2">Main Memory Capacity is the total storage size of the primary memory, which is much larger than Cache capacity.</data>
      <data key="d3">chunk-e0a87778cef25aba2903a8a3e12c5faa</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468391</data>
    </node>
    <node id="Cache Hit">
      <data key="d0">Cache Hit</data>
      <data key="d1">concept</data>
      <data key="d2">Cache Hit occurs when the requested data is found in the Cache, allowing direct access without accessing Main Memory.</data>
      <data key="d3">chunk-e0a87778cef25aba2903a8a3e12c5faa</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468391</data>
    </node>
    <node id="Write Policy">
      <data key="d0">Write Policy</data>
      <data key="d1">method</data>
      <data key="d2">Write Policy defines how updates to data in the Cache are handled, with common methods being Write-Through and Write-Back.</data>
      <data key="d3">chunk-e0a87778cef25aba2903a8a3e12c5faa</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468392</data>
    </node>
    <node id="Write-Through">
      <data key="d0">Write-Through</data>
      <data key="d1">method</data>
      <data key="d2">Write-Through is a write policy where data is written simultaneously to both Cache and Main Memory.</data>
      <data key="d3">chunk-e0a87778cef25aba2903a8a3e12c5faa</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468392</data>
    </node>
    <node id="Write-Back">
      <data key="d0">Write-Back</data>
      <data key="d1">method</data>
      <data key="d2">Write-Back is a write policy where data is written only to Cache initially, and written back to Main Memory later when the block is replaced.&lt;SEP&gt;Write-back is a technique used in virtual memory systems to delay writing modified data to secondary storage until necessary, improving performance.</data>
      <data key="d3">chunk-b5dba59d5f9377e5060b73fecdb0de06&lt;SEP&gt;chunk-e0a87778cef25aba2903a8a3e12c5faa</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468861</data>
    </node>
    <node id="Hardware Implementation">
      <data key="d0">Hardware Implementation</data>
      <data key="d1">concept</data>
      <data key="d2">Hardware Implementation refers to the fact that all Cache operations are managed by dedicated hardware.</data>
      <data key="d3">chunk-e0a87778cef25aba2903a8a3e12c5faa</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468392</data>
    </node>
    <node id="Data Transfer Unit">
      <data key="d0">Data Transfer Unit</data>
      <data key="d1">concept</data>
      <data key="d2">Data Transfer Unit is the size of data transferred between components: bytes between CPU and Cache, and Cache Blocks between Cache and Main Memory.</data>
      <data key="d3">chunk-e0a87778cef25aba2903a8a3e12c5faa</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468392</data>
    </node>
    <node id="Solid State Drive">
      <data key="d0">Solid State Drive</data>
      <data key="d1">artifact</data>
      <data key="d2">A Solid State Drive (SSD) is a storage device based on flash memory technology, featuring high performance, no moving parts, and improved reliability compared to traditional hard drives.&lt;SEP&gt;Solid State Drive (SSD) is a storage device that uses flash memory and has a limited write/erase endurance.</data>
      <data key="d3">chunk-5b1903143e069742cd454a3ac6ea0d4a&lt;SEP&gt;chunk-8722d229424243d0f7b9869b271bb08f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468675</data>
    </node>
    <node id="Flash Memory Chip">
      <data key="d0">Flash Memory Chip</data>
      <data key="d1">artifact</data>
      <data key="d2">A flash memory chip is a core component of an SSD, used for storing data and replacing mechanical drive components found in traditional hard disks.</data>
      <data key="d3">chunk-8722d229424243d0f7b9869b271bb08f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468407</data>
    </node>
    <node id="Flash Translation Layer">
      <data key="d0">Flash Translation Layer</data>
      <data key="d1">artifact</data>
      <data key="d2">The flash translation layer translates logical block read/write requests from the CPU into physical read/write signals for the flash memory, acting as a substitute for the disk controller.</data>
      <data key="d3">chunk-8722d229424243d0f7b9869b271bb08f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468407</data>
    </node>
    <node id="Block">
      <data key="d0">Block</data>
      <data key="d1">artifact</data>
      <data key="d2">A block is a unit of memory in flash memory that consists of multiple pages and is used for data erasure operations in SSDs.&lt;SEP&gt;Block is a segment of data in main memory that is mapped to a cache line.</data>
      <data key="d3">chunk-361185a50ecc6636f127fb6f6ad6eabd&lt;SEP&gt;chunk-8722d229424243d0f7b9869b271bb08f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468587</data>
    </node>
    <node id="Data Erasure">
      <data key="d0">Data Erasure</data>
      <data key="d1">concept</data>
      <data key="d2">Data erasure in SSDs is performed at the block level and requires the entire block to be erased before new data can be written.</data>
      <data key="d3">chunk-8722d229424243d0f7b9869b271bb08f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468407</data>
    </node>
    <node id="Random Write Operation">
      <data key="d0">Random Write Operation</data>
      <data key="d1">concept</data>
      <data key="d2">A random write operation in SSDs is slow due to the need to copy valid data from a block to a new block before rewriting, which involves block-level erasure and page migration.</data>
      <data key="d3">chunk-8722d229424243d0f7b9869b271bb08f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468407</data>
    </node>
    <node id="Mechanical Hard Disk">
      <data key="d0">Mechanical Hard Disk</data>
      <data key="d1">artifact</data>
      <data key="d2">A mechanical hard disk uses spinning platters and moving read/write heads, in contrast to the solid-state nature of SSDs.</data>
      <data key="d3">chunk-8722d229424243d0f7b9869b271bb08f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468407</data>
    </node>
    <node id="Flash Memory Technology">
      <data key="d0">Flash Memory Technology</data>
      <data key="d1">method</data>
      <data key="d2">Flash memory technology enables non-volatile data storage and is the foundation of SSD operation, allowing data retention without power.</data>
      <data key="d3">chunk-8722d229424243d0f7b9869b271bb08f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468408</data>
    </node>
    <node id="Ssd Performance">
      <data key="d0">Ssd Performance</data>
      <data key="d1">concept</data>
      <data key="d2">SSD performance includes fast random access times, low latency, and high data throughput due to the absence of moving parts.</data>
      <data key="d3">chunk-8722d229424243d0f7b9869b271bb08f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468408</data>
    </node>
    <node id="Energy Efficiency">
      <data key="d0">Energy Efficiency</data>
      <data key="d1">concept</data>
      <data key="d2">Energy efficiency in SSDs results from the lack of mechanical components, reducing power consumption compared to traditional hard drives.</data>
      <data key="d3">chunk-8722d229424243d0f7b9869b271bb08f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468408</data>
    </node>
    <node id="Vibration Resistance">
      <data key="d0">Vibration Resistance</data>
      <data key="d1">concept</data>
      <data key="d2">Vibration resistance is a characteristic of SSDs due to their solid-state design, making them less susceptible to physical damage from shocks.</data>
      <data key="d3">chunk-8722d229424243d0f7b9869b271bb08f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468408</data>
    </node>
    <node id="Data Security">
      <data key="d0">Data Security</data>
      <data key="d1">concept</data>
      <data key="d2">Data security is enhanced in SSDs because they have no moving components and are less prone to mechanical failure.&lt;SEP&gt;Data security refers to the protection of data from loss or corruption, enhanced by redundancy and parity in RAID.</data>
      <data key="d3">chunk-8722d229424243d0f7b9869b271bb08f&lt;SEP&gt;chunk-f75d6db24d56fe7631645ee707b4ca7f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468552</data>
    </node>
    <node id="Price Trend">
      <data key="d0">Price Trend</data>
      <data key="d1">data</data>
      <data key="d2">The price trend of SSDs shows a continual decline with technological advancement, making them more accessible over time.</data>
      <data key="d3">chunk-8722d229424243d0f7b9869b271bb08f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468408</data>
    </node>
    <node id="Mechanical Hard Disk Controller">
      <data key="d0">Mechanical Hard Disk Controller</data>
      <data key="d3">chunk-8722d229424243d0f7b9869b271bb08f</data>
      <data key="d2">The flash translation layer performs the role of a disk controller in traditional hard disks by managing data access requests.</data>
      <data key="d1">UNKNOWN</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468411</data>
    </node>
    <node id="多体并行存储器">
      <data key="d0">多体并行存储器</data>
      <data key="d1">concept</data>
      <data key="d2">Multi-body parallel memory is a type of memory system divided into multiple modules for improved data access efficiency, with two main addressing methods: high-order interleaving and low-order interleaving.</data>
      <data key="d3">chunk-b013853f3a4a507351aa3af1ef0f6cfb</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468427</data>
    </node>
    <node id="高位交叉编址">
      <data key="d0">高位交叉编址</data>
      <data key="d1">method</data>
      <data key="d2">High-order interleaving is an addressing method where high-order bits represent module numbers and low-order bits represent addresses within a module, resulting in sequential access and no parallelism.</data>
      <data key="d3">chunk-b013853f3a4a507351aa3af1ef0f6cfb</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468427</data>
    </node>
    <node id="低位交叉编址">
      <data key="d0">低位交叉编址</data>
      <data key="d1">method</data>
      <data key="d2">Low-order interleaving is an addressing method where low-order bits represent module numbers and high-order bits represent addresses within a module, enabling cross-module access and improved throughput.</data>
      <data key="d3">chunk-b013853f3a4a507351aa3af1ef0f6cfb</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468427</data>
    </node>
    <node id="模块号">
      <data key="d0">模块号</data>
      <data key="d1">concept</data>
      <data key="d2">Module number refers to the identifier used to select a specific memory module based on address bits.</data>
      <data key="d3">chunk-b013853f3a4a507351aa3af1ef0f6cfb</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468427</data>
    </node>
    <node id="体内地址">
      <data key="d0">体内地址</data>
      <data key="d1">concept</data>
      <data key="d2">Within-module address is the address of a data location inside a memory module.</data>
      <data key="d3">chunk-b013853f3a4a507351aa3af1ef0f6cfb</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468427</data>
    </node>
    <node id="顺序方式">
      <data key="d0">顺序方式</data>
      <data key="d1">method</data>
      <data key="d2">Sequential access method involves accessing memory modules one after another, with no overlapping operations.</data>
      <data key="d3">chunk-b013853f3a4a507351aa3af1ef0f6cfb</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468427</data>
    </node>
    <node id="交叉方式">
      <data key="d0">交叉方式</data>
      <data key="d1">method</data>
      <data key="d2">Interleaved access method allows continuous data placement across modules and enables parallel or overlapping operations for improved performance.</data>
      <data key="d3">chunk-b013853f3a4a507351aa3af1ef0f6cfb</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468427</data>
    </node>
    <node id="模块内地址">
      <data key="d0">模块内地址</data>
      <data key="d1">concept</data>
      <data key="d2">Module internal address refers to the address within a specific memory module.</data>
      <data key="d3">chunk-b013853f3a4a507351aa3af1ef0f6cfb</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468427</data>
    </node>
    <node id="数据总线位数">
      <data key="d0">数据总线位数</data>
      <data key="d1">concept</data>
      <data key="d2">Data bus width indicates the number of bits transferred in parallel during a single data operation.</data>
      <data key="d3">chunk-b013853f3a4a507351aa3af1ef0f6cfb</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468429</data>
    </node>
    <node id="存取周期">
      <data key="d0">存取周期</data>
      <data key="d1">concept</data>
      <data key="d2">Access cycle is the time required for a memory module to complete one read or write operation.</data>
      <data key="d3">chunk-b013853f3a4a507351aa3af1ef0f6cfb</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468429</data>
    </node>
    <node id="总线周期">
      <data key="d0">总线周期</data>
      <data key="d1">concept</data>
      <data key="d2">Bus cycle is the time interval between successive bus operations.</data>
      <data key="d3">chunk-b013853f3a4a507351aa3af1ef0f6cfb</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468429</data>
    </node>
    <node id="轮流启动方式">
      <data key="d0">轮流启动方式</data>
      <data key="d1">method</data>
      <data key="d2">Round-robin initiation method allows modules to be accessed in sequence with fixed intervals to avoid conflicts, enabling pipelined access.</data>
      <data key="d3">chunk-b013853f3a4a507351aa3af1ef0f6cfb</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468429</data>
    </node>
    <node id="同时启动方式">
      <data key="d0">同时启动方式</data>
      <data key="d1">method</data>
      <data key="d2">Simultaneous initiation method enables all memory modules to be accessed in parallel at the same time, utilizing full data bus width.</data>
      <data key="d3">chunk-b013853f3a4a507351aa3af1ef0f6cfb</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468429</data>
    </node>
    <node id="访存冲突">
      <data key="d0">访存冲突</data>
      <data key="d1">concept</data>
      <data key="d2">Memory access conflict occurs when multiple consecutive accesses target the same memory module, causing delays.</data>
      <data key="d3">chunk-b013853f3a4a507351aa3af1ef0f6cfb</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468429</data>
    </node>
    <node id="m体交叉存储器">
      <data key="d0">m体交叉存储器</data>
      <data key="d1">concept</data>
      <data key="d2">M-body interleaved memory is a system with m memory modules arranged in a way that supports parallel access and increased throughput.</data>
      <data key="d3">chunk-b013853f3a4a507351aa3af1ef0f6cfb</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468429</data>
    </node>
    <node id="模块数">
      <data key="d0">模块数</data>
      <data key="d1">concept</data>
      <data key="d2">Module count refers to the number of memory modules in a multi-body parallel memory system, which determines the degree of parallelism and must satisfy timing constraints for correct operation.</data>
      <data key="d3">chunk-b013853f3a4a507351aa3af1ef0f6cfb</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468429</data>
    </node>
    <node id="数据总线">
      <data key="d0">数据总线</data>
      <data key="d1">artifact</data>
      <data key="d2">Data bus is the physical or logical pathway used to transfer data between components, with a fixed width that determines the amount of data transferred in parallel.</data>
      <data key="d3">chunk-b013853f3a4a507351aa3af1ef0f6cfb</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468430</data>
    </node>
    <node id="总时间">
      <data key="d0">总时间</data>
      <data key="d1">concept</data>
      <data key="d2">Total time refers to the time required to access m consecutive words in an interleaved memory system, calculated as T + (m−1)r.</data>
      <data key="d3">chunk-b013853f3a4a507351aa3af1ef0f6cfb</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468430</data>
    </node>
    <node id="启动间隔">
      <data key="d0">启动间隔</data>
      <data key="d1">concept</data>
      <data key="d2">Startup interval is the time between initiating access to the same module, which must be at least m×r to prevent access conflicts.</data>
      <data key="d3">chunk-b013853f3a4a507351aa3af1ef0f6cfb</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468430</data>
    </node>
    <node id="Auxiliary Memory">
      <data key="d0">Auxiliary Memory</data>
      <data key="d1">artifact</data>
      <data key="d2">Auxiliary Memory, also called secondary memory or external memory, stores data and programs not currently in use and information requiring permanent storage; it has large capacity, slower access speed, and lower cost per unit.</data>
      <data key="d3">chunk-ce9d79eec3b8225be9c02cda24c5a519</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468446</data>
    </node>
    <node id="Magnetic Surface Storage">
      <data key="d0">Magnetic Surface Storage</data>
      <data key="d1">artifact</data>
      <data key="d2">Magnetic Surface Storage includes magnetic disks and tapes, using magnetic media to store data.</data>
      <data key="d3">chunk-ce9d79eec3b8225be9c02cda24c5a519</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468446</data>
    </node>
    <node id="Magnetic Core Memory">
      <data key="d0">Magnetic Core Memory</data>
      <data key="d1">artifact</data>
      <data key="d2">Magnetic Core Memory is an early type of memory that uses magnetic cores to store data.</data>
      <data key="d3">chunk-ce9d79eec3b8225be9c02cda24c5a519</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468446</data>
    </node>
    <node id="Semiconductor Memory">
      <data key="d0">Semiconductor Memory</data>
      <data key="d1">artifact</data>
      <data key="d2">Semiconductor Memory includes MOS-type and bipolar-type memory, fabricated using semiconductor materials for data storage.</data>
      <data key="d3">chunk-ce9d79eec3b8225be9c02cda24c5a519</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468446</data>
    </node>
    <node id="Optical Storage">
      <data key="d0">Optical Storage</data>
      <data key="d1">artifact</data>
      <data key="d2">Optical Storage refers to memory using optical discs for data storage, such as CD and DVD.</data>
      <data key="d3">chunk-ce9d79eec3b8225be9c02cda24c5a519</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468446</data>
    </node>
    <node id="Static RAM">
      <data key="d0">Static RAM</data>
      <data key="d1">artifact</data>
      <data key="d2">Static RAM is a type of RAM that maintains data as long as power is supplied and does not require refreshing.</data>
      <data key="d3">chunk-ce9d79eec3b8225be9c02cda24c5a519</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468447</data>
    </node>
    <node id="Dynamic RAM">
      <data key="d0">Dynamic RAM</data>
      <data key="d1">artifact</data>
      <data key="d2">Dynamic RAM is a type of RAM that must be periodically refreshed to maintain stored data and is more space-efficient than static RAM.</data>
      <data key="d3">chunk-ce9d79eec3b8225be9c02cda24c5a519</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468447</data>
    </node>
    <node id="Serial Access Storage">
      <data key="d0">Serial Access Storage</data>
      <data key="d1">artifact</data>
      <data key="d2">Serial Access Storage requires data to be accessed in a sequential or predetermined physical order, including sequential and direct access types such as magnetic tape and disk.</data>
      <data key="d3">chunk-ce9d79eec3b8225be9c02cda24c5a519</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468447</data>
    </node>
    <node id="Sequential Access Storage">
      <data key="d0">Sequential Access Storage</data>
      <data key="d1">artifact</data>
      <data key="d2">Sequential Access Storage allows data access only in a deterministic physical order, with access times dependent on location; it is slow and used for large data archives.</data>
      <data key="d3">chunk-ce9d79eec3b8225be9c02cda24c5a519</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468447</data>
    </node>
    <node id="Direct Access Storage">
      <data key="d0">Direct Access Storage</data>
      <data key="d1">artifact</data>
      <data key="d2">Direct Access Storage enables access to specific data locations by first finding a general region (e.g., disk track) and then searching within it, combining features of sequential and random access.</data>
      <data key="d3">chunk-ce9d79eec3b8225be9c02cda24c5a519</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468447</data>
    </node>
    <node id="Memory System">
      <data key="d0">Memory System</data>
      <data key="d3">chunk-ce9d79eec3b8225be9c02cda24c5a519</data>
      <data key="d2">Destructive readout necessitates regeneration after reading, requiring immediate refresh to maintain data integrity.</data>
      <data key="d1">UNKNOWN</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468451</data>
    </node>
    <node id="Cache Consistency Problem">
      <data key="d0">Cache Consistency Problem</data>
      <data key="d1">concept</data>
      <data key="d2">The Cache consistency problem arises because Cache content is a copy of main memory blocks, requiring strategies to maintain data synchronization when Cache is updated.</data>
      <data key="d3">chunk-cef942e7cbaeb916484eb8b3e7bcbd9a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468472</data>
    </node>
    <node id="Write Hit">
      <data key="d0">Write Hit</data>
      <data key="d1">concept</data>
      <data key="d2">Write Hit occurs when a write operation targets a Cache block that is already present, triggering specific write strategies to maintain consistency between Cache and main memory.</data>
      <data key="d3">chunk-cef942e7cbaeb916484eb8b3e7bcbd9a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468472</data>
    </node>
    <node id="Write Through">
      <data key="d0">Write Through</data>
      <data key="d1">method</data>
      <data key="d2">Write Through, also known as Write-Through, is a write strategy where data is written simultaneously to Cache and main memory upon a write hit.</data>
      <data key="d3">chunk-cef942e7cbaeb916484eb8b3e7bcbd9a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468472</data>
    </node>
    <node id="Write Back">
      <data key="d0">Write Back</data>
      <data key="d1">method</data>
      <data key="d2">Write Back is a write strategy where data is written only to Cache on a write hit, and main memory is updated only when the block is replaced.</data>
      <data key="d3">chunk-cef942e7cbaeb916484eb8b3e7bcbd9a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468472</data>
    </node>
    <node id="Write Buffer">
      <data key="d0">Write Buffer</data>
      <data key="d1">artifact</data>
      <data key="d2">A Write Buffer is a FIFO queue placed between Cache and main memory to reduce the latency of direct main memory writes in Write Through mode.</data>
      <data key="d3">chunk-cef942e7cbaeb916484eb8b3e7bcbd9a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468472</data>
    </node>
    <node id="Dirty Bit">
      <data key="d0">Dirty Bit</data>
      <data key="d1">artifact</data>
      <data key="d2">A Dirty Bit is a flag in each Cache line indicating whether the corresponding block has been modified and needs to be written back to main memory upon replacement.</data>
      <data key="d3">chunk-cef942e7cbaeb916484eb8b3e7bcbd9a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468472</data>
    </node>
    <node id="Write Allocate">
      <data key="d0">Write Allocate</data>
      <data key="d1">method</data>
      <data key="d2">Write Allocate, also known as Write Allocation, is a strategy where a miss in a write operation loads the corresponding block into Cache before performing the write.</data>
      <data key="d3">chunk-cef942e7cbaeb916484eb8b3e7bcbd9a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468472</data>
    </node>
    <node id="Not-Write-Allocate">
      <data key="d0">Not-Write-Allocate</data>
      <data key="d1">method</data>
      <data key="d2">Not-Write-Allocate is a strategy where a write miss updates main memory only without loading the block into Cache.</data>
      <data key="d3">chunk-cef942e7cbaeb916484eb8b3e7bcbd9a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468472</data>
    </node>
    <node id="Separate Cache Structure">
      <data key="d0">Separate Cache Structure</data>
      <data key="d1">method</data>
      <data key="d2">Separate Cache Structure refers to the design of independent instruction and data caches to avoid resource conflicts and improve performance.</data>
      <data key="d3">chunk-cef942e7cbaeb916484eb8b3e7bcbd9a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468474</data>
    </node>
    <node id="L1 Cache">
      <data key="d0">L1 Cache</data>
      <data key="d1">artifact</data>
      <data key="d2">L1 Cache is the first-level cache closest to the CPU, offering the fastest access speed but limited capacity.</data>
      <data key="d3">chunk-cef942e7cbaeb916484eb8b3e7bcbd9a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468474</data>
    </node>
    <node id="L2 Cache">
      <data key="d0">L2 Cache</data>
      <data key="d1">artifact</data>
      <data key="d2">L2 Cache is the second-level cache, further from the CPU than L1 Cache, with slower access speed but larger capacity.</data>
      <data key="d3">chunk-cef942e7cbaeb916484eb8b3e7bcbd9a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468474</data>
    </node>
    <node id="Instruction Cache">
      <data key="d0">Instruction Cache</data>
      <data key="d1">artifact</data>
      <data key="d2">Instruction Cache is a dedicated cache for storing frequently accessed instructions to improve instruction fetch efficiency.</data>
      <data key="d3">chunk-cef942e7cbaeb916484eb8b3e7bcbd9a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468474</data>
    </node>
    <node id="Data Cache">
      <data key="d0">Data Cache</data>
      <data key="d1">artifact</data>
      <data key="d2">Data Cache is a dedicated cache for storing frequently accessed data to speed up data read and write operations.</data>
      <data key="d3">chunk-cef942e7cbaeb916484eb8b3e7bcbd9a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468474</data>
    </node>
    <node id="Cache Write Strategy">
      <data key="d0">Cache Write Strategy</data>
      <data key="d1">concept</data>
      <data key="d2">Cache Write Strategy refers to the decision-making process for handling write operations based on hit/miss conditions and system design.</data>
      <data key="d3">chunk-cef942e7cbaeb916484eb8b3e7bcbd9a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468474</data>
    </node>
    <node id="Memory Access Conflict">
      <data key="d0">Memory Access Conflict</data>
      <data key="d1">concept</data>
      <data key="d2">Memory Access Conflict arises in unified Cache systems when instruction fetch and data access compete for the same Cache resources.</data>
      <data key="d3">chunk-cef942e7cbaeb916484eb8b3e7bcbd9a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468474</data>
    </node>
    <node id="Performance Optimization">
      <data key="d0">Performance Optimization</data>
      <data key="d1">concept</data>
      <data key="d2">Performance Optimization in caching involves leveraging architectural features like separate caches and multi-level hierarchies to improve system efficiency.</data>
      <data key="d3">chunk-cef942e7cbaeb916484eb8b3e7bcbd9a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468475</data>
    </node>
    <node id="段页式虚拟存储器">
      <data key="d0">段页式虚拟存储器</data>
      <data key="d1">concept</data>
      <data key="d2">段页式虚拟存储器是一种内存管理技术，结合了页式和段式虚拟存储器的优点，将程序按逻辑段划分，每段再分为固定大小的页，主存空间也划分为相同大小的页，以页为基本交换单位。</data>
      <data key="d3">chunk-a531a45f53700863615cfa8c40892f61</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468489</data>
    </node>
    <node id="程序">
      <data key="d0">程序</data>
      <data key="d1">content</data>
      <data key="d2">程序是逻辑上分段的实体，包含多个段，每个段被划分为固定大小的页。</data>
      <data key="d3">chunk-a531a45f53700863615cfa8c40892f61</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468489</data>
    </node>
    <node id="页表">
      <data key="d0">页表</data>
      <data key="d1">artifact</data>
      <data key="d2">页表是每段对应的结构，记录该段页与主存实页之间的映射关系。&lt;SEP&gt;页表is a data structure used in virtual memory management to map virtual pages to physical pages, containing status bits like valid bit, dirty bit, and reference bit.</data>
      <data key="d3">chunk-0af5a7c8d38a4b5d1e4bac2d53e20424&lt;SEP&gt;chunk-a531a45f53700863615cfa8c40892f61</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468768</data>
    </node>
    <node id="主存空间">
      <data key="d0">主存空间</data>
      <data key="d1">artifact</data>
      <data key="d2">主存空间被划分为大小相等的页，用于存储程序的页，是虚拟存储器的物理基础。</data>
      <data key="d3">chunk-a531a45f53700863615cfa8c40892f61</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468489</data>
    </node>
    <node id="页">
      <data key="d0">页</data>
      <data key="d1">artifact</data>
      <data key="d2">页是固定大小的存储单位，程序和主存空间均按页划分，是调入调出的基本单位。</data>
      <data key="d3">chunk-a531a45f53700863615cfa8c40892f61</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468489</data>
    </node>
    <node id="虚地址">
      <data key="d0">虚地址</data>
      <data key="d1">data</data>
      <data key="d2">虚地址由段号、段内页号和页内地址三部分组成，用于访问虚拟内存。</data>
      <data key="d3">chunk-a531a45f53700863615cfa8c40892f61</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468489</data>
    </node>
    <node id="实地址">
      <data key="d0">实地址</data>
      <data key="d1">data</data>
      <data key="d2">实地址是主存中的物理地址，由页表中取出的实页号与页内地址拼接形成。</data>
      <data key="d3">chunk-a531a45f53700863615cfa8c40892f61</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468489</data>
    </node>
    <node id="段内页号">
      <data key="d0">段内页号</data>
      <data key="d1">data</data>
      <data key="d2">段内页号是虚地址的一部分，与页表起始地址结合生成页表地址。</data>
      <data key="d3">chunk-a531a45f53700863615cfa8c40892f61</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468491</data>
    </node>
    <node id="页内地址">
      <data key="d0">页内地址</data>
      <data key="d1">data</data>
      <data key="d2">页内地址是虚地址的一部分，用于定位页内具体位置。</data>
      <data key="d3">chunk-a531a45f53700863615cfa8c40892f61</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468491</data>
    </node>
    <node id="地址变换过程">
      <data key="d0">地址变换过程</data>
      <data key="d1">method</data>
      <data key="d2">地址变换过程是CPU根据虚地址访问内存时，通过段表和页表两次查表，最终生成实地址的流程。</data>
      <data key="d3">chunk-a531a45f53700863615cfa8c40892f61</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468491</data>
    </node>
    <node id="共享">
      <data key="d0">共享</data>
      <data key="d1">concept</data>
      <data key="d2">共享是段页式虚拟存储器的优点之一，允许按段实现程序模块的共享。</data>
      <data key="d3">chunk-a531a45f53700863615cfa8c40892f61</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468491</data>
    </node>
    <node id="保护">
      <data key="d0">保护</data>
      <data key="d1">concept</data>
      <data key="d2">保护是段页式虚拟存储器的优点之一，允许按段实现对内存区域的访问控制。</data>
      <data key="d3">chunk-a531a45f53700863615cfa8c40892f61</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468491</data>
    </node>
    <node id="页长">
      <data key="d0">页长</data>
      <data key="d1">concept</data>
      <data key="d2">页长是页大小的度量，段长必须是页长的整数倍，且段的起点必须对齐到页的起始位置。</data>
      <data key="d3">chunk-a531a45f53700863615cfa8c40892f61</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468491</data>
    </node>
    <node id="RAID">
      <data key="d0">RAID</data>
      <data key="d1">concept</data>
      <data key="d2">RAID (Redundant Array of Independent Disks) is a data storage technology that combines multiple physical disks into a single logical unit to improve performance, reliability, and data safety.</data>
      <data key="d3">chunk-f75d6db24d56fe7631645ee707b4ca7f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468550</data>
    </node>
    <node id="RAID0">
      <data key="d0">RAID0</data>
      <data key="d1">method</data>
      <data key="d2">RAID0 is a disk array configuration that uses striping without redundancy or parity, providing high performance and increased storage capacity but no fault tolerance.</data>
      <data key="d3">chunk-f75d6db24d56fe7631645ee707b4ca7f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468550</data>
    </node>
    <node id="RAID1">
      <data key="d0">RAID1</data>
      <data key="d1">method</data>
      <data key="d2">RAID1 is a disk array configuration that uses mirroring, duplicating data across two drives for redundancy and fault tolerance.</data>
      <data key="d3">chunk-f75d6db24d56fe7631645ee707b4ca7f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468550</data>
    </node>
    <node id="RAID2">
      <data key="d0">RAID2</data>
      <data key="d1">method</data>
      <data key="d2">RAID2 is a disk array configuration that uses Hamming code error correction for data redundancy, requiring multiple disks and specialized hardware.</data>
      <data key="d3">chunk-f75d6db24d56fe7631645ee707b4ca7f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468550</data>
    </node>
    <node id="RAID3">
      <data key="d0">RAID3</data>
      <data key="d1">method</data>
      <data key="d2">RAID3 is a disk array configuration that uses byte-level striping with dedicated parity, enabling fault tolerance and sequential data access.</data>
      <data key="d3">chunk-f75d6db24d56fe7631645ee707b4ca7f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468550</data>
    </node>
    <node id="RAID4">
      <data key="d0">RAID4</data>
      <data key="d1">method</data>
      <data key="d2">RAID4 is a disk array configuration that uses block-level striping with a dedicated parity disk for fault tolerance.</data>
      <data key="d3">chunk-f75d6db24d56fe7631645ee707b4ca7f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468550</data>
    </node>
    <node id="RAID5">
      <data key="d0">RAID5</data>
      <data key="d1">method</data>
      <data key="d2">RAID5 is a disk array configuration that uses block-level striping with distributed parity, providing fault tolerance and efficient use of storage space.</data>
      <data key="d3">chunk-f75d6db24d56fe7631645ee707b4ca7f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468550</data>
    </node>
    <node id="Physical Disk">
      <data key="d0">Physical Disk</data>
      <data key="d1">artifact</data>
      <data key="d2">A physical disk is an individual hardware component used in RAID configurations to store data.</data>
      <data key="d3">chunk-f75d6db24d56fe7631645ee707b4ca7f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468550</data>
    </node>
    <node id="Logical Disk">
      <data key="d0">Logical Disk</data>
      <data key="d1">artifact</data>
      <data key="d2">A logical disk is a virtual disk unit created by combining multiple physical disks in a RAID setup.</data>
      <data key="d3">chunk-f75d6db24d56fe7631645ee707b4ca7f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468552</data>
    </node>
    <node id="Data Striping">
      <data key="d0">Data Striping</data>
      <data key="d1">method</data>
      <data key="d2">Data striping is the process of dividing data into blocks and distributing them across multiple disks for parallel access and improved performance.</data>
      <data key="d3">chunk-f75d6db24d56fe7631645ee707b4ca7f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468552</data>
    </node>
    <node id="Mirroring">
      <data key="d0">Mirroring</data>
      <data key="d1">method</data>
      <data key="d2">Mirroring is a data redundancy technique where data is duplicated across multiple disks in RAID1 to ensure availability upon failure.</data>
      <data key="d3">chunk-f75d6db24d56fe7631645ee707b4ca7f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468552</data>
    </node>
    <node id="Parity">
      <data key="d0">Parity</data>
      <data key="d1">concept</data>
      <data key="d2">Parity is a mechanism used in RAID to provide fault tolerance by storing redundant data for error detection and recovery.</data>
      <data key="d3">chunk-f75d6db24d56fe7631645ee707b4ca7f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468552</data>
    </node>
    <node id="Fault Tolerance">
      <data key="d0">Fault Tolerance</data>
      <data key="d1">concept</data>
      <data key="d2">Fault tolerance is the ability of a storage system to continue operating despite the failure of one or more disks.</data>
      <data key="d3">chunk-f75d6db24d56fe7631645ee707b4ca7f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468552</data>
    </node>
    <node id="Data Recovery">
      <data key="d0">Data Recovery</data>
      <data key="d1">concept</data>
      <data key="d2">Data recovery refers to the process of retrieving data from a failed disk in a RAID system, enabled by redundancy or parity.</data>
      <data key="d3">chunk-f75d6db24d56fe7631645ee707b4ca7f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468552</data>
    </node>
    <node id="Storage Performance">
      <data key="d0">Storage Performance</data>
      <data key="d1">concept</data>
      <data key="d2">Storage performance describes the speed and efficiency of data read/write operations in a RAID system.</data>
      <data key="d3">chunk-f75d6db24d56fe7631645ee707b4ca7f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468552</data>
    </node>
    <node id="Independent Redundant Disk Array">
      <data key="d0">Independent Redundant Disk Array</data>
      <data key="d1">concept</data>
      <data key="d2">Independent Redundant Disk Array is the full form of RAID, referring to the technology that combines multiple physical disks into a single logical unit for enhanced performance and reliability.</data>
      <data key="d3">chunk-f75d6db24d56fe7631645ee707b4ca7f</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468553</data>
    </node>
    <node id="Tag">
      <data key="d0">Tag</data>
      <data key="d1">artifact</data>
      <data key="d2">Tag is a field in a cache line that stores the higher-order bits of the main memory address to identify which block it contains.</data>
      <data key="d3">chunk-361185a50ecc6636f127fb6f6ad6eabd</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468587</data>
    </node>
    <node id="Valid Bit">
      <data key="d0">Valid Bit</data>
      <data key="d1">artifact</data>
      <data key="d2">Valid bit is a flag in a cache line indicating whether the data in the line is valid (i.e., a valid copy of a main memory block).</data>
      <data key="d3">chunk-361185a50ecc6636f127fb6f6ad6eabd</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468587</data>
    </node>
    <node id="Fully Associative Mapping">
      <data key="d0">Fully Associative Mapping</data>
      <data key="d1">method</data>
      <data key="d2">Fully associative mapping allows any main memory block to be placed in any cache line, requiring comparison of all tags during access.</data>
      <data key="d3">chunk-361185a50ecc6636f127fb6f6ad6eabd</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468587</data>
    </node>
    <node id="Cache Line Number">
      <data key="d0">Cache Line Number</data>
      <data key="d1">concept</data>
      <data key="d2">Cache line number is computed using the formula: main memory block number modulo total cache lines.</data>
      <data key="d3">chunk-361185a50ecc6636f127fb6f6ad6eabd</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468589</data>
    </node>
    <node id="Main Memory Block Number">
      <data key="d0">Main Memory Block Number</data>
      <data key="d1">concept</data>
      <data key="d2">Main memory block number is the identifier for a block in main memory, used for mapping to cache.</data>
      <data key="d3">chunk-361185a50ecc6636f127fb6f6ad6eabd</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468589</data>
    </node>
    <node id="Block Conflict">
      <data key="d0">Block Conflict</data>
      <data key="d1">concept</data>
      <data key="d2">Block conflict occurs when a block needs to be loaded into a cache line that is already occupied and cannot be replaced.</data>
      <data key="d3">chunk-361185a50ecc6636f127fb6f6ad6eabd</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468589</data>
    </node>
    <node id="Hit">
      <data key="d0">Hit</data>
      <data key="d1">concept</data>
      <data key="d2">Hit occurs when requested data is found in the cache, resulting in faster access than from main memory.</data>
      <data key="d3">chunk-361185a50ecc6636f127fb6f6ad6eabd</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468589</data>
    </node>
    <node id="Miss">
      <data key="d0">Miss</data>
      <data key="d1">concept</data>
      <data key="d2">Miss occurs when requested data is not found in the cache, requiring a read from main memory.</data>
      <data key="d3">chunk-361185a50ecc6636f127fb6f6ad6eabd</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468589</data>
    </node>
    <node id="Figure 3.19">
      <data key="d0">Figure 3.19</data>
      <data key="d1">content</data>
      <data key="d2">Figure 3.19 is a diagram illustrating the fully associative mapping method in cache memory.</data>
      <data key="d3">chunk-361185a50ecc6636f127fb6f6ad6eabd</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468590</data>
    </node>
    <node id="Figure 3.20">
      <data key="d0">Figure 3.20</data>
      <data key="d1">content</data>
      <data key="d2">Figure 3.20 is a diagram demonstrating the set associative mapping method in cache memory.</data>
      <data key="d3">chunk-361185a50ecc6636f127fb6f6ad6eabd</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468590</data>
    </node>
    <node id="2-Way Set Associative">
      <data key="d0">2-Way Set Associative</data>
      <data key="d1">method</data>
      <data key="d2">2-Way set associative mapping refers to a configuration where each cache set contains two cache lines, allowing flexibility in block placement within the set.</data>
      <data key="d3">chunk-361185a50ecc6636f127fb6f6ad6eabd</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468590</data>
    </node>
    <node id="Block Inclusion">
      <data key="d0">Block Inclusion</data>
      <data key="d1">concept</data>
      <data key="d2">Block inclusion refers to the principle that every block in a lower-level cache (e.g., L1) must also be present in a higher-level cache (e.g., L2) if it is part of the address hierarchy.</data>
      <data key="d3">chunk-361185a50ecc6636f127fb6f6ad6eabd</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468590</data>
    </node>
    <node id="Address Tag Field">
      <data key="d0">Address Tag Field</data>
      <data key="d1">artifact</data>
      <data key="d2">Address tag field is the portion of the main memory address used to match against the tag in a cache line during a memory access.</data>
      <data key="d3">chunk-361185a50ecc6636f127fb6f6ad6eabd</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468590</data>
    </node>
    <node id="High-Speed Buffer Memory">
      <data key="d0">High-Speed Buffer Memory</data>
      <data key="d1">artifact</data>
      <data key="d2">High-Speed Buffer Memory is a component designed to improve data access speed in computing systems.</data>
      <data key="d3">chunk-d02693bcc2f3ef38eee5bb553035284e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468593</data>
    </node>
    <node id="Program Transfer Probability">
      <data key="d0">Program Transfer Probability</data>
      <data key="d1">concept</data>
      <data key="d2">Program Transfer Probability refers to the likelihood of program execution transferring between different sections of memory.</data>
      <data key="d3">chunk-d02693bcc2f3ef38eee5bb553035284e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468593</data>
    </node>
    <node id="Data Distribution Discreteness">
      <data key="d0">Data Distribution Discreteness</data>
      <data key="d1">concept</data>
      <data key="d2">Data Distribution Discreteness describes the scattered or non-uniform distribution of data within memory.</data>
      <data key="d3">chunk-d02693bcc2f3ef38eee5bb553035284e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468593</data>
    </node>
    <node id="Parallel Main Memory System">
      <data key="d0">Parallel Main Memory System</data>
      <data key="d1">system</data>
      <data key="d2">Parallel Main Memory System is a memory architecture that uses multiple memory modules to improve data throughput.</data>
      <data key="d3">chunk-d02693bcc2f3ef38eee5bb553035284e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468593</data>
    </node>
    <node id="Memory System Efficiency">
      <data key="d0">Memory System Efficiency</data>
      <data key="d1">concept</data>
      <data key="d2">Memory System Efficiency refers to the performance and speed with which a memory system delivers data to the CPU.</data>
      <data key="d3">chunk-d02693bcc2f3ef38eee5bb553035284e</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468595</data>
    </node>
    <node id="Wear Leveling">
      <data key="d0">Wear Leveling</data>
      <data key="d1">method</data>
      <data key="d2">Wear Leveling is a technology used in SSDs to distribute write and erase cycles evenly across flash memory blocks to prevent premature failure.</data>
      <data key="d3">chunk-5b1903143e069742cd454a3ac6ea0d4a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468675</data>
    </node>
    <node id="Dynamic Wear Leveling">
      <data key="d0">Dynamic Wear Leveling</data>
      <data key="d1">method</data>
      <data key="d2">Dynamic Wear Leveling is a wear leveling technique that prioritizes writing data to flash blocks with fewer erase cycles.</data>
      <data key="d3">chunk-5b1903143e069742cd454a3ac6ea0d4a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468675</data>
    </node>
    <node id="Static Wear Leveling">
      <data key="d0">Static Wear Leveling</data>
      <data key="d1">method</data>
      <data key="d2">Static Wear Leveling is an advanced wear leveling method that redistributes data even in the absence of writes, to balance usage across all flash blocks.</data>
      <data key="d3">chunk-5b1903143e069742cd454a3ac6ea0d4a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468675</data>
    </node>
    <node id="256GB SSD">
      <data key="d0">256GB SSD</data>
      <data key="d1">artifact</data>
      <data key="d2">A 256GB SSD is a solid-state drive with a total storage capacity of 256 gigabytes, commonly used in consumer and enterprise systems.</data>
      <data key="d3">chunk-5b1903143e069742cd454a3ac6ea0d4a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468675</data>
    </node>
    <node id="Program/Erase Cycles">
      <data key="d0">Program/Erase Cycles</data>
      <data key="d1">concept</data>
      <data key="d2">Program/Erase Cycles refer to the number of times a flash memory cell can be written to and erased before it fails.</data>
      <data key="d3">chunk-5b1903143e069742cd454a3ac6ea0d4a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468675</data>
    </node>
    <node id="Data Write Concentration">
      <data key="d0">Data Write Concentration</data>
      <data key="d1">concept</data>
      <data key="d2">Data Write Concentration is the phenomenon where data writes are unevenly distributed across flash memory blocks, leading to early failure of certain blocks.</data>
      <data key="d3">chunk-5b1903143e069742cd454a3ac6ea0d4a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468675</data>
    </node>
    <node id="Flash Memory Block">
      <data key="d0">Flash Memory Block</data>
      <data key="d1">artifact</data>
      <data key="d2">A Flash Memory Block is a unit of storage in flash memory that is erased and written in bulk and is subject to wear over time.</data>
      <data key="d3">chunk-5b1903143e069742cd454a3ac6ea0d4a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468676</data>
    </node>
    <node id="Lifetime of SSD">
      <data key="d0">Lifetime of SSD</data>
      <data key="d1">concept</data>
      <data key="d2">The lifetime of an SSD is determined by the endurance of its flash memory, with proper wear leveling significantly extending usable life.</data>
      <data key="d3">chunk-5b1903143e069742cd454a3ac6ea0d4a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468677</data>
    </node>
    <node id="Storage Capacity">
      <data key="d0">Storage Capacity</data>
      <data key="d1">concept</data>
      <data key="d2">Storage capacity refers to the total amount of data that a storage device can hold, calculated as the product of the number of storage words and the word length.</data>
      <data key="d3">chunk-3c1c3cb1cdfefa986a82277dd52e88ef</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468735</data>
    </node>
    <node id="Unit Cost">
      <data key="d0">Unit Cost</data>
      <data key="d1">concept</data>
      <data key="d2">Unit cost represents the cost per bit of storage, calculated as total cost divided by total storage capacity.</data>
      <data key="d3">chunk-3c1c3cb1cdfefa986a82277dd52e88ef</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468735</data>
    </node>
    <node id="Storage Speed">
      <data key="d0">Storage Speed</data>
      <data key="d1">concept</data>
      <data key="d2">Storage speed indicates how quickly data can be transferred to or from the storage device, measured by data transfer rate.</data>
      <data key="d3">chunk-3c1c3cb1cdfefa986a82277dd52e88ef</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468735</data>
    </node>
    <node id="Access Time">
      <data key="d0">Access Time</data>
      <data key="d1">concept</data>
      <data key="d2">Access time is the duration from initiating a memory operation to its completion, including read and write times.</data>
      <data key="d3">chunk-3c1c3cb1cdfefa986a82277dd52e88ef</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468735</data>
    </node>
    <node id="Main Memory Bandwidth">
      <data key="d0">Main Memory Bandwidth</data>
      <data key="d1">concept</data>
      <data key="d2">Main memory bandwidth, also known as data transfer rate, measures the maximum amount of information that can be transferred from main memory per second, expressed in words/second, bytes/second, or bits/second.</data>
      <data key="d3">chunk-3c1c3cb1cdfefa986a82277dd52e88ef</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468735</data>
    </node>
    <node id="Byte">
      <data key="d0">Byte</data>
      <data key="d1">unit</data>
      <data key="d2">Byte is a unit of digital information equal to 8 bits.</data>
      <data key="d3">chunk-3c1c3cb1cdfefa986a82277dd52e88ef</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468735</data>
    </node>
    <node id="Bit">
      <data key="d0">Bit</data>
      <data key="d1">unit</data>
      <data key="d2">Bit is the smallest unit of digital information, representing a binary digit.</data>
      <data key="d3">chunk-3c1c3cb1cdfefa986a82277dd52e88ef</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468737</data>
    </node>
    <node id="Storage Word Count">
      <data key="d0">Storage Word Count</data>
      <data key="d1">concept</data>
      <data key="d2">Storage word count defines the size of the address space of a storage device.</data>
      <data key="d3">chunk-3c1c3cb1cdfefa986a82277dd52e88ef</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468737</data>
    </node>
    <node id="Word Length">
      <data key="d0">Word Length</data>
      <data key="d1">concept</data>
      <data key="d2">Word length refers to the amount of data that can be accessed in a single operation.</data>
      <data key="d3">chunk-3c1c3cb1cdfefa986a82277dd52e88ef</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468737</data>
    </node>
    <node id="Restoration Time">
      <data key="d0">Restoration Time</data>
      <data key="d1">concept</data>
      <data key="d2">Restoration time is the period required for a memory device to recover its internal state after a read or write operation.</data>
      <data key="d3">chunk-3c1c3cb1cdfefa986a82277dd52e88ef</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468737</data>
    </node>
    <node id="有效位">
      <data key="d0">有效位</data>
      <data key="d1">concept</data>
      <data key="d2">有效位, also known as the valid bit, indicates whether a virtual page is currently loaded into main memory; if set to 1, the page is in main memory, and the page table entry holds the physical page number.</data>
      <data key="d3">chunk-0af5a7c8d38a4b5d1e4bac2d53e20424</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468768</data>
    </node>
    <node id="外存">
      <data key="d0">外存</data>
      <data key="d1">location</data>
      <data key="d2">外存refers to secondary storage, such as a hard disk, where data is stored long-term and not directly accessible by the CPU.</data>
      <data key="d3">chunk-0af5a7c8d38a4b5d1e4bac2d53e20424</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468768</data>
    </node>
    <node id="物理页号">
      <data key="d0">物理页号</data>
      <data key="d1">data</data>
      <data key="d2">物理页号is the actual memory address in main memory corresponding to a virtual page, stored in the page table when the page is loaded.</data>
      <data key="d3">chunk-0af5a7c8d38a4b5d1e4bac2d53e20424</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468768</data>
    </node>
    <node id="磁盘地址">
      <data key="d0">磁盘地址</data>
      <data key="d1">concept</data>
      <data key="d2">磁盘地址is the location on secondary storage where a page is stored when not in main memory.&lt;SEP&gt;磁盘地址is the address format used by the host system to locate data, typically consisting of cylinder (track) number, head (disk surface) number, and sector number.</data>
      <data key="d3">chunk-0af5a7c8d38a4b5d1e4bac2d53e20424&lt;SEP&gt;chunk-bc61336da91a3616939ad75ed1c5543a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468931</data>
    </node>
    <node id="脏位">
      <data key="d0">脏位</data>
      <data key="d1">concept</data>
      <data key="d2">脏位, also known as the modified bit, indicates whether a memory page has been modified and needs to be written back to disk during replacement.</data>
      <data key="d3">chunk-0af5a7c8d38a4b5d1e4bac2d53e20424</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468768</data>
    </node>
    <node id="修改位">
      <data key="d0">修改位</data>
      <data key="d1">concept</data>
      <data key="d2">修改位is an alternative term for the dirty bit, used to track if a page has been altered since it was loaded.</data>
      <data key="d3">chunk-0af5a7c8d38a4b5d1e4bac2d53e20424</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468769</data>
    </node>
    <node id="回写法">
      <data key="d0">回写法</data>
      <data key="d1">method</data>
      <data key="d2">回写法is a memory management strategy where pages are only written back to disk when they are replaced, based on the dirty bit.</data>
      <data key="d3">chunk-0af5a7c8d38a4b5d1e4bac2d53e20424</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468769</data>
    </node>
    <node id="引用位">
      <data key="d0">引用位</data>
      <data key="d1">concept</data>
      <data key="d2">引用位, also known as the reference bit, tracks page usage for replacement algorithms such as FIFO or LRU.</data>
      <data key="d3">chunk-0af5a7c8d38a4b5d1e4bac2d53e20424</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468769</data>
    </node>
    <node id="使用位">
      <data key="d0">使用位</data>
      <data key="d1">concept</data>
      <data key="d2">使用位is an alternative name for the reference bit, used to support page replacement policies.</data>
      <data key="d3">chunk-0af5a7c8d38a4b5d1e4bac2d53e20424</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468769</data>
    </node>
    <node id="FIFO位">
      <data key="d0">FIFO位</data>
      <data key="d1">concept</data>
      <data key="d2">FIFO位is a logical indicator used in the First-In-First-Out page replacement strategy to determine which page to evict.</data>
      <data key="d3">chunk-0af5a7c8d38a4b5d1e4bac2d53e20424</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468769</data>
    </node>
    <node id="LRU位">
      <data key="d0">LRU位</data>
      <data key="d1">concept</data>
      <data key="d2">LRU位is a logical indicator used in the Least Recently Used replacement strategy to track recency of page access.</data>
      <data key="d3">chunk-0af5a7c8d38a4b5d1e4bac2d53e20424</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468769</data>
    </node>
    <node id="地址转换部件">
      <data key="d0">地址转换部件</data>
      <data key="d1">artifact</data>
      <data key="d2">地址转换部件is a hardware component responsible for translating virtual addresses into physical addresses.</data>
      <data key="d3">chunk-0af5a7c8d38a4b5d1e4bac2d53e20424</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468771</data>
    </node>
    <node id="缺页">
      <data key="d0">缺页</data>
      <data key="d1">concept</data>
      <data key="d2">缺页refers to a situation where the requested virtual page is not in main memory, triggering a page fault.</data>
      <data key="d3">chunk-0af5a7c8d38a4b5d1e4bac2d53e20424</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468771</data>
    </node>
    <node id="缺页异常">
      <data key="d0">缺页异常</data>
      <data key="d1">event</data>
      <data key="d2">缺页异常occurs when a page is not in main memory, requiring the operating system to load it from secondary storage.</data>
      <data key="d3">chunk-0af5a7c8d38a4b5d1e4bac2d53e20424</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468771</data>
    </node>
    <node id="缺页异常处理程序">
      <data key="d0">缺页异常处理程序</data>
      <data key="d1">organization</data>
      <data key="d2">缺页异常处理程序is an operating system routine triggered to handle a page fault by loading the required page from disk.</data>
      <data key="d3">chunk-0af5a7c8d38a4b5d1e4bac2d53e20424</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468771</data>
    </node>
    <node id="磁盘">
      <data key="d0">磁盘</data>
      <data key="d1">naturalobject</data>
      <data key="d2">磁盘is a secondary storage device used to store pages not currently in main memory.</data>
      <data key="d3">chunk-0af5a7c8d38a4b5d1e4bac2d53e20424</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468771</data>
    </node>
    <node id="空闲物理页框">
      <data key="d0">空闲物理页框</data>
      <data key="d1">concept</data>
      <data key="d2">空闲物理页框refers to a free memory frame in main memory available for loading a new page.</data>
      <data key="d3">chunk-0af5a7c8d38a4b5d1e4bac2d53e20424</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468771</data>
    </node>
    <node id="换出页面">
      <data key="d0">换出页面</data>
      <data key="d1">concept</data>
      <data key="d2">换出页面is the process of removing a page from main memory to make space for a new one.</data>
      <data key="d3">chunk-0af5a7c8d38a4b5d1e4bac2d53e20424</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468771</data>
    </node>
    <node id="替换法">
      <data key="d0">替换法</data>
      <data key="d1">method</data>
      <data key="d2">替换法is a strategy used in virtual memory management to select a page for removal when a new page is to be loaded.</data>
      <data key="d3">chunk-0af5a7c8d38a4b5d1e4bac2d53e20424</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468771</data>
    </node>
    <node id="页式虚拟存储器">
      <data key="d0">页式虚拟存储器</data>
      <data key="d1">concept</data>
      <data key="d2">页式虚拟存储器is a memory management scheme that divides memory into fixed-size pages.</data>
      <data key="d3">chunk-0af5a7c8d38a4b5d1e4bac2d53e20424</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468772</data>
    </node>
    <node id="最后一页的零头">
      <data key="d0">最后一页的零头</data>
      <data key="d1">concept</data>
      <data key="d2">最后一页的零头refers to the unused portion of the last page when the program size is not an exact multiple of the page size, resulting in wasted space.</data>
      <data key="d3">chunk-0af5a7c8d38a4b5d1e4bac2d53e20424</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468773</data>
    </node>
    <node id="页表简单">
      <data key="d0">页表简单</data>
      <data key="d1">concept</data>
      <data key="d2">页表简单describes the structural simplicity of page tables in page-based virtual memory.</data>
      <data key="d3">chunk-0af5a7c8d38a4b5d1e4bac2d53e20424</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468773</data>
    </node>
    <node id="调入方便">
      <data key="d0">调入方便</data>
      <data key="d1">concept</data>
      <data key="d2">调入方便refers to the ease with which pages can be loaded into memory in a page-based system.</data>
      <data key="d3">chunk-0af5a7c8d38a4b5d1e4bac2d53e20424</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468773</data>
    </node>
    <node id="页面长度固定">
      <data key="d0">页面长度固定</data>
      <data key="d1">concept</data>
      <data key="d2">页面长度固定is a characteristic of page-based systems where all pages have the same size.</data>
      <data key="d3">chunk-0af5a7c8d38a4b5d1e4bac2d53e20424</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468773</data>
    </node>
    <node id="Logical Address">
      <data key="d0">Logical Address</data>
      <data key="d1">concept</data>
      <data key="d2">A logical address is another term for virtual address, representing the address space as seen by a program.</data>
      <data key="d3">chunk-b5dba59d5f9377e5060b73fecdb0de06</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468859</data>
    </node>
    <node id="Virtual Space">
      <data key="d0">Virtual Space</data>
      <data key="d1">concept</data>
      <data key="d2">Virtual space is the memory space accessible by a program, defined by virtual addresses.</data>
      <data key="d3">chunk-b5dba59d5f9377e5060b73fecdb0de06</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468859</data>
    </node>
    <node id="Program Space">
      <data key="d0">Program Space</data>
      <data key="d1">concept</data>
      <data key="d2">Program space is synonymous with virtual space, the conceptual address space allocated to a program.</data>
      <data key="d3">chunk-b5dba59d5f9377e5060b73fecdb0de06</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468859</data>
    </node>
    <node id="Real Address Space">
      <data key="d0">Real Address Space</data>
      <data key="d1">concept</data>
      <data key="d2">Real address space is the actual address space of main memory, corresponding to physical addresses.</data>
      <data key="d3">chunk-b5dba59d5f9377e5060b73fecdb0de06</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468861</data>
    </node>
    <node id="Segment">
      <data key="d0">Segment</data>
      <data key="d1">artifact</data>
      <data key="d2">A segment is a block of memory that may vary in size, used in segmented memory systems; it may be referred to in the context of page or segment faults.</data>
      <data key="d3">chunk-b5dba59d5f9377e5060b73fecdb0de06</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468861</data>
    </node>
    <node id="Main Memory Full">
      <data key="d0">Main Memory Full</data>
      <data key="d1">concept</data>
      <data key="d2">A condition when the main memory is completely occupied, requiring page replacement to accommodate new data.</data>
      <data key="d3">chunk-b5dba59d5f9377e5060b73fecdb0de06</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468861</data>
    </node>
    <node id="Virtual Memory Management">
      <data key="d0">Virtual Memory Management</data>
      <data key="d1">concept</data>
      <data key="d2">Virtual memory management is the process of controlling the mapping between virtual and physical addresses and managing data movement between main and secondary memory.</data>
      <data key="d3">chunk-b5dba59d5f9377e5060b73fecdb0de06</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468862</data>
    </node>
    <node id="Fault">
      <data key="d0">Fault</data>
      <data key="d1">concept</data>
      <data key="d2">A fault occurs when a requested virtual page is not present in main memory, triggering a page fault handler to load the required page from secondary storage.</data>
      <data key="d3">chunk-b5dba59d5f9377e5060b73fecdb0de06</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468862</data>
    </node>
    <node id="磁盘存储器">
      <data key="d0">磁盘存储器</data>
      <data key="d1">artifact</data>
      <data key="d2">磁盘存储器is a storage device that uses magnetic disks as the medium, offering large capacity, low cost per bit, reusable recording media, and long-term information preservation without loss.</data>
      <data key="d3">chunk-bc61336da91a3616939ad75ed1c5543a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468923</data>
    </node>
    <node id="磁盘驱动器">
      <data key="d0">磁盘驱动器</data>
      <data key="d1">artifact</data>
      <data key="d2">磁盘驱动器is a device that drives the disk to rotate and performs read/write operations on the disk surface using magnetic heads.</data>
      <data key="d3">chunk-bc61336da91a3616939ad75ed1c5543a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468923</data>
    </node>
    <node id="磁盘控制器">
      <data key="d0">磁盘控制器</data>
      <data key="d1">artifact</data>
      <data key="d2">磁盘控制器serves as an interface between the disk drive and the host system, interpreting CPU commands, sending control signals to the disk drive, and monitoring its status.</data>
      <data key="d3">chunk-bc61336da91a3616939ad75ed1c5543a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468923</data>
    </node>
    <node id="盘片">
      <data key="d0">盘片</data>
      <data key="d1">artifact</data>
      <data key="d2">盘片is the physical medium of a disk storage device where data is recorded and retrieved through magnetic heads.</data>
      <data key="d3">chunk-bc61336da91a3616939ad75ed1c5543a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468923</data>
    </node>
    <node id="记录面">
      <data key="d0">记录面</data>
      <data key="d1">concept</data>
      <data key="d2">记录面refers to a surface of a disk platter that can store data, with one magnetic head corresponding to each recording surface.</data>
      <data key="d3">chunk-bc61336da91a3616939ad75ed1c5543a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468923</data>
    </node>
    <node id="磁道">
      <data key="d0">磁道</data>
      <data key="d1">concept</data>
      <data key="d2">磁道is a circular track on a disk surface, composed of segments divided into sectors for data storage.</data>
      <data key="d3">chunk-bc61336da91a3616939ad75ed1c5543a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468923</data>
    </node>
    <node id="扇区">
      <data key="d0">扇区</data>
      <data key="d1">concept</data>
      <data key="d2">扇区is the smallest unit of data storage on a disk, also known as a block, used for read/write operations.</data>
      <data key="d3">chunk-bc61336da91a3616939ad75ed1c5543a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468923</data>
    </node>
    <node id="磁头数">
      <data key="d0">磁头数</data>
      <data key="d1">concept</data>
      <data key="d2">磁头数represents the number of recording surfaces or magnetic heads in a disk storage system, one per surface.</data>
      <data key="d3">chunk-bc61336da91a3616939ad75ed1c5543a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468923</data>
    </node>
    <node id="柱面数">
      <data key="d0">柱面数</data>
      <data key="d1">concept</data>
      <data key="d2">柱面数refers to the number of tracks per disk surface, and a cylinder is formed by the same track number across all surfaces.</data>
      <data key="d3">chunk-bc61336da91a3616939ad75ed1c5543a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468926</data>
    </node>
    <node id="扇区数">
      <data key="d0">扇区数</data>
      <data key="d1">concept</data>
      <data key="d2">扇区数indicates the number of sectors on each magnetic track of a disk.</data>
      <data key="d3">chunk-bc61336da91a3616939ad75ed1c5543a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468926</data>
    </node>
    <node id="磁盘高速缓存">
      <data key="d0">磁盘高速缓存</data>
      <data key="d1">artifact</data>
      <data key="d2">磁盘高速缓存is a portion of memory used to buffer data before it is written to the disk, improving performance by reducing small, frequent disk writes.</data>
      <data key="d3">chunk-bc61336da91a3616939ad75ed1c5543a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468926</data>
    </node>
    <node id="磁记录原理">
      <data key="d0">磁记录原理</data>
      <data key="d1">concept</data>
      <data key="d2">磁记录原理is the method by which data is stored and retrieved via electromagnetic conversion between magnetic heads and the magnetic recording medium.</data>
      <data key="d3">chunk-bc61336da91a3616939ad75ed1c5543a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468926</data>
    </node>
    <node id="编码方法">
      <data key="d0">编码方法</data>
      <data key="d1">concept</data>
      <data key="d2">编码方法refers to the scheme used to transform binary data into a sequence of magnetic polarization states for reliable reading and writing.</data>
      <data key="d3">chunk-bc61336da91a3616939ad75ed1c5543a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468926</data>
    </node>
    <node id="调频制">
      <data key="d0">调频制</data>
      <data key="d1">method</data>
      <data key="d2">调频制(FM) is a magnetic recording technique that encodes data by modulating the frequency of magnetic transitions.</data>
      <data key="d3">chunk-bc61336da91a3616939ad75ed1c5543a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468926</data>
    </node>
    <node id="改进型调频制">
      <data key="d0">改进型调频制</data>
      <data key="d1">method</data>
      <data key="d2">改进型调频制(MFM) is an enhanced version of FM recording that improves efficiency by reducing the number of transitions.</data>
      <data key="d3">chunk-bc61336da91a3616939ad75ed1c5543a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468926</data>
    </node>
    <node id="记录密度">
      <data key="d0">记录密度</data>
      <data key="d1">concept</data>
      <data key="d2">记录密度is the measure of the amount of data stored per unit area of a disk surface, expressed as track density, bit density, or surface density.</data>
      <data key="d3">chunk-bc61336da91a3616939ad75ed1c5543a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468926</data>
    </node>
    <node id="道密度">
      <data key="d0">道密度</data>
      <data key="d1">concept</data>
      <data key="d2">道密度is the number of tracks per unit length along the radial direction of a disk.</data>
      <data key="d3">chunk-bc61336da91a3616939ad75ed1c5543a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468928</data>
    </node>
    <node id="位密度">
      <data key="d0">位密度</data>
      <data key="d1">concept</data>
      <data key="d2">位密度is the number of binary bits that can be stored per unit length along a disk track.</data>
      <data key="d3">chunk-bc61336da91a3616939ad75ed1c5543a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468929</data>
    </node>
    <node id="面密度">
      <data key="d0">面密度</data>
      <data key="d1">concept</data>
      <data key="d2">面密度is the product of bit density and track density, representing the total data capacity per unit area on a disk surface.</data>
      <data key="d3">chunk-bc61336da91a3616939ad75ed1c5543a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468929</data>
    </node>
    <node id="磁盘容量">
      <data key="d0">磁盘容量</data>
      <data key="d1">concept</data>
      <data key="d2">磁盘容量refers to the total amount of data that a disk can store, categorized as non-formatted or formatted capacity.</data>
      <data key="d3">chunk-bc61336da91a3616939ad75ed1c5543a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468929</data>
    </node>
    <node id="非格式化容量">
      <data key="d0">非格式化容量</data>
      <data key="d1">concept</data>
      <data key="d2">非格式化容量represents the total number of usable magnetic units on the recording surface before formatting.</data>
      <data key="d3">chunk-bc61336da91a3616939ad75ed1c5543a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468929</data>
    </node>
    <node id="格式化容量">
      <data key="d0">格式化容量</data>
      <data key="d1">concept</data>
      <data key="d2">格式化容量is the amount of data that can be stored after formatting, calculated based on number of surfaces, cylinders, sectors per track, and sector size.</data>
      <data key="d3">chunk-bc61336da91a3616939ad75ed1c5543a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468929</data>
    </node>
    <node id="存取时间">
      <data key="d0">存取时间</data>
      <data key="d1">concept</data>
      <data key="d2">存取时间is the total time required to access data and includes seek time, rotational latency, and transfer time.</data>
      <data key="d3">chunk-bc61336da91a3616939ad75ed1c5543a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468929</data>
    </node>
    <node id="寻道时间">
      <data key="d0">寻道时间</data>
      <data key="d1">concept</data>
      <data key="d2">寻道时间is the time required for the read/write head to move to the target track.</data>
      <data key="d3">chunk-bc61336da91a3616939ad75ed1c5543a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468929</data>
    </node>
    <node id="旋转延迟时间">
      <data key="d0">旋转延迟时间</data>
      <data key="d1">concept</data>
      <data key="d2">旋转延迟时间is the time for the desired sector to rotate under the read/write head after track access.</data>
      <data key="d3">chunk-bc61336da91a3616939ad75ed1c5543a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468931</data>
    </node>
    <node id="传输时间">
      <data key="d0">传输时间</data>
      <data key="d1">concept</data>
      <data key="d2">传输时间is the time taken to read or write the data once the head is positioned.</data>
      <data key="d3">chunk-bc61336da91a3616939ad75ed1c5543a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468931</data>
    </node>
    <node id="数据传输速率">
      <data key="d0">数据传输速率</data>
      <data key="d1">concept</data>
      <data key="d2">数据传输速率is the rate at which data is transferred from the disk to the host system per unit of time, measured in bytes per second.</data>
      <data key="d3">chunk-bc61336da91a3616939ad75ed1c5543a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468931</data>
    </node>
    <node id="柱面号">
      <data key="d0">柱面号</data>
      <data key="d1">concept</data>
      <data key="d2">柱面号is the track number in a disk, used in conjunction with head and sector numbers to locate data.</data>
      <data key="d3">chunk-bc61336da91a3616939ad75ed1c5543a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468931</data>
    </node>
    <node id="盘面号">
      <data key="d0">盘面号</data>
      <data key="d1">concept</data>
      <data key="d2">盘面号refers to the surface (or head) number in a disk, identifying which recording surface is involved.</data>
      <data key="d3">chunk-bc61336da91a3616939ad75ed1c5543a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468931</data>
    </node>
    <node id="扇区号">
      <data key="d0">扇区号</data>
      <data key="d1">concept</data>
      <data key="d2">扇区号is the number assigned to a specific sector on a track for unique data location.</data>
      <data key="d3">chunk-bc61336da91a3616939ad75ed1c5543a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468931</data>
    </node>
    <node id="16位二进制代码">
      <data key="d0">16位二进制代码</data>
      <data key="d1">data</data>
      <data key="d2">16位二进制代码is the format used to represent a sector address in a system with 16 disk surfaces, 256 tracks per surface, and 16 sectors per track.</data>
      <data key="d3">chunk-bc61336da91a3616939ad75ed1c5543a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468931</data>
    </node>
    <node id="Disk Address">
      <data key="d0">Disk Address</data>
      <data key="d1">concept</data>
      <data key="d2">Disk address refers to the unique identifier used by the host to locate data on a disk, consisting of cylinder (track) number, disk surface (head) number, and sector number.</data>
      <data key="d3">chunk-59c3b987a075436eab7c271ca2d5302a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468933</data>
    </node>
    <node id="Cylinder Track Number">
      <data key="d0">Cylinder Track Number</data>
      <data key="d1">concept</data>
      <data key="d2">Cylinder track number represents the radial position of a track on a disk surface, used in disk addressing.</data>
      <data key="d3">chunk-59c3b987a075436eab7c271ca2d5302a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468934</data>
    </node>
    <node id="Disk Surface Head Number">
      <data key="d0">Disk Surface Head Number</data>
      <data key="d1">concept</data>
      <data key="d2">Disk surface head number identifies the specific disk surface (or head) on a disk platter, used in disk addressing.</data>
      <data key="d3">chunk-59c3b987a075436eab7c271ca2d5302a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468934</data>
    </node>
    <node id="Sector Number">
      <data key="d0">Sector Number</data>
      <data key="d1">concept</data>
      <data key="d2">Sector number identifies the specific sector within a track on a disk surface, used in disk addressing.</data>
      <data key="d3">chunk-59c3b987a075436eab7c271ca2d5302a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468934</data>
    </node>
    <node id="16-Bit Binary Code">
      <data key="d0">16-Bit Binary Code</data>
      <data key="d1">data</data>
      <data key="d2">16-bit binary code is the binary representation used to encode disk addresses, comprising 8 bits for cylinder, 4 bits for surface, and 4 bits for sector.</data>
      <data key="d3">chunk-59c3b987a075436eab7c271ca2d5302a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468934</data>
    </node>
    <node id="Cylinder Track Number (8 Bits)">
      <data key="d0">Cylinder Track Number (8 Bits)</data>
      <data key="d1">data</data>
      <data key="d2">Cylinder track number is encoded using 8 bits in the 16-bit disk address format.</data>
      <data key="d3">chunk-59c3b987a075436eab7c271ca2d5302a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468934</data>
    </node>
    <node id="Disk Surface Head Number (4 Bits)">
      <data key="d0">Disk Surface Head Number (4 Bits)</data>
      <data key="d1">data</data>
      <data key="d2">Disk surface head number is encoded using 4 bits in the 16-bit disk address format.</data>
      <data key="d3">chunk-59c3b987a075436eab7c271ca2d5302a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468934</data>
    </node>
    <node id="Sector Number (4 Bits)">
      <data key="d0">Sector Number (4 Bits)</data>
      <data key="d1">data</data>
      <data key="d2">Sector number is encoded using 4 bits in the 16-bit disk address format.</data>
      <data key="d3">chunk-59c3b987a075436eab7c271ca2d5302a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468934</data>
    </node>
    <node id="Disk Controller">
      <data key="d0">Disk Controller</data>
      <data key="d1">artifact</data>
      <data key="d2">Disk controller is a hardware component that manages communication between the host and the disk, receiving addressing information and executing disk operations.</data>
      <data key="d3">chunk-59c3b987a075436eab7c271ca2d5302a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468936</data>
    </node>
    <node id="Read Operation">
      <data key="d0">Read Operation</data>
      <data key="d1">method</data>
      <data key="d2">Read operation is a disk function that retrieves data from a specific sector on a disk, performed sequentially.</data>
      <data key="d3">chunk-59c3b987a075436eab7c271ca2d5302a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468936</data>
    </node>
    <node id="Write Operation">
      <data key="d0">Write Operation</data>
      <data key="d1">method</data>
      <data key="d2">Write operation is a disk function that stores data into a specific sector on a disk, performed sequentially.</data>
      <data key="d3">chunk-59c3b987a075436eab7c271ca2d5302a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468936</data>
    </node>
    <node id="Seek Operation">
      <data key="d0">Seek Operation</data>
      <data key="d1">method</data>
      <data key="d2">Seek operation is a disk function that moves the disk head to the correct track (cylinder) for data access, executed as a sequential phase.</data>
      <data key="d3">chunk-59c3b987a075436eab7c271ca2d5302a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468936</data>
    </node>
    <node id="Control Word">
      <data key="d0">Control Word</data>
      <data key="d1">data</data>
      <data key="d2">Control word is a command sent to the disk controller that specifies the type of operation (e.g., read, write, seek) and its parameters.</data>
      <data key="d3">chunk-59c3b987a075436eab7c271ca2d5302a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468936</data>
    </node>
    <node id="Disk Access Process">
      <data key="d0">Disk Access Process</data>
      <data key="d1">concept</data>
      <data key="d2">Disk access process refers to the sequential steps involved in disk operations, starting with loading a control word followed by executing it.</data>
      <data key="d3">chunk-59c3b987a075436eab7c271ca2d5302a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468936</data>
    </node>
    <node id="Mechanical Disk">
      <data key="d0">Mechanical Disk</data>
      <data key="d1">artifact</data>
      <data key="d2">Mechanical disk is a physical storage device with moving parts, such as rotating platters and read/write heads, which perform serial operations.</data>
      <data key="d3">chunk-59c3b987a075436eab7c271ca2d5302a</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468938</data>
    </node>
    <node id="内存">
      <data key="d0">内存</data>
      <data key="d3">chunk-bc61336da91a3616939ad75ed1c5543a</data>
      <data key="d2">磁盘高速缓存is implemented as a region in main memory used to temporarily store data during disk operations.</data>
      <data key="d1">UNKNOWN</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468940</data>
    </node>
    <node id="电磁转换">
      <data key="d0">电磁转换</data>
      <data key="d3">chunk-bc61336da91a3616939ad75ed1c5543a</data>
      <data key="d2">The magnetic recording principle relies on electromagnetic conversion between the magnetic head and the medium during read and write.</data>
      <data key="d1">UNKNOWN</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468941</data>
    </node>
    <node id="磁记录方式">
      <data key="d0">磁记录方式</data>
      <data key="d3">chunk-bc61336da91a3616939ad75ed1c5543a</data>
      <data key="d2">Encoding methods determine how binary data is converted into magnetic states, with FM and MFM being common recording formats.</data>
      <data key="d1">UNKNOWN</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468941</data>
    </node>
    <node id="写磁盘">
      <data key="d0">写磁盘</data>
      <data key="d3">chunk-bc61336da91a3616939ad75ed1c5543a</data>
      <data key="d2">The disk cache improves write performance by batching small data writes into larger "clusters."</data>
      <data key="d1">UNKNOWN</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468943</data>
    </node>
    <node id="磁盘转数">
      <data key="d0">磁盘转数</data>
      <data key="d3">chunk-bc61336da91a3616939ad75ed1c5543a</data>
      <data key="d2">数据传输速率is directly proportional to the disk's rotational speed in revolutions per second.</data>
      <data key="d1">UNKNOWN</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468946</data>
    </node>
    <node id="中间结果数据">
      <data key="d0">中间结果数据</data>
      <data key="d3">chunk-bc61336da91a3616939ad75ed1c5543a</data>
      <data key="d2">Intermediate data stored in the disk cache can be quickly accessed again before being written to disk.</data>
      <data key="d1">UNKNOWN</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468946</data>
    </node>
    <node id="每条磁道容量">
      <data key="d0">每条磁道容量</data>
      <data key="d3">chunk-bc61336da91a3616939ad75ed1c5543a</data>
      <data key="d2">The total data transfer rate depends on the number of bytes per track and rotational speed.</data>
      <data key="d1">UNKNOWN</data>
      <data key="d4">unknown_source</data>
      <data key="d5">1761468950</data>
    </node>
    <edge source="DRAM" target="SRAM">
      <data key="d6">1.0</data>
      <data key="d7">DRAM and SRAM differ in their data storage mechanisms-DRAM uses capacitors and SRAM uses flip-flops-leading to differences in speed, density, and power consumption.</data>
      <data key="d8">density,performance,storage mechanism</data>
      <data key="d9">chunk-e100f5adcf7f52281eb1c5920bc2d5d0</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468060</data>
    </edge>
    <edge source="DRAM" target="Storage Cell">
      <data key="d6">1.0</data>
      <data key="d7">The storage cell in DRAM consists of a single transistor and capacitor used to store one bit of data.</data>
      <data key="d8">component,data storage</data>
      <data key="d9">chunk-e100f5adcf7f52281eb1c5920bc2d5d0</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468063</data>
    </edge>
    <edge source="DRAM" target="Gate Capacitor">
      <data key="d6">1.0</data>
      <data key="d7">The gate capacitor in a DRAM storage cell holds charge to represent data bits and requires periodic refresh.</data>
      <data key="d8">data retention,storage element</data>
      <data key="d9">chunk-e100f5adcf7f52281eb1c5920bc2d5d0</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468064</data>
    </edge>
    <edge source="DRAM" target="Refresh Cycle">
      <data key="d6">1.0</data>
      <data key="d7">A refresh cycle of 2ms ensures periodic regeneration of data in DRAM cells to prevent data loss.</data>
      <data key="d8">data integrity,refresh timing</data>
      <data key="d9">chunk-e100f5adcf7f52281eb1c5920bc2d5d0</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468064</data>
    </edge>
    <edge source="DRAM" target="Destructive Readout">
      <data key="d6">1.0</data>
      <data key="d7">Reading data from DRAM causes the stored charge to be destroyed, requiring regeneration after each read.</data>
      <data key="d8">data access characteristic,regeneration requirement</data>
      <data key="d9">chunk-e100f5adcf7f52281eb1c5920bc2d5d0</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468064</data>
    </edge>
    <edge source="DRAM" target="Concentrated Refresh">
      <data key="d6">1.0</data>
      <data key="d7">Concentrated refresh performs all row refreshes in a single interval, causing dead time but allowing uninterrupted access during normal operation.</data>
      <data key="d8">performance trade-off,refresh method</data>
      <data key="d9">chunk-e100f5adcf7f52281eb1c5920bc2d5d0</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468065</data>
    </edge>
    <edge source="DRAM" target="Distributed Refresh">
      <data key="d6">1.0</data>
      <data key="d7">Distributed refresh spreads refresh operations throughout the memory cycle, eliminating dead time at the cost of longer access cycles.</data>
      <data key="d8">access timing,refresh method</data>
      <data key="d9">chunk-e100f5adcf7f52281eb1c5920bc2d5d0</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468065</data>
    </edge>
    <edge source="DRAM" target="Asynchronous Refresh">
      <data key="d6">1.0</data>
      <data key="d7">Asynchronous refresh divides the refresh cycle into intervals between row refreshes, reducing idle CPU wait time.</data>
      <data key="d8">load balancing,refresh method</data>
      <data key="d9">chunk-e100f5adcf7f52281eb1c5920bc2d5d0</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468066</data>
    </edge>
    <edge source="DRAM" target="Memory Chip">
      <data key="d6">1.0</data>
      <data key="d7">DRAM is physically implemented in memory chips that contain arrays of storage cells.</data>
      <data key="d8">hardware implementation,integration</data>
      <data key="d9">chunk-e100f5adcf7f52281eb1c5920bc2d5d0</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468066</data>
    </edge>
    <edge source="DRAM" target="Address Pin Multiplexing">
      <data key="d6">1.0</data>
      <data key="d7">Address pin multiplexing reduces the number of address pins by sequentially inputting row and column addresses.</data>
      <data key="d8">packaging design,pin reduction</data>
      <data key="d9">chunk-e100f5adcf7f52281eb1c5920bc2d5d0</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468067</data>
    </edge>
    <edge source="DRAM" target="Bit Price">
      <data key="d6">1.0</data>
      <data key="d7">DRAM has a lower bit price than SRAM due to higher integration density.</data>
      <data key="d8">cost efficiency,density advantage</data>
      <data key="d9">chunk-e100f5adcf7f52281eb1c5920bc2d5d0</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468067</data>
    </edge>
    <edge source="DRAM" target="CPU">
      <data key="d6">1.0</data>
      <data key="d7">The CPU must account for memory refresh cycles when accessing DRAM, especially in systems with concentrated refresh.</data>
      <data key="d8">system interaction,timing dependency</data>
      <data key="d9">chunk-e100f5adcf7f52281eb1c5920bc2d5d0</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468068</data>
    </edge>
    <edge source="DRAM" target="Power Supply">
      <data key="d6">1.0</data>
      <data key="d7">Even with continuous power, DRAM data is lost after 1–2ms without refresh due to capacitor leakage.</data>
      <data key="d8">data loss risk,operational dependency</data>
      <data key="d9">chunk-e100f5adcf7f52281eb1c5920bc2d5d0</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468068</data>
    </edge>
    <edge source="DRAM" target="Read-After-Write Regeneration">
      <data key="d6">1.0</data>
      <data key="d7">Read-after-write regeneration restores data after a read operation to maintain data integrity.</data>
      <data key="d8">data maintenance,refresh operation</data>
      <data key="d9">chunk-e100f5adcf7f52281eb1c5920bc2d5d0</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468069</data>
    </edge>
    <edge source="DRAM" target="Random Access">
      <data key="d6">1.0</data>
      <data key="d7">DRAM supports random access and is widely used for its balance of cost and capacity.</data>
      <data key="d8">cost efficiency,memory access</data>
      <data key="d9">chunk-8ce34f8853facbe5658d8d7a94051590</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468135</data>
    </edge>
    <edge source="DRAM" target="Volatile">
      <data key="d6">1.0</data>
      <data key="d7">DRAM is volatile and requires continuous power to maintain data integrity.</data>
      <data key="d8">data loss,power dependency</data>
      <data key="d9">chunk-8ce34f8853facbe5658d8d7a94051590</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468135</data>
    </edge>
    <edge source="SRAM" target="Volatile">
      <data key="d6">1.0</data>
      <data key="d7">SRAM is volatile and loses its stored data when power is turned off.</data>
      <data key="d8">data loss,power dependency</data>
      <data key="d9">chunk-8ce34f8853facbe5658d8d7a94051590</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468134</data>
    </edge>
    <edge source="SRAM" target="Random Access">
      <data key="d6">1.0</data>
      <data key="d7">SRAM supports random access and is known for high speed in data retrieval.</data>
      <data key="d8">memory access,speed</data>
      <data key="d9">chunk-8ce34f8853facbe5658d8d7a94051590</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468135</data>
    </edge>
    <edge source="SRAM" target="TLB">
      <data key="d6">1.0</data>
      <data key="d7">SRAM is the physical storage medium used to implement TLB due to its fast access time.</data>
      <data key="d8">high-speed operation,memory implementation</data>
      <data key="d9">chunk-263465ac01c4eb10c3c852d62559620b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468164</data>
    </edge>
    <edge source="SRAM" target="Bistable Trigger">
      <data key="d6">1.0</data>
      <data key="d7">SRAM uses a bistable trigger as its core mechanism to store data.</data>
      <data key="d8">data retention,memory implementation</data>
      <data key="d9">chunk-7c2151344b39c51051c3dacc3290bcf9</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468380</data>
    </edge>
    <edge source="SRAM" target="Non-Destructive Readout">
      <data key="d6">1.0</data>
      <data key="d7">SRAM supports non-destructive readout, allowing data to remain unchanged after being read.</data>
      <data key="d8">data integrity,read operation</data>
      <data key="d9">chunk-7c2151344b39c51051c3dacc3290bcf9</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468381</data>
    </edge>
    <edge source="SRAM" target="High Access Speed">
      <data key="d6">1.0</data>
      <data key="d7">SRAM is characterized by high access speed, making it suitable for fast data retrieval.</data>
      <data key="d8">performance characteristic</data>
      <data key="d9">chunk-7c2151344b39c51051c3dacc3290bcf9</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468381</data>
    </edge>
    <edge source="SRAM" target="Low Integration Density">
      <data key="d6">1.0</data>
      <data key="d7">SRAM's integration density is low due to the use of multiple transistors per cell.</data>
      <data key="d8">design limitation</data>
      <data key="d9">chunk-7c2151344b39c51051c3dacc3290bcf9</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468381</data>
    </edge>
    <edge source="SRAM" target="High Power Consumption">
      <data key="d6">1.0</data>
      <data key="d7">SRAM consumes more power because the bistable circuit continuously draws current.</data>
      <data key="d8">energy efficiency issue</data>
      <data key="d9">chunk-7c2151344b39c51051c3dacc3290bcf9</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468382</data>
    </edge>
    <edge source="SRAM" target="High Cost">
      <data key="d6">1.0</data>
      <data key="d7">The complexity and low integration density of SRAM result in high production costs.</data>
      <data key="d8">economic factor</data>
      <data key="d9">chunk-7c2151344b39c51051c3dacc3290bcf9</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468382</data>
    </edge>
    <edge source="SRAM" target="Cache Memory">
      <data key="d6">1.0</data>
      <data key="d7">SRAM is commonly used in cache memory due to its high-speed access.</data>
      <data key="d8">application domain</data>
      <data key="d9">chunk-7c2151344b39c51051c3dacc3290bcf9</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468382</data>
    </edge>
    <edge source="SRAM" target="Cache">
      <data key="d6">1.0</data>
      <data key="d7">Cache is composed of SRAM, which contributes to its high-speed operation.</data>
      <data key="d8">material composition,performance criterion</data>
      <data key="d9">chunk-d02693bcc2f3ef38eee5bb553035284e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468625</data>
    </edge>
    <edge source="Storage Cell" target="Storage Matrix">
      <data key="d6">1.0</data>
      <data key="d7">The storage matrix is built from multiple storage cells, each capable of storing a binary digit.</data>
      <data key="d8">composite structure,functional unit</data>
      <data key="d9">chunk-14ad8c0a834e0ce37fd97c7ac9177add</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468060</data>
    </edge>
    <edge source="Storage Cell" target="Binary Representation">
      <data key="d6">1.0</data>
      <data key="d7">Each storage cell has two stable states to represent the binary values 0 and 1.</data>
      <data key="d8">data storage,physical state</data>
      <data key="d9">chunk-14ad8c0a834e0ce37fd97c7ac9177add</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468061</data>
    </edge>
    <edge source="Storage Cell" target="Gate Capacitor">
      <data key="d6">1.0</data>
      <data key="d7">The gate capacitor is the core component of the storage cell responsible for holding electrical charge as data.</data>
      <data key="d8">component,electrical charge</data>
      <data key="d9">chunk-e100f5adcf7f52281eb1c5920bc2d5d0</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468065</data>
    </edge>
    <edge source="Storage Cell" target="Storage Unit">
      <data key="d6">1.0</data>
      <data key="d7">Multiple storage cells with the same address code form a storage unit.</data>
      <data key="d8">component composition</data>
      <data key="d9">chunk-7c2151344b39c51051c3dacc3290bcf9</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468381</data>
    </edge>
    <edge source="Carbon-Fiber Spikes" target="Noah Carter">
      <data key="d6">1.0</data>
      <data key="d7">Noah Carter used carbon-fiber spikes to enhance performance during the race.</data>
      <data key="d8">athletic equipment,performance boost</data>
      <data key="d9">chunk-e100f5adcf7f52281eb1c5920bc2d5d0</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468067</data>
    </edge>
    <edge source="Concentrated Refresh" target="Distributed Refresh">
      <data key="d6">1.0</data>
      <data key="d7">Concentrated refresh introduces dead time but simplifies timing; distributed refresh removes dead time at the cost of increased access cycle.</data>
      <data key="d8">dead time trade-off,refresh strategy</data>
      <data key="d9">chunk-e100f5adcf7f52281eb1c5920bc2d5d0</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468066</data>
    </edge>
    <edge source="Main Memory" target="Storage Matrix">
      <data key="d6">1.0</data>
      <data key="d7">Main memory is structurally composed of a storage matrix, which serves as its central physical arrangement.</data>
      <data key="d8">core architecture,structural component</data>
      <data key="d9">chunk-14ad8c0a834e0ce37fd97c7ac9177add</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468060</data>
    </edge>
    <edge source="Main Memory" target="Addressing">
      <data key="d6">1.0</data>
      <data key="d7">Main memory requires addressing to identify and access individual storage units.</data>
      <data key="d8">data access mechanism,memory organization</data>
      <data key="d9">chunk-14ad8c0a834e0ce37fd97c7ac9177add</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468060</data>
    </edge>
    <edge source="Main Memory" target="Cache">
      <data key="d6">8.0</data>
      <data key="d7">The relation (Cache, Main Memory) denotes the interaction between a high-speed cache memory and the main memory in a computer system's hierarchical memory architecture. The cache stores copies of frequently accessed data from main memory to reduce access latency and accelerate data retrieval, thereby improving overall system performance. This arrangement functions as an intermediary layer between the CPU and main memory, enabling faster access to data that is likely to be reused, as dictated by the principle of locality. Data transfers from main memory to cache occur during memory access operations, typically triggered when the CPU requests data not currently present in the cache, a scenario known as a cache miss, which necessitates fetching the data from main memory. The cache employs address mapping techniques to determine which data from main memory should be stored, ensuring efficient retrieval. To maintain data consistency, synchronization strategies are implemented when updates occur in main memory, as changes must be propagated to the cache to prevent stale data from being used. This dynamic relationship forms a crucial component of modern computing systems, where the faster but smaller cache complements the slower but larger main memory to balance speed, capacity, and cost.</data>
      <data key="d8">access hierarchy,address mapping,cache relationship,caching,data caching,data replication,data synchronization,data transfer,memory hierarchy,speed optimization,storage hierarchy</data>
      <data key="d9">chunk-555f79801ef87ce95e52becac62479d6&lt;SEP&gt;chunk-cef942e7cbaeb916484eb8b3e7bcbd9a&lt;SEP&gt;chunk-833bb1bcf85cd79d91b4dcd6ca2eb3db&lt;SEP&gt;chunk-361185a50ecc6636f127fb6f6ad6eabd&lt;SEP&gt;chunk-e0a87778cef25aba2903a8a3e12c5faa&lt;SEP&gt;chunk-9dccf612396a3accbfe19f8f0ed1d51b&lt;SEP&gt;chunk-d02693bcc2f3ef38eee5bb553035284e&lt;SEP&gt;chunk-6c698405c4fcc8fb19ebad83fe798b48</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468625</data>
    </edge>
    <edge source="Main Memory" target="Disk Storage">
      <data key="d6">1.0</data>
      <data key="d7">Main memory uses disk storage as an extended storage medium to provide larger capacity.</data>
      <data key="d8">data transfer,storage extension</data>
      <data key="d9">chunk-9dccf612396a3accbfe19f8f0ed1d51b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468103</data>
    </edge>
    <edge source="Main Memory" target="Physical Address">
      <data key="d6">1.0</data>
      <data key="d7">The physical address is used to access data stored in main memory.</data>
      <data key="d8">data retrieval,memory access</data>
      <data key="d9">chunk-ed6056f0e58f2d01493e9eeb4c4363bd</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468113</data>
    </edge>
    <edge source="Main Memory" target="Page Table">
      <data key="d6">3.0</data>
      <data key="d7">The page table is stored in main memory and is accessed when a TLB miss occurs.&lt;SEP&gt;The page table is stored in main memory as the primary storage for virtual-to-physical address mapping.&lt;SEP&gt;The page table is stored in main memory and accessed during virtual memory translation.</data>
      <data key="d8">data storage,data structure location,memory hierarchy,memory storage,page table retrieval,system resource</data>
      <data key="d9">chunk-ed6056f0e58f2d01493e9eeb4c4363bd&lt;SEP&gt;chunk-263465ac01c4eb10c3c852d62559620b&lt;SEP&gt;chunk-6c698405c4fcc8fb19ebad83fe798b48</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468274</data>
    </edge>
    <edge source="Main Memory" target="Physical Page">
      <data key="d6">1.0</data>
      <data key="d7">Main memory is composed of physical pages, which serve as the basic storage units.</data>
      <data key="d8">memory allocation,storage unit</data>
      <data key="d9">chunk-0d5d7f0f10bdd7e081046bf9fbfdf10a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468130</data>
    </edge>
    <edge source="Main Memory" target="TLB">
      <data key="d6">1.0</data>
      <data key="d7">TLB stores copies of page table entries from main memory to reduce the number of accesses needed during address translation.</data>
      <data key="d8">caching,memory access optimization</data>
      <data key="d9">chunk-263465ac01c4eb10c3c852d62559620b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468162</data>
    </edge>
    <edge source="Main Memory" target="Virtual Memory">
      <data key="d6">2.0</data>
      <data key="d7">Virtual memory uses main memory as a backing store and expands its effective capacity via secondary storage.&lt;SEP&gt;Virtual memory uses main memory to store frequently accessed data and enables address translation between virtual and physical addresses.</data>
      <data key="d8">address translation,data management,memory expansion,memory management</data>
      <data key="d9">chunk-833bb1bcf85cd79d91b4dcd6ca2eb3db&lt;SEP&gt;chunk-b5dba59d5f9377e5060b73fecdb0de06</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468863</data>
    </edge>
    <edge source="Main Memory" target="CPU">
      <data key="d6">3.0</data>
      <data key="d7">Main memory connects directly to the CPU for real-time data and program execution.&lt;SEP&gt;Main memory connects to the CPU through data, address, and control buses to enable communication and data processing.&lt;SEP&gt;CPU can directly and randomly access data from main memory, which serves as active storage for running programs.</data>
      <data key="d8">data exchange,data processing,direct access,direct connection,execution support</data>
      <data key="d9">chunk-833bb1bcf85cd79d91b4dcd6ca2eb3db&lt;SEP&gt;chunk-f58beb694766dd43b7432ff7d16d2a65&lt;SEP&gt;chunk-ce9d79eec3b8225be9c02cda24c5a519</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468449</data>
    </edge>
    <edge source="Main Memory" target="Page Fault">
      <data key="d6">1.0</data>
      <data key="d7">A page fault occurs when the requested page is not present in main memory.</data>
      <data key="d8">memory state,page absence</data>
      <data key="d9">chunk-b1c06d839960e789e3e60c72b78fd928</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468192</data>
    </edge>
    <edge source="Main Memory" target="Page">
      <data key="d6">2.0</data>
      <data key="d7">Pages may reside in main memory; a page miss implies the page is not in main memory.&lt;SEP&gt;Pages are blocks of memory moved between main memory and secondary storage during virtual memory operations.</data>
      <data key="d8">allocation,data transfer,memory block,page residence</data>
      <data key="d9">chunk-b5dba59d5f9377e5060b73fecdb0de06&lt;SEP&gt;chunk-6c698405c4fcc8fb19ebad83fe798b48</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468864</data>
    </edge>
    <edge source="Main Memory" target="Multilevel Storage System">
      <data key="d6">1.0</data>
      <data key="d7">The multilevel storage system includes main memory as the primary active memory.</data>
      <data key="d8">central storage,structured hierarchy</data>
      <data key="d9">chunk-6c698405c4fcc8fb19ebad83fe798b48</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468273</data>
    </edge>
    <edge source="Main Memory" target="DRAM Chip">
      <data key="d6">1.0</data>
      <data key="d7">DRAM chips are used to implement main memory in computers.</data>
      <data key="d8">implementation,primary storage</data>
      <data key="d9">chunk-84c8d12524cbd30a01b0da556f764478</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468326</data>
    </edge>
    <edge source="Main Memory" target="Memory Module">
      <data key="d6">1.0</data>
      <data key="d7">Multiple memory modules contribute to the overall main memory space of a computer.</data>
      <data key="d8">component integration,system memory assembly</data>
      <data key="d9">chunk-f58beb694766dd43b7432ff7d16d2a65</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468354</data>
    </edge>
    <edge source="Main Memory" target="ROM Chip">
      <data key="d6">1.0</data>
      <data key="d7">ROM chips on the motherboard are part of the broader computing system that supports main memory operations.</data>
      <data key="d8">memory setup,system component integration</data>
      <data key="d9">chunk-f58beb694766dd43b7432ff7d16d2a65</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468355</data>
    </edge>
    <edge source="Main Memory" target="Main Memory Capacity">
      <data key="d6">1.0</data>
      <data key="d7">Main Memory Capacity defines the total storage space available in the main memory.</data>
      <data key="d8">storage size</data>
      <data key="d9">chunk-e0a87778cef25aba2903a8a3e12c5faa</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468394</data>
    </edge>
    <edge source="Main Memory" target="Cache Memory">
      <data key="d6">1.0</data>
      <data key="d7">Main memory exchanges data with cache memory to improve CPU access speed by storing frequently used instructions and data.</data>
      <data key="d8">data synchronization,performance enhancement</data>
      <data key="d9">chunk-ce9d79eec3b8225be9c02cda24c5a519</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468450</data>
    </edge>
    <edge source="Main Memory" target="Auxiliary Memory">
      <data key="d6">1.0</data>
      <data key="d7">Auxiliary memory stores data not currently in main memory and transfers it to main memory before CPU access.</data>
      <data key="d8">data transfer,secondary storage</data>
      <data key="d9">chunk-ce9d79eec3b8225be9c02cda24c5a519</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468450</data>
    </edge>
    <edge source="Main Memory" target="Random Access Memory">
      <data key="d6">1.0</data>
      <data key="d7">RAM is primarily used as main memory due to its flexibility and fast access for running processes.</data>
      <data key="d8">primary role,usage</data>
      <data key="d9">chunk-ce9d79eec3b8225be9c02cda24c5a519</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468451</data>
    </edge>
    <edge source="Main Memory" target="Read-Only Memory">
      <data key="d6">1.0</data>
      <data key="d7">ROM is a component of main memory, used to store fixed data and instructions that do not change.</data>
      <data key="d8">component,system integration</data>
      <data key="d9">chunk-ce9d79eec3b8225be9c02cda24c5a519</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468451</data>
    </edge>
    <edge source="Main Memory" target="Volatile Memory">
      <data key="d6">1.0</data>
      <data key="d7">Volatile memory such as RAM loses data upon power loss and is used for temporary storage during operations.</data>
      <data key="d8">characteristic attribute,data retention</data>
      <data key="d9">chunk-ce9d79eec3b8225be9c02cda24c5a519</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468452</data>
    </edge>
    <edge source="Main Memory" target="CPU Memory Access">
      <data key="d6">1.0</data>
      <data key="d7">When a cache miss occurs, the CPU retrieves data directly from main memory.</data>
      <data key="d8">data fetch,fallback access</data>
      <data key="d9">chunk-361185a50ecc6636f127fb6f6ad6eabd</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468609</data>
    </edge>
    <edge source="Main Memory" target="Virtual Address">
      <data key="d6">1.0</data>
      <data key="d7">Virtual addresses are mapped to physical addresses in main memory for data access.</data>
      <data key="d8">address mapping,memory access</data>
      <data key="d9">chunk-b5dba59d5f9377e5060b73fecdb0de06</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468864</data>
    </edge>
    <edge source="Main Memory" target="Segment">
      <data key="d6">1.0</data>
      <data key="d7">Segments are blocks of memory that may be loaded into main memory during transitions from secondary storage.</data>
      <data key="d8">data transfer,memory block</data>
      <data key="d9">chunk-b5dba59d5f9377e5060b73fecdb0de06</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468864</data>
    </edge>
    <edge source="Storage Matrix" target="Address Decoder">
      <data key="d6">1.0</data>
      <data key="d7">The address decoder activates specific storage cells within the storage matrix based on the incoming address.</data>
      <data key="d8">access control,selection mechanism</data>
      <data key="d9">chunk-14ad8c0a834e0ce37fd97c7ac9177add</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468061</data>
    </edge>
    <edge source="Storage Matrix" target="Read/Write Control Circuit">
      <data key="d6">1.0</data>
      <data key="d7">The read/write control circuit manages access to the storage matrix, enabling read or write operations.</data>
      <data key="d8">memory access,operation control</data>
      <data key="d9">chunk-14ad8c0a834e0ce37fd97c7ac9177add</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468062</data>
    </edge>
    <edge source="Storage Matrix" target="Data Bus">
      <data key="d6">1.0</data>
      <data key="d7">The data bus carries data to and from the storage matrix during read and write operations.</data>
      <data key="d8">data transfer path,memory access</data>
      <data key="d9">chunk-14ad8c0a834e0ce37fd97c7ac9177add</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468063</data>
    </edge>
    <edge source="Addressing" target="Byte Addressing">
      <data key="d6">1.0</data>
      <data key="d7">Byte addressing is one of the primary methods used to assign addresses to memory units.</data>
      <data key="d8">addressing mode,memory organization</data>
      <data key="d9">chunk-14ad8c0a834e0ce37fd97c7ac9177add</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468062</data>
    </edge>
    <edge source="Addressing" target="Word Addressing">
      <data key="d6">1.0</data>
      <data key="d7">Word addressing is an alternative method where entire words are assigned addresses.</data>
      <data key="d8">addressing mode,memory organization</data>
      <data key="d9">chunk-14ad8c0a834e0ce37fd97c7ac9177add</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468063</data>
    </edge>
    <edge source="Byte Addressing" target="64-Bit Data Bus">
      <data key="d6">1.0</data>
      <data key="d7">With a 64-bit data bus and byte addressing, the system can access up to 8 storage units per operation.</data>
      <data key="d8">access capability,data throughput</data>
      <data key="d9">chunk-14ad8c0a834e0ce37fd97c7ac9177add</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468063</data>
    </edge>
    <edge source="MAR" target="CPU">
      <data key="d6">1.0</data>
      <data key="d7">The CPU sends the memory address to the MAR before initiating a memory access operation.</data>
      <data key="d8">address transmission,control register</data>
      <data key="d9">chunk-14ad8c0a834e0ce37fd97c7ac9177add</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468060</data>
    </edge>
    <edge source="MAR" target="Address Bus">
      <data key="d6">1.0</data>
      <data key="d7">The MAR outputs the memory address to the address bus, which carries it to the main memory.</data>
      <data key="d8">address signal transmission</data>
      <data key="d9">chunk-14ad8c0a834e0ce37fd97c7ac9177add</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468060</data>
    </edge>
    <edge source="Row Address" target="Column Address">
      <data key="d6">1.0</data>
      <data key="d7">Row and column addresses are input sequentially through the same address pins using address pin multiplexing.</data>
      <data key="d8">address multiplexing,sequential input</data>
      <data key="d9">chunk-e100f5adcf7f52281eb1c5920bc2d5d0</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468065</data>
    </edge>
    <edge source="Bit Price" target="Unit Cost">
      <data key="d6">1.0</data>
      <data key="d7">Unit cost is quantified as bit price, defined as total cost divided by total capacity.</data>
      <data key="d8">equivalent metric</data>
      <data key="d9">chunk-3c1c3cb1cdfefa986a82277dd52e88ef</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468738</data>
    </edge>
    <edge source="MDR" target="CPU">
      <data key="d6">1.0</data>
      <data key="d7">The CPU uses the MDR to hold data being read from or written to memory.</data>
      <data key="d8">data register,data transmission</data>
      <data key="d9">chunk-14ad8c0a834e0ce37fd97c7ac9177add</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468060</data>
    </edge>
    <edge source="MDR" target="Data Bus">
      <data key="d6">1.0</data>
      <data key="d7">The MDR interfaces with the data bus to transfer data between the CPU and main memory.</data>
      <data key="d8">data exchange,data transfer path</data>
      <data key="d9">chunk-14ad8c0a834e0ce37fd97c7ac9177add</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468062</data>
    </edge>
    <edge source="MDR" target="Storage Word Length">
      <data key="d6">1.0</data>
      <data key="d7">The MDR’s bit width usually equals the storage word length, unless restricted by data bus width.</data>
      <data key="d8">data width,register size</data>
      <data key="d9">chunk-14ad8c0a834e0ce37fd97c7ac9177add</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468063</data>
    </edge>
    <edge source="Address Bus" target="Address Decoder">
      <data key="d6">1.0</data>
      <data key="d7">The address bus delivers the address to the address decoder, which then selects the correct memory cell.</data>
      <data key="d8">address selection,signal transmission</data>
      <data key="d9">chunk-14ad8c0a834e0ce37fd97c7ac9177add</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468062</data>
    </edge>
    <edge source="Address Bus" target="Maximum Memory Space">
      <data key="d6">1.0</data>
      <data key="d7">The number of bits in the address bus defines the maximum memory space that can be addressed.</data>
      <data key="d8">addressing capability,capacity limitation</data>
      <data key="d9">chunk-f58beb694766dd43b7432ff7d16d2a65</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468351</data>
    </edge>
    <edge source="Data Bus" target="Storage Word Length">
      <data key="d6">1.0</data>
      <data key="d7">The width of the data bus typically matches the storage word length, determining the data size transferred per cycle.</data>
      <data key="d8">data width,register alignment</data>
      <data key="d9">chunk-14ad8c0a834e0ce37fd97c7ac9177add</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468064</data>
    </edge>
    <edge source="Data Bus" target="Data Transfer Rate">
      <data key="d6">1.0</data>
      <data key="d7">The bit width and operating frequency of the data bus directly determine the data transfer rate.</data>
      <data key="d8">performance indicator,proportional relationship</data>
      <data key="d9">chunk-f58beb694766dd43b7432ff7d16d2a65</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468351</data>
    </edge>
    <edge source="Read/Write Control Circuit" target="CPU">
      <data key="d6">1.0</data>
      <data key="d7">The CPU sends read/write control signals via control lines to the read/write control circuit in main memory.</data>
      <data key="d8">control signal transmission,memory operation</data>
      <data key="d9">chunk-14ad8c0a834e0ce37fd97c7ac9177add</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468062</data>
    </edge>
    <edge source="Address Decoder" target="Decoder-Based Chip Selection">
      <data key="d6">1.0</data>
      <data key="d7">The address decoder is a key component in implementing decoder-based chip selection.</data>
      <data key="d8">component integration</data>
      <data key="d9">chunk-a438ed247c5a79e72ee6372aba002ee0</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468306</data>
    </edge>
    <edge source="CPU" target="Cache">
      <data key="d6">4.0</data>
      <data key="d7">The CPU first accesses the cache when retrieving data, which reduces latency compared to direct access to main memory.&lt;SEP&gt;Cache is directly accessible by the CPU, enabling faster data retrieval during execution.&lt;SEP&gt;CPU issues read and write requests to Cache for data access.&lt;SEP&gt;Cache is directly integrated with the CPU to reduce data access latency and enhance system efficiency.</data>
      <data key="d8">access request,data access,data retrieval,direct access,hardware integration,performance bottleneck,performance enhancement</data>
      <data key="d9">chunk-833bb1bcf85cd79d91b4dcd6ca2eb3db&lt;SEP&gt;chunk-d02693bcc2f3ef38eee5bb553035284e&lt;SEP&gt;chunk-e0a87778cef25aba2903a8a3e12c5faa&lt;SEP&gt;chunk-9dccf612396a3accbfe19f8f0ed1d51b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468609</data>
    </edge>
    <edge source="CPU" target="High-Speed Buffering Technology">
      <data key="d6">1.0</data>
      <data key="d7">High-Speed Buffering Technology improves CPU performance by reducing memory access latency through faster cache-based operations.</data>
      <data key="d8">performance optimization,system improvement</data>
      <data key="d9">chunk-3dce61048f7c557d41879fb4d9705cdc</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468118</data>
    </edge>
    <edge source="CPU" target="Storage Chip">
      <data key="d6">2.0</data>
      <data key="d7">The CPU connects to the storage chip through address lines, data lines, and control signals to manage data storage and retrieval.&lt;SEP&gt;The CPU controls the selection of storage chips through chip select signals.</data>
      <data key="d8">access,control,control signal transmission,memory interface</data>
      <data key="d9">chunk-a438ed247c5a79e72ee6372aba002ee0&lt;SEP&gt;chunk-946a56828431f2eb84c208ded0826aae</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468303</data>
    </edge>
    <edge source="CPU" target="Address Line">
      <data key="d6">1.0</data>
      <data key="d7">The CPU uses its address lines to identify specific memory locations within storage chips.</data>
      <data key="d8">address decoding,signal generation</data>
      <data key="d9">chunk-946a56828431f2eb84c208ded0826aae</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468225</data>
    </edge>
    <edge source="CPU" target="Data Line">
      <data key="d6">1.0</data>
      <data key="d7">The CPU transfers data via data lines, requiring alignment with the storage chip’s data width through expansion if necessary.</data>
      <data key="d8">bit-width alignment,data transmission</data>
      <data key="d9">chunk-946a56828431f2eb84c208ded0826aae</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468225</data>
    </edge>
    <edge source="CPU" target="Read/Write Control Line">
      <data key="d6">1.0</data>
      <data key="d7">The CPU uses the read/write control line to determine whether to read from or write to the storage chip.</data>
      <data key="d8">data direction,operation control</data>
      <data key="d9">chunk-946a56828431f2eb84c208ded0826aae</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468226</data>
    </edge>
    <edge source="CPU" target="Chip Select Control Line">
      <data key="d6">1.0</data>
      <data key="d7">The CPU drives the chip select control line to activate a specific storage chip during memory operations.</data>
      <data key="d8">access control,chip selection</data>
      <data key="d9">chunk-946a56828431f2eb84c208ded0826aae</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468226</data>
    </edge>
    <edge source="CPU" target="MREQ">
      <data key="d6">1.0</data>
      <data key="d7">The MREQ signal from the CPU indicates a memory access request and is used to trigger chip selection.</data>
      <data key="d8">memory access indication,signal dependency</data>
      <data key="d9">chunk-946a56828431f2eb84c208ded0826aae</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468227</data>
    </edge>
    <edge source="CPU" target="External Decoder Logic">
      <data key="d6">1.0</data>
      <data key="d7">External decoder logic interprets high-order CPU address lines to generate chip select signals.</data>
      <data key="d8">chip selection logic,high-order addressing</data>
      <data key="d9">chunk-946a56828431f2eb84c208ded0826aae</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468227</data>
    </edge>
    <edge source="CPU" target="Single-Body Multi-Word Memory">
      <data key="d6">1.0</data>
      <data key="d7">Single-body multi-word memory allows the CPU to receive one instruction every 1/m access cycle, optimizing instruction execution speed.</data>
      <data key="d8">instruction timing,performance optimization</data>
      <data key="d9">chunk-8f87fc865b405b5892e67cab1873a773</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468278</data>
    </edge>
    <edge source="CPU" target="Word Select">
      <data key="d6">1.0</data>
      <data key="d7">The CPU issues word select commands using low-order address lines to access specific storage units.</data>
      <data key="d8">instruction execution</data>
      <data key="d9">chunk-a438ed247c5a79e72ee6372aba002ee0</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468305</data>
    </edge>
    <edge source="CPU" target="Chip Select">
      <data key="d6">1.0</data>
      <data key="d7">The CPU determines which memory chip is selected using high-order address lines.</data>
      <data key="d8">control signal generation</data>
      <data key="d9">chunk-a438ed247c5a79e72ee6372aba002ee0</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468306</data>
    </edge>
    <edge source="CPU" target="Data Transfer Unit">
      <data key="d6">1.0</data>
      <data key="d7">CPU transfers data with Cache in units of single bytes, while Cache and Main Memory exchange data in blocks.</data>
      <data key="d8">access granularity,hardware interaction</data>
      <data key="d9">chunk-e0a87778cef25aba2903a8a3e12c5faa</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468396</data>
    </edge>
    <edge source="CPU" target="Cache Memory">
      <data key="d6">1.0</data>
      <data key="d7">Cache memory is positioned between CPU and main memory to deliver data at speeds comparable to the CPU.</data>
      <data key="d8">high-speed access,speed matching</data>
      <data key="d9">chunk-ce9d79eec3b8225be9c02cda24c5a519</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468450</data>
    </edge>
    <edge source="CPU" target="虚拟地址">
      <data key="d6">1.0</data>
      <data key="d7">The CPU generates virtual addresses for memory access, which are later translated.</data>
      <data key="d8">address generation,memory access</data>
      <data key="d9">chunk-0af5a7c8d38a4b5d1e4bac2d53e20424</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468775</data>
    </edge>
    <edge source="Destructive Readout" target="Memory System">
      <data key="d6">1.0</data>
      <data key="d7">Destructive readout necessitates regeneration after reading, requiring immediate refresh to maintain data integrity.</data>
      <data key="d8">data recovery,read mechanism</data>
      <data key="d9">chunk-ce9d79eec3b8225be9c02cda24c5a519</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468451</data>
    </edge>
    <edge source="Destructive Readout" target="Restoration Time">
      <data key="d6">1.0</data>
      <data key="d7">Destructive readout requires restoration time to regenerate data after each access.</data>
      <data key="d8">operational dependency,recovery requirement</data>
      <data key="d9">chunk-3c1c3cb1cdfefa986a82277dd52e88ef</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468738</data>
    </edge>
    <edge source="Destructive Readout" target="Access Cycle">
      <data key="d6">1.0</data>
      <data key="d7">In destructive readout systems, the access cycle can be significantly longer than access time, often reaching twice the access time (Tm = 2Ta).</data>
      <data key="d8">extended cycle,timing impact</data>
      <data key="d9">chunk-3c1c3cb1cdfefa986a82277dd52e88ef</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468740</data>
    </edge>
    <edge source="100m Sprint Record" target="Noah Carter">
      <data key="d6">1.0</data>
      <data key="d7">Noah Carter set a new 100m sprint record at the championship.</data>
      <data key="d8">athlete achievement,record-breaking</data>
      <data key="d9">chunk-e100f5adcf7f52281eb1c5920bc2d5d0</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468066</data>
    </edge>
    <edge source="36-Bit Address Bus" target="Addressable Memory Space">
      <data key="d6">1.0</data>
      <data key="d7">A 36-bit address bus allows access to a maximum of 2^36 memory locations, ranging from 0 to 2^36 - 1.</data>
      <data key="d8">address range,memory capacity</data>
      <data key="d9">chunk-14ad8c0a834e0ce37fd97c7ac9177add</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468062</data>
    </edge>
    <edge source="Noah Carter" target="World Athletics Championship">
      <data key="d6">1.0</data>
      <data key="d7">Noah Carter is competing at the World Athletics Championship.</data>
      <data key="d8">athlete participation,competition</data>
      <data key="d9">chunk-e100f5adcf7f52281eb1c5920bc2d5d0</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468068</data>
    </edge>
    <edge source="Tokyo" target="World Athletics Championship">
      <data key="d6">1.0</data>
      <data key="d7">The World Athletics Championship is being hosted in Tokyo.</data>
      <data key="d8">event location,international competition</data>
      <data key="d9">chunk-e100f5adcf7f52281eb1c5920bc2d5d0</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468067</data>
    </edge>
    <edge source="Multi-Level Storage System" target="Storage Hierarchy Structure">
      <data key="d6">1.0</data>
      <data key="d7">The multi-level storage system is based on the concept of a storage hierarchy structure that organizes memory layers in a cascading manner.</data>
      <data key="d8">architectural principle,system design</data>
      <data key="d9">chunk-9dccf612396a3accbfe19f8f0ed1d51b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468102</data>
    </edge>
    <edge source="Cache" target="Physical Address">
      <data key="d6">1.0</data>
      <data key="d7">The Cache uses the physical address to determine which cache line or set to access based on its mapping method.</data>
      <data key="d8">data caching,mapping</data>
      <data key="d9">chunk-ed6056f0e58f2d01493e9eeb4c4363bd</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468112</data>
    </edge>
    <edge source="Cache" target="Replacement Policy">
      <data key="d6">1.0</data>
      <data key="d7">When the Cache is full, the Replacement Policy determines which data to remove to make room for new data.</data>
      <data key="d8">cache management,eviction</data>
      <data key="d9">chunk-ed6056f0e58f2d01493e9eeb4c4363bd</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468113</data>
    </edge>
    <edge source="Cache" target="Tag Field">
      <data key="d6">1.0</data>
      <data key="d7">The Cache compares the tag field from the physical address with the stored tag to determine if a cache hit has occurred.</data>
      <data key="d8">data validation,hit detection</data>
      <data key="d9">chunk-ed6056f0e58f2d01493e9eeb4c4363bd</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468114</data>
    </edge>
    <edge source="Cache" target="High-Speed Buffering Technology">
      <data key="d6">1.0</data>
      <data key="d7">High-Speed Buffering Technology utilizes Cache to store frequently accessed data for faster retrieval.</data>
      <data key="d8">implementation,technology use</data>
      <data key="d9">chunk-3dce61048f7c557d41879fb4d9705cdc</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468117</data>
    </edge>
    <edge source="Cache" target="TLB">
      <data key="d6">1.0</data>
      <data key="d7">TLB operates similarly to cache memory, using fast SRAM and mapping techniques to improve access speed.</data>
      <data key="d8">design similarity,speed optimization</data>
      <data key="d9">chunk-263465ac01c4eb10c3c852d62559620b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468164</data>
    </edge>
    <edge source="Cache" target="System Performance">
      <data key="d6">1.0</data>
      <data key="d7">Cache improves system performance by reducing average access time to frequently used data.</data>
      <data key="d8">memory optimization,performance enhancement</data>
      <data key="d9">chunk-833bb1bcf85cd79d91b4dcd6ca2eb3db</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468183</data>
    </edge>
    <edge source="Cache" target="Hardware">
      <data key="d6">1.0</data>
      <data key="d7">Cache is fully implemented in hardware, making it a physical component of the system.</data>
      <data key="d8">implementation,physical design</data>
      <data key="d9">chunk-833bb1bcf85cd79d91b4dcd6ca2eb3db</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468184</data>
    </edge>
    <edge source="Cache" target="Cache Miss">
      <data key="d6">2.0</data>
      <data key="d7">A cache miss results in slower data access as the system must fetch data from main memory.&lt;SEP&gt;When CPU accesses data not in Cache, a Cache Miss occurs, requiring access to Main Memory.</data>
      <data key="d8">access failure,main memory access,performance impact</data>
      <data key="d9">chunk-833bb1bcf85cd79d91b4dcd6ca2eb3db&lt;SEP&gt;chunk-e0a87778cef25aba2903a8a3e12c5faa</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468396</data>
    </edge>
    <edge source="Cache" target="Virtual Memory">
      <data key="d6">2.0</data>
      <data key="d7">Both virtual memory and cache are part of the memory hierarchy, with cache optimizing speed and virtual memory optimizing capacity.&lt;SEP&gt;Virtual memory employs techniques similar to cache by caching frequently accessed data from secondary storage into main memory.</data>
      <data key="d8">memory hierarchy,performance optimization,similar technology,speed vs. capacity trade-off</data>
      <data key="d9">chunk-833bb1bcf85cd79d91b4dcd6ca2eb3db&lt;SEP&gt;chunk-b5dba59d5f9377e5060b73fecdb0de06</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468864</data>
    </edge>
    <edge source="Cache" target="Information Block">
      <data key="d6">1.0</data>
      <data key="d7">Both cache and virtual memory use information blocks as the fundamental unit for data exchange.</data>
      <data key="d8">data unit,exchange mechanism</data>
      <data key="d9">chunk-833bb1bcf85cd79d91b4dcd6ca2eb3db</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468189</data>
    </edge>
    <edge source="Cache" target="Replacement Algorithm">
      <data key="d6">3.0</data>
      <data key="d7">Replacement algorithms manage which data is removed from cache when space is full.&lt;SEP&gt;Replacement algorithms are used to manage cache lines when cache space is full.&lt;SEP&gt;When Cache is full, a Replacement Algorithm selects which block to evict to make space for new data.</data>
      <data key="d8">data eviction,implementation,management,management strategy,performance optimization,space utilization</data>
      <data key="d9">chunk-833bb1bcf85cd79d91b4dcd6ca2eb3db&lt;SEP&gt;chunk-e0a87778cef25aba2903a8a3e12c5faa&lt;SEP&gt;chunk-555f79801ef87ce95e52becac62479d6</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468396</data>
    </edge>
    <edge source="Cache" target="Update Strategy">
      <data key="d6">1.0</data>
      <data key="d7">Update strategies ensure data consistency between cache and main memory during writes.</data>
      <data key="d8">data consistency,write policy</data>
      <data key="d9">chunk-833bb1bcf85cd79d91b4dcd6ca2eb3db</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468191</data>
    </edge>
    <edge source="Cache" target="Address Mapping">
      <data key="d6">1.0</data>
      <data key="d7">Address mapping is used in cache to translate logical addresses into physical locations.</data>
      <data key="d8">memory access,translation process</data>
      <data key="d9">chunk-833bb1bcf85cd79d91b4dcd6ca2eb3db</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468192</data>
    </edge>
    <edge source="Cache" target="Multilevel Storage System">
      <data key="d6">1.0</data>
      <data key="d7">The multilevel storage system includes cache as an intermediate storage layer between CPU and main memory.</data>
      <data key="d8">performance optimization,structured hierarchy</data>
      <data key="d9">chunk-6c698405c4fcc8fb19ebad83fe798b48</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468272</data>
    </edge>
    <edge source="Cache" target="CPU Memory Access">
      <data key="d6">2.0</data>
      <data key="d7">CPU memory access checks the cache for data before accessing main memory.&lt;SEP&gt;CPU accesses data through the cache, checking for a hit before falling back to main memory.</data>
      <data key="d8">data retrieval,hit/miss handling,performance layer</data>
      <data key="d9">chunk-361185a50ecc6636f127fb6f6ad6eabd&lt;SEP&gt;chunk-6c698405c4fcc8fb19ebad83fe798b48</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468608</data>
    </edge>
    <edge source="Cache" target="SRAM Chip">
      <data key="d6">1.0</data>
      <data key="d7">SRAM chips are used to implement cache memory due to their speed and proximity to the processor.</data>
      <data key="d8">implementation,proximity to processor</data>
      <data key="d9">chunk-84c8d12524cbd30a01b0da556f764478</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468326</data>
    </edge>
    <edge source="Cache" target="Full Associative Mapping">
      <data key="d6">1.0</data>
      <data key="d7">Full Associative Mapping allows flexible placement of main memory blocks into cache lines.</data>
      <data key="d8">mapping technique,storage</data>
      <data key="d9">chunk-555f79801ef87ce95e52becac62479d6</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468357</data>
    </edge>
    <edge source="Cache" target="Set Associative Mapping">
      <data key="d6">2.0</data>
      <data key="d7">Set Associative Mapping partitions cache into groups for improved efficiency and reduced conflict.&lt;SEP&gt;Set associative mapping balances cost and performance by combining direct and fully associative mappings.</data>
      <data key="d8">hybrid mapping,mapping technique,performance balance,storage</data>
      <data key="d9">chunk-361185a50ecc6636f127fb6f6ad6eabd&lt;SEP&gt;chunk-555f79801ef87ce95e52becac62479d6</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468608</data>
    </edge>
    <edge source="Cache" target="Direct Mapping">
      <data key="d6">1.0</data>
      <data key="d7">Direct Mapping assigns each main memory block to a single fixed cache line, minimizing complexity but increasing conflict.</data>
      <data key="d8">conflict avoidance,fixed mapping</data>
      <data key="d9">chunk-555f79801ef87ce95e52becac62479d6</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468358</data>
    </edge>
    <edge source="Cache" target="Cache Line">
      <data key="d6">1.0</data>
      <data key="d7">Cache Line is the smallest unit of data storage in a cache.</data>
      <data key="d8">data block,unit of storage</data>
      <data key="d9">chunk-555f79801ef87ce95e52becac62479d6</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468358</data>
    </edge>
    <edge source="Cache" target="Cache Group">
      <data key="d6">1.0</data>
      <data key="d7">Cache Group is part of the cache architecture used in set-associative mapping.</data>
      <data key="d8">system component</data>
      <data key="d9">chunk-555f79801ef87ce95e52becac62479d6</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468358</data>
    </edge>
    <edge source="Cache" target="Thrashing">
      <data key="d6">1.0</data>
      <data key="d7">Thrashing occurs when the working set exceeds cache capacity, causing frequent replacements and reduced performance.</data>
      <data key="d8">performance degradation,system failure mode</data>
      <data key="d9">chunk-555f79801ef87ce95e52becac62479d6</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468358</data>
    </edge>
    <edge source="Cache" target="Main Memory Block">
      <data key="d6">1.0</data>
      <data key="d7">A main memory block is loaded into cache when accessed, forming a cache line.</data>
      <data key="d8">caching,data transfer</data>
      <data key="d9">chunk-555f79801ef87ce95e52becac62479d6</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468359</data>
    </edge>
    <edge source="Cache" target="Cache Block">
      <data key="d6">1.0</data>
      <data key="d7">Cache is organized into Cache Blocks, which are the fundamental units of data stored in Cache.</data>
      <data key="d8">data unit,storage structure</data>
      <data key="d9">chunk-e0a87778cef25aba2903a8a3e12c5faa</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468394</data>
    </edge>
    <edge source="Cache" target="Cache Capacity">
      <data key="d6">1.0</data>
      <data key="d7">Cache Capacity limits the number of Cache Blocks the Cache can hold.</data>
      <data key="d8">size limitation</data>
      <data key="d9">chunk-e0a87778cef25aba2903a8a3e12c5faa</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468395</data>
    </edge>
    <edge source="Cache" target="Cache Hit">
      <data key="d6">1.0</data>
      <data key="d7">When CPU accesses data in Cache and finds it, a Cache Hit occurs, enabling fast access.</data>
      <data key="d8">access outcome,performance optimization</data>
      <data key="d9">chunk-e0a87778cef25aba2903a8a3e12c5faa</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468396</data>
    </edge>
    <edge source="Cache" target="Write Policy">
      <data key="d6">1.0</data>
      <data key="d7">Write Policy governs how data changes in Cache are propagated to Main Memory to maintain consistency.</data>
      <data key="d8">data consistency,update strategy</data>
      <data key="d9">chunk-e0a87778cef25aba2903a8a3e12c5faa</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468397</data>
    </edge>
    <edge source="Cache" target="Hardware Implementation">
      <data key="d6">1.0</data>
      <data key="d7">All Cache operations, including hit/miss handling and replacement, are executed automatically by hardware.</data>
      <data key="d8">automated management,system level operation</data>
      <data key="d9">chunk-e0a87778cef25aba2903a8a3e12c5faa</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468397</data>
    </edge>
    <edge source="Cache" target="Write Through">
      <data key="d6">1.0</data>
      <data key="d7">Write Through is a method used by Cache to ensure that data written to Cache is also written to main memory immediately.</data>
      <data key="d8">operation mode,write strategy</data>
      <data key="d9">chunk-cef942e7cbaeb916484eb8b3e7bcbd9a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468478</data>
    </edge>
    <edge source="Cache" target="Write Back">
      <data key="d6">1.0</data>
      <data key="d7">Write Back is a method where Cache updates are delayed until the block is replaced, minimizing main memory accesses.</data>
      <data key="d8">operation mode,write strategy</data>
      <data key="d9">chunk-cef942e7cbaeb916484eb8b3e7bcbd9a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468479</data>
    </edge>
    <edge source="Cache" target="Write Allocate">
      <data key="d6">1.0</data>
      <data key="d7">Write Allocate is a strategy used by Cache during write misses to load a block into Cache before writing.</data>
      <data key="d8">cache management,write operation</data>
      <data key="d9">chunk-cef942e7cbaeb916484eb8b3e7bcbd9a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468479</data>
    </edge>
    <edge source="Cache" target="Not-Write-Allocate">
      <data key="d6">1.0</data>
      <data key="d7">Not-Write-Allocate is a strategy used by Cache to update main memory without loading the block into Cache during write misses.</data>
      <data key="d8">cache management,write operation</data>
      <data key="d9">chunk-cef942e7cbaeb916484eb8b3e7bcbd9a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468479</data>
    </edge>
    <edge source="Cache" target="Dirty Bit">
      <data key="d6">1.0</data>
      <data key="d7">The Dirty Bit in Cache indicates whether a block has been modified and needs to be written back to main memory.</data>
      <data key="d8">replacement decision,state tracking</data>
      <data key="d9">chunk-cef942e7cbaeb916484eb8b3e7bcbd9a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468480</data>
    </edge>
    <edge source="Cache" target="Separate Cache Structure">
      <data key="d6">1.0</data>
      <data key="d7">The Separate Cache Structure is a design approach that divides Cache into instruction and data components for improved performance.</data>
      <data key="d8">architectural design,performance</data>
      <data key="d9">chunk-cef942e7cbaeb916484eb8b3e7bcbd9a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468480</data>
    </edge>
    <edge source="Cache" target="L1 Cache">
      <data key="d6">1.0</data>
      <data key="d7">L1 Cache is the first level of Cache hierarchy, located closest to the CPU with the fastest access speed.</data>
      <data key="d8">hierarchical level,proximity to CPU</data>
      <data key="d9">chunk-cef942e7cbaeb916484eb8b3e7bcbd9a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468480</data>
    </edge>
    <edge source="Cache" target="L2 Cache">
      <data key="d6">1.0</data>
      <data key="d7">L2 Cache is the second level of Cache hierarchy, larger in size and slower in access speed than L1 Cache.</data>
      <data key="d8">capacity,hierarchical level</data>
      <data key="d9">chunk-cef942e7cbaeb916484eb8b3e7bcbd9a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468480</data>
    </edge>
    <edge source="Cache" target="Instruction Cache">
      <data key="d6">1.0</data>
      <data key="d7">Instruction Cache is a dedicated cache used to store instruction data for faster instruction fetching.</data>
      <data key="d8">instruction storage,specialized cache</data>
      <data key="d9">chunk-cef942e7cbaeb916484eb8b3e7bcbd9a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468481</data>
    </edge>
    <edge source="Cache" target="Data Cache">
      <data key="d6">1.0</data>
      <data key="d7">Data Cache is a dedicated cache used to store data for faster data access during processing.</data>
      <data key="d8">data storage,specialized cache</data>
      <data key="d9">chunk-cef942e7cbaeb916484eb8b3e7bcbd9a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468481</data>
    </edge>
    <edge source="Virtual Storage System" target="Address Space">
      <data key="d6">1.0</data>
      <data key="d7">The virtual storage system provides a programmer-accessible address space that is larger than the physical main memory.</data>
      <data key="d8">abstraction,logical memory</data>
      <data key="d9">chunk-9dccf612396a3accbfe19f8f0ed1d51b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468102</data>
    </edge>
    <edge source="Virtual Storage System" target="Programmer">
      <data key="d6">1.0</data>
      <data key="d7">Programmers can work within a virtual address space that is larger than actual physical main memory, thanks to the virtual storage system.</data>
      <data key="d8">address space access,programming abstraction</data>
      <data key="d9">chunk-9dccf612396a3accbfe19f8f0ed1d51b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468103</data>
    </edge>
    <edge source="Hardware" target="Cache- Main Memory Layer">
      <data key="d6">1.0</data>
      <data key="d7">Hardware autonomously handles data movement between cache and main memory, which is transparent to all programmers.</data>
      <data key="d8">automatic management,transparency</data>
      <data key="d9">chunk-9dccf612396a3accbfe19f8f0ed1d51b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468104</data>
    </edge>
    <edge source="Hardware" target="Cache Miss">
      <data key="d6">1.0</data>
      <data key="d7">Cache misses are handled automatically by hardware to maintain performance.</data>
      <data key="d8">automatic handling,system performance</data>
      <data key="d9">chunk-6c698405c4fcc8fb19ebad83fe798b48</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468270</data>
    </edge>
    <edge source="Operating System" target="Main Memory- Auxiliary Storage Layer">
      <data key="d6">1.0</data>
      <data key="d7">The operating system plays a critical role in managing data transfer between main memory and auxiliary storage.</data>
      <data key="d8">data coordination,system management</data>
      <data key="d9">chunk-9dccf612396a3accbfe19f8f0ed1d51b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468104</data>
    </edge>
    <edge source="Operating System" target="Virtual Memory">
      <data key="d6">2.0</data>
      <data key="d7">The operating system plays a key role in managing virtual memory by handling page tables and backing store interactions.&lt;SEP&gt;The operating system implements virtual memory through page fault handling and memory allocation policies.</data>
      <data key="d8">memory management,policy implementation,system coordination</data>
      <data key="d9">chunk-833bb1bcf85cd79d91b4dcd6ca2eb3db</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468184</data>
    </edge>
    <edge source="Operating System" target="Page Fault">
      <data key="d6">1.0</data>
      <data key="d7">The operating system handles page faults by loading the required page into main memory.</data>
      <data key="d8">error handler,page loading</data>
      <data key="d9">chunk-b1c06d839960e789e3e60c72b78fd928</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468191</data>
    </edge>
    <edge source="Cache- Main Memory Layer" target="Speed-Matching Solution">
      <data key="d6">1.0</data>
      <data key="d7">This layer resolves the speed mismatch between the CPU and main memory through hardware-managed data transfers that are transparent to programmers.</data>
      <data key="d8">hardware transparency,performance optimization</data>
      <data key="d9">chunk-9dccf612396a3accbfe19f8f0ed1d51b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468102</data>
    </edge>
    <edge source="Main Memory- Auxiliary Storage Layer" target="Capacity Expansion Solution">
      <data key="d6">1.0</data>
      <data key="d7">This layer addresses storage capacity limitations by allowing data to be swapped between main memory and auxiliary storage, managed by hardware and the operating system in a transparent way to application programmers.</data>
      <data key="d8">scalability,system transparency</data>
      <data key="d9">chunk-9dccf612396a3accbfe19f8f0ed1d51b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468102</data>
    </edge>
    <edge source="Address Space" target="Line Selection Method">
      <data key="d6">1.0</data>
      <data key="d7">The line selection method results in non-continuous address spaces, leading to inefficiencies.</data>
      <data key="d8">address continuity</data>
      <data key="d9">chunk-a438ed247c5a79e72ee6372aba002ee0</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468305</data>
    </edge>
    <edge source="TLB" target="Virtual Page Number">
      <data key="d6">1.0</data>
      <data key="d7">The TLB stores virtual page numbers and their corresponding physical page numbers, enabling fast address translation.</data>
      <data key="d8">address translation,lookup</data>
      <data key="d9">chunk-ed6056f0e58f2d01493e9eeb4c4363bd</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468112</data>
    </edge>
    <edge source="TLB" target="Full Associative TLB">
      <data key="d6">1.0</data>
      <data key="d7">The Full Associative TLB is a specific configuration of the TLB that allows any virtual page to be stored in any entry.</data>
      <data key="d8">organization,structure</data>
      <data key="d9">chunk-ed6056f0e58f2d01493e9eeb4c4363bd</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468113</data>
    </edge>
    <edge source="TLB" target="Virtual Memory">
      <data key="d6">1.0</data>
      <data key="d7">Virtual Memory relies on the TLB to speed up the mapping of virtual addresses to physical ones.</data>
      <data key="d8">caching,virtual address translation</data>
      <data key="d9">chunk-ed6056f0e58f2d01493e9eeb4c4363bd</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468114</data>
    </edge>
    <edge source="TLB" target="Virtual Address Translation">
      <data key="d6">1.0</data>
      <data key="d7">TLB accelerates virtual address translation by providing rapid access to page table entries.</data>
      <data key="d8">address resolution,performance enhancement</data>
      <data key="d9">chunk-263465ac01c4eb10c3c852d62559620b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468163</data>
    </edge>
    <edge source="TLB" target="Locality Principle">
      <data key="d6">1.0</data>
      <data key="d7">The effectiveness of TLB relies on the locality principle, as frequently accessed pages are kept in the TLB.</data>
      <data key="d8">computer architecture principle,efficiency</data>
      <data key="d9">chunk-263465ac01c4eb10c3c852d62559620b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468163</data>
    </edge>
    <edge source="TLB" target="Full Associative Mapping">
      <data key="d6">1.0</data>
      <data key="d7">In full associative mapping, the entire virtual page number serves as the TLB tag to identify matching entries.</data>
      <data key="d8">mapping strategy,tag usage</data>
      <data key="d9">chunk-263465ac01c4eb10c3c852d62559620b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468164</data>
    </edge>
    <edge source="TLB" target="Set Associative Mapping">
      <data key="d6">1.0</data>
      <data key="d7">In set associative mapping, the virtual page number is split, with the high bits used as a tag and low bits as the set index.</data>
      <data key="d8">indexing,mapping strategy</data>
      <data key="d9">chunk-263465ac01c4eb10c3c852d62559620b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468165</data>
    </edge>
    <edge source="TLB" target="Slow Table">
      <data key="d6">1.0</data>
      <data key="d7">TLB serves as a high-speed cache for the slow table (page table in main memory), reducing the need to access slower main memory during address translation.</data>
      <data key="d8">memory hierarchy,performance contrast</data>
      <data key="d9">chunk-263465ac01c4eb10c3c852d62559620b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468165</data>
    </edge>
    <edge source="TLB" target="Page">
      <data key="d6">1.0</data>
      <data key="d7">TLB stores translations of virtual page addresses to physical addresses, and a TLB miss implies a need to access the page table.</data>
      <data key="d8">cache relationship,virtual memory lookup</data>
      <data key="d9">chunk-6c698405c4fcc8fb19ebad83fe798b48</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468270</data>
    </edge>
    <edge source="TLB" target="Multilevel Storage System">
      <data key="d6">1.0</data>
      <data key="d7">The multilevel storage system includes TLB as a high-speed component for virtual address translation.</data>
      <data key="d8">performance optimization,structured hierarchy</data>
      <data key="d9">chunk-6c698405c4fcc8fb19ebad83fe798b48</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468271</data>
    </edge>
    <edge source="TLB" target="CPU Memory Access">
      <data key="d6">1.0</data>
      <data key="d7">CPU memory access initiates a lookup in the TLB to resolve virtual-to-physical address translation.</data>
      <data key="d8">cache lookup,memory request</data>
      <data key="d9">chunk-6c698405c4fcc8fb19ebad83fe798b48</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468272</data>
    </edge>
    <edge source="2 Way Set Associative Cache" target="Cache Line">
      <data key="d6">1.0</data>
      <data key="d7">In a 2-way set associative cache, each cache line belongs to one of two possible slots within a set.</data>
      <data key="d8">indexing,mapping strategy</data>
      <data key="d9">chunk-ed6056f0e58f2d01493e9eeb4c4363bd</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468112</data>
    </edge>
    <edge source="Virtual Page Number" target="TLB Entry">
      <data key="d6">1.0</data>
      <data key="d7">A TLB entry stores the virtual page number as part of its mapping to physical memory.</data>
      <data key="d8">mapping content,virtual-to-physical mapping</data>
      <data key="d9">chunk-263465ac01c4eb10c3c852d62559620b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468163</data>
    </edge>
    <edge source="Virtual Page Number" target="Page Table">
      <data key="d6">1.0</data>
      <data key="d7">The virtual page number is used as an index to locate the corresponding entry in the page table.</data>
      <data key="d8">lookup,translation input</data>
      <data key="d9">chunk-b1c06d839960e789e3e60c72b78fd928</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468189</data>
    </edge>
    <edge source="Virtual Page Number" target="Physical Page Number">
      <data key="d6">1.0</data>
      <data key="d7">Virtual page numbers are translated into physical page numbers through the page table or TLB.</data>
      <data key="d8">memory mapping,translation</data>
      <data key="d9">chunk-6c698405c4fcc8fb19ebad83fe798b48</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468272</data>
    </edge>
    <edge source="Page Directory Index" target="Page Table">
      <data key="d6">1.0</data>
      <data key="d7">The Page Directory Index is used to locate the appropriate page table entry in a two-level page table system.</data>
      <data key="d8">hierarchical mapping,page table indexing</data>
      <data key="d9">chunk-ed6056f0e58f2d01493e9eeb4c4363bd</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468112</data>
    </edge>
    <edge source="Page Table Index" target="Page Table">
      <data key="d6">1.0</data>
      <data key="d7">The Page Table Index is used to find the specific page table entry within the selected page table.</data>
      <data key="d8">hierarchical mapping,page table indexing</data>
      <data key="d9">chunk-ed6056f0e58f2d01493e9eeb4c4363bd</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468113</data>
    </edge>
    <edge source="Page Table" target="Virtual Memory">
      <data key="d6">1.0</data>
      <data key="d7">Virtual Memory uses a two-level page table to manage the translation between virtual and physical addresses.</data>
      <data key="d8">hierarchical structure,virtual address translation</data>
      <data key="d9">chunk-ed6056f0e58f2d01493e9eeb4c4363bd</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468113</data>
    </edge>
    <edge source="Page Table" target="Physical Page">
      <data key="d6">1.0</data>
      <data key="d7">The page table records the location of each virtual page when loaded into physical page in main memory.</data>
      <data key="d8">mapping,storage location</data>
      <data key="d9">chunk-0d5d7f0f10bdd7e081046bf9fbfdf10a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468130</data>
    </edge>
    <edge source="Page Table" target="Virtual Page">
      <data key="d6">1.0</data>
      <data key="d7">The page table stores the mapping between virtual pages and their corresponding physical pages.</data>
      <data key="d8">address translation,mapping</data>
      <data key="d9">chunk-0d5d7f0f10bdd7e081046bf9fbfdf10a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468131</data>
    </edge>
    <edge source="Page Table" target="Page-Based Virtual Memory">
      <data key="d6">1.0</data>
      <data key="d7">The page table is typically stored in main memory and remains there for duration of process execution.</data>
      <data key="d8">data structure,persistent storage</data>
      <data key="d9">chunk-0d5d7f0f10bdd7e081046bf9fbfdf10a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468131</data>
    </edge>
    <edge source="Page Table" target="Physical Page Number">
      <data key="d6">1.0</data>
      <data key="d7">The page table provides the mapping from virtual page numbers to physical page numbers.</data>
      <data key="d8">data lookup,mapping</data>
      <data key="d9">chunk-b1c06d839960e789e3e60c72b78fd928</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468190</data>
    </edge>
    <edge source="Page Table" target="Page Table Base Register">
      <data key="d6">1.0</data>
      <data key="d7">The page table base register stores the address of the first entry in the process's page table.</data>
      <data key="d8">access point,base address</data>
      <data key="d9">chunk-b1c06d839960e789e3e60c72b78fd928</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468191</data>
    </edge>
    <edge source="Page Table" target="Page Fault">
      <data key="d6">1.0</data>
      <data key="d7">A page fault occurs when the page table entry indicates that a page is not currently loaded into main memory.</data>
      <data key="d8">error condition,handling trigger</data>
      <data key="d9">chunk-b1c06d839960e789e3e60c72b78fd928</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468191</data>
    </edge>
    <edge source="Page Table" target="Page">
      <data key="d6">1.0</data>
      <data key="d7">The page table maintains mappings between virtual pages and their physical equivalents.</data>
      <data key="d8">mapping relationship,virtual memory management</data>
      <data key="d9">chunk-6c698405c4fcc8fb19ebad83fe798b48</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468273</data>
    </edge>
    <edge source="Page Table" target="CPU Memory Access">
      <data key="d6">1.0</data>
      <data key="d7">When TLB misses, CPU memory access must access the page table to translate virtual addresses.</data>
      <data key="d8">page mapping,translation</data>
      <data key="d9">chunk-6c698405c4fcc8fb19ebad83fe798b48</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468273</data>
    </edge>
    <edge source="Physical Address" target="Block Offset">
      <data key="d6">1.0</data>
      <data key="d7">The Block Offset is used to select a specific byte within a cache block once the correct cache line is located.</data>
      <data key="d8">byte-level addressing,data selection</data>
      <data key="d9">chunk-ed6056f0e58f2d01493e9eeb4c4363bd</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468114</data>
    </edge>
    <edge source="Physical Address" target="Virtual Address">
      <data key="d6">1.0</data>
      <data key="d7">The virtual address is translated into a physical address using the page table for data and instruction retrieval from main memory.</data>
      <data key="d8">address translation,memory access</data>
      <data key="d9">chunk-b1c06d839960e789e3e60c72b78fd928</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468190</data>
    </edge>
    <edge source="Physical Address" target="Page Offset">
      <data key="d6">1.0</data>
      <data key="d7">The physical address is divided into a physical page number (high bits) and a page offset (low bits), with the page offset matching that of the virtual address.</data>
      <data key="d8">address component,field division</data>
      <data key="d9">chunk-b1c06d839960e789e3e60c72b78fd928</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468191</data>
    </edge>
    <edge source="Physical Address" target="Real Address Space">
      <data key="d6">1.0</data>
      <data key="d7">Physical addresses refer to locations in the real address space, corresponding to main memory.</data>
      <data key="d8">actual storage,memory location</data>
      <data key="d9">chunk-b5dba59d5f9377e5060b73fecdb0de06</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468863</data>
    </edge>
    <edge source="Physical Address" target="Virtual Memory">
      <data key="d6">1.0</data>
      <data key="d7">Virtual memory translates virtual addresses into physical addresses for memory access.</data>
      <data key="d8">access mechanism,translation</data>
      <data key="d9">chunk-b5dba59d5f9377e5060b73fecdb0de06</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468865</data>
    </edge>
    <edge source="Cache Line" target="Cache Line Replacement">
      <data key="d6">1.0</data>
      <data key="d7">When a new block is loaded and no space is available, a cache line undergoes replacement.</data>
      <data key="d8">operation,replacement process</data>
      <data key="d9">chunk-555f79801ef87ce95e52becac62479d6</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468357</data>
    </edge>
    <edge source="Cache Line" target="Cache Block">
      <data key="d6">1.0</data>
      <data key="d7">Cache Block and Cache Line refer to the same concept, representing a single data unit in the Cache.</data>
      <data key="d8">data unit,synonym</data>
      <data key="d9">chunk-e0a87778cef25aba2903a8a3e12c5faa</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468395</data>
    </edge>
    <edge source="Cache Line" target="Block">
      <data key="d6">1.0</data>
      <data key="d7">Each cache line holds a copy of a block from main memory.</data>
      <data key="d8">data replication,mapping</data>
      <data key="d9">chunk-361185a50ecc6636f127fb6f6ad6eabd</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468606</data>
    </edge>
    <edge source="Cache Line" target="Tag">
      <data key="d6">1.0</data>
      <data key="d7">The tag field in a cache line identifies the corresponding main memory block.</data>
      <data key="d8">identification,metadata</data>
      <data key="d9">chunk-361185a50ecc6636f127fb6f6ad6eabd</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468607</data>
    </edge>
    <edge source="Cache Line" target="Valid Bit">
      <data key="d6">1.0</data>
      <data key="d7">The valid bit indicates whether the data in the cache line is a valid copy of a main memory block.</data>
      <data key="d8">data validity,state tracking</data>
      <data key="d9">chunk-361185a50ecc6636f127fb6f6ad6eabd</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468608</data>
    </edge>
    <edge source="Virtual Memory" target="System Performance">
      <data key="d6">1.0</data>
      <data key="d7">Virtual memory improves system performance by enabling the execution of large programs beyond physical memory limits.</data>
      <data key="d8">memory optimization,performance enhancement</data>
      <data key="d9">chunk-833bb1bcf85cd79d91b4dcd6ca2eb3db</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468183</data>
    </edge>
    <edge source="Virtual Memory" target="Secondary Storage">
      <data key="d6">2.0</data>
      <data key="d7">Virtual memory relies on secondary storage to provide space for data not currently in main memory.&lt;SEP&gt;Virtual memory extends the address space using secondary storage, storing less frequently accessed data.</data>
      <data key="d8">address space extension,backing storage,data persistence</data>
      <data key="d9">chunk-833bb1bcf85cd79d91b4dcd6ca2eb3db&lt;SEP&gt;chunk-b5dba59d5f9377e5060b73fecdb0de06</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468863</data>
    </edge>
    <edge source="Virtual Memory" target="Information Block">
      <data key="d6">1.0</data>
      <data key="d7">Virtual memory uses information blocks, typically pages, as the unit of data transfer between main and secondary memory.</data>
      <data key="d8">data unit,exchange mechanism</data>
      <data key="d9">chunk-833bb1bcf85cd79d91b4dcd6ca2eb3db</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468185</data>
    </edge>
    <edge source="Virtual Memory" target="Address Mapping">
      <data key="d6">1.0</data>
      <data key="d7">Address mapping is essential for converting virtual addresses to physical addresses in virtual memory.</data>
      <data key="d8">memory access,translation process</data>
      <data key="d9">chunk-833bb1bcf85cd79d91b4dcd6ca2eb3db</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468186</data>
    </edge>
    <edge source="Virtual Memory" target="Replacement Algorithm">
      <data key="d6">2.0</data>
      <data key="d7">Replacement algorithms determine which virtual pages are evicted during memory management.&lt;SEP&gt;The virtual memory system uses a replacement algorithm to manage memory occupancy when main memory is full.</data>
      <data key="d8">data eviction,memory management,performance optimization</data>
      <data key="d9">chunk-833bb1bcf85cd79d91b4dcd6ca2eb3db&lt;SEP&gt;chunk-b5dba59d5f9377e5060b73fecdb0de06</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468865</data>
    </edge>
    <edge source="Virtual Memory" target="Update Strategy">
      <data key="d6">1.0</data>
      <data key="d7">Update strategies in virtual memory govern how modified pages are written back to secondary storage.</data>
      <data key="d8">data consistency,page write policy</data>
      <data key="d9">chunk-833bb1bcf85cd79d91b4dcd6ca2eb3db</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468189</data>
    </edge>
    <edge source="Virtual Memory" target="Write-Back">
      <data key="d6">1.0</data>
      <data key="d7">Write-back is used in virtual memory to delay writing data to secondary storage, improving efficiency.</data>
      <data key="d8">data consistency,write optimization</data>
      <data key="d9">chunk-b5dba59d5f9377e5060b73fecdb0de06</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468864</data>
    </edge>
    <edge source="Virtual Memory" target="Full Associative Mapping">
      <data key="d6">1.0</data>
      <data key="d7">Full associative mapping allows virtual pages to be stored in any free location in main memory, improving hit rates.</data>
      <data key="d8">memory placement,page mapping</data>
      <data key="d9">chunk-b5dba59d5f9377e5060b73fecdb0de06</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468864</data>
    </edge>
    <edge source="Virtual Memory" target="Virtual Space">
      <data key="d6">1.0</data>
      <data key="d7">Virtual memory organizes virtual space to allow programs to operate independently with their own logical address spaces.</data>
      <data key="d8">address space management,program isolation</data>
      <data key="d9">chunk-b5dba59d5f9377e5060b73fecdb0de06</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468865</data>
    </edge>
    <edge source="Virtual Memory" target="Fault">
      <data key="d6">1.0</data>
      <data key="d7">Virtual memory system handles faults by loading missing pages from secondary storage when accessed.</data>
      <data key="d8">error handling,page retrieval</data>
      <data key="d9">chunk-b5dba59d5f9377e5060b73fecdb0de06</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468866</data>
    </edge>
    <edge source="Program Access Locality Principle" target="Time Locality">
      <data key="d6">2.0</data>
      <data key="d7">The Program Access Locality Principle includes time locality as a fundamental component.&lt;SEP&gt;Time locality is a key basis for the Program Access Locality Principle.</data>
      <data key="d8">conceptual basis,conceptual relationship,dependence,principle component</data>
      <data key="d9">chunk-3dce61048f7c557d41879fb4d9705cdc</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468117</data>
    </edge>
    <edge source="Program Access Locality Principle" target="Spatial Locality">
      <data key="d6">2.0</data>
      <data key="d7">The Program Access Locality Principle includes spatial locality as a fundamental component.&lt;SEP&gt;Spatial locality is a key basis for the Program Access Locality Principle.</data>
      <data key="d8">conceptual basis,conceptual relationship,dependence,principle component</data>
      <data key="d9">chunk-3dce61048f7c557d41879fb4d9705cdc</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468117</data>
    </edge>
    <edge source="Spatial Locality" target="Write Allocate">
      <data key="d6">1.0</data>
      <data key="d7">Write Allocate exploits spatial locality by loading blocks into Cache during write misses.</data>
      <data key="d8">utilization of locality,write strategy</data>
      <data key="d9">chunk-cef942e7cbaeb916484eb8b3e7bcbd9a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468476</data>
    </edge>
    <edge source="Page-Based Virtual Memory" target="Physical Page">
      <data key="d6">1.0</data>
      <data key="d7">Page-based virtual memory uses physical pages as units of allocation in main memory.</data>
      <data key="d8">addressing,memory management</data>
      <data key="d9">chunk-0d5d7f0f10bdd7e081046bf9fbfdf10a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468129</data>
    </edge>
    <edge source="Page-Based Virtual Memory" target="Virtual Page">
      <data key="d6">1.0</data>
      <data key="d7">Page-based virtual memory organizes virtual address space into virtual pages.</data>
      <data key="d8">addressing,memory management</data>
      <data key="d9">chunk-0d5d7f0f10bdd7e081046bf9fbfdf10a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468130</data>
    </edge>
    <edge source="Virtual Page" target="Virtual Address Space">
      <data key="d6">1.0</data>
      <data key="d7">Virtual address space is divided into equal-sized virtual pages.</data>
      <data key="d8">division,memory structure</data>
      <data key="d9">chunk-0d5d7f0f10bdd7e081046bf9fbfdf10a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468129</data>
    </edge>
    <edge source="ROM" target="Non-Volatile">
      <data key="d6">1.0</data>
      <data key="d7">ROM is non-volatile, meaning it retains stored information even when power is removed.</data>
      <data key="d8">data retention,non-volatility</data>
      <data key="d9">chunk-8ce34f8853facbe5658d8d7a94051590</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468134</data>
    </edge>
    <edge source="ROM" target="Structural Simplicity">
      <data key="d6">1.0</data>
      <data key="d7">ROM has a simple structure, which results in higher bit density compared to read-write memories.</data>
      <data key="d8">design efficiency,high bit density</data>
      <data key="d9">chunk-8ce34f8853facbe5658d8d7a94051590</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468134</data>
    </edge>
    <edge source="ROM" target="Bit Density">
      <data key="d6">1.0</data>
      <data key="d7">The structural simplicity of ROM enables higher bit density, improving storage efficiency.</data>
      <data key="d8">efficiency,storage capacity</data>
      <data key="d9">chunk-8ce34f8853facbe5658d8d7a94051590</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468135</data>
    </edge>
    <edge source="RAM" target="Random Access">
      <data key="d6">1.0</data>
      <data key="d7">RAM supports random access, allowing fast and direct access to any stored data.</data>
      <data key="d8">memory access,performance</data>
      <data key="d9">chunk-8ce34f8853facbe5658d8d7a94051590</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468134</data>
    </edge>
    <edge source="Locality Principle" target="Fast Cache">
      <data key="d6">1.0</data>
      <data key="d7">The locality principle underpins the fast cache concept by predicting which data will be accessed next.</data>
      <data key="d8">data placement,design foundation</data>
      <data key="d9">chunk-833bb1bcf85cd79d91b4dcd6ca2eb3db</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468184</data>
    </edge>
    <edge source="Locality Principle" target="LRU Algorithm">
      <data key="d6">1.0</data>
      <data key="d7">LRU Algorithm is based on the principle of locality, improving hit rate by replacing infrequently accessed lines.</data>
      <data key="d8">algorithm justification,theoretical basis</data>
      <data key="d9">chunk-555f79801ef87ce95e52becac62479d6</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468356</data>
    </edge>
    <edge source="Locality Principle" target="FIFO Algorithm">
      <data key="d6">1.0</data>
      <data key="d7">FIFO Algorithm does not leverage locality principle, leading to potentially lower efficiency.</data>
      <data key="d8">conceptual limitation,performance</data>
      <data key="d9">chunk-555f79801ef87ce95e52becac62479d6</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468357</data>
    </edge>
    <edge source="Set Associative Mapping" target="Cache Group">
      <data key="d6">1.0</data>
      <data key="d7">Cache Group is a structural component in set-associative mapping, grouping cache lines for selective placement.</data>
      <data key="d8">mapping structure,storage unit</data>
      <data key="d9">chunk-555f79801ef87ce95e52becac62479d6</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468357</data>
    </edge>
    <edge source="Set Associative Mapping" target="Main Memory Block Number">
      <data key="d6">1.0</data>
      <data key="d7">In set associative mapping, the group (set) number is determined by the higher-order bits of the main memory block number.</data>
      <data key="d8">group assignment,mapping rule</data>
      <data key="d9">chunk-361185a50ecc6636f127fb6f6ad6eabd</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468606</data>
    </edge>
    <edge source="Set Associative Mapping" target="Figure 3.20">
      <data key="d6">1.0</data>
      <data key="d7">Figure 3.20 illustrates the structure and operation of set associative mapping in cache memory.</data>
      <data key="d8">diagrammatic representation,visual aid</data>
      <data key="d9">chunk-361185a50ecc6636f127fb6f6ad6eabd</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468608</data>
    </edge>
    <edge source="Set Associative Mapping" target="2-Way Set Associative">
      <data key="d6">1.0</data>
      <data key="d7">2-Way set associative is a specific case of set associative mapping where each set contains two lines.</data>
      <data key="d8">configuration variant,performance trade-off</data>
      <data key="d9">chunk-361185a50ecc6636f127fb6f6ad6eabd</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468609</data>
    </edge>
    <edge source="TLB Tag" target="TLB Entry">
      <data key="d6">1.0</data>
      <data key="d7">A TLB entry includes a TLB tag field to identify the corresponding virtual page.</data>
      <data key="d8">data composition,entry structure</data>
      <data key="d9">chunk-263465ac01c4eb10c3c852d62559620b</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468162</data>
    </edge>
    <edge source="System Performance" target="Cache Miss">
      <data key="d6">1.0</data>
      <data key="d7">A cache miss degrades system performance due to increased access time to main memory.</data>
      <data key="d8">latency impact,performance cost</data>
      <data key="d9">chunk-833bb1bcf85cd79d91b4dcd6ca2eb3db</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468188</data>
    </edge>
    <edge source="System Performance" target="Page Fault">
      <data key="d6">1.0</data>
      <data key="d7">A page fault significantly impacts system performance due to slower access to secondary storage.</data>
      <data key="d8">latency impact,performance cost</data>
      <data key="d9">chunk-833bb1bcf85cd79d91b4dcd6ca2eb3db</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468189</data>
    </edge>
    <edge source="Replacement Algorithm" target="Random Algorithm">
      <data key="d6">1.0</data>
      <data key="d7">Random Algorithm is a simple implementation of replacement in cache management.</data>
      <data key="d8">implementation,randomness</data>
      <data key="d9">chunk-555f79801ef87ce95e52becac62479d6</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468354</data>
    </edge>
    <edge source="Replacement Algorithm" target="FIFO Algorithm">
      <data key="d6">1.0</data>
      <data key="d7">FIFO Algorithm manages cache replacement based on the order of insertion.</data>
      <data key="d8">first-in-first-out,implementation</data>
      <data key="d9">chunk-555f79801ef87ce95e52becac62479d6</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468354</data>
    </edge>
    <edge source="Replacement Algorithm" target="LRU Algorithm">
      <data key="d6">1.0</data>
      <data key="d7">LRU Algorithm is implemented using LRU replacement bits to track access recency.</data>
      <data key="d8">implementation,locality-driven,policy-based</data>
      <data key="d9">chunk-555f79801ef87ce95e52becac62479d6</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468355</data>
    </edge>
    <edge source="Replacement Algorithm" target="LFU Algorithm">
      <data key="d6">1.0</data>
      <data key="d7">LFU Algorithm uses counters to track access frequency for replacement decisions.</data>
      <data key="d8">frequency-based,implementation</data>
      <data key="d9">chunk-555f79801ef87ce95e52becac62479d6</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468355</data>
    </edge>
    <edge source="Replacement Algorithm" target="Main Memory Full">
      <data key="d6">1.0</data>
      <data key="d7">When main memory is full, a replacement algorithm determines which page to remove.</data>
      <data key="d8">memory management,page replacement</data>
      <data key="d9">chunk-b5dba59d5f9377e5060b73fecdb0de06</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468863</data>
    </edge>
    <edge source="Virtual Memory System" target="Page Fault">
      <data key="d6">1.0</data>
      <data key="d7">Page faults occur when data is not present in main memory and must be retrieved from secondary storage in a virtual memory system.</data>
      <data key="d8">memory access failure,system event</data>
      <data key="d9">chunk-833bb1bcf85cd79d91b4dcd6ca2eb3db</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468184</data>
    </edge>
    <edge source="Virtual Address" target="Page Offset">
      <data key="d6">1.0</data>
      <data key="d7">The virtual address is divided into a virtual page number (high bits) and a page offset (low bits).</data>
      <data key="d8">address component,field division</data>
      <data key="d9">chunk-b1c06d839960e789e3e60c72b78fd928</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468189</data>
    </edge>
    <edge source="Virtual Address" target="Virtual Space">
      <data key="d6">1.0</data>
      <data key="d7">Virtual addresses define the logical memory space visible to a program, also known as virtual space.</data>
      <data key="d8">address representation,logical view</data>
      <data key="d9">chunk-b5dba59d5f9377e5060b73fecdb0de06</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468863</data>
    </edge>
    <edge source="Page Table Base Register" target="Process">
      <data key="d6">1.0</data>
      <data key="d7">Each process has its own page table base register that holds the base address of its page table.</data>
      <data key="d8">context storage,ownership</data>
      <data key="d9">chunk-b1c06d839960e789e3e60c72b78fd928</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468190</data>
    </edge>
    <edge source="主存容量的扩展" target="位扩展法">
      <data key="d6">1.0</data>
      <data key="d7">主存容量的扩展includes位扩展法as one of its core techniques to increase word length.</data>
      <data key="d8">memory expansion,method combination</data>
      <data key="d9">chunk-d6bddd3dfdc4b05e9f684acd41e40adb</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468221</data>
    </edge>
    <edge source="主存容量的扩展" target="字扩展法">
      <data key="d6">1.0</data>
      <data key="d7">主存容量的扩展includes字扩展法as one of its core techniques to increase storage word count.</data>
      <data key="d8">memory expansion,method combination</data>
      <data key="d9">chunk-d6bddd3dfdc4b05e9f684acd41e40adb</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468224</data>
    </edge>
    <edge source="主存容量的扩展" target="字位同时扩展法">
      <data key="d6">1.0</data>
      <data key="d7">主存容量的扩展includes字位同时扩展法as a combined approach of both bit and word expansion.</data>
      <data key="d8">memory expansion,method combination</data>
      <data key="d9">chunk-d6bddd3dfdc4b05e9f684acd41e40adb</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468225</data>
    </edge>
    <edge source="位扩展法" target="存储芯片">
      <data key="d6">1.0</data>
      <data key="d7">位扩展法connects multiple存储芯片in parallel, with their data lines separately connected to the system data lines to extend word length.</data>
      <data key="d8">data width extension,parallel connection</data>
      <data key="d9">chunk-d6bddd3dfdc4b05e9f684acd41e40adb</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468223</data>
    </edge>
    <edge source="位扩展法" target="字位同时扩展法">
      <data key="d6">1.0</data>
      <data key="d7">字位同时扩展法is a composite method that integrates位扩展法within groups of chips.</data>
      <data key="d8">combination,composite method</data>
      <data key="d9">chunk-d6bddd3dfdc4b05e9f684acd41e40adb</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468224</data>
    </edge>
    <edge source="字扩展法" target="存储芯片">
      <data key="d6">1.0</data>
      <data key="d7">字扩展法uses system address line higher bits to decode chip select signals for different存储芯片, enabling expansion of storage word count.</data>
      <data key="d8">address-based selection,word count extension</data>
      <data key="d9">chunk-d6bddd3dfdc4b05e9f684acd41e40adb</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468221</data>
    </edge>
    <edge source="字扩展法" target="字位同时扩展法">
      <data key="d6">1.0</data>
      <data key="d7">字位同时扩展法is a composite method that integrates字扩展法through the use of higher address lines and decoding.</data>
      <data key="d8">combination,composite method</data>
      <data key="d9">chunk-d6bddd3dfdc4b05e9f684acd41e40adb</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468223</data>
    </edge>
    <edge source="系统总线" target="并联">
      <data key="d6">1.0</data>
      <data key="d7">各芯片的数据线和读/写控制线are connected in并联to the系统总线to allow simultaneous access to the same data and control signals.</data>
      <data key="d8">data control,parallel signal connection</data>
      <data key="d9">chunk-d6bddd3dfdc4b05e9f684acd41e40adb</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468223</data>
    </edge>
    <edge source="片选控制线" target="高位译码">
      <data key="d6">1.0</data>
      <data key="d7">片选控制线is generated by the output of高位译码to activate specific存储芯片.</data>
      <data key="d8">chip activation,signal generation</data>
      <data key="d9">chunk-d6bddd3dfdc4b05e9f684acd41e40adb</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468224</data>
    </edge>
    <edge source="高位译码" target="系统地址线">
      <data key="d6">1.0</data>
      <data key="d7">系统地址线higher bits are used in高位译码to generate individual chip select signals.</data>
      <data key="d8">chip selection,signal decoding</data>
      <data key="d9">chunk-d6bddd3dfdc4b05e9f684acd41e40adb</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468221</data>
    </edge>
    <edge source="低位连接" target="系统地址线">
      <data key="d6">1.0</data>
      <data key="d7">系统地址线lower bits are connected to the corresponding address lines of存储芯片for addressing.</data>
      <data key="d8">address line connection,address mapping</data>
      <data key="d9">chunk-d6bddd3dfdc4b05e9f684acd41e40adb</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468224</data>
    </edge>
    <edge source="Storage Chip" target="Data Line">
      <data key="d6">1.0</data>
      <data key="d7">The storage chip connects to data lines to exchange data, requiring matching or expanded bit widths with the CPU.</data>
      <data key="d8">bit width compatibility,data interfacing</data>
      <data key="d9">chunk-946a56828431f2eb84c208ded0826aae</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468225</data>
    </edge>
    <edge source="Storage Chip" target="Read/Write Control Line">
      <data key="d6">1.0</data>
      <data key="d7">The storage chip uses the read/write control line to perform either a read or write operation based on control signals.</data>
      <data key="d8">access mode,operation execution</data>
      <data key="d9">chunk-946a56828431f2eb84c208ded0826aae</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468225</data>
    </edge>
    <edge source="Storage Chip" target="Chip Select Control Line">
      <data key="d6">1.0</data>
      <data key="d7">The storage chip activates only when the chip select control line receives a valid signal from the CPU.</data>
      <data key="d8">activation,enable signal</data>
      <data key="d9">chunk-946a56828431f2eb84c208ded0826aae</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468226</data>
    </edge>
    <edge source="Storage Chip" target="Address Line">
      <data key="d6">1.0</data>
      <data key="d7">The storage chip uses its address lines to select a specific memory cell or unit within the chip.</data>
      <data key="d8">address decoding,cell selection</data>
      <data key="d9">chunk-946a56828431f2eb84c208ded0826aae</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468226</data>
    </edge>
    <edge source="Storage Chip" target="Chip Interior Logic">
      <data key="d6">1.0</data>
      <data key="d7">Chip interior logic handles the decoding of lower-order address lines within the storage chip for internal cell selection.</data>
      <data key="d8">cell addressing,internal decodin</data>
      <data key="d9">chunk-946a56828431f2eb84c208ded0826aae</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468227</data>
    </edge>
    <edge source="Memory Access Request" target="MREQ">
      <data key="d6">1.0</data>
      <data key="d7">A memory access request is valid only when the MREQ signal is asserted (low), indicating the CPU is accessing memory.</data>
      <data key="d8">access validity,control signal dependency</data>
      <data key="d9">chunk-946a56828431f2eb84c208ded0826aae</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468226</data>
    </edge>
    <edge source="MROM" target="Semiconductor Manufacturing Process">
      <data key="d6">1.0</data>
      <data key="d7">MROM is created using the semiconductor manufacturing process, where data is embedded during chip fabrication and cannot be changed afterward.</data>
      <data key="d8">manufacturing method,permanent data writing</data>
      <data key="d9">chunk-364aa0dbd990ea22dbb324056cc5473e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468252</data>
    </edge>
    <edge source="PROM" target="Programming">
      <data key="d6">1.0</data>
      <data key="d7">PROM allows users to program data once using a programmer, with the data becoming permanent after the initial write.</data>
      <data key="d8">one-time write,user programming</data>
      <data key="d9">chunk-364aa0dbd990ea22dbb324056cc5473e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468252</data>
    </edge>
    <edge source="EPROM" target="Programming">
      <data key="d6">1.0</data>
      <data key="d7">EPROM can be programmed by users and later erased and reprogrammed multiple times using ultraviolet light.</data>
      <data key="d8">multiple revisions,user programming</data>
      <data key="d9">chunk-364aa0dbd990ea22dbb324056cc5473e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468253</data>
    </edge>
    <edge source="EPROM" target="Ultraviolet Erasure">
      <data key="d6">1.0</data>
      <data key="d7">EPROM requires exposure to ultraviolet light to erase stored data, enabling multiple rewriting cycles.</data>
      <data key="d8">erasure method,reprogrammability</data>
      <data key="d9">chunk-364aa0dbd990ea22dbb324056cc5473e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468253</data>
    </edge>
    <edge source="Flash Memory" target="Electric Erasure">
      <data key="d6">1.0</data>
      <data key="d7">Flash Memory uses electric erasure to quickly erase and rewrite data, allowing efficient updates.</data>
      <data key="d8">erasure method,high-speed updating</data>
      <data key="d9">chunk-364aa0dbd990ea22dbb324056cc5473e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468252</data>
    </edge>
    <edge source="Flash Memory" target="Non-Volatile Storage">
      <data key="d6">1.0</data>
      <data key="d7">Flash Memory retains data without power, fulfilling the core requirement of non-volatile storage.</data>
      <data key="d8">data persistence,power-independent storage</data>
      <data key="d9">chunk-364aa0dbd990ea22dbb324056cc5473e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468253</data>
    </edge>
    <edge source="Flash Memory" target="Integration Density">
      <data key="d6">1.0</data>
      <data key="d7">Flash Memory achieves high integration density, allowing a large number of memory cells in a small area.</data>
      <data key="d8">compact design,high integration</data>
      <data key="d9">chunk-364aa0dbd990ea22dbb324056cc5473e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468253</data>
    </edge>
    <edge source="Flash Memory" target="Cost Efficiency">
      <data key="d6">1.0</data>
      <data key="d7">Flash Memory benefits from cost efficiency due to mass production and low manufacturing expense per bit.</data>
      <data key="d8">economical production,scalability</data>
      <data key="d9">chunk-364aa0dbd990ea22dbb324056cc5473e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468253</data>
    </edge>
    <edge source="Flash Memory" target="Write Speed">
      <data key="d6">1.0</data>
      <data key="d7">Flash Memory allows rapid data rewriting, making it suitable for high-speed applications.</data>
      <data key="d8">fast programming,high performance</data>
      <data key="d9">chunk-364aa0dbd990ea22dbb324056cc5473e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468254</data>
    </edge>
    <edge source="Flash Memory" target="SSD">
      <data key="d6">1.0</data>
      <data key="d7">SSD is built on flash memory technology, using flash chips as its primary storage component.</data>
      <data key="d8">foundation technology,storage architecture</data>
      <data key="d9">chunk-364aa0dbd990ea22dbb324056cc5473e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468255</data>
    </edge>
    <edge source="Flash Memory" target="Solid State Drive">
      <data key="d6">1.0</data>
      <data key="d7">Flash Memory is the fundamental storage medium in Solid State Drives.</data>
      <data key="d8">core component,storage foundation</data>
      <data key="d9">chunk-5b1903143e069742cd454a3ac6ea0d4a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468677</data>
    </edge>
    <edge source="SSD" target="Non-Volatile Storage">
      <data key="d6">1.0</data>
      <data key="d7">SSD relies on non-volatile storage to maintain data without continuous power.</data>
      <data key="d8">permanent data retention,power independence</data>
      <data key="d9">chunk-364aa0dbd990ea22dbb324056cc5473e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468253</data>
    </edge>
    <edge source="SSD" target="Write Speed">
      <data key="d6">1.0</data>
      <data key="d7">SSD provides faster read/write speeds compared to traditional hard drives.</data>
      <data key="d8">high-speed operations,performance advantage</data>
      <data key="d9">chunk-364aa0dbd990ea22dbb324056cc5473e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468254</data>
    </edge>
    <edge source="SSD" target="Power Consumption">
      <data key="d6">1.0</data>
      <data key="d7">SSD consumes less power than traditional hard drives, improving battery life in mobile devices.</data>
      <data key="d8">energy efficiency,low power usage</data>
      <data key="d9">chunk-364aa0dbd990ea22dbb324056cc5473e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468254</data>
    </edge>
    <edge source="SSD" target="Cost Efficiency">
      <data key="d6">1.0</data>
      <data key="d7">SSD has a higher upfront cost but offers better performance and durability, providing long-term value despite higher price.</data>
      <data key="d8">high initial cost,long-term value</data>
      <data key="d9">chunk-364aa0dbd990ea22dbb324056cc5473e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468254</data>
    </edge>
    <edge source="Page" target="Disk">
      <data key="d6">1.0</data>
      <data key="d7">When a page is not in main memory, it must be loaded from disk, requiring a page fault handling process.</data>
      <data key="d8">fault recovery,page storage</data>
      <data key="d9">chunk-6c698405c4fcc8fb19ebad83fe798b48</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468271</data>
    </edge>
    <edge source="Page" target="Data Erasure">
      <data key="d6">1.0</data>
      <data key="d7">A page can only be written after its entire containing block has been erased, making erasure a prerequisite for writing.</data>
      <data key="d8">data lifecycle,write and erase dependency</data>
      <data key="d9">chunk-8722d229424243d0f7b9869b271bb08f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468409</data>
    </edge>
    <edge source="Page" target="Block">
      <data key="d6">1.0</data>
      <data key="d7">Blocks are composed of multiple pages, with each page being the smallest unit for reading and writing data.</data>
      <data key="d8">data unit,hierarchical structure</data>
      <data key="d9">chunk-8722d229424243d0f7b9869b271bb08f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468410</data>
    </edge>
    <edge source="Disk" target="Multilevel Storage System">
      <data key="d6">1.0</data>
      <data key="d7">The multilevel storage system includes disk for persistent secondary storage.</data>
      <data key="d8">persistent storage,structured hierarchy</data>
      <data key="d9">chunk-6c698405c4fcc8fb19ebad83fe798b48</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468273</data>
    </edge>
    <edge source="Disk" target="Disk Controller">
      <data key="d6">1.0</data>
      <data key="d7">The disk controller receives addressing information from the host and manages the disk's operations.</data>
      <data key="d8">command handling,device communication</data>
      <data key="d9">chunk-59c3b987a075436eab7c271ca2d5302a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468950</data>
    </edge>
    <edge source="Disk" target="Control Word">
      <data key="d6">1.0</data>
      <data key="d7">The disk uses control words to determine the type of operation (read, write, seek) to perform.</data>
      <data key="d8">execution input,operation command</data>
      <data key="d9">chunk-59c3b987a075436eab7c271ca2d5302a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468952</data>
    </edge>
    <edge source="TLB Miss" target="TLB Replacement">
      <data key="d6">1.0</data>
      <data key="d7">A TLB miss may be handled by hardware or software through TLB replacement algorithms.</data>
      <data key="d8">memory management,replacement mechanism</data>
      <data key="d9">chunk-6c698405c4fcc8fb19ebad83fe798b48</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468270</data>
    </edge>
    <edge source="Page Miss" target="Page Fault Handling">
      <data key="d6">1.0</data>
      <data key="d7">A page miss triggers a page fault, which is handled by the operating system via the page fault handling method.</data>
      <data key="d8">exception handling,software intervention</data>
      <data key="d9">chunk-6c698405c4fcc8fb19ebad83fe798b48</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468270</data>
    </edge>
    <edge source="Page Miss" target="Software">
      <data key="d6">1.0</data>
      <data key="d7">Page misses are managed by software, specifically the operating system, which performs disk I/O to resolve the fault.</data>
      <data key="d8">disk access,operating system management</data>
      <data key="d9">chunk-6c698405c4fcc8fb19ebad83fe798b48</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468272</data>
    </edge>
    <edge source="Multi-Module Memory" target="Memory Throughput">
      <data key="d6">1.0</data>
      <data key="d7">Multi-module memory improves memory throughput by leveraging spatial parallelism through multiple storage modules.</data>
      <data key="d8">performance enhancement,spatial parallelism</data>
      <data key="d9">chunk-8f87fc865b405b5892e67cab1873a773</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468278</data>
    </edge>
    <edge source="Single-Body Multi-Word Memory" target="Continuous Data Storage">
      <data key="d6">1.0</data>
      <data key="d7">The speed improvement of single-body multi-word memory depends on instructions and data being stored continuously.</data>
      <data key="d8">data arrangement,efficiency dependency</data>
      <data key="d9">chunk-8f87fc865b405b5892e67cab1873a773</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468279</data>
    </edge>
    <edge source="Single-Body Multi-Word Memory" target="Transfer Instruction">
      <data key="d6">1.0</data>
      <data key="d7">The presence of transfer instructions can disrupt the flow of continuous data, reducing the effectiveness of single-body multi-word memory.</data>
      <data key="d8">execution disruption,performance degradation</data>
      <data key="d9">chunk-8f87fc865b405b5892e67cab1873a773</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468279</data>
    </edge>
    <edge source="Multi-Body Interleaved Memory" target="Independent Read/Write Control Circuits">
      <data key="d6">1.0</data>
      <data key="d7">Each module in multi-body interleaved memory has independent read/write control circuits enabling parallel and interleaved operations.</data>
      <data key="d8">modular design,parallel operation</data>
      <data key="d9">chunk-8f87fc865b405b5892e67cab1873a773</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468278</data>
    </edge>
    <edge source="Multi-Body Interleaved Memory" target="Address Register">
      <data key="d6">1.0</data>
      <data key="d7">Each module in multi-body interleaved memory has its own address register for independent address handling.</data>
      <data key="d8">address management,modular operation</data>
      <data key="d9">chunk-8f87fc865b405b5892e67cab1873a773</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468279</data>
    </edge>
    <edge source="Multi-Body Interleaved Memory" target="Data Register">
      <data key="d6">1.0</data>
      <data key="d7">Each module in multi-body interleaved memory has a data register to store data during read/write operations.</data>
      <data key="d8">data transfer,modular operation</data>
      <data key="d9">chunk-8f87fc865b405b5892e67cab1873a773</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468279</data>
    </edge>
    <edge source="Multi-Body Interleaved Memory" target="Memory Throughput">
      <data key="d6">1.0</data>
      <data key="d7">Multi-body interleaved memory enhances memory throughput through parallel and interleaved access across modules.</data>
      <data key="d8">high bandwidth,parallelism</data>
      <data key="d9">chunk-8f87fc865b405b5892e67cab1873a773</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468279</data>
    </edge>
    <edge source="Multi-Body Interleaved Memory" target="Multi-Body Parallel Memory">
      <data key="d6">1.0</data>
      <data key="d7">Multi-body parallel memory and multi-body interleaved memory refer to the same concept, describing a system where multiple memory modules work in parallel or interleaved fashion.</data>
      <data key="d8">synonymy,technical equivalence</data>
      <data key="d9">chunk-8f87fc865b405b5892e67cab1873a773</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468280</data>
    </edge>
    <edge source="Access Cycle" target="Data Transfer Rate">
      <data key="d6">1.0</data>
      <data key="d7">Data transfer rate is calculated by dividing data width by access cycle duration.</data>
      <data key="d8">inverse relationship,time-based calculation</data>
      <data key="d9">chunk-3c1c3cb1cdfefa986a82277dd52e88ef</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468738</data>
    </edge>
    <edge source="Access Cycle" target="Access Time">
      <data key="d6">1.0</data>
      <data key="d7">Access cycle is typically longer than access time due to the need for internal restoration time.</data>
      <data key="d8">duration comparison,temporal relationship</data>
      <data key="d9">chunk-3c1c3cb1cdfefa986a82277dd52e88ef</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468739</data>
    </edge>
    <edge source="Word Select" target="N Bits of Low-Order Address Lines">
      <data key="d6">1.0</data>
      <data key="d7">N bits of low-order address lines are used to perform word selection within a memory chip.</data>
      <data key="d8">addressing function</data>
      <data key="d9">chunk-a438ed247c5a79e72ee6372aba002ee0</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468306</data>
    </edge>
    <edge source="Line Selection Method" target="High-Order Address Lines">
      <data key="d6">1.0</data>
      <data key="d7">High-order address lines provide input signals directly to the line selection method for chip selection.</data>
      <data key="d8">control mechanism,signal input</data>
      <data key="d9">chunk-a438ed247c5a79e72ee6372aba002ee0</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468303</data>
    </edge>
    <edge source="Line Selection Method" target="Memory Capacity">
      <data key="d6">1.0</data>
      <data key="d7">The line selection method restricts use of full memory capacity due to address space fragmentation.</data>
      <data key="d8">address allocation limitation</data>
      <data key="d9">chunk-a438ed247c5a79e72ee6372aba002ee0</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468306</data>
    </edge>
    <edge source="Decoder-Based Chip Selection" target="High-Order Address Lines">
      <data key="d6">1.0</data>
      <data key="d7">High-order address lines feed into the address decoder in decoder-based chip selection.</data>
      <data key="d8">control mechanism,signal input</data>
      <data key="d9">chunk-a438ed247c5a79e72ee6372aba002ee0</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468305</data>
    </edge>
    <edge source="Memory Capacity" target="2^N">
      <data key="d6">1.0</data>
      <data key="d7">The memory capacity of a chip is mathematically defined as 2^N, where N corresponds to the number of low-order address lines used for word selection.</data>
      <data key="d8">mathematical representation</data>
      <data key="d9">chunk-a438ed247c5a79e72ee6372aba002ee0</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468305</data>
    </edge>
    <edge source="段式虚拟存储器" target="段号">
      <data key="d6">1.0</data>
      <data key="d7">段式虚拟存储器使用段号作为虚拟地址的一部分来标识逻辑段。</data>
      <data key="d8">address structure,logical segmentation</data>
      <data key="d9">chunk-87c0289dc1f88d2676624e47042c749f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468307</data>
    </edge>
    <edge source="段式虚拟存储器" target="段内地址">
      <data key="d6">1.0</data>
      <data key="d7">段式虚拟存储器使用段内地址作为段内的偏移量，用于定位段内具体位置。</data>
      <data key="d8">address structure,offset calculation</data>
      <data key="d9">chunk-87c0289dc1f88d2676624e47042c749f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468307</data>
    </edge>
    <edge source="段式虚拟存储器" target="段表">
      <data key="d6">1.0</data>
      <data key="d7">段式虚拟存储器通过段表实现虚拟地址到物理地址的映射。</data>
      <data key="d8">address translation,memory mapping</data>
      <data key="d9">chunk-87c0289dc1f88d2676624e47042c749f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468310</data>
    </edge>
    <edge source="段式虚拟存储器" target="页式虚拟存储器">
      <data key="d6">1.0</data>
      <data key="d7">Page-based systems are contrasted with segment-based systems in terms of handling, protection, and sharing.</data>
      <data key="d8">data management,memory model comparison</data>
      <data key="d9">chunk-0af5a7c8d38a4b5d1e4bac2d53e20424</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468778</data>
    </edge>
    <edge source="段号" target="段表">
      <data key="d6">2.0</data>
      <data key="d7">段表中的每行记录对应一个段号，标识其逻辑段。&lt;SEP&gt;段表通过段号作为索引，定位对应段的页表起始地址。</data>
      <data key="d8">address indexing,logical segment indexing,mapping entry</data>
      <data key="d9">chunk-a531a45f53700863615cfa8c40892f61&lt;SEP&gt;chunk-87c0289dc1f88d2676624e47042c749f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468494</data>
    </edge>
    <edge source="段表" target="装入位">
      <data key="d6">1.0</data>
      <data key="d7">段表中的装入位指示该段是否已调入主存。</data>
      <data key="d8">memory availability,page state</data>
      <data key="d9">chunk-87c0289dc1f88d2676624e47042c749f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468307</data>
    </edge>
    <edge source="段表" target="段起点">
      <data key="d6">1.0</data>
      <data key="d7">段表中的段起点记录该段在主存中的起始地址。</data>
      <data key="d8">base address,memory location</data>
      <data key="d9">chunk-87c0289dc1f88d2676624e47042c749f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468308</data>
    </edge>
    <edge source="段表" target="段长">
      <data key="d6">1.0</data>
      <data key="d7">段表中的段长用于界定段的大小，确保地址访问不越界。</data>
      <data key="d8">memory boundary,size validation</data>
      <data key="d9">chunk-87c0289dc1f88d2676624e47042c749f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468309</data>
    </edge>
    <edge source="段表" target="程序">
      <data key="d6">1.0</data>
      <data key="d7">每个程序对应一个段表，用于管理其各段的页表信息。</data>
      <data key="d8">data structure association</data>
      <data key="d9">chunk-a531a45f53700863615cfa8c40892f61</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468493</data>
    </edge>
    <edge source="段表" target="页表">
      <data key="d6">1.0</data>
      <data key="d7">段表中存储了各段的页表起始地址，用于获取对应段的页表。</data>
      <data key="d8">hierarchical mapping</data>
      <data key="d9">chunk-a531a45f53700863615cfa8c40892f61</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468493</data>
    </edge>
    <edge source="段表" target="虚地址">
      <data key="d6">1.0</data>
      <data key="d7">段表通过段号解析虚地址，获取对应的页表起始地址。</data>
      <data key="d8">address resolution</data>
      <data key="d9">chunk-a531a45f53700863615cfa8c40892f61</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468494</data>
    </edge>
    <edge source="段表基地址" target="虚拟地址">
      <data key="d6">1.0</data>
      <data key="d7">CPU根据段表基地址和段号拼接成段表项的地址，以查找段信息。</data>
      <data key="d8">address processing,table indexing</data>
      <data key="d9">chunk-87c0289dc1f88d2676624e47042c749f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468307</data>
    </edge>
    <edge source="段起点" target="物理地址">
      <data key="d6">1.0</data>
      <data key="d7">物理地址由段起点与段内地址相加得到。</data>
      <data key="d8">address calculation,linear translation</data>
      <data key="d9">chunk-87c0289dc1f88d2676624e47042c749f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468309</data>
    </edge>
    <edge source="段起点" target="页长">
      <data key="d6">1.0</data>
      <data key="d7">段的起点必须位于某一页的起始位置，即段起点地址必须是页长的整数倍。</data>
      <data key="d8">memory alignment</data>
      <data key="d9">chunk-a531a45f53700863615cfa8c40892f61</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468494</data>
    </edge>
    <edge source="段长" target="页长">
      <data key="d6">1.0</data>
      <data key="d7">段长必须是页长的整数倍，以满足段与页的逻辑对齐要求。</data>
      <data key="d8">alignment constraint,size requirement</data>
      <data key="d9">chunk-a531a45f53700863615cfa8c40892f61</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468493</data>
    </edge>
    <edge source="虚拟地址" target="物理地址">
      <data key="d6">1.0</data>
      <data key="d7">虚拟地址经段表转换后，生成主存中的物理地址以访问内存。</data>
      <data key="d8">address translation,memory access</data>
      <data key="d9">chunk-87c0289dc1f88d2676624e47042c749f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468308</data>
    </edge>
    <edge source="虚拟地址" target="地址转换部件">
      <data key="d6">1.0</data>
      <data key="d7">The address translation unit converts virtual addresses to physical addresses.</data>
      <data key="d8">address translation,memory access</data>
      <data key="d9">chunk-0af5a7c8d38a4b5d1e4bac2d53e20424</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468776</data>
    </edge>
    <edge source="主存" target="有效位">
      <data key="d6">1.0</data>
      <data key="d7">A valid bit of 1 indicates that the corresponding page is present in main memory.</data>
      <data key="d8">memory location,page presence indication</data>
      <data key="d9">chunk-0af5a7c8d38a4b5d1e4bac2d53e20424</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468774</data>
    </edge>
    <edge source="物理地址" target="地址转换部件">
      <data key="d6">1.0</data>
      <data key="d7">The address translation unit resolves virtual addresses into physical addresses for data access.</data>
      <data key="d8">address resolution,memory access</data>
      <data key="d9">chunk-0af5a7c8d38a4b5d1e4bac2d53e20424</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468777</data>
    </edge>
    <edge source="程序的逻辑结构" target="分段">
      <data key="d6">1.0</data>
      <data key="d7">分段依据程序的逻辑结构划分，增强了逻辑独立性。</data>
      <data key="d8">logical organization,memory design</data>
      <data key="d9">chunk-87c0289dc1f88d2676624e47042c749f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468308</data>
    </edge>
    <edge source="分段" target="逻辑独立性">
      <data key="d6">1.0</data>
      <data key="d7">分段使程序段具有逻辑独立性，便于管理和维护。</data>
      <data key="d8">modularity,system design</data>
      <data key="d9">chunk-87c0289dc1f88d2676624e47042c749f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468308</data>
    </edge>
    <edge source="分段" target="多道程序共享">
      <data key="d6">1.0</data>
      <data key="d7">分段机制支持多道程序的段共享，提升系统利用率。</data>
      <data key="d8">efficiency,resource sharing</data>
      <data key="d9">chunk-87c0289dc1f88d2676624e47042c749f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468309</data>
    </edge>
    <edge source="分段" target="内存碎片">
      <data key="d6">1.0</data>
      <data key="d7">由于段长度可变，分段容易在段间产生内存碎片，造成空间浪费。</data>
      <data key="d8">inefficiency,memory management issue</data>
      <data key="d9">chunk-87c0289dc1f88d2676624e47042c749f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468310</data>
    </edge>
    <edge source="分页" target="透明性">
      <data key="d6">1.0</data>
      <data key="d7">分页对程序员透明，无需关心程序分页细节。</data>
      <data key="d8">abstraction,user transparency</data>
      <data key="d9">chunk-87c0289dc1f88d2676624e47042c749f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468309</data>
    </edge>
    <edge source="SRAM Chip" target="Static Random Access Memory">
      <data key="d6">1.0</data>
      <data key="d7">SRAM Chip is a physical implementation of Static Random Access Memory technology.</data>
      <data key="d8">technology category,type of</data>
      <data key="d9">chunk-84c8d12524cbd30a01b0da556f764478</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468327</data>
    </edge>
    <edge source="DRAM Chip" target="Dynamic Random Access Memory">
      <data key="d6">1.0</data>
      <data key="d7">DRAM Chip is a physical implementation of Dynamic Random Access Memory technology.</data>
      <data key="d8">technology category,type of</data>
      <data key="d9">chunk-84c8d12524cbd30a01b0da556f764478</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468328</data>
    </edge>
    <edge source="Random Access Memory" target="Static RAM">
      <data key="d6">1.0</data>
      <data key="d7">Static RAM is a type of RAM distinguished by its lack of need for refreshing.</data>
      <data key="d8">subtype,type</data>
      <data key="d9">chunk-ce9d79eec3b8225be9c02cda24c5a519</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468449</data>
    </edge>
    <edge source="Random Access Memory" target="Dynamic RAM">
      <data key="d6">1.0</data>
      <data key="d7">Dynamic RAM is another type of RAM that requires periodic refreshing to maintain data.</data>
      <data key="d8">subtype,type</data>
      <data key="d9">chunk-ce9d79eec3b8225be9c02cda24c5a519</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468450</data>
    </edge>
    <edge source="Read-Only Memory" target="Non-Volatile Memory">
      <data key="d6">1.0</data>
      <data key="d7">Read-Only Memory is classified as a type of non-volatile memory.</data>
      <data key="d8">classification,memory type</data>
      <data key="d9">chunk-84c8d12524cbd30a01b0da556f764478</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468326</data>
    </edge>
    <edge source="Static Random Access Memory" target="Volatile Memory">
      <data key="d6">1.0</data>
      <data key="d7">Static Random Access Memory is classified as a type of volatile memory.</data>
      <data key="d8">classification,memory type</data>
      <data key="d9">chunk-84c8d12524cbd30a01b0da556f764478</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468326</data>
    </edge>
    <edge source="Dynamic Random Access Memory" target="Volatile Memory">
      <data key="d6">1.0</data>
      <data key="d7">Dynamic Random Access Memory is classified as a type of volatile memory.</data>
      <data key="d8">classification,memory type</data>
      <data key="d9">chunk-84c8d12524cbd30a01b0da556f764478</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468327</data>
    </edge>
    <edge source="Non-Volatile Memory" target="Auxiliary Memory">
      <data key="d6">1.0</data>
      <data key="d7">Non-volatile memory retains data after power loss and is employed for long-term storage in auxiliary memory.</data>
      <data key="d8">characteristic attribute,data retention</data>
      <data key="d9">chunk-ce9d79eec3b8225be9c02cda24c5a519</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468452</data>
    </edge>
    <edge source="Control Bus" target="Read/Write Operation">
      <data key="d6">1.0</data>
      <data key="d7">The control bus signals the type of operation and marks the completion of data input or output.</data>
      <data key="d8">operation type indication,timing control</data>
      <data key="d9">chunk-f58beb694766dd43b7432ff7d16d2a65</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468351</data>
    </edge>
    <edge source="Memory Chip Extension Technology" target="Memory Module">
      <data key="d6">1.0</data>
      <data key="d7">Memory chip extension technology integrates multiple memory chips into a single memory module to increase storage.</data>
      <data key="d8">capacity expansion,integration method</data>
      <data key="d9">chunk-f58beb694766dd43b7432ff7d16d2a65</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468351</data>
    </edge>
    <edge source="Memory Chip Extension Technology" target="Single Chip Capacity Limitation">
      <data key="d6">1.0</data>
      <data key="d7">The limitation in single chip capacity drives the need for memory chip extension technology to achieve larger memory configurations.</data>
      <data key="d8">design solution,technical necessity</data>
      <data key="d9">chunk-f58beb694766dd43b7432ff7d16d2a65</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468354</data>
    </edge>
    <edge source="Direct Mapping" target="Cache Line Number">
      <data key="d6">1.0</data>
      <data key="d7">In direct mapping, the cache line number is determined by the main memory block number modulo the total number of cache lines.</data>
      <data key="d8">address computation,fixed mapping</data>
      <data key="d9">chunk-361185a50ecc6636f127fb6f6ad6eabd</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468606</data>
    </edge>
    <edge source="LRU Algorithm" target="LRU Replacement Bit">
      <data key="d6">1.0</data>
      <data key="d7">LRU Replacement Bit is used by the LRU Algorithm to record recent access order.</data>
      <data key="d8">counter implementation,tracking</data>
      <data key="d9">chunk-555f79801ef87ce95e52becac62479d6</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468355</data>
    </edge>
    <edge source="LRU Algorithm" target="Counting Mechanism">
      <data key="d6">1.0</data>
      <data key="d7">Counting Mechanism is used to track access patterns in LRU algorithm.</data>
      <data key="d8">data usage,tracking mechanism</data>
      <data key="d9">chunk-555f79801ef87ce95e52becac62479d6</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468356</data>
    </edge>
    <edge source="LRU Algorithm" target="Count Value">
      <data key="d6">1.0</data>
      <data key="d7">The count value is used by the LRU Algorithm to determine which line to replace based on recency.</data>
      <data key="d8">counter,usage tracking</data>
      <data key="d9">chunk-555f79801ef87ce95e52becac62479d6</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468357</data>
    </edge>
    <edge source="LFU Algorithm" target="Counting Mechanism">
      <data key="d6">1.0</data>
      <data key="d7">Counting Mechanism is used to track how often each cache line is accessed in the LFU Algorithm.</data>
      <data key="d8">frequency counting,tracking mechanism</data>
      <data key="d9">chunk-555f79801ef87ce95e52becac62479d6</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468356</data>
    </edge>
    <edge source="LFU Algorithm" target="Count Value">
      <data key="d6">1.0</data>
      <data key="d7">The count value is used by the LFU Algorithm to track how often a line has been accessed.</data>
      <data key="d8">frequency count,usage tracking</data>
      <data key="d9">chunk-555f79801ef87ce95e52becac62479d6</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468358</data>
    </edge>
    <edge source="Data Transfer Rate" target="Main Memory Bandwidth">
      <data key="d6">1.0</data>
      <data key="d7">Main memory bandwidth is synonymous with data transfer rate, representing the maximum data throughput.</data>
      <data key="d8">equivalent metric,performance measure</data>
      <data key="d9">chunk-3c1c3cb1cdfefa986a82277dd52e88ef</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468739</data>
    </edge>
    <edge source="Storage Unit" target="Storage Body">
      <data key="d6">1.0</data>
      <data key="d7">A storage body is composed of multiple storage units.</data>
      <data key="d8">component composition</data>
      <data key="d9">chunk-7c2151344b39c51051c3dacc3290bcf9</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468381</data>
    </edge>
    <edge source="Bistable Trigger" target="Six Transistor MOS">
      <data key="d6">1.0</data>
      <data key="d7">A bistable trigger in SRAM is implemented using a six-transistor MOS configuration.</data>
      <data key="d8">circuit implementation</data>
      <data key="d9">chunk-7c2151344b39c51051c3dacc3290bcf9</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468381</data>
    </edge>
    <edge source="Non-Destructive Readout" target="Memory System">
      <data key="d6">1.0</data>
      <data key="d7">Non-destructive readout preserves stored data during read operations, eliminating the need for regeneration.</data>
      <data key="d8">data preservation,read mechanism</data>
      <data key="d9">chunk-ce9d79eec3b8225be9c02cda24c5a519</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468452</data>
    </edge>
    <edge source="Cache Block" target="Block Length">
      <data key="d6">1.0</data>
      <data key="d7">Block Length defines the number of bytes in each Cache Block.</data>
      <data key="d8">size specification</data>
      <data key="d9">chunk-e0a87778cef25aba2903a8a3e12c5faa</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468394</data>
    </edge>
    <edge source="Write-Through" target="Write-Back">
      <data key="d6">1.0</data>
      <data key="d7">Write-Through and Write-Back are two different implementations of write policies with distinct data consistency mechanisms.</data>
      <data key="d8">consistency approach,write policy variants</data>
      <data key="d9">chunk-e0a87778cef25aba2903a8a3e12c5faa</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468395</data>
    </edge>
    <edge source="Solid State Drive" target="Flash Memory Chip">
      <data key="d6">1.0</data>
      <data key="d7">The Solid State Drive consists of one or more flash memory chips that serve as the primary storage medium.</data>
      <data key="d8">component integration,data storage</data>
      <data key="d9">chunk-8722d229424243d0f7b9869b271bb08f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468409</data>
    </edge>
    <edge source="Solid State Drive" target="Flash Translation Layer">
      <data key="d6">1.0</data>
      <data key="d7">The flash translation layer is a critical component of the SSD responsible for translating CPU requests into physical operations on the flash memory.</data>
      <data key="d8">functional component,logical to physical mapping</data>
      <data key="d9">chunk-8722d229424243d0f7b9869b271bb08f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468410</data>
    </edge>
    <edge source="Solid State Drive" target="Mechanical Hard Disk">
      <data key="d6">1.0</data>
      <data key="d7">SSDs offer superior performance, energy efficiency, and durability compared to mechanical hard disks due to their solid-state architecture.</data>
      <data key="d8">performance contrast,technological comparison</data>
      <data key="d9">chunk-8722d229424243d0f7b9869b271bb08f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468411</data>
    </edge>
    <edge source="Solid State Drive" target="Random Write Operation">
      <data key="d6">1.0</data>
      <data key="d7">Random write operations in SSDs are slower due to the overhead of block erasure and data migration.</data>
      <data key="d8">operational limitation,performance characteristic</data>
      <data key="d9">chunk-8722d229424243d0f7b9869b271bb08f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468411</data>
    </edge>
    <edge source="Solid State Drive" target="Ssd Performance">
      <data key="d6">1.0</data>
      <data key="d7">SSD performance benefits from fast access times, low latency, and high throughput due to the absence of moving parts.</data>
      <data key="d8">technical attribute</data>
      <data key="d9">chunk-8722d229424243d0f7b9869b271bb08f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468412</data>
    </edge>
    <edge source="Solid State Drive" target="Energy Efficiency">
      <data key="d6">1.0</data>
      <data key="d7">SSDs are more energy efficient than mechanical hard disks due to lack of mechanical components.</data>
      <data key="d8">operational benefit,power consumption</data>
      <data key="d9">chunk-8722d229424243d0f7b9869b271bb08f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468412</data>
    </edge>
    <edge source="Solid State Drive" target="Vibration Resistance">
      <data key="d6">1.0</data>
      <data key="d7">SSDs exhibit high vibration resistance due to their solid-state construction without moving parts.</data>
      <data key="d8">durability,physical resilience</data>
      <data key="d9">chunk-8722d229424243d0f7b9869b271bb08f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468412</data>
    </edge>
    <edge source="Solid State Drive" target="Data Security">
      <data key="d6">1.0</data>
      <data key="d7">Data security in SSDs is improved due to immunity to mechanical shocks and failure.</data>
      <data key="d8">reliability,survivability characteristic</data>
      <data key="d9">chunk-8722d229424243d0f7b9869b271bb08f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468412</data>
    </edge>
    <edge source="Solid State Drive" target="Price Trend">
      <data key="d6">1.0</data>
      <data key="d7">The price of SSDs has been decreasing over time due to technological advancement, increasing their adoption rate.</data>
      <data key="d8">accessibility,market evolution</data>
      <data key="d9">chunk-8722d229424243d0f7b9869b271bb08f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468413</data>
    </edge>
    <edge source="Solid State Drive" target="Wear Leveling">
      <data key="d6">1.0</data>
      <data key="d7">Wear Leveling technology is implemented in Solid State Drives to extend their usable lifespan.</data>
      <data key="d8">lifespan extension,technology enhancement</data>
      <data key="d9">chunk-5b1903143e069742cd454a3ac6ea0d4a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468677</data>
    </edge>
    <edge source="Solid State Drive" target="Flash Memory Block">
      <data key="d6">1.0</data>
      <data key="d7">Solid State Drives are composed of multiple Flash Memory Blocks used for storing data.</data>
      <data key="d8">data organization,storage unit</data>
      <data key="d9">chunk-5b1903143e069742cd454a3ac6ea0d4a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468678</data>
    </edge>
    <edge source="Flash Memory Chip" target="Block">
      <data key="d6">1.0</data>
      <data key="d7">Flash memory chips are organized into blocks, which are units for erasing data.</data>
      <data key="d8">data organization,storage unit</data>
      <data key="d9">chunk-8722d229424243d0f7b9869b271bb08f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468410</data>
    </edge>
    <edge source="Flash Translation Layer" target="Mechanical Hard Disk Controller">
      <data key="d6">1.0</data>
      <data key="d7">The flash translation layer performs the role of a disk controller in traditional hard disks by managing data access requests.</data>
      <data key="d8">functional equivalent,system role replacement</data>
      <data key="d9">chunk-8722d229424243d0f7b9869b271bb08f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468411</data>
    </edge>
    <edge source="Block" target="Fully Associative Mapping">
      <data key="d6">1.0</data>
      <data key="d7">Fully associative mapping allows any main memory block to be stored in any cache line, minimizing conflict.</data>
      <data key="d8">conflict reduction,flexible placement</data>
      <data key="d9">chunk-361185a50ecc6636f127fb6f6ad6eabd</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468607</data>
    </edge>
    <edge source="Data Security" target="RAID">
      <data key="d6">1.0</data>
      <data key="d7">RAID enhances data security by preventing data loss through redundancy and distributed parity.</data>
      <data key="d8">core objective</data>
      <data key="d9">chunk-f75d6db24d56fe7631645ee707b4ca7f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468558</data>
    </edge>
    <edge source="多体并行存储器" target="高位交叉编址">
      <data key="d6">1.0</data>
      <data key="d7">The multi-body parallel memory system may use high-order interleaving as one of its addressing methods, which results in sequential access.</data>
      <data key="d8">addressing method,sequential access</data>
      <data key="d9">chunk-b013853f3a4a507351aa3af1ef0f6cfb</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468431</data>
    </edge>
    <edge source="多体并行存储器" target="低位交叉编址">
      <data key="d6">1.0</data>
      <data key="d7">The multi-body parallel memory system may use low-order interleaving as one of its addressing methods, enabling parallel module access.</data>
      <data key="d8">addressing method,parallel access</data>
      <data key="d9">chunk-b013853f3a4a507351aa3af1ef0f6cfb</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468431</data>
    </edge>
    <edge source="高位交叉编址" target="模块号">
      <data key="d6">1.0</data>
      <data key="d7">In high-order interleaving, high-order bits of the address define the module number.</data>
      <data key="d8">addressing scheme,module selection</data>
      <data key="d9">chunk-b013853f3a4a507351aa3af1ef0f6cfb</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468431</data>
    </edge>
    <edge source="高位交叉编址" target="体内地址">
      <data key="d6">1.0</data>
      <data key="d7">In high-order interleaving, low-order bits of the address represent the within-module address.</data>
      <data key="d8">addressing scheme,internal addressing</data>
      <data key="d9">chunk-b013853f3a4a507351aa3af1ef0f6cfb</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468432</data>
    </edge>
    <edge source="低位交叉编址" target="模块号">
      <data key="d6">1.0</data>
      <data key="d7">In low-order interleaving, low-order bits are used to determine the module number via modulo operation.</data>
      <data key="d8">addressing scheme,module selection</data>
      <data key="d9">chunk-b013853f3a4a507351aa3af1ef0f6cfb</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468432</data>
    </edge>
    <edge source="低位交叉编址" target="体内地址">
      <data key="d6">1.0</data>
      <data key="d7">In low-order interleaving, high-order bits define the within-module address.</data>
      <data key="d8">addressing scheme,internal addressing</data>
      <data key="d9">chunk-b013853f3a4a507351aa3af1ef0f6cfb</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468432</data>
    </edge>
    <edge source="低位交叉编址" target="m体交叉存储器">
      <data key="d6">1.0</data>
      <data key="d7">Low-order interleaving is the foundation for the m-body interleaved memory system.</data>
      <data key="d8">modular design,system configuration</data>
      <data key="d9">chunk-b013853f3a4a507351aa3af1ef0f6cfb</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468433</data>
    </edge>
    <edge source="数据总线位数" target="同时启动方式">
      <data key="d6">1.0</data>
      <data key="d7">Simultaneous initiation requires that the total data width from all modules equals the data bus width.</data>
      <data key="d8">data width matching,parallel capability</data>
      <data key="d9">chunk-b013853f3a4a507351aa3af1ef0f6cfb</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468431</data>
    </edge>
    <edge source="存取周期" target="轮流启动方式">
      <data key="d6">1.0</data>
      <data key="d7">The number of modules must be at least T/r to ensure that a module is not reactivated before its previous access is completed.</data>
      <data key="d8">pipeline control,timing constraint</data>
      <data key="d9">chunk-b013853f3a4a507351aa3af1ef0f6cfb</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468431</data>
    </edge>
    <edge source="总线周期" target="轮流启动方式">
      <data key="d6">1.0</data>
      <data key="d7">The bus cycle determines the interval between module initiations in round-robin fashion.</data>
      <data key="d8">synchronization,timing constraint</data>
      <data key="d9">chunk-b013853f3a4a507351aa3af1ef0f6cfb</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468431</data>
    </edge>
    <edge source="轮流启动方式" target="模块数">
      <data key="d6">1.0</data>
      <data key="d7">The module count must be greater than or equal to T/r to satisfy the timing requirement for round-robin initiation.</data>
      <data key="d8">schedule requirement,timing constraint</data>
      <data key="d9">chunk-b013853f3a4a507351aa3af1ef0f6cfb</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468432</data>
    </edge>
    <edge source="轮流启动方式" target="总时间">
      <data key="d6">1.0</data>
      <data key="d7">The total time for accessing m words is given by t = T + (m−1)r in the round-robin initiation method.</data>
      <data key="d8">access efficiency,performance metric</data>
      <data key="d9">chunk-b013853f3a4a507351aa3af1ef0f6cfb</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468433</data>
    </edge>
    <edge source="轮流启动方式" target="m体交叉存储器">
      <data key="d6">1.0</data>
      <data key="d7">The m-body interleaved memory can operate using round-robin initiation to maintain continuous data access.</data>
      <data key="d8">access control,system operation</data>
      <data key="d9">chunk-b013853f3a4a507351aa3af1ef0f6cfb</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468433</data>
    </edge>
    <edge source="同时启动方式" target="模块数">
      <data key="d6">1.0</data>
      <data key="d7">For simultaneous initiation, the sum of data bits from all modules must match the bus width, requiring proper module count.</data>
      <data key="d8">hardware configuration,parallelism requirement</data>
      <data key="d9">chunk-b013853f3a4a507351aa3af1ef0f6cfb</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468432</data>
    </edge>
    <edge source="同时启动方式" target="启动间隔">
      <data key="d6">1.0</data>
      <data key="d7">In simultaneous initiation, the startup interval must ensure that each module is not accessed again before its previous operation completes, maintaining data integrity.</data>
      <data key="d8">parallel operation,timing requirement</data>
      <data key="d9">chunk-b013853f3a4a507351aa3af1ef0f6cfb</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468433</data>
    </edge>
    <edge source="同时启动方式" target="m体交叉存储器">
      <data key="d6">1.0</data>
      <data key="d7">The m-body interleaved memory supports simultaneous initiation for maximum parallelism.</data>
      <data key="d8">access control,system operation</data>
      <data key="d9">chunk-b013853f3a4a507351aa3af1ef0f6cfb</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468434</data>
    </edge>
    <edge source="访存冲突" target="m体交叉存储器">
      <data key="d6">1.0</data>
      <data key="d7">If m consecutive accesses target the same module, a memory access conflict occurs, requiring delays.</data>
      <data key="d8">access contention,performance limitation</data>
      <data key="d9">chunk-b013853f3a4a507351aa3af1ef0f6cfb</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468433</data>
    </edge>
    <edge source="m体交叉存储器" target="模块数">
      <data key="d6">1.0</data>
      <data key="d7">The number of modules directly determines the configuration and performance characteristics of the m-body interleaved memory system.</data>
      <data key="d8">parallelism factor,system parameter</data>
      <data key="d9">chunk-b013853f3a4a507351aa3af1ef0f6cfb</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468434</data>
    </edge>
    <edge source="Auxiliary Memory" target="Magnetic Surface Storage">
      <data key="d6">1.0</data>
      <data key="d7">Magnetic surface storage such as disks and tapes is a type of auxiliary memory used for persistent data storage.</data>
      <data key="d8">long-term backup,storage medium</data>
      <data key="d9">chunk-ce9d79eec3b8225be9c02cda24c5a519</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468451</data>
    </edge>
    <edge source="Auxiliary Memory" target="Optical Storage">
      <data key="d6">1.0</data>
      <data key="d7">Optical storage, like CDs and DVDs, is a type of auxiliary memory used for long-term information retention.</data>
      <data key="d8">archival use,storage medium</data>
      <data key="d9">chunk-ce9d79eec3b8225be9c02cda24c5a519</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468451</data>
    </edge>
    <edge source="Serial Access Storage" target="Direct Access Storage">
      <data key="d6">2.0</data>
      <data key="d7">Direct access storage is a subset of serial access storage that supports partial random access by first locating a region and then scanning within it.&lt;SEP&gt;Serial access storage includes both sequential and direct access types and represents different ways of data retrieval.</data>
      <data key="d8">access method analogy,hierarchical structure,subtype,type</data>
      <data key="d9">chunk-ce9d79eec3b8225be9c02cda24c5a519</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468450</data>
    </edge>
    <edge source="Serial Access Storage" target="Sequential Access Storage">
      <data key="d6">1.0</data>
      <data key="d7">Sequential access storage is a subset of serial access storage where data must be accessed in sequential order.</data>
      <data key="d8">subtype,type</data>
      <data key="d9">chunk-ce9d79eec3b8225be9c02cda24c5a519</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468451</data>
    </edge>
    <edge source="Cache Consistency Problem" target="Write Through">
      <data key="d6">1.0</data>
      <data key="d7">Write Through provides a mechanism to resolve the Cache consistency problem by writing to both Cache and main memory simultaneously.</data>
      <data key="d8">data synchronization,solution</data>
      <data key="d9">chunk-cef942e7cbaeb916484eb8b3e7bcbd9a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468476</data>
    </edge>
    <edge source="Cache Consistency Problem" target="Write Back">
      <data key="d6">1.0</data>
      <data key="d7">Write Back resolves cache consistency by deferring main memory updates until block replacement.</data>
      <data key="d8">data consistency,solution</data>
      <data key="d9">chunk-cef942e7cbaeb916484eb8b3e7bcbd9a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468478</data>
    </edge>
    <edge source="Write Through" target="Write Buffer">
      <data key="d6">1.0</data>
      <data key="d7">The Write Buffer reduces latency in Write Through by decoupling Cache and main memory write operations.</data>
      <data key="d8">latency reduction,support mechanism</data>
      <data key="d9">chunk-cef942e7cbaeb916484eb8b3e7bcbd9a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468477</data>
    </edge>
    <edge source="Write Through" target="Not-Write-Allocate">
      <data key="d6">1.0</data>
      <data key="d7">Not-Write-Allocate is typically used with Write Through to avoid unnecessary Cache loading.</data>
      <data key="d8">efficiency,strategy pairing</data>
      <data key="d9">chunk-cef942e7cbaeb916484eb8b3e7bcbd9a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468478</data>
    </edge>
    <edge source="Write Back" target="Dirty Bit">
      <data key="d6">1.0</data>
      <data key="d7">The Dirty Bit tracks modified blocks in Write Back, triggering write-back during replacement.</data>
      <data key="d8">replacement logic,state tracking</data>
      <data key="d9">chunk-cef942e7cbaeb916484eb8b3e7bcbd9a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468476</data>
    </edge>
    <edge source="Write Back" target="Write Allocate">
      <data key="d6">1.0</data>
      <data key="d7">Write Allocate is commonly used with Write Back to enhance write efficiency and reduce memory traffic.</data>
      <data key="d8">cache optimization,strategy pairing</data>
      <data key="d9">chunk-cef942e7cbaeb916484eb8b3e7bcbd9a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468477</data>
    </edge>
    <edge source="Separate Cache Structure" target="Memory Access Conflict">
      <data key="d6">1.0</data>
      <data key="d7">The separate Cache structure eliminates memory access conflict by isolating instruction and data paths.</data>
      <data key="d8">conflict resolution,design optimization</data>
      <data key="d9">chunk-cef942e7cbaeb916484eb8b3e7bcbd9a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468476</data>
    </edge>
    <edge source="Separate Cache Structure" target="Performance Optimization">
      <data key="d6">1.0</data>
      <data key="d7">The separate Cache structure supports performance optimization by enabling better use of instruction and data locality.</data>
      <data key="d8">architectural improvement,efficiency gain</data>
      <data key="d9">chunk-cef942e7cbaeb916484eb8b3e7bcbd9a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468477</data>
    </edge>
    <edge source="L1 Cache" target="L2 Cache">
      <data key="d6">1.0</data>
      <data key="d7">L1 Cache is faster than L2 Cache and is located closer to the CPU in the memory hierarchy.</data>
      <data key="d8">access speed,hierarchical storage</data>
      <data key="d9">chunk-cef942e7cbaeb916484eb8b3e7bcbd9a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468476</data>
    </edge>
    <edge source="Instruction Cache" target="Data Cache">
      <data key="d6">1.0</data>
      <data key="d7">Instruction and Data Cache are separated to allow parallel access and improve performance.</data>
      <data key="d8">performance improvement,separate resource allocation</data>
      <data key="d9">chunk-cef942e7cbaeb916484eb8b3e7bcbd9a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468477</data>
    </edge>
    <edge source="段页式虚拟存储器" target="程序">
      <data key="d6">1.0</data>
      <data key="d7">段页式虚拟存储器将程序按逻辑结构分段，实现逻辑与物理的映射。</data>
      <data key="d8">logical segmentation,memory management</data>
      <data key="d9">chunk-a531a45f53700863615cfa8c40892f61</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468492</data>
    </edge>
    <edge source="段页式虚拟存储器" target="地址变换过程">
      <data key="d6">1.0</data>
      <data key="d7">段页式虚拟存储器的地址变换过程需要两次查表，系统开销较大。</data>
      <data key="d8">memory access process,two-level lookup</data>
      <data key="d9">chunk-a531a45f53700863615cfa8c40892f61</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468493</data>
    </edge>
    <edge source="段页式虚拟存储器" target="共享">
      <data key="d6">1.0</data>
      <data key="d7">段页式虚拟存储器支持按段实现内存共享，提高资源利用率。</data>
      <data key="d8">memory feature,segmentation advantage</data>
      <data key="d9">chunk-a531a45f53700863615cfa8c40892f61</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468494</data>
    </edge>
    <edge source="段页式虚拟存储器" target="保护">
      <data key="d6">1.0</data>
      <data key="d7">段页式虚拟存储器支持按段实现内存保护，增强系统安全性。</data>
      <data key="d8">memory feature,segmentation advantage</data>
      <data key="d9">chunk-a531a45f53700863615cfa8c40892f61</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468494</data>
    </edge>
    <edge source="页表" target="虚地址">
      <data key="d6">1.0</data>
      <data key="d7">页表通过段内页号解析虚地址，获取对应的实页号。</data>
      <data key="d8">address resolution</data>
      <data key="d9">chunk-a531a45f53700863615cfa8c40892f61</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468492</data>
    </edge>
    <edge source="页表" target="段内页号">
      <data key="d6">1.0</data>
      <data key="d7">页表通过段内页号作为索引，查找对应页的实页号。</data>
      <data key="d8">page mapping</data>
      <data key="d9">chunk-a531a45f53700863615cfa8c40892f61</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468494</data>
    </edge>
    <edge source="页表" target="有效位">
      <data key="d6">1.0</data>
      <data key="d7">The valid bit is a component of the page table used to indicate whether a virtual page is currently in main memory.</data>
      <data key="d8">memory management,page status tracking</data>
      <data key="d9">chunk-0af5a7c8d38a4b5d1e4bac2d53e20424</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468773</data>
    </edge>
    <edge source="页表" target="脏位">
      <data key="d6">1.0</data>
      <data key="d7">The dirty bit is part of the page table and indicates whether a page has been modified and needs to be written back to disk.</data>
      <data key="d8">page modification tracking,write-back policy</data>
      <data key="d9">chunk-0af5a7c8d38a4b5d1e4bac2d53e20424</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468774</data>
    </edge>
    <edge source="页表" target="引用位">
      <data key="d6">1.0</data>
      <data key="d7">The reference bit in the page table helps determine which page to replace based on access patterns.</data>
      <data key="d8">page usage tracking,replacement strategy</data>
      <data key="d9">chunk-0af5a7c8d38a4b5d1e4bac2d53e20424</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468774</data>
    </edge>
    <edge source="页表" target="缺页异常处理程序">
      <data key="d6">1.0</data>
      <data key="d7">After loading a page, the page fault handler updates the page table with the new physical page and valid bit status.</data>
      <data key="d8">state synchronization,table update</data>
      <data key="d9">chunk-0af5a7c8d38a4b5d1e4bac2d53e20424</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468777</data>
    </edge>
    <edge source="主存空间" target="页">
      <data key="d6">1.0</data>
      <data key="d7">主存空间按页划分，每个页对应主存中的一个固定大小的物理区域。</data>
      <data key="d8">physical memory allocation</data>
      <data key="d9">chunk-a531a45f53700863615cfa8c40892f61</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468493</data>
    </edge>
    <edge source="虚地址" target="实地址">
      <data key="d6">1.0</data>
      <data key="d7">通过段表和页表的两次查表，虚地址被转换为实地址。</data>
      <data key="d8">address translation</data>
      <data key="d9">chunk-a531a45f53700863615cfa8c40892f61</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468493</data>
    </edge>
    <edge source="RAID" target="RAID0">
      <data key="d6">1.0</data>
      <data key="d7">RAID0 is a specific level of RAID configuration characterized by striping without redundancy.</data>
      <data key="d8">configuration type</data>
      <data key="d9">chunk-f75d6db24d56fe7631645ee707b4ca7f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468554</data>
    </edge>
    <edge source="RAID" target="RAID1">
      <data key="d6">1.0</data>
      <data key="d7">RAID1 is a specific level of RAID configuration that uses mirroring for data redundancy.</data>
      <data key="d8">configuration type</data>
      <data key="d9">chunk-f75d6db24d56fe7631645ee707b4ca7f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468554</data>
    </edge>
    <edge source="RAID" target="RAID2">
      <data key="d6">1.0</data>
      <data key="d7">RAID2 is a specific level of RAID configuration using Hamming code for error correction.</data>
      <data key="d8">configuration type</data>
      <data key="d9">chunk-f75d6db24d56fe7631645ee707b4ca7f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468554</data>
    </edge>
    <edge source="RAID" target="RAID3">
      <data key="d6">1.0</data>
      <data key="d7">RAID3 is a specific level of RAID configuration that employs byte-level striping with dedicated parity.</data>
      <data key="d8">configuration type</data>
      <data key="d9">chunk-f75d6db24d56fe7631645ee707b4ca7f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468555</data>
    </edge>
    <edge source="RAID" target="RAID4">
      <data key="d6">1.0</data>
      <data key="d7">RAID4 is a specific level of RAID configuration featuring block-level striping with a dedicated parity disk.</data>
      <data key="d8">configuration type</data>
      <data key="d9">chunk-f75d6db24d56fe7631645ee707b4ca7f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468555</data>
    </edge>
    <edge source="RAID" target="RAID5">
      <data key="d6">1.0</data>
      <data key="d7">RAID5 is a specific level of RAID configuration that implements distributed parity across all drives.</data>
      <data key="d8">configuration type</data>
      <data key="d9">chunk-f75d6db24d56fe7631645ee707b4ca7f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468555</data>
    </edge>
    <edge source="RAID" target="Data Striping">
      <data key="d6">1.0</data>
      <data key="d7">RAID uses data striping to distribute data across multiple disks for improved performance.</data>
      <data key="d8">underlying technique</data>
      <data key="d9">chunk-f75d6db24d56fe7631645ee707b4ca7f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468555</data>
    </edge>
    <edge source="RAID" target="Mirroring">
      <data key="d6">1.0</data>
      <data key="d7">RAID1 utilizes mirroring to duplicate data across two disks for fault tolerance.</data>
      <data key="d8">underlying technique</data>
      <data key="d9">chunk-f75d6db24d56fe7631645ee707b4ca7f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468556</data>
    </edge>
    <edge source="RAID" target="Parity">
      <data key="d6">1.0</data>
      <data key="d7">RAID systems such as RAID3, RAID4, and RAID5 use parity to enable fault tolerance.</data>
      <data key="d8">underlying technique</data>
      <data key="d9">chunk-f75d6db24d56fe7631645ee707b4ca7f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468556</data>
    </edge>
    <edge source="RAID" target="Fault Tolerance">
      <data key="d6">1.0</data>
      <data key="d7">RAID is designed to provide fault tolerance by allowing system operation despite disk failure.</data>
      <data key="d8">core objective</data>
      <data key="d9">chunk-f75d6db24d56fe7631645ee707b4ca7f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468557</data>
    </edge>
    <edge source="RAID" target="Data Recovery">
      <data key="d6">1.0</data>
      <data key="d7">RAID enables data recovery in the event of a disk failure through redundancy or parity.</data>
      <data key="d8">functional outcome</data>
      <data key="d9">chunk-f75d6db24d56fe7631645ee707b4ca7f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468557</data>
    </edge>
    <edge source="RAID" target="Storage Performance">
      <data key="d6">1.0</data>
      <data key="d7">RAID improves storage performance by enabling parallel access to multiple disks.</data>
      <data key="d8">functional outcome</data>
      <data key="d9">chunk-f75d6db24d56fe7631645ee707b4ca7f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468558</data>
    </edge>
    <edge source="RAID" target="Independent Redundant Disk Array">
      <data key="d6">1.0</data>
      <data key="d7">RAID is an acronym for Independent Redundant Disk Array, representing the same concept.</data>
      <data key="d8">synonym relationship</data>
      <data key="d9">chunk-f75d6db24d56fe7631645ee707b4ca7f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468558</data>
    </edge>
    <edge source="RAID0" target="Data Striping">
      <data key="d6">1.0</data>
      <data key="d7">RAID0 implements data striping to improve performance and expand storage capacity.</data>
      <data key="d8">primary mechanism</data>
      <data key="d9">chunk-f75d6db24d56fe7631645ee707b4ca7f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468556</data>
    </edge>
    <edge source="RAID1" target="Mirroring">
      <data key="d6">1.0</data>
      <data key="d7">RAID1 relies on mirroring to ensure data availability in case of disk failure.</data>
      <data key="d8">primary mechanism</data>
      <data key="d9">chunk-f75d6db24d56fe7631645ee707b4ca7f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468556</data>
    </edge>
    <edge source="RAID1" target="Physical Disk">
      <data key="d6">1.0</data>
      <data key="d7">RAID1 requires at least two physical disks to maintain mirrored data.</data>
      <data key="d8">component relationship</data>
      <data key="d9">chunk-f75d6db24d56fe7631645ee707b4ca7f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468557</data>
    </edge>
    <edge source="RAID3" target="Parity">
      <data key="d6">1.0</data>
      <data key="d7">RAID3 uses dedicated parity for error detection and recovery during disk failure.</data>
      <data key="d8">core mechanism</data>
      <data key="d9">chunk-f75d6db24d56fe7631645ee707b4ca7f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468557</data>
    </edge>
    <edge source="RAID4" target="Parity">
      <data key="d6">1.0</data>
      <data key="d7">RAID4 employs a dedicated parity disk to support fault tolerance.</data>
      <data key="d8">core mechanism</data>
      <data key="d9">chunk-f75d6db24d56fe7631645ee707b4ca7f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468557</data>
    </edge>
    <edge source="RAID5" target="Parity">
      <data key="d6">1.0</data>
      <data key="d7">RAID5 distributes parity information across all disks to enable fault tolerance.</data>
      <data key="d8">core mechanism</data>
      <data key="d9">chunk-f75d6db24d56fe7631645ee707b4ca7f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468558</data>
    </edge>
    <edge source="RAID5" target="Physical Disk">
      <data key="d6">1.0</data>
      <data key="d7">RAID5 typically uses at least three physical disks, with one dedicated to parity.</data>
      <data key="d8">component relationship</data>
      <data key="d9">chunk-f75d6db24d56fe7631645ee707b4ca7f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468558</data>
    </edge>
    <edge source="Physical Disk" target="Logical Disk">
      <data key="d6">1.0</data>
      <data key="d7">A logical disk is constructed from multiple physical disks in a RAID configuration.</data>
      <data key="d8">construction relationship</data>
      <data key="d9">chunk-f75d6db24d56fe7631645ee707b4ca7f</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468557</data>
    </edge>
    <edge source="Tag" target="Address Tag Field">
      <data key="d6">1.0</data>
      <data key="d7">The address tag field provides the bits used to identify the main memory block stored in a cache line’s tag.</data>
      <data key="d8">address component,data identification</data>
      <data key="d9">chunk-361185a50ecc6636f127fb6f6ad6eabd</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468608</data>
    </edge>
    <edge source="Fully Associative Mapping" target="Figure 3.19">
      <data key="d6">1.0</data>
      <data key="d7">Figure 3.19 visually represents the fully associative mapping technique in cache design.</data>
      <data key="d8">diagrammatic representation,visual aid</data>
      <data key="d9">chunk-361185a50ecc6636f127fb6f6ad6eabd</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468608</data>
    </edge>
    <edge source="Program Transfer Probability" target="Data Distribution Discreteness">
      <data key="d6">1.0</data>
      <data key="d7">High program transfer probability combined with data distribution discreteness increases the challenge for memory system efficiency.</data>
      <data key="d8">memory load characteristic,system demand pattern</data>
      <data key="d9">chunk-d02693bcc2f3ef38eee5bb553035284e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468607</data>
    </edge>
    <edge source="Parallel Main Memory System" target="Memory System Efficiency">
      <data key="d6">1.0</data>
      <data key="d7">The efficiency of a parallel main memory system is limited when handling high transfer probability and distributed data.</data>
      <data key="d8">performance limitation,system constraint</data>
      <data key="d9">chunk-d02693bcc2f3ef38eee5bb553035284e</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468607</data>
    </edge>
    <edge source="Wear Leveling" target="Dynamic Wear Leveling">
      <data key="d6">1.0</data>
      <data key="d7">Dynamic Wear Leveling is a type of Wear Leveling that focuses on active write distribution during data operations.</data>
      <data key="d8">operational strategy,technical variant</data>
      <data key="d9">chunk-5b1903143e069742cd454a3ac6ea0d4a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468677</data>
    </edge>
    <edge source="Wear Leveling" target="Static Wear Leveling">
      <data key="d6">1.0</data>
      <data key="d7">Static Wear Leveling is a more advanced form of Wear Leveling that manages wear even without active data writes.</data>
      <data key="d8">advanced variant,proactive maintenance</data>
      <data key="d9">chunk-5b1903143e069742cd454a3ac6ea0d4a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468678</data>
    </edge>
    <edge source="Wear Leveling" target="256GB SSD">
      <data key="d6">1.0</data>
      <data key="d7">Wear Leveling is essential for maintaining the lifespan of a 256GB SSD under regular use.</data>
      <data key="d8">application context,performance improvement</data>
      <data key="d9">chunk-5b1903143e069742cd454a3ac6ea0d4a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468678</data>
    </edge>
    <edge source="Wear Leveling" target="Flash Memory Block">
      <data key="d6">1.0</data>
      <data key="d7">Wear Leveling ensures even wear across Flash Memory Blocks to maximize endurance.</data>
      <data key="d8">endurance optimization,usage balancing</data>
      <data key="d9">chunk-5b1903143e069742cd454a3ac6ea0d4a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468678</data>
    </edge>
    <edge source="Data Write Concentration" target="Flash Memory Block">
      <data key="d6">1.0</data>
      <data key="d7">Uneven writing to certain Flash Memory Blocks increases the risk of premature wear and failure.</data>
      <data key="d8">failure risk,wear hazard</data>
      <data key="d9">chunk-5b1903143e069742cd454a3ac6ea0d4a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468679</data>
    </edge>
    <edge source="Storage Capacity" target="Storage Word Count">
      <data key="d6">1.0</data>
      <data key="d7">Storage capacity is calculated by multiplying storage word count by word length.</data>
      <data key="d8">computational relationship,formula-based</data>
      <data key="d9">chunk-3c1c3cb1cdfefa986a82277dd52e88ef</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468738</data>
    </edge>
    <edge source="Storage Capacity" target="Word Length">
      <data key="d6">1.0</data>
      <data key="d7">Storage capacity depends on the word length, which determines the data amount per access.</data>
      <data key="d8">computational relationship,formula-based</data>
      <data key="d9">chunk-3c1c3cb1cdfefa986a82277dd52e88ef</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468739</data>
    </edge>
    <edge source="Byte" target="Bit">
      <data key="d6">1.0</data>
      <data key="d7">One byte equals eight bits, representing the conversion relationship between these digital information units.</data>
      <data key="d8">unit conversion</data>
      <data key="d9">chunk-3c1c3cb1cdfefa986a82277dd52e88ef</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468739</data>
    </edge>
    <edge source="有效位" target="外存">
      <data key="d6">1.0</data>
      <data key="d7">A valid bit of 0 indicates that the page is not in main memory and resides in secondary storage.</data>
      <data key="d8">page absence indication,storage location</data>
      <data key="d9">chunk-0af5a7c8d38a4b5d1e4bac2d53e20424</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468775</data>
    </edge>
    <edge source="有效位" target="物理页号">
      <data key="d6">1.0</data>
      <data key="d7">When the valid bit is 1, the page table entry holds the physical page number for address translation.</data>
      <data key="d8">address translation,page mapping</data>
      <data key="d9">chunk-0af5a7c8d38a4b5d1e4bac2d53e20424</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468775</data>
    </edge>
    <edge source="有效位" target="磁盘地址">
      <data key="d6">1.0</data>
      <data key="d7">When the valid bit is 0, the page table entry holds the disk address for page retrieval.</data>
      <data key="d8">fault handling,page storage location</data>
      <data key="d9">chunk-0af5a7c8d38a4b5d1e4bac2d53e20424</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468776</data>
    </edge>
    <edge source="磁盘地址" target="柱面号">
      <data key="d6">1.0</data>
      <data key="d7">柱面号is a key component of the disk address format used to locate data by track number.</data>
      <data key="d8">addressing structure,location identifier</data>
      <data key="d9">chunk-bc61336da91a3616939ad75ed1c5543a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468946</data>
    </edge>
    <edge source="磁盘地址" target="盘面号">
      <data key="d6">1.0</data>
      <data key="d7">盘面号is used to specify which recording surface (disk head) is involved in a read/write operation.</data>
      <data key="d8">addressing structure,surface identifier</data>
      <data key="d9">chunk-bc61336da91a3616939ad75ed1c5543a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468948</data>
    </edge>
    <edge source="磁盘地址" target="扇区号">
      <data key="d6">1.0</data>
      <data key="d7">扇区号is a unique identifier for a sector within a track in the disk addressing system.</data>
      <data key="d8">addressing structure,sector identifier</data>
      <data key="d9">chunk-bc61336da91a3616939ad75ed1c5543a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468949</data>
    </edge>
    <edge source="磁盘地址" target="16位二进制代码">
      <data key="d6">1.0</data>
      <data key="d7">16位二进制代码is the binary format used to represent a complete disk address in a system with 16 surfaces, 256 tracks, and 16 sectors.</data>
      <data key="d8">address representation,binary encoding</data>
      <data key="d9">chunk-bc61336da91a3616939ad75ed1c5543a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468950</data>
    </edge>
    <edge source="脏位" target="回写法">
      <data key="d6">1.0</data>
      <data key="d7">The dirty bit determines whether a page must be written back to disk during the replacement process using the write-back method.</data>
      <data key="d8">disk update,write-back mechanism</data>
      <data key="d9">chunk-0af5a7c8d38a4b5d1e4bac2d53e20424</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468774</data>
    </edge>
    <edge source="脏位" target="换出页面">
      <data key="d6">1.0</data>
      <data key="d7">If the dirty bit is set, a page being replaced must be written back to disk before being removed.</data>
      <data key="d8">disk write requirement,page replacement</data>
      <data key="d9">chunk-0af5a7c8d38a4b5d1e4bac2d53e20424</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468775</data>
    </edge>
    <edge source="引用位" target="替换法">
      <data key="d6">1.0</data>
      <data key="d7">The reference bit is used by replacement algorithms such as FIFO and LRU to determine which page to evict.</data>
      <data key="d8">access tracking,replacement algorithm</data>
      <data key="d9">chunk-0af5a7c8d38a4b5d1e4bac2d53e20424</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468775</data>
    </edge>
    <edge source="引用位" target="FIFO位">
      <data key="d6">1.0</data>
      <data key="d7">The reference bit supports the FIFO replacement strategy by tracking the order of page loading.</data>
      <data key="d8">FIFO strategy,page evict logic</data>
      <data key="d9">chunk-0af5a7c8d38a4b5d1e4bac2d53e20424</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468776</data>
    </edge>
    <edge source="引用位" target="LRU位">
      <data key="d6">1.0</data>
      <data key="d7">The reference bit is used in LRU to identify the least recently used page for replacement.</data>
      <data key="d8">LRU strategy,recency tracking</data>
      <data key="d9">chunk-0af5a7c8d38a4b5d1e4bac2d53e20424</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468776</data>
    </edge>
    <edge source="缺页异常" target="缺页异常处理程序">
      <data key="d6">1.0</data>
      <data key="d7">A page fault triggers the operating system's page fault handler to load the missing page.</data>
      <data key="d8">exception handling,operating system intervention</data>
      <data key="d9">chunk-0af5a7c8d38a4b5d1e4bac2d53e20424</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468776</data>
    </edge>
    <edge source="缺页异常处理程序" target="磁盘">
      <data key="d6">1.0</data>
      <data key="d7">The page fault handler accesses the disk to load the missing page into memory.</data>
      <data key="d8">page retrieval,secondary storage access</data>
      <data key="d9">chunk-0af5a7c8d38a4b5d1e4bac2d53e20424</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468776</data>
    </edge>
    <edge source="缺页异常处理程序" target="空闲物理页框">
      <data key="d6">1.0</data>
      <data key="d7">The page fault handler uses an empty physical frame to load the requested page.</data>
      <data key="d8">memory allocation,page loading</data>
      <data key="d9">chunk-0af5a7c8d38a4b5d1e4bac2d53e20424</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468777</data>
    </edge>
    <edge source="页式虚拟存储器" target="页面长度固定">
      <data key="d6">1.0</data>
      <data key="d7">Page-based virtual memory uses fixed-size pages, which simplifies memory management.</data>
      <data key="d8">memory organization,page size consistency</data>
      <data key="d9">chunk-0af5a7c8d38a4b5d1e4bac2d53e20424</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468776</data>
    </edge>
    <edge source="页式虚拟存储器" target="页表简单">
      <data key="d6">1.0</data>
      <data key="d7">The page table structure in page-based systems is simpler compared to segment-based systems.</data>
      <data key="d8">data structure simplicity</data>
      <data key="d9">chunk-0af5a7c8d38a4b5d1e4bac2d53e20424</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468777</data>
    </edge>
    <edge source="页式虚拟存储器" target="调入方便">
      <data key="d6">1.0</data>
      <data key="d7">Page-based systems facilitate efficient loading of pages from secondary storage.</data>
      <data key="d8">page loading ease,system efficiency</data>
      <data key="d9">chunk-0af5a7c8d38a4b5d1e4bac2d53e20424</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468777</data>
    </edge>
    <edge source="页式虚拟存储器" target="最后一页的零头">
      <data key="d6">1.0</data>
      <data key="d7">The inability to fully utilize the last page's remainder causes inefficient memory usage.</data>
      <data key="d8">fragmentation,memory waste</data>
      <data key="d9">chunk-0af5a7c8d38a4b5d1e4bac2d53e20424</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468778</data>
    </edge>
    <edge source="磁盘存储器" target="磁盘驱动器">
      <data key="d6">1.0</data>
      <data key="d7">磁盘驱动器is a core component of the磁盘存储器, responsible for mechanical movement and data transfer.</data>
      <data key="d8">component relationship,physical assembly</data>
      <data key="d9">chunk-bc61336da91a3616939ad75ed1c5543a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468938</data>
    </edge>
    <edge source="磁盘存储器" target="磁盘控制器">
      <data key="d6">1.0</data>
      <data key="d7">磁盘控制器interfaces with the磁盘存储器and serves as the communication channel between it and the host computer.</data>
      <data key="d8">component relationship,control interface</data>
      <data key="d9">chunk-bc61336da91a3616939ad75ed1c5543a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468939</data>
    </edge>
    <edge source="磁盘存储器" target="盘片">
      <data key="d6">1.0</data>
      <data key="d7">盘片is the primary physical storage component within the磁盘存储器.</data>
      <data key="d8">component relationship,storage medium</data>
      <data key="d9">chunk-bc61336da91a3616939ad75ed1c5543a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468941</data>
    </edge>
    <edge source="磁盘驱动器" target="磁头数">
      <data key="d6">1.0</data>
      <data key="d7">The number of magnetic heads in a disk drive corresponds directly to the number of recordable surfaces.</data>
      <data key="d8">hardware configuration,technical specification</data>
      <data key="d9">chunk-bc61336da91a3616939ad75ed1c5543a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468939</data>
    </edge>
    <edge source="磁盘驱动器" target="记录面">
      <data key="d6">1.0</data>
      <data key="d7">Each recording surface in a disk is accessed by one corresponding magnetic head in the disk drive.</data>
      <data key="d8">physical relationship,surface association</data>
      <data key="d9">chunk-bc61336da91a3616939ad75ed1c5543a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468941</data>
    </edge>
    <edge source="磁盘驱动器" target="磁道">
      <data key="d6">1.0</data>
      <data key="d7">The disk drive reads from and writes to concentric magnetic tracks through the movement of the magnetic head.</data>
      <data key="d8">operation domain,read/write access</data>
      <data key="d9">chunk-bc61336da91a3616939ad75ed1c5543a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468942</data>
    </edge>
    <edge source="磁道" target="扇区">
      <data key="d6">1.0</data>
      <data key="d7">Each magnetic track is divided into multiple sectors, the smallest units for data storage.</data>
      <data key="d8">hierarchical relationship,logical segmentation</data>
      <data key="d9">chunk-bc61336da91a3616939ad75ed1c5543a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468938</data>
    </edge>
    <edge source="磁道" target="柱面数">
      <data key="d6">1.0</data>
      <data key="d7">The number of cylinders equals the number of tracks per surface, with each cylinder formed by tracks of the same number across all surfaces.</data>
      <data key="d8">geometric alignment,spatial mapping</data>
      <data key="d9">chunk-bc61336da91a3616939ad75ed1c5543a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468939</data>
    </edge>
    <edge source="扇区" target="扇区数">
      <data key="d6">1.0</data>
      <data key="d7">The number of sectors per track determines how many sectors are available on each track.</data>
      <data key="d8">quantitative specification,sector distribution</data>
      <data key="d9">chunk-bc61336da91a3616939ad75ed1c5543a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468939</data>
    </edge>
    <edge source="柱面数" target="柱面号">
      <data key="d6">1.0</data>
      <data key="d7">Each cylinder is identified by a cylinder number, used in the disk addressing system.</data>
      <data key="d8">cylinder identification,logical address mapping</data>
      <data key="d9">chunk-bc61336da91a3616939ad75ed1c5543a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468940</data>
    </edge>
    <edge source="磁盘高速缓存" target="内存">
      <data key="d6">1.0</data>
      <data key="d7">磁盘高速缓存is implemented as a region in main memory used to temporarily store data during disk operations.</data>
      <data key="d8">buffer area,memory allocation</data>
      <data key="d9">chunk-bc61336da91a3616939ad75ed1c5543a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468940</data>
    </edge>
    <edge source="磁盘高速缓存" target="写磁盘">
      <data key="d6">1.0</data>
      <data key="d7">The disk cache improves write performance by batching small data writes into larger "clusters."</data>
      <data key="d8">data optimization,performance enhancement</data>
      <data key="d9">chunk-bc61336da91a3616939ad75ed1c5543a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468943</data>
    </edge>
    <edge source="磁盘高速缓存" target="中间结果数据">
      <data key="d6">1.0</data>
      <data key="d7">Intermediate data stored in the disk cache can be quickly accessed again before being written to disk.</data>
      <data key="d8">reuse optimization,temporary storage</data>
      <data key="d9">chunk-bc61336da91a3616939ad75ed1c5543a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468946</data>
    </edge>
    <edge source="磁记录原理" target="电磁转换">
      <data key="d6">1.0</data>
      <data key="d7">The magnetic recording principle relies on electromagnetic conversion between the magnetic head and the medium during read and write.</data>
      <data key="d8">data operation,physical mechanism</data>
      <data key="d9">chunk-bc61336da91a3616939ad75ed1c5543a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468941</data>
    </edge>
    <edge source="编码方法" target="磁记录方式">
      <data key="d6">1.0</data>
      <data key="d7">Encoding methods determine how binary data is converted into magnetic states, with FM and MFM being common recording formats.</data>
      <data key="d8">data representation,recording technique</data>
      <data key="d9">chunk-bc61336da91a3616939ad75ed1c5543a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468941</data>
    </edge>
    <edge source="调频制" target="改进型调频制">
      <data key="d6">1.0</data>
      <data key="d7">改进型调频制is an enhanced version of调频制with improved space efficiency and data density.</data>
      <data key="d8">evolution,technological improvement</data>
      <data key="d9">chunk-bc61336da91a3616939ad75ed1c5543a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468942</data>
    </edge>
    <edge source="记录密度" target="道密度">
      <data key="d6">1.0</data>
      <data key="d7">录密度is calculated by multiplying bit density and track density, with track density being a key factor.</data>
      <data key="d8">composite metric,dimensional analysis</data>
      <data key="d9">chunk-bc61336da91a3616939ad75ed1c5543a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468943</data>
    </edge>
    <edge source="记录密度" target="位密度">
      <data key="d6">1.0</data>
      <data key="d7">位密度determines the amount of data stored per unit length along a track and contributes to overall surface density.</data>
      <data key="d8">composite metric,dimensional analysis</data>
      <data key="d9">chunk-bc61336da91a3616939ad75ed1c5543a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468945</data>
    </edge>
    <edge source="记录密度" target="面密度">
      <data key="d6">1.0</data>
      <data key="d7">面密度is the product of bit and track density, determining total data storage capacity per disk surface.</data>
      <data key="d8">composite metric,surface capacity</data>
      <data key="d9">chunk-bc61336da91a3616939ad75ed1c5543a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468946</data>
    </edge>
    <edge source="磁盘容量" target="非格式化容量">
      <data key="d6">1.0</data>
      <data key="d7">非格式化容量refers to the total number of magnetic units available before formatting.</data>
      <data key="d8">capacity type,raw storage</data>
      <data key="d9">chunk-bc61336da91a3616939ad75ed1c5543a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468944</data>
    </edge>
    <edge source="磁盘容量" target="格式化容量">
      <data key="d6">1.0</data>
      <data key="d7">格式化容量is the actual usable storage after formatting, which is less than non-formatted capacity due to formatting overhead.</data>
      <data key="d8">capacity type,usable storage</data>
      <data key="d9">chunk-bc61336da91a3616939ad75ed1c5543a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468946</data>
    </edge>
    <edge source="存取时间" target="寻道时间">
      <data key="d6">1.0</data>
      <data key="d7">寻道时间is a component of access time, measured as the average time to move the head to a target track.</data>
      <data key="d8">component,mechanical delay</data>
      <data key="d9">chunk-bc61336da91a3616939ad75ed1c5543a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468945</data>
    </edge>
    <edge source="存取时间" target="旋转延迟时间">
      <data key="d6">1.0</data>
      <data key="d7">旋转延迟时间contributes to access time, typically averaging half a rotation cycle.</data>
      <data key="d8">component,rotational delay</data>
      <data key="d9">chunk-bc61336da91a3616939ad75ed1c5543a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468946</data>
    </edge>
    <edge source="存取时间" target="传输时间">
      <data key="d6">1.0</data>
      <data key="d7">传输时间is the duration required to transfer data from disk to host, depending on data size and disk speed.</data>
      <data key="d8">component,data transfer phase</data>
      <data key="d9">chunk-bc61336da91a3616939ad75ed1c5543a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468948</data>
    </edge>
    <edge source="数据传输速率" target="磁盘转数">
      <data key="d6">1.0</data>
      <data key="d7">数据传输速率is directly proportional to the disk's rotational speed in revolutions per second.</data>
      <data key="d8">performance calculation,speed factor</data>
      <data key="d9">chunk-bc61336da91a3616939ad75ed1c5543a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468946</data>
    </edge>
    <edge source="数据传输速率" target="每条磁道容量">
      <data key="d6">1.0</data>
      <data key="d7">The total data transfer rate depends on the number of bytes per track and rotational speed.</data>
      <data key="d8">capacity factor,performance calculation</data>
      <data key="d9">chunk-bc61336da91a3616939ad75ed1c5543a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468950</data>
    </edge>
    <edge source="Disk Address" target="Cylinder Track Number">
      <data key="d6">1.0</data>
      <data key="d7">Cylinder track number is a key component of the disk address used to locate data on a disk.</data>
      <data key="d8">addressing component,data location</data>
      <data key="d9">chunk-59c3b987a075436eab7c271ca2d5302a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468948</data>
    </edge>
    <edge source="Disk Address" target="Disk Surface Head Number">
      <data key="d6">1.0</data>
      <data key="d7">Disk surface head number is a key component of the disk address used to specify the correct disk surface.</data>
      <data key="d8">addressing component,data location</data>
      <data key="d9">chunk-59c3b987a075436eab7c271ca2d5302a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468950</data>
    </edge>
    <edge source="Disk Address" target="Sector Number">
      <data key="d6">1.0</data>
      <data key="d7">Sector number is a key component of the disk address used to pinpoint the exact data sector.</data>
      <data key="d8">addressing component,data location</data>
      <data key="d9">chunk-59c3b987a075436eab7c271ca2d5302a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468951</data>
    </edge>
    <edge source="16-Bit Binary Code" target="Cylinder Track Number (8 Bits)">
      <data key="d6">1.0</data>
      <data key="d7">The 16-bit binary code includes 8 bits dedicated to encoding the cylinder track number.</data>
      <data key="d8">data format component,encoding</data>
      <data key="d9">chunk-59c3b987a075436eab7c271ca2d5302a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468950</data>
    </edge>
    <edge source="16-Bit Binary Code" target="Disk Surface Head Number (4 Bits)">
      <data key="d6">1.0</data>
      <data key="d7">The 16-bit binary code includes 4 bits dedicated to encoding the disk surface head number.</data>
      <data key="d8">data format component,encoding</data>
      <data key="d9">chunk-59c3b987a075436eab7c271ca2d5302a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468951</data>
    </edge>
    <edge source="16-Bit Binary Code" target="Sector Number (4 Bits)">
      <data key="d6">1.0</data>
      <data key="d7">The 16-bit binary code includes 4 bits dedicated to encoding the sector number.</data>
      <data key="d8">data format component,encoding</data>
      <data key="d9">chunk-59c3b987a075436eab7c271ca2d5302a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468953</data>
    </edge>
    <edge source="Read Operation" target="Disk Access Process">
      <data key="d6">1.0</data>
      <data key="d7">The disk access process includes the sequential execution of a read operation.</data>
      <data key="d8">operation execution,sequential process</data>
      <data key="d9">chunk-59c3b987a075436eab7c271ca2d5302a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468952</data>
    </edge>
    <edge source="Read Operation" target="Mechanical Disk">
      <data key="d6">1.0</data>
      <data key="d7">Mechanical disks cannot perform read and write operations simultaneously due to physical limitations.</data>
      <data key="d8">operation constraint,physical limitation</data>
      <data key="d9">chunk-59c3b987a075436eab7c271ca2d5302a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468953</data>
    </edge>
    <edge source="Write Operation" target="Disk Access Process">
      <data key="d6">1.0</data>
      <data key="d7">The disk access process includes the sequential execution of a write operation.</data>
      <data key="d8">operation execution,sequential process</data>
      <data key="d9">chunk-59c3b987a075436eab7c271ca2d5302a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468953</data>
    </edge>
    <edge source="Write Operation" target="Mechanical Disk">
      <data key="d6">1.0</data>
      <data key="d7">Mechanical disks cannot perform multiple write operations at the same time due to physical limitations.</data>
      <data key="d8">operation constraint,physical limitation</data>
      <data key="d9">chunk-59c3b987a075436eab7c271ca2d5302a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468954</data>
    </edge>
    <edge source="Seek Operation" target="Disk Access Process">
      <data key="d6">1.0</data>
      <data key="d7">The disk access process includes the sequential execution of a seek operation.</data>
      <data key="d8">operation execution,sequential process</data>
      <data key="d9">chunk-59c3b987a075436eab7c271ca2d5302a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468954</data>
    </edge>
    <edge source="Control Word" target="Disk Access Process">
      <data key="d6">1.0</data>
      <data key="d7">The disk access process begins with retrieving the control word before executing the operation.</data>
      <data key="d8">command retrieval,operation sequence</data>
      <data key="d9">chunk-59c3b987a075436eab7c271ca2d5302a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468954</data>
    </edge>
    <edge source="Control Word" target="Mechanical Disk">
      <data key="d6">1.0</data>
      <data key="d7">Mechanical disks execute operations based on control words received from the controller.</data>
      <data key="d8">command flow,operation execution</data>
      <data key="d9">chunk-59c3b987a075436eab7c271ca2d5302a</data>
      <data key="d10">unknown_source</data>
      <data key="d11">1761468955</data>
    </edge>
  </graph>
</graphml>
