{
  "chunk-e100f5adcf7f52281eb1c5920bc2d5d0": {
    "tokens": 722,
    "content": "DRAM的工作原理 与SRAM的存储原理不同，动态随机存储器(DRAM) 是利用存储元电路中栅极电容上的电荷来存储信息的，DRAM的基本存储元通常只使用一个晶体管，所以它比SRAM 的密度要高很 多。相对于 SRAM来说 ，DRAM 具有集成度高、位价低和功耗小等优点，但 DRAM 的存取速度比 SRAM慢，且必须定时刷新和读后再生，一般用于大容量的主存系统。 DRAM电容上的电荷一般只能维持1～2ms, 因此即使电源不断电，信息也会自动消失。此 外，读操作会使其状态发生改变(破坏性读出),需读后再生，这也是称其为动态存储器的原因。 刷新可以采用读出的方法进行，根据读出内容对相应单元进行重写，即读后再生。对同一行进行相邻两次刷新的时间间隔称为刷新周期，通常取2ms。常用的刷新方式有以下3种： 1)集中刷新：在一个刷新周期内，利用一段固定的时间，依次对存储器的所有行进行逐一 再生，在此期间停止对存储器的读/写操作，称为死时间，也称访存死区。优点是读/写操 作期间不受刷新操作的影响；缺点是在集中刷新期间(死区)不能访问存储器。 2)分散刷新：将一个存储器系统的工作周期分为两部分：前半部分用于正常的读/写操作； 后半部分用于刷新。这种刷新方式增加了系统的存取周期，如存储芯片的存取周期为 0.5μs,则系统的存取周期为 lμs 。优点是没有死区；缺点是加长了系统的存取周期。 3)异步刷新：结合了前两种方法，使得在一个刷新周期内每一行仅刷新一次。具体做法是 将刷新周期除以行数，得到相邻两行之间刷新的时间间隔t, 每隔时间t 产生一次刷新请 求。这样就使“死时间”的分布更加分散，避免让CPU 连续等待过长的时间。 DRAM 的刷新需要注意以下问题： ①刷新对CPU 是透明的，即刷新不依赖于外部的访问； ②DRAM 的刷新单位是行，由芯片内部自行生成行地址；③刷新操作类似于读操作，但又有所不 同。另外，刷新时不需要选片，即整个存储器中的所有芯片同时被刷新。 虽然DRAM的刷新和再生都是恢复数据，但刷新与再生的过程并不完全相同。刷新是以行为单位，逐行恢复数据的，而再生仅需恢复被读出的那些单元的数据。 DRAM芯片容量较大，地址位数较多，为了减少芯片的地址引脚数，通常采用地址引脚复用 技术，行地址和列地址通过相同的引脚分先后两次输入，这样地址引脚数可减少一半。",
    "chunk_order_index": 0,
    "full_doc_id": "doc-e100f5adcf7f52281eb1c5920bc2d5d0",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:2df8ab51cca51e907687301bca74ef25",
      "default:extract:e4cf334d88742092196f638569a2313d"
    ],
    "create_time": 1761468003,
    "update_time": 1761468052,
    "_id": "chunk-e100f5adcf7f52281eb1c5920bc2d5d0"
  },
  "chunk-14ad8c0a834e0ce37fd97c7ac9177add": {
    "tokens": 462,
    "content": "主存储器的基本组成 由一个个存储0或1的记忆单元 (也称存储元件、存储单元)构成的存储矩阵(也称存储体、存储阵列)是存储器的核心部件。存储元件是具有两种稳态的能表示二进制0和1的物理器件。为了存取存储体中的信息，必须对存储单元编号(也称编址)。编址单位是指具有相同地址的那些存储元件构成的一个单位，可以按字节编址，也可以按字编址。现代计算机通常采用字节编址方式。 指令执行过程中需要访问主存时，CPU 首先把被访问单元的地址送到MAR 中，然后通过地 址线将主存地址送到主存中的地址寄存器，以便地址译码器进行译码，选中相应单元，同时 CPU 将读/写控制信号通过控制线送到主存的读/写控制电路。若是写操作，则CPU 同时将要写的 信息送到MDR 中，在读/写控制电路的控制下，经数据线将信号写入选中的单元；若是读操作， 则主存读出选中单元的内容送至数据线，然后被送到 MDR 中 。MDR的位数与数据线的位数相 同 ，MAR的位数与地址线的位数相同。图3.6采用64位数据线，所以在按字节编址方式下，每 次最多可以存取8个单元的内容。地址线的位数决定了主存地址空间的最大可寻址范围。例如， 36位地址的最大寻址范围为0～2³⁶-1,即地址从0开始编号。 数据线的位数通常等于存储字长，因此MDR的位数通常等于存储字长；若数据线的位数不等于存 储字长，则MDR的位数由数据线的位数决定。",
    "chunk_order_index": 0,
    "full_doc_id": "doc-14ad8c0a834e0ce37fd97c7ac9177add",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:b9b4364dc89326fb94fda207fe098857",
      "default:extract:03278d9b8397222c30427edcd94335c8"
    ],
    "create_time": 1761468003,
    "update_time": 1761468053,
    "_id": "chunk-14ad8c0a834e0ce37fd97c7ac9177add"
  },
  "chunk-9dccf612396a3accbfe19f8f0ed1d51b": {
    "tokens": 404,
    "content": "多级层次的存储系统 为了解决存储系统大容量、高速度和低成本这三个相互制约的矛盾，在计算机系统中，通常 采用多级存储器结构。存储器层次结构的主要思想是上一层的存储器作为低一层存储器的高速缓存。 当 CPU要从存储器中存取数据时，先访问Cache, 若不在Cache中，则访问主存，若不在主存中，则访问磁盘，此时，操作数从磁盘读出送到主存，然后从主存送到Cache 。从 CPU 的角度看， Cache-主存层的速度接近于Cache, 容量和位价却接近于主存。从主存-辅存层分析，其速度接近于主存，容量和位价却接近于辅存。这就解决了速度、容量、成本这三者之间的矛盾。 Cache- 主存层主要解决CPU 和主存速度不匹配的问题，主存和 Cache 之间的数据调动是由硬件自动完成的，对所有程序员均是透明的。主存一辅存层主要解决存储系统的容量问题，主存 和辅存之间的数据调动是由硬件和操作系统共同完成的，对应用程序员是透明的。 在主存-辅存层的不断发展中，逐渐形成了虚拟存储系统，在这个系统中程序员编程的地址 范围与虚拟存储器的地址空间相对应，编程时可用的地址空间远大于主存空间。 在Cache-主存层和主存一辅存层中，上一层中的内容都只是下一层中的内容的副本，也即Cache(或主存)中的内容只是主存(或辅存)中的内容的一部分。",
    "chunk_order_index": 0,
    "full_doc_id": "doc-9dccf612396a3accbfe19f8f0ed1d51b",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:7e7436908ee8d6f874fe11f930fa6f1b",
      "default:extract:892e6ed4d7b2a69f05d9c9537f87a334"
    ],
    "create_time": 1761468064,
    "update_time": 1761468099,
    "_id": "chunk-9dccf612396a3accbfe19f8f0ed1d51b"
  },
  "chunk-ed6056f0e58f2d01493e9eeb4c4363bd": {
    "tokens": 357,
    "content": "31. 具有TLB 和 Cache 的多级存储系统 假设一个具有TLB 和 Cache 的多级存储系统，其中Cache 采用2路组相联方式。 CPU 给出一个32位的虚拟地址，TLB采用全相联方式，每一项都有一个比较器，查找时将虚页号与每个TLB标记字段同时进行比较，若有某一项相等且对应有效位为1,则 TLB 命中，此时可直接通过 TLB 进行地址转换；若未命中，则TLB 缺失，需要访问主存去查页表。对于两级页表方式，虚页号被分成页目录索引和页表索引两部分，由这两部分得到对应的页表项，从而进行地址转换，并将相应表项调入 TLB, 若 TLB 已满，则还需要采用替换法。完成由虚拟地址到物理地址的转换后，Cache机构根据映射方式将物理地址划分成多个字段，然后根据映射规则 找到对应的Cache 行或组，将对应Cache 行中的标记与物理地址中的高位部分进行比较，若相等 且对应有效位为1,则Cache 命中，此时根据块内地址取出对应的字送给CPU。 查找时，快表和慢表也可以同步进行，若快表中有此虚页号，则能很快地找到对应的实页号， 并且使慢表的查找作废，从而就能做到虽采用虚拟存储器但访问主存速度几乎没有下降。",
    "chunk_order_index": 0,
    "full_doc_id": "doc-ed6056f0e58f2d01493e9eeb4c4363bd",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:fb983b0f8a8b1569f4f6bca71cb2cc33",
      "default:extract:0de4a4d95bbef0b05c29baefd86b9391"
    ],
    "create_time": 1761468069,
    "update_time": 1761468109,
    "_id": "chunk-ed6056f0e58f2d01493e9eeb4c4363bd"
  },
  "chunk-3dce61048f7c557d41879fb4d9705cdc": {
    "tokens": 197,
    "content": "21. 程序访问的局部性原理 程序访问的局部性原理包括时间局部性和空间局部性。 时间局部性是指最近的未来要用到的信息，很可能是现在正在使用的信息，因为程序中存在 循环和需要多次重复执行的子程序段，以及对数组的存储和访问操作。空间局部性是指最近的未 来要用到的信息，很可能与现在正在使用的信息在存储空间上是邻近的，因为指令通常是顺序存 放、顺序执行的，数据一般也是以向量、数组等形式簇聚地存储的。 高速缓冲技术就是利用局部性原理，把程序中正在使用的部分数据存放在一个高速的、容量 较小的Cache 中，使CPU 的访存操作大多数针对 Cache 进行，从而提高程序的执行速度。",
    "chunk_order_index": 0,
    "full_doc_id": "doc-3dce61048f7c557d41879fb4d9705cdc",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:39830beb286cc364ba37336ad809f19b",
      "default:extract:ff05b4da49149223a906a70287b1ba08"
    ],
    "create_time": 1761468104,
    "update_time": 1761468116,
    "_id": "chunk-3dce61048f7c557d41879fb4d9705cdc"
  },
  "chunk-0d5d7f0f10bdd7e081046bf9fbfdf10a": {
    "tokens": 107,
    "content": "27. 页式虚拟存储器 页式虚拟存储器以页为基本单位。主存空间和虚拟地址空间都被划分成相同大小的页，主存 空间中的页称为物理页、实页、页框，虚拟地址空间中的页称为虚拟页、虚页。页表记录了程序的虚页调入主存时被安排在主存中的位置。页表一般长久地保存在内存中。",
    "chunk_order_index": 0,
    "full_doc_id": "doc-0d5d7f0f10bdd7e081046bf9fbfdf10a",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:ad5995522e10d88cdeaa13ba3115e833",
      "default:extract:8478def1bf2df4a6aa6df41056796a09"
    ],
    "create_time": 1761468114,
    "update_time": 1761468128,
    "_id": "chunk-0d5d7f0f10bdd7e081046bf9fbfdf10a"
  },
  "chunk-8ce34f8853facbe5658d8d7a94051590": {
    "tokens": 104,
    "content": "只读存储器 (ROM)的特点 ROM 和 RAM 都是支持随机访问的存储器，其中SRAM 和 DRAM 均为易失性半导体存储器。 而ROM 中一旦有了信息，就不能轻易改变，即使掉电也不会丢失。ROM 具有两个显著的优点：①结构简单，所以位密度比可读/写存储器的高。②具有非易失性，所以可靠性高。",
    "chunk_order_index": 0,
    "full_doc_id": "doc-8ce34f8853facbe5658d8d7a94051590",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:d261c814701a12324df1f262f4278b89",
      "default:extract:627f5a62576e0ee2d70a8c4bd36df007"
    ],
    "create_time": 1761468118,
    "update_time": 1761468132,
    "_id": "chunk-8ce34f8853facbe5658d8d7a94051590"
  },
  "chunk-263465ac01c4eb10c3c852d62559620b": {
    "tokens": 274,
    "content": "30. 快表 (TLB) 由地址转换过程可知，访存时先访问一次主存去查页表，再访问主存才能取得数据。若缺页， 则还要进行页面替换、页面修改等，因此采用虚拟存储机制后，访问主存的次数更多了。 依据程序访问的局部性原理，在一段时间内总是经常访问某些页时，若把这些页对应的页表 项存放在高速缓冲器组成的快表 (TLB)中，则可以明显提高效率。相应地把放在主存中的页表称为慢表 (Page) 。在地址转换时，首先查找快表，若命中，则无须访问主存中的页表。 快表用SRAM 实现，其工作原理类似于Cache, 通常采用全相联或组相联映射方式。TLB 表 项由页表表项内容和 TLB 标记组成。全相联映射下，TLB 标记就是对应页表项的虚拟页号；组相联方式下，TLB标记则是对应虚拟页号的高位部分，而虚拟页号的低位部分作为TLB组的组号。",
    "chunk_order_index": 0,
    "full_doc_id": "doc-263465ac01c4eb10c3c852d62559620b",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:a775e3af1739aa2a91dee3943a50b90f",
      "default:extract:b244490e991a494c44265e643344f285"
    ],
    "create_time": 1761468131,
    "update_time": 1761468160,
    "_id": "chunk-263465ac01c4eb10c3c852d62559620b"
  },
  "chunk-833bb1bcf85cd79d91b4dcd6ca2eb3db": {
    "tokens": 354,
    "content": "35. 虚拟存储器与Cache 的比较 虚拟存储器与Cache 既有很多相同之处，又有很多不同之处。 (1)相同之处 1)最终目标都是为了提高系统性能，两者都有容量、速度、价格的梯度。 2)都把数据划分为小信息块，并作为基本的交换单位，虚存系统的信息块更大。 3)都有地址映射、替换算法、更新策略等问题。 4)都依据局部性原理应用“快速缓存”的思想，将活跃的数据放在相对高速的部件中。 (2)不同之处 1)Cache主要解决系统速度，而虚拟存储器却是为了解决主存容量。 2)Cache全由硬件实现，是硬件存储器，对所有程序员透明；而虚拟存储器由OS 和硬件共 同实现，是逻辑上的存储器，对系统程序员不透明，但对应用程序员透明。 3)对于不命中性能影响，因为CPU 的速度约为Cache 的10倍，主存的速度为硬盘的100 倍以上，因此虚拟存储器系统不命中时对系统性能影响更大。 4)CPU 与 Cache 和主存都建立了直接访问的通路，而辅存与CPU 没有直接通路。也就是说 在 Cache 不命中时主存能和 CPU 直接通信，同时将数据调入 Cache; 而虚拟存储器系统 不命中时，只能先由硬盘调入主存，而不能直接和 CPU 通信。",
    "chunk_order_index": 0,
    "full_doc_id": "doc-833bb1bcf85cd79d91b4dcd6ca2eb3db",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:d63d98495d25cfbece012189ef2ca807",
      "default:extract:e3d496dbfb56baaa7f2a80070b538354"
    ],
    "create_time": 1761468136,
    "update_time": 1761468179,
    "_id": "chunk-833bb1bcf85cd79d91b4dcd6ca2eb3db"
  },
  "chunk-b1c06d839960e789e3e60c72b78fd928": {
    "tokens": 272,
    "content": "29. 虚拟地址和物理地址转换 在虚拟存储系统中，指令给出的地址是虚拟地址，因此当 CPU执行指令时，要先将虚拟地址转换为主存物理地址，才能到主存中存取指令和数据。虚拟地址分为两个字段：高位为虚页号，低位为页内偏移地址。物理地址也分为两个字段：高位为物理页号，低位为页内偏移地址。两者的页面大小相同，因此页内偏移地址是相等的。虚拟地址到物理地址的转换是由页表实现的，页表是一张存放在主存中的虚页号和实页号的对照表。 每个进程都有一个页表基址寄存器，存放该进程的页表首地址，据此找到对应的页表首地址 ,然后根据虚拟地址高位的虚拟页号找到对应的页表项,若装入位为1,则取 出物理页号,和虚拟地址低位的页内地址拼接，形成实际物理地址。若装入位为0,说明缺页，需要操作系统进行缺页处理。",
    "chunk_order_index": 0,
    "full_doc_id": "doc-b1c06d839960e789e3e60c72b78fd928",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:a7954b1230e2f434ff1c1f52a39f3c96",
      "default:extract:b19f6e59e2e23735c1c6f153775c52d5"
    ],
    "create_time": 1761468165,
    "update_time": 1761468186,
    "_id": "chunk-b1c06d839960e789e3e60c72b78fd928"
  },
  "chunk-d6bddd3dfdc4b05e9f684acd41e40adb": {
    "tokens": 413,
    "content": "13. 主存容量的扩展 单个存储芯片的容量是有限的，它在字数或字长方面与实际存储器的要求都有差距，因此需 要在字和位两方面进行扩充才能满足实际存储器的容量要求。 （1）位扩展法 位扩展是指对字长进行扩展(增加存储字长)。当CPU 的系统数据线数多于存储芯片的数 据位数时，必须对存储芯片扩位，使其数据位数与 CPU 的数据线数相等。 位扩展的连接方式：各芯片的地址线、片选控制线和读/写控制线与系统总线相应并联；各芯片的数据线单独引出，分别连接系统数据线。各芯片同时工作。 （2）字扩展法 字扩展是指对存储字的数量进行扩展，而存储字的位数满足系统要求。系统数据线位数等于 芯片数据线位数，系统地址线位数多于芯片地址线位数。 字扩展的连接方式：各芯片的地址线与系统地址线的低位对应相连；芯片的数据线和读/写控 制线与系统总线相应并联；由系统地址线的高位译码得到各芯片的片选信号。各芯片分时工作。 （3）字位同时扩展法 字位同时扩展是前两种扩展的组合，这种方式既增加存储字的数量，又增加存储字长。 字位同时扩展的连接方式：将进行位扩展的芯片作为一组，各组的连接方式与位扩展的相 同；由系统地址线高位译码产生若干片选信号，分别接到各组芯片的片选控制线。",
    "chunk_order_index": 0,
    "full_doc_id": "doc-d6bddd3dfdc4b05e9f684acd41e40adb",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:3838754e2e70abd04ac0805c4926e365",
      "default:extract:0dd5fa08ffa98076ec6aa54080f6c28b"
    ],
    "create_time": 1761468192,
    "update_time": 1761468216,
    "_id": "chunk-d6bddd3dfdc4b05e9f684acd41e40adb"
  },
  "chunk-946a56828431f2eb84c208ded0826aae": {
    "tokens": 545,
    "content": "15. 存储器与CPU的连接 （1）合理选择存储芯片 要组成一个主存系统，选择存储芯片是第一步，主要指存储芯片的类型 (RAM或ROM) 和数量的选择。通常选用ROM 存放系统程序、标准子程序和各类常数，RAM则是为用户编程而设置的。此外，在考虑芯片数量时，要尽量使连线简单、方便。 （2）地址线的连接 存储芯片的容量不同，其地址线数也不同，而 CPU 的地址线数往往比存储芯片的地址线数 要多。通常将CPU 地址线的低位与存储芯片的地址线相连，以选择芯片中的某一单元(字选), 这部分的译码是由芯片的片内逻辑完成的。而CPU 地址线的高位则在扩充存储芯片时使用，用来 选择存储芯片(片选),这部分译码由外接译码器逻辑完成。 （3）数据线的连接 CPU的数据线数与存储芯片的数据线数不一定相等，在相等时可直接相连；在不等时必须对 存储芯片扩位，使其数据位数与CPU 的数据线数相等。 （4）读/写控制线的连接 CPU读/写控制线一般可直接与存储芯片的读/写控制端相连，通常高电平为读，低电平为写。 有些CPU 的读/写控制线是分开的(读为RD,写为WE,均为低电平有效),此时CPU 的读命令 线应与芯片的允许读控制端相连，而CPU 的写命令线则应与芯片的允许写控制端相连。 （5）片选控制线的连接 片选控制线的连接是 CPU 与存储芯片连接的关键。存储器由许多存储芯片叠加而成，哪一 片被选中完全取决于该存储芯片的片选控制端CS 是否能接收到来自CPU 的片选有效信号。片选有效信号与 CPU 的访存控制信号MREQ(低电平有效)有关，因为只有当CPU 要求访存时，才要求选中存储芯片。若CPU 访问I/O, 则MREQ为高，表示不要求存储器工作。",
    "chunk_order_index": 0,
    "full_doc_id": "doc-946a56828431f2eb84c208ded0826aae",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:59e169df8e8c6e0f12d216dfa0a8775a",
      "default:extract:d3d2d67ee7eac7f4510b63570fff98cd"
    ],
    "create_time": 1761468192,
    "update_time": 1761468219,
    "_id": "chunk-946a56828431f2eb84c208ded0826aae"
  },
  "chunk-6c698405c4fcc8fb19ebad83fe798b48": {
    "tokens": 389,
    "content": "32. TLB、Cache和Page缺失组合的分析 在一个具有TLB和Cache 的多级存储系统中，CPU一次访存操作可能涉及TLB、页表、Cache、 主存和磁盘的访问。CPU 访存过程中存在三种缺失情况： ①TLB缺失：要访问的页面的页表项不在 TLB中。 ②Cache缺失：要访问的主存块不在Cache中： ③Page 缺失：要访问的页面不在主存中。 TLB只是页表的一部分副本，因此Page缺失时， T LB也必然缺失。同理，Cache也只是主存的一部分副本，页表未命中意味着信息不在主存，因此 Page 缺失时，Cache也必然缺失 。 TLB命中则Page一定命中，信息在主存，就可能在Cache中 TLB命中则Page一定命中，信息在主存，也可能不在Cache中 TLB缺失但Page可能命中，信息在主存，就可能在Cache中 TLB缺失但Page可能命中，信息在主存，也可能不在Cache中 TLB缺失则Page也可能缺失，信息不在主存，也一定不在Cache 最好的情况是第1种组合，此时无须访问主存；第2种和第3种组合都需要访问一次主存； 第4种组合需要访问两次主存；第5种组合发生“缺页异常”,需要访问磁盘，并且至少访问两次主存。Cache缺失处理由硬件完成；缺页处理由软件完成，操作系统通过“缺页异常处理程序”来实现；而TLB 缺失既可以用硬件又可以用软件来处理。",
    "chunk_order_index": 0,
    "full_doc_id": "doc-6c698405c4fcc8fb19ebad83fe798b48",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:f6af926768173a455f9b6b90f5217548",
      "default:extract:21c24eca37ec3b61c31a645e4f4711ed"
    ],
    "create_time": 1761468225,
    "update_time": 1761468264,
    "_id": "chunk-6c698405c4fcc8fb19ebad83fe798b48"
  },
  "chunk-364aa0dbd990ea22dbb324056cc5473e": {
    "tokens": 467,
    "content": "ROM的类型 根据制造工艺的不同，ROM可分为掩模式只读存储器 (MROM)、一次可编程只读存储器 (PROM )、可擦除可编程只读存储器 (EPROM) 、Flash存储器和固态硬盘 (SSD)。 (1)掩模式只读存储器 MROM 的内容由半导体制造厂商按用户提出的要求在芯片的生产过程中直接写入，写入以 后任何人都无法改变其内容。优点是可靠性高、集成度高、价格便宜；缺点是灵活性差。 (2)一次可编程只读存储器 PROM 是可以实现一次性编程的只读存储器，允许用户利用专门的设备(编程器)写入自己 的程序，一旦写入，内容就无法改变。 (3)可擦除可编程只读存储器 EPROM 不仅可以由用户利用编程器写入信息，而且可以对其内容进行多次改写。EPROM 虽 然既可读又可写，但它不能取代RAM, 因为EPROM 的编程次数有限，且写入时间过长。 (4)Flash存储器 Flash 存储器是在EPROM 的基础上发展起来的，它兼有ROM 和 RAM 的优点，可在不加电 的情况下长期保存信息，又能在线进行快速擦除与重写。Flash 存储器既有 EPROM 价格便宜、集成度高的优点，又有 E²PROM 电可擦除重写的特点，且擦除重写的速度快。 (5)固态硬盘 (Solid State Drive,SSD) 基于闪存的固态硬盘是用固态电子存储芯片阵列制成的硬盘，由控制单元和存储单元(Flash 芯片)组成。保留了 Flash 存储器长期保存信息、快速擦除与重写的特性。对比传统硬盘也具有 读/写速度快、低功耗的特性，缺点是价格较高。",
    "chunk_order_index": 0,
    "full_doc_id": "doc-364aa0dbd990ea22dbb324056cc5473e",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:2c41ca94515d8ab47557c5dee5ffda7e",
      "default:extract:8928f27a0ad5a72e6f58b4f2b6e516a5"
    ],
    "create_time": 1761468227,
    "update_time": 1761468249,
    "_id": "chunk-364aa0dbd990ea22dbb324056cc5473e"
  },
  "chunk-8f87fc865b405b5892e67cab1873a773": {
    "tokens": 355,
    "content": "10. 多模块存储器 多模块存储器是一种空间并行技术，利用多个结构完全相同的存储模块的并行工作来提高存储 器的吞吐率。常用的有单体多字存储器和多体低位交叉存储器。 CPU的速度比存储器快得多，若同时从存储器中取出n条指令，就可以充分利用CPU资源，提高 运行速度。多体交叉存储器就是基于这种思想提出的。 （1）单体多字存储器 在单体多字系统中，每个存储单元存储m 个字，总线宽度也为m 个字，一次并行读出m个字。在一个存取周期内，从同一地址取出m 条指令，然后将指令逐条送至CPU 执行，即每隔1/m 存 取 周 期 ，CPU 向主存取一条指令。这显然提高了单体存储器的工作速度。 缺点：只有指令和数据在主存中连续存放时，这种方法才能有效提升存取速度。 一旦遇到转 移指令，或操作数不能连续存放时，这种方法的提升效果就不明显。 （2）多体并行存储器 多体并行存储器由多体模块组成。每个模块都有相同的容量和存取速度，各模块都有独立的 读/写控制电路、地址寄存器和数据寄存器。它们既能并行工作，又能交叉工作。",
    "chunk_order_index": 0,
    "full_doc_id": "doc-8f87fc865b405b5892e67cab1873a773",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:79bd2c395738731827f4f2015e9af2fd",
      "default:extract:a3d23357664e2d75ef872dbf38c3f337"
    ],
    "create_time": 1761468255,
    "update_time": 1761468275,
    "_id": "chunk-8f87fc865b405b5892e67cab1873a773"
  },
  "chunk-a438ed247c5a79e72ee6372aba002ee0": {
    "tokens": 313,
    "content": "14. 存储芯片的地址分配和片选 CPU要实现对存储单元的访问，首先要选择存储芯片，即进行片选；然后在选定的芯片中选 择具体的存储单元，以进行数据的读/写，即进行字选。芯片内的字选通常是由CPU 送出的N 条 低位地址线完成 (N 由片内存储容量2决定)。片选信号的产生方法分为线选法和译码片选法。 （1）线选法 线选法用除片内寻址外的高位地址线直接连接至各个存储芯片的片选端，当某位地址线信息 为“0”时，就选中与之对应的存储芯片。这些片选地址线每次寻址时只能有一位有效，不允许 同时有多位有效，这样才能保证每次只选中一个芯片(或芯片组)。 优点：不需要地址译码器，线路简单。缺点：地址空间不连续， 选片的地址线必须分时为低电平(否则不能工作),不能充分利用系 统的存储器空间 ， 造成地址资源的浪费 。 （2）译码片选法 译码片选法用除片内寻址外的高位地址线通过地址译码器产生片选信号。",
    "chunk_order_index": 0,
    "full_doc_id": "doc-a438ed247c5a79e72ee6372aba002ee0",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:3ceae1a429c2dbaff9f0b2b35c9d16e4",
      "default:extract:4d7f3c3722a5adcf77ebbe25ed4d3b43"
    ],
    "create_time": 1761468274,
    "update_time": 1761468296,
    "_id": "chunk-a438ed247c5a79e72ee6372aba002ee0"
  },
  "chunk-87c0289dc1f88d2676624e47042c749f": {
    "tokens": 414,
    "content": "33. 段式虚拟存储器 段式虚拟存储器中的段是按程序的逻辑结构划分的，各个段的长度因程序而异。把虚拟地址 分为两部分：段号和段内地址。虚拟地址到实地址之间的变换是由段表来实现的。段表是程序的 逻辑段和在主存中存放位置的对照表。段表的每行记录与某个段对应的段号、装入位、段起点和 段长等信息。因为段的长度可变，所以段表中要给出各段的起始地址与段的长度。 CPU 根据虚拟地址访存时，首先根据段表基地址与段号拼接成对应的段表项，然后根据该段 表项的装入位判断该段是否已调入主存(装入位为“1”,表示该段已调入主存；装入位为“0”, 表示该段不在主存中)。已调入主存时，从段表读出该段在主存中的起始地址，与段内地址(偏 移量)相加，得到对应的主存实地址。 因为段本身是程序的逻辑结构所决定的一些独立部分，因此分段对程序员来说是不透明的； 而分页对程序员来说是透明的，程序员编写程序时不需知道程序将如何分页。 段式虚拟存储器的优点是，段的分界与程序的自然分界相对应，因此具有逻辑独立性，使得 它易于编译、管理、修改和保护，也便于多道程序的共享；缺点是段长度可变，分配空间不便， 容易在段间留下碎片，不好利用，造成浪费。",
    "chunk_order_index": 0,
    "full_doc_id": "doc-87c0289dc1f88d2676624e47042c749f",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:b84a91389686d362f35cb4fcac57d3e5",
      "default:extract:ccc4b4265d1b62b960f50eda64a7e0bd"
    ],
    "create_time": 1761468280,
    "update_time": 1761468302,
    "_id": "chunk-87c0289dc1f88d2676624e47042c749f"
  },
  "chunk-84c8d12524cbd30a01b0da556f764478": {
    "tokens": 101,
    "content": "SRAM芯片和DRAM芯片 半导体存储器分为随机存储器 (RAM)和只读存储器 (ROM)。RA又分为静态随机存储器 (SRAM )和动态随机存储器(DRAM), 主存储器主要由DRAM实现，靠近处理器的那一层(Cache)则由SRAM实现，它们都是易失性存储器。ROM 是非易失性存储器。",
    "chunk_order_index": 0,
    "full_doc_id": "doc-84c8d12524cbd30a01b0da556f764478",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:fc6f535d1de5cd85ec6ecb928b34dc14",
      "default:extract:77a18d04b75a9404bf5b22c17e04d6f9"
    ],
    "create_time": 1761468308,
    "update_time": 1761468324,
    "_id": "chunk-84c8d12524cbd30a01b0da556f764478"
  },
  "chunk-555f79801ef87ce95e52becac62479d6": {
    "tokens": 641,
    "content": "24. Cache中主存块的替换算法 在采用全相联映射或组相联映射方式时，从主存向Cache 传送一个新块，当Cache 或 Cache 组中的空间已被占满时，就需要使用替换算法置换 Cache 行。而采用直接映射时，一个给定的主存块只能放到唯一的固定Cache 行中，所以在对应 Cache 行已有一个主存块的情况下，新的主存块毫无选择地把原先已有的那个主存块替换掉，因此无须考虑替换算法。 常用的替换算法有随机 (RAND) 算法、先进先出 (FIFO) 算法、近期最少使用 (LRU) 算法和最不经常使用 (LFU) 算法。 1)随机算法：随机地确定替换的 Cache 行。它的实现比较简单，但未依据程序访问的局部 性原理，因此可能命中率较低。 2)先进先出算法：选择最早调入的 Cache行进行替换。它比较容易实现，但也未依据程序访问的局部性原理，因为最早进入的主存块也可能是目前经常要用的。 3)近期最少使用算法(LRU): 依据程序访问的局部性原理，选择近期内长久未访问过的Cache 行进行替换，其平均命中率要比FIFO 的高，是堆栈类算法。LRU 算法对每个Cache 行设置一个计数器(也称LRU替换位),用计数值来记录主存块的使用情况，并根据计数值选择淘汰某个块，计数值的位数与 Cache 组大小有关，2路时有1位 LRU 位，4路时有2位LRU 位。 计数器的变化规则：①命中时，所命中的行的计数器清零，比其低的计数器加1,其余不变； ②未命中且还有空闲行时，新装入的行的计数器置0,其余非空闲行全加1;③未命中且无空闲 行时，计数值为3的行的信息块被替换，新装入的行的计数器置0,其余全加1。 当集中访问的存储区超过 Cache 组的大小时，命中率可能变得很低,这种现象称为抖动。 4)最不经常使用算法：将一段时间内被访问次数最少的 Cache 行换出。每行也设置一个计 数器，新行装入后从0开始计数，每访问一次，被访问的行计数器加1,需要替换时比较各特定行的计数值，将计数值最小的行换出。这种算法与LRU 类似，但不完全相同。",
    "chunk_order_index": 0,
    "full_doc_id": "doc-555f79801ef87ce95e52becac62479d6",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:59f1fe9e4751a3d289c87982a9150e02",
      "default:extract:067a7e780810e2a52e943eec22e2b3c9"
    ],
    "create_time": 1761468310,
    "update_time": 1761468348,
    "_id": "chunk-555f79801ef87ce95e52becac62479d6"
  },
  "chunk-f58beb694766dd43b7432ff7d16d2a65": {
    "tokens": 175,
    "content": "12. 主存储器与CPU连接原理 1)主存储器通过数据总线、地址总线和控制总线与CPU 连接。 2)数据总线的位数与工作频率的乘积正比于数据传输速率。 3)地址总线的位数决定了可寻址的最大内存空间。 4)控制总线(读/写)指出总线周期的类型和本次输入/输出操作完成的时刻。 单个芯片的容量是有限的，因此通过存储器芯片扩展技术，将多个芯片集成在一个内存条上， 然后由多个内存条及主板上的ROM 芯片组成计算机所需的主存空间，再通过总线与CPU 相连。",
    "chunk_order_index": 0,
    "full_doc_id": "doc-f58beb694766dd43b7432ff7d16d2a65",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:bf2507fd8fa757abdc4afea5b5aa86d5",
      "default:extract:3edf3233ad9215ca967eeb6593929041"
    ],
    "create_time": 1761468328,
    "update_time": 1761468347,
    "_id": "chunk-f58beb694766dd43b7432ff7d16d2a65"
  },
  "chunk-e0a87778cef25aba2903a8a3e12c5faa": {
    "tokens": 388,
    "content": "22. Cache的基本工作原理 为便于Cache与主存交换信息， Cache和主存都被划分为大小相等的块， Cache块也称 Cache行，每块由若干字节组成，块的长度称为块长 (也称行长)。因为 Cache的容量远小于主存的容 量，所以Cache中的块数要远少于主存中的块数， Cache中仅保存主存中最活跃的若干块的副本。 因此，可按照某种策略预测 CPU在未来一段时间内欲访存的数据，将其装入Cache。 当CPU发出读请求时，若访存地址在Cache中命中(也称Cache命中),就将此地址转换成 Cache地址，直接对Cache进行读操作，与主存无关；若Cache 不命中，则仍需访问主存，并把此字所在的块一次性地从主存调入 Cache 。 若此时 Cache已满，则需根据某种替换算法，用这个块替换Cache中原来的某块信息。整个过程全部由硬件实现。值得注意的是， CPU与Cache之间的数据交换以字为单位，而Cache与主存之间的数据交换则以Cache 块为单位。 当CPU发出写请求时，若Cache命中，有可能遇到Cache与主存中的内容不一致的问题。 例如，CPU写Cache,把Cache某单元中的内容从X修改成X, 而主存对应单元中的内容仍然是 X,没有改变，若 Cache命中，则需要按照一定的写策略处理，常见的处理方法有全写法和回写 法.某些计算机中也采用同时访问Cache 和主存的方式，若Cache 命中，则终止访存。",
    "chunk_order_index": 0,
    "full_doc_id": "doc-e0a87778cef25aba2903a8a3e12c5faa",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:dd527d9641e7732dfd4e8b59fa3d11e7",
      "default:extract:e392b1d6a448e62028d44a7d41639e90"
    ],
    "create_time": 1761468355,
    "update_time": 1761468391,
    "_id": "chunk-e0a87778cef25aba2903a8a3e12c5faa"
  },
  "chunk-7c2151344b39c51051c3dacc3290bcf9": {
    "tokens": 165,
    "content": "SRAM的工作原理 通常把存放一个二进制位的物理器件称为存储元，它是存储器的最基本的构件。地址码相同 的多个存储元构成一个存储单元。若干存储单元的集合构成存储体。 静态随机存储器 (SRAM)的存储元是用双稳态触发器(六晶体管MOS)来记忆信息的，静态是指即使信息被读出后，它仍保持其原状态而不需要再生(非破坏性读出)。 SRAM的存取速度快，但集成度低，功耗较大，价格昂贵，一般用于高速缓冲存储器。",
    "chunk_order_index": 0,
    "full_doc_id": "doc-7c2151344b39c51051c3dacc3290bcf9",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:8d1d1fbaae2a7e66616ffb956c6ef24d",
      "default:extract:26448afa56f9810e4f3c6d90f5ec703c"
    ],
    "create_time": 1761468359,
    "update_time": 1761468378,
    "_id": "chunk-7c2151344b39c51051c3dacc3290bcf9"
  },
  "chunk-8722d229424243d0f7b9869b271bb08f": {
    "tokens": 451,
    "content": "18. 固态硬盘 1. 固态硬盘的特性 固态硬盘( SSD ) 是一种基于闪存技术的存储器。它与U 盘并无本质差别，只是容量更大， 存取性能更好。一个 SSD 由一个或多个闪存芯片和闪存翻译层组成，如图3.15所示。闪存芯片 替代传统旋转磁盘中的机械驱动器，而闪存翻译层将来自CPU 的逻辑块读/写请求翻译成对底层 物理设备的读/写控制信号，因此，这个闪存翻译层相当于代替了磁盘控制器的角色。 例如，一个闪存由B 个块组成，每块由P 页组成。通常，页的大小是512B～4KB, 每块由32～128页组成，块的大小为16KB～512KB 。数据是以页为单位读/写的。以块为单位擦除，只有在一页所属的块整个被擦除后，才能写这一页。一旦一个块被擦除，块中的每个页就都 可以直接再写一次。某个块进行了若干次重复写之后，就会磨损坏，不能再使用。 随机写很慢，有两个原因。首先，擦除块比较慢，通常比访问页高一个数量级。其次，若写 操作试图修改一个包含已有数据的页P, 则这个块中所有含有用数据的页都必须被复制到一个新 (擦除过的)块中，然后才能进行对页P, 的写操作。 比起传统磁盘，SSD 有很多优点，它由半导体存储器构成，没有移动的部件，因此随机访问 时间比机械磁盘要快很多，也没有任何机械噪声和振动，能耗更低，抗震性好，安全性高等。 随着技术的不断发展，价格也不断下降， SSD 有望逐步取代传统机械硬盘。",
    "chunk_order_index": 0,
    "full_doc_id": "doc-8722d229424243d0f7b9869b271bb08f",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:f0a757d3a183899553477cb961dc10e5",
      "default:extract:e76d05ae79a0768c90861c56dc59f2e4"
    ],
    "create_time": 1761468383,
    "update_time": 1761468407,
    "_id": "chunk-8722d229424243d0f7b9869b271bb08f"
  },
  "chunk-b013853f3a4a507351aa3af1ef0f6cfb": {
    "tokens": 665,
    "content": "11. 多体并行存储器分为高位交叉编址和低位交叉编址两种。 (1)高位交叉编址(顺序方式) 高位地址表示模块号(或体号),低位地址为模块内地址(或体内地址) 在高位交叉方式下，总把低位的体内地址送到由高位体号确定的模块内进行译码。访问一个 连续主存块时，总是先在一个模块内访问，等到该模块访问完才转到下一个模块访问， CPU 总是按顺序访问存储模块，各模块不能被并行访问，因此不能提高存储器的吞吐率。 注意 模块内的地址是连续的，存取方式仍是串行存取，因此这种存储器仍是顺序存储器。 (2)低位交叉编址(交叉方式) 低位地址为模块号，高位地址为模块内地址。每个模块按“模m” 交叉编址， 模块号=单 元地址%m。 在低位交叉方式下，总是把高位的体内地址送到由低位体号所确定的模块内进行译码。程 序连续存放在相邻模块中，因此称采用此编址方式的存储器为交叉存储器。 交叉存储器可以采用轮流启动或同时启动两种方式。 ● 轮流启动方式 若每个模块一次读/写的位数正好等于数据总线位数，模块的存取周期为 T, 总线周期为r, 为实现轮流启动方式，存储器交叉模块数应大于或等于m= T/r。 按每隔1/m个存取周期轮流启动各模块，则每隔1/m个存取周期就可读出或写入一个数据， 存取速度提高m 倍，交叉存储器要求其模块数大于或等于m, 以保证启动某模块后经过m×r 的时间后再次启动该模块时，其上次的存取操作已经完成(以保证流水线不间断)。这样，连续存取m 个字所需的时间为t=T+(m-1)r。 在理想情况下，m 体交叉存储器每隔1/m 存取周期可读/写一个数据，若相邻的m 次访问的 访存地址出现在同一个模块内，则会发生访存冲突，此时需延迟发生冲突的访问请求。 ●同时启动方式 若所有模块一次并行读/写的总位数正好等于数据总线位数，则可以同时启动所有模块进行 读/写。设每个模块一次读/写的位数为16位，模块数m=4, 数据总线位数为64位，4个模块 一共提供64位，正好构成一个存储字，因此应该同时启动4个模块进行并行读/写。",
    "chunk_order_index": 0,
    "full_doc_id": "doc-b013853f3a4a507351aa3af1ef0f6cfb",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:b4ede4617192f501a1c4b103dc9990e7",
      "default:extract:0d1a66ee40613cf98b9cdf2c7bf85713"
    ],
    "create_time": 1761468397,
    "update_time": 1761468427,
    "_id": "chunk-b013853f3a4a507351aa3af1ef0f6cfb"
  },
  "chunk-ce9d79eec3b8225be9c02cda24c5a519": {
    "tokens": 955,
    "content": "存储器的分类 （1）按在计算机中的作用(层次)分类 1)主存储器。简称主存，也称内存储器(内存),用来存放计算机运行期间所需的程序和数 据 ，CPU 可以直接随机地对其进行访问，也可以和高速缓冲存储器(Cache) 及辅助存储 器交换数据。其特点是容量较小、存取速度较快、单位成本较高。 2)辅助存储器。简称辅存，也称外存储器或外存，用来存放当前暂时不用的程序和数据， 以及一些需要永久性保存的信息。辅存的内容需要调入主存后才能被 CPU 访问。其特点 是容量大、存取速度较慢、单位成本低。 3)高速缓冲存储器。简称Cache, 位于主存和CPU之间，用来存放当前CPU 经常使用的指 令和数据，以便CPU 能高速地访问它们。Cache 的存取速度可与CPU 的速度相匹配，但 存储容量小、价格高。现代计算机通常将它们制作在CPU 中。 （2）按存储介质分类 按存储介质，存储器可分为磁表面存储器(磁盘、磁带)、磁芯存储器、半导体存储器(MOS 型存储器、双极型存储器)和光存储器(光盘)。 （3）按存取方式分类 1)随机存储器(RA M)。存储器的任何一个存储单元都可以随机存取，而且存取时间与存储 单元的物理位置无关。其优点是读/写方便、使用灵活，主要用作主存或高速缓冲存储器。 RAM 又分为静态RAM和动态 RAM. 2)只读存储器 (ROM)。存储器的内容只能随机读出而不能写入。信息一旦写入存储器就固 定不变，即使断电，内容也不会丢失。因此，通常用它存放固定不变的程序、常数和汉 字字库等。它与随机存储器可共同作为主存的一部分，统一构成主存的地址域。 由 ROM 派生出的存储器也包含可反复重写的类型，ROM 和 RAM 的存取方式均为随机 存取。广义上的只读存储器已可通过电擦除等方式进行写入，其“只读”的概念没有保 留，但仍保留了断电内容保留、随机读取特性，但其写入速度比读取速度慢得多。 3)串行访问存储器。 对存储单元进行读/写操作时，需按其物理位置的先后顺序寻址，包括 顺序存取存储器(如磁带)和直接存取存储器(如磁盘、光盘)。 顺序存取存储器的内容只能按某种顺序存取，存取时间的长短与信息在存储体上的物理位置 有关，其特点是存取速度慢。直接存取存储器既不像 RAM 那样随机地访问任何一个存储单元， 又不像顺序存取存储器那样完全按顺序存取，而是介于两者之间。存取信息时通常先寻找整个存 储器中的某个小区域(如磁盘上的磁道),再在小区域内顺序查找。 （4）按信息的可保存性分类 断电后，存储信息即消失的存储器，称为易失性存储器，如 RAM 。断电后信息仍然保持的 存储器，称为非易失性存储器，如 ROM、磁表面存储器和光存储器。 若某个存储单元所存储的信息被读出时，原存储信息被破坏，则称为破坏性读出；若读出时， 被读单元原存储信息不被破坏，则称为非破坏性读出。具有破坏性读出性能的存储器，每次读出操作后，必须紧接一个再生的操作，以便恢复被破坏的信息。",
    "chunk_order_index": 0,
    "full_doc_id": "doc-ce9d79eec3b8225be9c02cda24c5a519",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:4689ec0173592982cd54167bc22d9d84",
      "default:extract:3748d9a11ff51d542398a0c7639943f1"
    ],
    "create_time": 1761468413,
    "update_time": 1761468446,
    "_id": "chunk-ce9d79eec3b8225be9c02cda24c5a519"
  },
  "chunk-cef942e7cbaeb916484eb8b3e7bcbd9a": {
    "tokens": 766,
    "content": "25. Cache的一致性问题 因为Cache 中的内容是主存块副本，当对Cache 中的内容进行更新时，就需选用写操作策略使Cache 内容和主存内容保持一致。此时分两种情况。 对于Cache写操作命中 (Write Hit), 有两种处理方法。 1)全写法(直写法、Write Through)。当 CPU 对 Cache 写命中时，必须把数据同时写入Cache 和主存。当某一块需要替换时，就不必把这一块写回主存了，用新调入的块直接覆盖即 可。这种方法实现简单，能随时保持主存数据的正确性。缺点是增加了访存次数，降低了Cache 的效率。写缓冲：为减少全写法直接写入主存的时间损耗，在 Cache 和主存之 间加一个写缓冲(Write Buffer),如下图所示。CPU 同时写数据到Cache 和写缓冲中，写缓冲再将内容写入主存。写缓冲是一个FIFO 队列，写缓冲可以解决速度不匹配的问题。但若出现频繁写时，会使写缓冲饱和溢出。 2)回写法 (Write Back)。当 CPU对Cache写命中时，只把数据写入Cache, 而不立即写入主存，只有当此块被替换出时才写回主存。这种方法减少了访存次数，但存在数据不一致的隐患。为了减少写回主存的次数，给每个Cache 行设置一个修改位 (脏位)。若修改位为1,则说明对应Cache 行中的块被修改过，替换时须写回主存；若修改位为0,则 说明对应 Cache 行中的块未被修改过，替换时无须写回主存。 全写法和回写法都对应于Cache 写命中(要被修改的块在Cache 中)时的情况。 对于Cache写操作不命中，也有两种处理方法。 1)写分配法(Write Allocate)。更新主存单元，然后把这个主存块调入Cache。它试图利用程序的空间局部性，缺点是每次写不命中都要从主存读一个块到Cache 中。 2)非写分配法 ( Not-Write-Allocate) 。只更新主存单元，而不把主存块调入Cache。 非写分配法通常与全写法合用，写分配法通常和回写法合用。 随着指令流水技术的发展，需要将指令Cache 和数据Cache 分开设计，这就有了分离的Cache结构。统一 Cache 的优点是设计和实现相对简单，但由于执行部件存取数据时，指令预取部件要 从同一Cache 读指令，会引发冲突。采用分离的Cache 结构可以解决这个问题，而且分离的指令和数据Cache 还可以充分利用指令和数据的不同局部性来优化性能。 现代计算机的Cache 通常设立多级Cache, 假定设2级Cache, 按离 CPU 的远近可各自命名 为 L1Cache 、L2 Cache, 离CPU 越远，访问速度越慢，容量越大。指令Cache 与数据Cache 分离一般在 L1 级，此时通常为写分配法与回写法合用。",
    "chunk_order_index": 0,
    "full_doc_id": "doc-cef942e7cbaeb916484eb8b3e7bcbd9a",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:2640117528c4db72038c394c3aa9f6b8",
      "default:extract:35cb7a431586968577a01f033ffa0cf3"
    ],
    "create_time": 1761468434,
    "update_time": 1761468472,
    "_id": "chunk-cef942e7cbaeb916484eb8b3e7bcbd9a"
  },
  "chunk-a531a45f53700863615cfa8c40892f61": {
    "tokens": 261,
    "content": "34. 段页式虚拟存储器 在段页式虚拟存储器中，把程序按逻辑结构分段，每段再划分为固定大小的页，主存空间也 划分为大小相等的页，程序对主存的调入、调出仍以页为基本交换单位。每个程序对应一个段表， 每段对应一个页表，段的长度必须是页长的整数倍，段的起点必须是某一页的起点。 虚地址分为段号、段内页号、页内地址三部分。CPU 根据虚地址访存时，首先根据段号得到 段表地址；然后从段表中取出该段的页表起始地址，与虚地址段内页号合成，得到页表地址；最 后从页表中取出实页号，与页内地址拼接形成主存实地址。 段页式虚拟存储器的优点是，兼具页式和段式虚拟存储器的优点，可以按段实现共享和保护。 缺点是在地址变换过程中需要两次查表，系统开销较大。",
    "chunk_order_index": 0,
    "full_doc_id": "doc-a531a45f53700863615cfa8c40892f61",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:48660eba95575700ca60180eecdd3e6e",
      "default:extract:fb42d51e3ce8cc3a50abbca364c8d15b"
    ],
    "create_time": 1761468453,
    "update_time": 1761468489,
    "_id": "chunk-a531a45f53700863615cfa8c40892f61"
  },
  "chunk-f75d6db24d56fe7631645ee707b4ca7f": {
    "tokens": 415,
    "content": "17. 磁盘阵列 RAID (独立冗余磁盘阵列)是指将多个独立的物理磁盘组成一个独立的逻辑盘，数据在多个物理盘上分割交叉存储、并行访问，具有更好的存储性能、可靠性和安全性。 RAID的分级如下所示。在RAID1～RAID5几种方案中，无论何时有磁盘损坏，都可随时拔出受损的磁盘再插入好的磁盘，而数据不会损坏，提升了系统的可靠性。 ● RAID0: 无冗余和无校验的磁盘阵列。 ● RAID1: 镜像磁盘阵列。 ● RAID2: 采用纠错的海明码的磁盘阵列。 ● RAID3: 位交叉奇偶校验的磁盘阵列。 ● RAID4: 块交叉奇偶校验的磁盘阵列。 ● RAID5: 无独立校验的奇偶校验磁盘阵列。 RAID0把连续多个数据块交替地存放在不同物理磁盘的扇区中，几个磁盘交叉并行读/写， 即条带化技术，这样不仅扩大了存储容量，还提高了磁盘存取速度，但 RAID0 没有容错能力。 为了提高可靠性，RAID1 使两个磁盘同时进行读/写，互为备份，若一个磁盘出现故障，可 从另一磁盘中读出数据。两个磁盘当一个磁盘使用，意味着容量减少一半。 总之，RAID 通过同时使用多个磁盘，提高了传输速率；通过在多个磁盘上并行存取来大幅 提高存储系统的数据吞吐量；通过镜像功能，提高安全可靠性；通过数据校验，提供容错能力。",
    "chunk_order_index": 0,
    "full_doc_id": "doc-f75d6db24d56fe7631645ee707b4ca7f",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:1af1a989f755ca949485798b5a9d97d7",
      "default:extract:d658e787f5d15d8e99eb400e9fde7af7"
    ],
    "create_time": 1761468481,
    "update_time": 1761468550,
    "_id": "chunk-f75d6db24d56fe7631645ee707b4ca7f"
  },
  "chunk-361185a50ecc6636f127fb6f6ad6eabd": {
    "tokens": 772,
    "content": "23. Cache和主存的映射方式 Cache行数比主存块数少得多，因此主存中只有一部分块的信息可放在 Cache中，因此在 Cache中要为每块加一个标记位，指明它是主存中哪一块的副本。该标记的内容相当于主存中块 的编号。为了说明 Cache 行中的信息是否有效，每个Cache行需要一个有效位。 Cache 行中的信息是主存中某个块的副本，地址映射是指把主存地址空间映射到Cache 地址空间，即把存放在主存中的信息按照某种规则装入Cache 。地址映射的方法有以下3种。 （1）直接映射 主存中的每一块只能装入Cache 中的唯一位置。若这个位置已有内容，则产生块冲突，原来 的块将无条件地被替换出去(无须使用替换算法)。直接映射实现简单，但不够灵活，即使Cache 的其他许多地址空着也不能占用，这使得直接映射的块冲突概率最高，空间利用率最低。直接映射的关系可定义为：Cache 行号=主存块号 mod Cache总行数。 （2）全相联映射 主存中的每一块可以装入Cache中的任何位置，如图3.19所示，每行的标记用于指出该行来自主存的哪一块，因此CPU 访存时需要与所有Cache行的标记进行比较。优点：①Cache 块的冲突概率低，只要有空闲Cache行，就不会发生冲突；②空间利用率高；③命中率高。缺点：①标 记的比较速度较慢；②实现成本较高，通常需采用按内容寻址的相联存储器。 （3）组相联映射 将 Cache 分成 Q 个大小相等的组，每个主存块可以装入固定组中的任意一行，即组间采用直接映射、而组内采用全相联映射的方式，如图3.20所示。它是对直接映射和全相联映射的一种折中，当Q=1时变为全相联映射，当Q=Cache行数时变为直接映射。路数越大，即每组 Cache 行的数量越大，发生块冲突的概率越低，但相联比较电路也越复杂。选定适当的数量，可使组相联映射的成本接近直接映射，而性能上仍接近全相联映射。假设每组有 r 路组相联，图3.20中每组有两个Cache 行，因此称为2路组相联。联映射的成本接近直接映射，而性能上仍接近全相联映射。 CPU 访存过程如下：首先根据访存地址中间的组号找到对应的Cache 组；将对应Cache 组中 每个行的标记与主存地址的高位标记进行比较；若有一个相等且有效位为1,则访问Cache 命中， 此时根据主存地址中的块内地址，在对应Cache 行中存取信息；若都不相等或虽相等但有效位为 0,则不命中，此时CPU 从主存中读出该地址所在的一块信息送到对应Cache 组的任意一个空闲行中，将有效位置1,并设置标记，同时将该地址中的内容送CPU。",
    "chunk_order_index": 0,
    "full_doc_id": "doc-361185a50ecc6636f127fb6f6ad6eabd",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:768ba668ff05c6cbbf56e0fe94b8c79b",
      "default:extract:2889e0329e562b796e1764e8bef9ff91"
    ],
    "create_time": 1761468495,
    "update_time": 1761468587,
    "_id": "chunk-361185a50ecc6636f127fb6f6ad6eabd"
  },
  "chunk-d02693bcc2f3ef38eee5bb553035284e": {
    "tokens": 97,
    "content": "20. 高速缓冲存储器 程序的转移概率不会很低，数据分布的离散性较大，因此单纯依靠并行主存系统提高主存系 统的效率是有限的。高速缓存Cache 拥有比主存更快的速度，因此在CPU 和主存之间设置Cache可以显著提高存储系统的效率。Cache由SRAM组成，通常直接集成在CPU 中 。",
    "chunk_order_index": 0,
    "full_doc_id": "doc-d02693bcc2f3ef38eee5bb553035284e",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:d02e8e1556551a4022751cdb323f1324",
      "default:extract:4254e1df9839d1b7e9618b8aed0b2aff"
    ],
    "create_time": 1761468559,
    "update_time": 1761468593,
    "_id": "chunk-d02693bcc2f3ef38eee5bb553035284e"
  },
  "chunk-0af5a7c8d38a4b5d1e4bac2d53e20424": {
    "tokens": 419,
    "content": "28. 页表 有效位也称装入位，用来表示对应页面是否在主存，若为1,则表示该虚拟页已从外存调入主存，此时页表项存放该页的物理页号；若为0,则表示没有调入主存，此时页表项可以存放该页的磁盘地址。脏位也称修改位，用来表示页面是否被修改过，虚存机制中采用回写法，利用脏位可判断替换时是否需要写回磁盘。引用位也称使用位，用来配合替换法进行设置，例如是否实现最先调入 (FIFO位)或最近最少用(LRU位)策略等。 假设CPU 欲访问的数据在第1页，对应的有效位为1,说明该页已 存放在主存中，再通过地址转换部件将虚拟地址转换为物理地址，然后到相应的主存实页中存取数据。若该数据在第5页且有效位为0,则发生“缺页”异常，需调用操作系统的缺页异常处理程序。缺页处理程序根据对应表项中的存放位置字段，将所缺页面从磁盘调入一个空闲的物理页框。若主存中没有空闲页框，还需要选择一个页面替换。采用回写法，因此换出页面时根据脏位确定是否要写回磁盘。缺页处理过程中需要对页表进行相应的更新。 页式虚拟存储器的优点是，页面的长度固定，页表简单，调入方便。缺点是，因为程序不可 能正好是页面的整数倍，最后一页的零头将无法利用而造成浪费，并且页不是逻辑上独立的实体， 所以处理、保护和共享都不及段式虚拟存储器方便。",
    "chunk_order_index": 0,
    "full_doc_id": "doc-0af5a7c8d38a4b5d1e4bac2d53e20424",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:389bf264dcac47e3b9b3cc78f192e856",
      "default:extract:bdcb941be9a7cee967e7ebf9c63d6964"
    ],
    "create_time": 1761468610,
    "update_time": 1761468768,
    "_id": "chunk-0af5a7c8d38a4b5d1e4bac2d53e20424"
  },
  "chunk-5b1903143e069742cd454a3ac6ea0d4a": {
    "tokens": 399,
    "content": "19. 磨损均衡 (Wear Leveling) 固态硬盘也有缺点，闪存的擦写寿命是有限的，一般是几百次到几千次。若直接用普通闪存 组装SSD, 则实际的寿命表现可能非常令人失望——读/写数据时会集中在 SSD的一部分闪存， 这部分闪存的寿命会损耗得特别快。一旦这部分闪存损坏，整块SSD也就损坏了。这种磨损不均衡的情况，可能导致一块256GB的SSD, 只因数兆字节空间的闪存损坏而整块损坏。 为了弥补SSD 的寿命缺陷，引入了磨损均衡。 SSD 磨损均衡技术大致分为两种： 1)动态磨损均衡。 写入数据时，优先选择擦除次数少的新闪存块，老的闪存块先歇一歇。 2)静态磨损均衡。这种技术更为先进，就算没有数据写入， SSD 也会监测并自动进行数据 分配，让老的闪存块承担以读为主的存储任务。同时让较新的闪存块腾出空间，以承担 更多以写为主的存储任务。如此一来，各闪存块的寿命损耗就都差不多。 有了这种算法加持，SSD 的寿命就比较可观了。例如，对于一个256GB 的 SSD, 若 闪 存 的 擦写寿命是500次，则需要写入125TB 数据，才寿终正寝。就算每天写入10GB 数据，也要三十多年才能将闪存磨损坏，更何况很少有人每天往SSD 中写入10GB 数据。",
    "chunk_order_index": 0,
    "full_doc_id": "doc-5b1903143e069742cd454a3ac6ea0d4a",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:4adfb373283c730907a3504c3b3e8621",
      "default:extract:c9958caba27a73fb6aefba73bb283023"
    ],
    "create_time": 1761468625,
    "update_time": 1761468675,
    "_id": "chunk-5b1903143e069742cd454a3ac6ea0d4a"
  },
  "chunk-3c1c3cb1cdfefa986a82277dd52e88ef": {
    "tokens": 413,
    "content": "存储器的性能指标 存储器有三个主要性能指标，即存储容量、单位成本和存储速度。这三个指标相互制约，设 计存储器系统所追求的目标就是大容量、低成本和高速度。 1)存储容量=存储字数×字长(如1M×8 位)。单位换算：1B(Byte,字节) = 8b(bit,位)。 存储字数表示存储器的地址空间大小，字长表示一次存取操作的数据量。 2)单位成本：位价=总成本/总容量。 3)存储速度：数据传输速率(每秒传送信息的位数)=数据的宽度/存取周期。 ① 存取时间(Ta): 存取时间是指从启动一次存储器操作到完成该操作所经历的时间，分为读出时间和写入时间。 ② 存取周期(Tm): 存取周期是指存储器进行一次完整的读/写操作所需的全部时间，即连续两次独立访问存储器操作(读或写操作)之间所需的最小时间间隔。 ③ 主存带宽(Bm): 也称数据传输速率，表示每秒从主存进出信息的最大数量，单位为字/秒、字节/秒(B/s) 或位/秒(b/s)。 存取时间不等于存取周期，通常存取周期大于存取时间。这是因为对任何一种存储器，在读/ 写操作之后，总要有一段恢复内部状态的复原时间。对于破坏性读出的存储器，存取周期往往比存取时间大得多，甚至可达Tm=2Ta, 因为存储器中的信息读出后需要马上进行再生。",
    "chunk_order_index": 0,
    "full_doc_id": "doc-3c1c3cb1cdfefa986a82277dd52e88ef",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:6075678c50d206fce9043d6a51c2ed8e",
      "default:extract:08db9be8306568773c6e8b2a8d7ae794"
    ],
    "create_time": 1761468679,
    "update_time": 1761468735,
    "_id": "chunk-3c1c3cb1cdfefa986a82277dd52e88ef"
  },
  "chunk-bc61336da91a3616939ad75ed1c5543a": {
    "tokens": 1200,
    "content": "16. 磁盘存储器 磁盘存储器是以磁盘为存储介质的存储器，其主要优点：①存储容量大，位价低；②记录介 质可重复使用；③记录信息可长期保存而不丢失，甚至可脱机存档；④非破坏性读出，读出时不需要再生。缺点：存取速度慢，机械结构复杂，对工作环境要求较高。 （1）磁盘设备的组成 ①磁盘存储器的组成。磁盘存储器由磁盘驱动器、磁盘控制器和盘片组成。 磁盘驱动器是驱动磁盘转动并在盘面上通过磁头进行读/写操作的装置。 磁盘控制器是磁盘驱动器与主机的接口，负责接收并解释 CPU 发来的命令，向磁盘驱动器发出各种控制信号，并负责检测磁盘驱动器的状态。 ②存储区域。一个磁盘含有若干记录面，每个记录面划分为若干圆形的磁道，而每条磁道 又划分为若干扇区，扇区(也称块)是磁盘读/写的最小单位，即磁盘按块存取。 磁头数 (Heads )即记录面数，表示磁盘共有多少个磁头，磁头用于读取盘片上记录 面的信息和写入信息，一个记录面对应一个磁头。 柱面数(Cylinders)表示磁盘每面盘片上有多少条磁道。在一个盘组中，不同记录面 的相同编号(位置)的诸磁道构成一个圆柱面。 扇区数 ( Sectors)表示每条磁道上有多少个扇区。 相邻磁道及相邻扇区间通过一定的间隙分隔开，以避免精度错误。扇区按固定圆心角度划分，因此位密度从最外道向里道增加，磁盘的存储能力受限于最内道的最大记录密度。 ③磁盘高速缓存 (Disk Cache)。在内存中开辟一部分区域，用于缓冲将被送到磁盘上的数 据。优点：写磁盘时是按“簇”进行的，可以避免频繁地用小块数据写盘；有些中间结 果数据在写回磁盘之前可被快速地再次使用。 （2）磁记录原理 原理：磁头和磁性记录介质相对运动时，通过电磁转换完成读/写操作。 编码方法：按某种方案(规律),把一连串的二进制数据变换成存储介质磁层中一个磁化翻转状态的序列，并使读/写控制电路容易、可靠地实现转换。 磁记录方式：通常采用调频制 (FM)和改进型调频制 (MFM)的记录方式。 （3）磁盘的性能指标 ①记录密度。记录密度是指盘片单位面积上记录的二进制数据量，通常以道密度、位密度 和面密度表示。道密度是沿磁盘半径方向单位长度上的磁道数，位密度是磁道单位长度 上能记录的二进制代码位数，面密度是位密度和道密度的乘积。 ②磁盘的容量。磁盘容量有非格式化容量和格式化容量之分。非格式化容量是指磁记录表面 可利用的磁化单元总数，非格式化容量=记录面数×柱面数×每条磁道的磁化单元数。格 式化容量是指按照某种特定的记录格式所能存储信息的总量。格式化容量=记录面数×柱面数×每道扇区数×每个扇区的容量。格式化后的容量比非格式化容量要小。 ③存取时间。存取时间由寻道时间(磁头移动到目的磁道的时间)、 旋转延迟时间(磁头定 位到要读/写扇区的时间)和传输时间(传输数据所花费的时间)三部分构成。因为寻道 和找扇区的距离远近不一，所以寻道时间和旋转延迟时间通常取平均值(平均寻道时间取从最外道移动到最内道时间的一半，平均旋转延迟时间取旋转半周的时间)。 ④数据传输速率。磁盘存储器在单位时间内向主机传送数据的字节数，称为数据传输速率。 假设磁盘转数为r 转/秒，每条磁道容量为N 字节，则数据传输速率为D=r*N （4）磁盘地址 主机向磁盘控制器发送寻址信息，磁盘的地址一般为：柱面(磁道)号+盘面(磁头)号 +扇区号。 若磁盘有16个盘面，每个盘面有256个磁道，每个磁道划分为16个扇区，则每个扇区地址 为16位二进制代码，其格式为： 柱面(磁道)号(8位",
    "chunk_order_index": 0,
    "full_doc_id": "doc-7d97c00461f6819fdc944b43a4f18f4e",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:8e3eeb3e37695219d4185a46cb461f3d",
      "default:extract:9002860350dd3d4ee9308f6d9b034d36"
    ],
    "create_time": 1761468740,
    "update_time": 1761468923,
    "_id": "chunk-bc61336da91a3616939ad75ed1c5543a"
  },
  "chunk-59c3b987a075436eab7c271ca2d5302a": {
    "tokens": 220,
    "content": "盘地址 主机向磁盘控制器发送寻址信息，磁盘的地址一般为：柱面(磁道)号+盘面(磁头)号 +扇区号。 若磁盘有16个盘面，每个盘面有256个磁道，每个磁道划分为16个扇区，则每个扇区地址 为16位二进制代码，其格式为： 柱面(磁道)号(8位)+盘面(磁头)号(4位)+扇区号(4位)。 （5）磁盘的工作过程 磁盘的主要操作是寻址、读盘、写盘。每个操作都对应一个控制字，磁盘工作时，第一步是 取控制字，第二步是执行控制字。磁盘属于机械式部件，其读/写操作是串行的，不可能在同一时 刻既读又写，也不可能在同一时刻读两组数据或写两组数据。",
    "chunk_order_index": 1,
    "full_doc_id": "doc-7d97c00461f6819fdc944b43a4f18f4e",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:cae27ce1fcd48368b992e4ce5dbfb511",
      "default:extract:cca75e2fba8dd365394c4edcc69ebf45"
    ],
    "create_time": 1761468740,
    "update_time": 1761468824,
    "_id": "chunk-59c3b987a075436eab7c271ca2d5302a"
  },
  "chunk-b5dba59d5f9377e5060b73fecdb0de06": {
    "tokens": 349,
    "content": "26. 虚拟存储器的基本概念 虚拟存储器将主存或辅存的地址空间统一编址,形成一个庞大的地址空间，在这个空间内， 用户可以自由编程，而不必在乎实际的主存容量和程序在主存中实际的存放位置。 用户编程允许涉及的地址称为虚地址或逻辑地址，虚地址对应的存储空间称为虚拟空间或程 序空间。实际的主存单元地址称为实地址或物理地址，实地址对应的是主存地址空间，也称实地址空间。虚地址比实地址要大很多。 CPU 使用虚地址时，先判断这个虚地址对应的内容是否已装入主存。若已在主存中，则通过地址变换，CPU 可直接访问主存指示的实际单元；若不在主存中，则把包含这个字的一页或一段调入主存后再由CPU 访问。若主存已满，则采用替换算法置换主存中的交换块(页面)。虚拟存储器也采用和Cache 类似的技术，将辅存中经常访问的数据副本存放到主存中。但是缺页(或段)而访问辅存的代价很大，提高命中率是关键，因此虚拟存储机制采用全相联映射，每个虚页面可以存放到对应主存区域的任何一个空闲页位置。此外，当进行写操作时，不能每次写操作都同时写回磁盘，因此，在处理一致性问题时，采用回写法。",
    "chunk_order_index": 0,
    "full_doc_id": "doc-b5dba59d5f9377e5060b73fecdb0de06",
    "file_path": "unknown_source",
    "llm_cache_list": [
      "default:extract:007f9321b16deca444c9edb50b0a8fca",
      "default:extract:fe440ad537039b545fb97b3cdad6d906"
    ],
    "create_time": 1761468778,
    "update_time": 1761468859,
    "_id": "chunk-b5dba59d5f9377e5060b73fecdb0de06"
  }
}